From ba594e4ffe61afc1ae1966011894037c7425c7ba Mon Sep 17 00:00:00 2001
From: Puyodead1 <puyodead@proton.me>
Date: Wed, 20 Nov 2024 14:20:28 -0500
Subject: [PATCH] Fix Compile

---
 .../ICSharpCode/SharpZipLib/BZip2/BZip2.cs    |   45 -
 .../SharpZipLib/BZip2/BZip2Constants.cs       |  536 -----
 .../SharpZipLib/BZip2/BZip2Exception.cs       |   29 -
 .../SharpZipLib/BZip2/BZip2InputStream.cs     |  715 ------
 .../SharpZipLib/BZip2/BZip2OutputStream.cs    | 1326 -----------
 .../SharpZipLib/Checksums/Adler32.cs          |   63 -
 .../SharpZipLib/Checksums/Crc32.cs            |  311 ---
 .../SharpZipLib/Checksums/IChecksum.cs        |   16 -
 .../SharpZipLib/Checksums/StrangeCRC.cs       |  304 ---
 .../SharpZipLib/Core/DirectoryEventArgs.cs    |   16 -
 .../Core/DirectoryFailureDelegate.cs          |    5 -
 .../SharpZipLib/Core/ExtendedPathFilter.cs    |   89 -
 .../SharpZipLib/Core/FileFailureDelegate.cs   |    5 -
 .../SharpZipLib/Core/FileSystemScanner.cs     |  151 --
 .../SharpZipLib/Core/INameTransform.cs        |   10 -
 .../SharpZipLib/Core/IScanFilter.cs           |    8 -
 .../SharpZipLib/Core/NameAndSizeFilter.cs     |   49 -
 .../SharpZipLib/Core/NameFilter.cs            |  117 -
 .../SharpZipLib/Core/PathFilter.cs            |   20 -
 .../Core/ProcessDirectoryDelegate.cs          |    5 -
 .../SharpZipLib/Core/ProcessFileDelegate.cs   |    5 -
 .../SharpZipLib/Core/ScanEventArgs.cs         |   21 -
 .../SharpZipLib/Core/ScanFailureEventArgs.cs  |   29 -
 .../SharpZipLib/Core/StreamUtils.cs           |   64 -
 .../SharpZipLib/Encryption/PkzipClassic.cs    |   46 -
 .../Encryption/PkzipClassicCryptoBase.cs      |   44 -
 .../PkzipClassicDecryptCryptoTransform.cs     |   47 -
 .../PkzipClassicEncryptCryptoTransform.cs     |   47 -
 .../Encryption/PkzipClassicManaged.cs         |   69 -
 .../SharpZipLib/GZip/GZipConstants.cs         |   17 -
 .../SharpZipLib/GZip/GZipException.cs         |   29 -
 .../SharpZipLib/GZip/GZipInputStream.cs       |  147 --
 .../SharpZipLib/GZip/GZipOutputStream.cs      |   88 -
 .../SharpZipLib/SharpZipBaseException.cs      |   29 -
 .../SharpZipLib/Tar/InvalidHeaderException.cs |   29 -
 .../SharpZipLib/Tar/ProgressMessageHandler.cs |    5 -
 .../ICSharpCode/SharpZipLib/Tar/TarArchive.cs |  467 ----
 .../ICSharpCode/SharpZipLib/Tar/TarBuffer.cs  |  221 --
 .../ICSharpCode/SharpZipLib/Tar/TarEntry.cs   |  199 --
 .../SharpZipLib/Tar/TarException.cs           |   29 -
 .../ICSharpCode/SharpZipLib/Tar/TarHeader.cs  |  486 ----
 .../SharpZipLib/Tar/TarInputStream.cs         |  290 ---
 .../SharpZipLib/Tar/TarOutputStream.cs        |  191 --
 .../SharpZipLib/Zip/BaseArchiveStorage.cs     |   24 -
 .../Zip/Compression/DeflateStrategy.cs        |   10 -
 .../SharpZipLib/Zip/Compression/Deflater.cs   |  178 --
 .../Zip/Compression/DeflaterConstants.cs      |   96 -
 .../Zip/Compression/DeflaterEngine.cs         |  426 ----
 .../Zip/Compression/DeflaterHuffman.cs        |  582 -----
 .../Zip/Compression/DeflaterPending.cs        |   11 -
 .../SharpZipLib/Zip/Compression/Inflater.cs   |  504 ----
 .../Zip/Compression/InflaterDynHeader.cs      |  197 --
 .../Zip/Compression/InflaterHuffmanTree.cs    |  147 --
 .../Zip/Compression/PendingBuffer.cs          |  111 -
 .../Streams/DeflaterOutputStream.cs           |  221 --
 .../Streams/InflaterInputBuffer.cs            |  167 --
 .../Streams/InflaterInputStream.cs            |  153 --
 .../Zip/Compression/Streams/OutputWindow.cs   |  116 -
 .../Compression/Streams/StreamManipulator.cs  |  111 -
 .../SharpZipLib/Zip/CompressionMethod.cs      |   12 -
 .../SharpZipLib/Zip/DiskArchiveStorage.cs     |  134 --
 .../SharpZipLib/Zip/DynamicDiskDataSource.cs  |   16 -
 .../SharpZipLib/Zip/EncryptionAlgorithm.cs    |   21 -
 .../ICSharpCode/SharpZipLib/Zip/FastZip.cs    |  293 ---
 .../SharpZipLib/Zip/FastZipEvents.cs          |   62 -
 .../SharpZipLib/Zip/FileUpdateMode.cs         |    9 -
 .../SharpZipLib/Zip/GeneralBitFlags.cs        |   25 -
 .../SharpZipLib/Zip/HostSystemID.cs           |   28 -
 .../SharpZipLib/Zip/IArchiveStorage.cs        |   20 -
 .../SharpZipLib/Zip/IDynamicDataSource.cs     |   10 -
 .../SharpZipLib/Zip/IEntryFactory.cs          |   14 -
 .../SharpZipLib/Zip/IStaticDataSource.cs      |   10 -
 .../SharpZipLib/Zip/KeysRequiredEventArgs.cs  |   27 -
 .../SharpZipLib/Zip/MemoryArchiveStorage.cs   |   69 -
 .../SharpZipLib/Zip/StaticDiskDataSource.cs   |   14 -
 .../SharpZipLib/Zip/TestOperation.cs          |   13 -
 .../ICSharpCode/SharpZipLib/Zip/TestStatus.cs |   44 -
 .../SharpZipLib/Zip/TestStrategy.cs           |    9 -
 .../ICSharpCode/SharpZipLib/Zip/UseZip64.cs   |   10 -
 .../SharpZipLib/Zip/ZipConstants.cs           |  107 -
 .../ICSharpCode/SharpZipLib/Zip/ZipEntry.cs   |  399 ----
 .../SharpZipLib/Zip/ZipEntryFactory.cs        |  148 --
 .../SharpZipLib/Zip/ZipException.cs           |   29 -
 .../SharpZipLib/Zip/ZipExtraData.cs           |  230 --
 .../ICSharpCode/SharpZipLib/Zip/ZipFile.cs    | 1851 ---------------
 .../SharpZipLib/Zip/ZipHelperStream.cs        |  189 --
 .../SharpZipLib/Zip/ZipInputStream.cs         |  299 ---
 .../SharpZipLib/Zip/ZipNameTransform.cs       |   90 -
 .../SharpZipLib/Zip/ZipOutputStream.cs        |  406 ----
 .../SharpZipLib/Zip/ZipTestResultHandler.cs   |    5 -
 MSHALTester/LzmaAlone/Properties/Settings.cs  |   37 -
 MSHALTester/MSHALTester.csproj                |  670 +-----
 MSHALTester/MSHALTester.sln                   |   10 +-
 MSHALTester/Newtonsoft/Json/Bson/BsonArray.cs |   26 -
 .../Newtonsoft/Json/Bson/BsonBinary.cs        |   14 -
 .../Newtonsoft/Json/Bson/BsonBinaryType.cs    |   16 -
 .../Newtonsoft/Json/Bson/BsonBinaryWriter.cs  |  215 --
 .../Newtonsoft/Json/Bson/BsonBoolean.cs       |   14 -
 MSHALTester/Newtonsoft/Json/Bson/BsonEmpty.cs |   13 -
 .../Newtonsoft/Json/Bson/BsonObject.cs        |   30 -
 .../Newtonsoft/Json/Bson/BsonObjectId.cs      |   18 -
 .../Newtonsoft/Json/Bson/BsonProperty.cs      |   10 -
 .../Newtonsoft/Json/Bson/BsonReader.cs        |  581 -----
 MSHALTester/Newtonsoft/Json/Bson/BsonRegex.cs |   18 -
 .../Newtonsoft/Json/Bson/BsonString.cs        |   16 -
 MSHALTester/Newtonsoft/Json/Bson/BsonToken.cs |   12 -
 MSHALTester/Newtonsoft/Json/Bson/BsonType.cs  |   27 -
 MSHALTester/Newtonsoft/Json/Bson/BsonValue.cs |   19 -
 .../Newtonsoft/Json/Bson/BsonWriter.cs        |  297 ---
 .../Newtonsoft/Json/ConstructorHandling.cs    |    9 -
 .../Json/Converters/BinaryConverter.cs        |  104 -
 .../Json/Converters/BsonObjectIdConverter.cs  |   32 -
 .../Converters/CustomCreationConverter`1.cs   |   34 -
 .../Json/Converters/DataSetConverter.cs       |   56 -
 .../Json/Converters/DataTableConverter.cs     |  151 --
 .../Json/Converters/DateTimeConverterBase.cs  |   13 -
 .../Converters/EntityKeyMemberConverter.cs    |   83 -
 .../Json/Converters/IXmlDeclaration.cs        |   12 -
 .../Json/Converters/IXmlDocument.cs           |   36 -
 .../Json/Converters/IXmlDocumentType.cs       |   14 -
 .../Newtonsoft/Json/Converters/IXmlElement.cs |   12 -
 .../Newtonsoft/Json/Converters/IXmlNode.cs    |   27 -
 .../Json/Converters/IsoDateTimeConverter.cs   |   76 -
 .../Converters/JavaScriptDateTimeConverter.cs |   51 -
 .../Json/Converters/KeyValuePairConverter.cs  |   85 -
 .../Json/Converters/RegexConverter.cs         |  128 -
 .../Json/Converters/StringEnumConverter.cs    |   83 -
 .../Json/Converters/UnixDateTimeConverter.cs  |   60 -
 .../Json/Converters/VersionConverter.cs       |   46 -
 .../Json/Converters/XAttributeWrapper.cs      |   28 -
 .../Json/Converters/XCommentWrapper.cs        |   24 -
 .../Json/Converters/XContainerWrapper.cs      |   76 -
 .../Json/Converters/XDeclarationWrapper.cs    |   33 -
 .../Json/Converters/XDocumentTypeWrapper.cs   |   26 -
 .../Json/Converters/XDocumentWrapper.cs       |  109 -
 .../Json/Converters/XElementWrapper.cs        |   86 -
 .../Json/Converters/XObjectWrapper.cs         |   37 -
 .../XProcessingInstructionWrapper.cs          |   22 -
 .../Json/Converters/XTextWrapper.cs           |   24 -
 .../Json/Converters/XmlDeclarationWrapper.cs  |   30 -
 .../Json/Converters/XmlDocumentTypeWrapper.cs |   26 -
 .../Json/Converters/XmlDocumentWrapper.cs     |   94 -
 .../Json/Converters/XmlElementWrapper.cs      |   28 -
 .../Json/Converters/XmlNodeConverter.cs       |  944 --------
 .../Json/Converters/XmlNodeWrapper.cs         |  116 -
 .../Newtonsoft/Json/DateFormatHandling.cs     |    9 -
 .../Newtonsoft/Json/DateParseHandling.cs      |   10 -
 .../Newtonsoft/Json/DateTimeZoneHandling.cs   |   11 -
 .../Newtonsoft/Json/DefaultValueHandling.cs   |   14 -
 .../Newtonsoft/Json/FloatFormatHandling.cs    |   10 -
 .../Newtonsoft/Json/FloatParseHandling.cs     |    9 -
 MSHALTester/Newtonsoft/Json/Formatting.cs     |    9 -
 MSHALTester/Newtonsoft/Json/IArrayPool`1.cs   |   10 -
 MSHALTester/Newtonsoft/Json/IJsonLineInfo.cs  |   12 -
 .../Newtonsoft/Json/JsonArrayAttribute.cs     |   28 -
 .../Json/JsonConstructorAttribute.cs          |   10 -
 .../Newtonsoft/Json/JsonContainerAttribute.cs |   79 -
 .../Newtonsoft/Json/JsonContainerType.cs      |   11 -
 MSHALTester/Newtonsoft/Json/JsonConvert.cs    |  524 -----
 MSHALTester/Newtonsoft/Json/JsonConverter.cs  |   22 -
 .../Newtonsoft/Json/JsonConverterAttribute.cs |   26 -
 .../Json/JsonConverterCollection.cs           |    9 -
 .../Newtonsoft/Json/JsonConverter`1.cs        |   46 -
 .../Json/JsonDictionaryAttribute.cs           |   18 -
 MSHALTester/Newtonsoft/Json/JsonException.cs  |   35 -
 .../Json/JsonExtensionDataAttribute.cs        |   19 -
 .../Newtonsoft/Json/JsonIgnoreAttribute.cs    |   10 -
 .../Newtonsoft/Json/JsonObjectAttribute.cs    |   45 -
 MSHALTester/Newtonsoft/Json/JsonPosition.cs   |  139 --
 .../Newtonsoft/Json/JsonPropertyAttribute.cs  |  103 -
 MSHALTester/Newtonsoft/Json/JsonReader.cs     |  825 -------
 .../Newtonsoft/Json/JsonReaderException.cs    |   80 -
 .../Newtonsoft/Json/JsonRequiredAttribute.cs  |   10 -
 .../Json/JsonSerializationException.cs        |   52 -
 MSHALTester/Newtonsoft/Json/JsonSerializer.cs |  742 ------
 .../Newtonsoft/Json/JsonSerializerSettings.cs |  259 --
 MSHALTester/Newtonsoft/Json/JsonTextReader.cs | 2091 -----------------
 MSHALTester/Newtonsoft/Json/JsonTextWriter.cs |  579 -----
 MSHALTester/Newtonsoft/Json/JsonToken.cs      |   25 -
 .../Newtonsoft/Json/JsonValidatingReader.cs   |  693 ------
 MSHALTester/Newtonsoft/Json/JsonWriter.cs     | 1209 ----------
 .../Newtonsoft/Json/JsonWriterException.cs    |   48 -
 .../Newtonsoft/Json/Linq/CommentHandling.cs   |    9 -
 .../Newtonsoft/Json/Linq/Extensions.cs        |  151 --
 .../Newtonsoft/Json/Linq/IJEnumerable`1.cs    |   11 -
 MSHALTester/Newtonsoft/Json/Linq/JArray.cs    |  152 --
 .../Newtonsoft/Json/Linq/JConstructor.cs      |  121 -
 .../Newtonsoft/Json/Linq/JContainer.cs        |  718 ------
 .../Newtonsoft/Json/Linq/JEnumerable`1.cs     |   53 -
 MSHALTester/Newtonsoft/Json/Linq/JObject.cs   |  395 ----
 MSHALTester/Newtonsoft/Json/Linq/JProperty.cs |  230 --
 .../Json/Linq/JPropertyDescriptor.cs          |   43 -
 .../Json/Linq/JPropertyKeyedCollection.cs     |  173 --
 MSHALTester/Newtonsoft/Json/Linq/JRaw.cs      |   34 -
 MSHALTester/Newtonsoft/Json/Linq/JToken.cs    | 1291 ----------
 .../Json/Linq/JTokenEqualityComparer.cs       |   12 -
 .../Newtonsoft/Json/Linq/JTokenReader.cs      |  210 --
 .../Newtonsoft/Json/Linq/JTokenType.cs        |   25 -
 .../Newtonsoft/Json/Linq/JTokenWriter.cs      |  292 ---
 MSHALTester/Newtonsoft/Json/Linq/JValue.cs    |  453 ----
 .../Newtonsoft/Json/Linq/JsonLoadSettings.cs  |   35 -
 .../Newtonsoft/Json/Linq/JsonMergeSettings.cs |   29 -
 .../Json/Linq/JsonPath/ArrayIndexFilter.cs    |   41 -
 .../Linq/JsonPath/ArrayMultipleIndexFilter.cs |   26 -
 .../Json/Linq/JsonPath/ArraySliceFilter.cs    |   92 -
 .../Linq/JsonPath/BooleanQueryExpression.cs   |  158 --
 .../Json/Linq/JsonPath/CompositeExpression.cs |   36 -
 .../Json/Linq/JsonPath/FieldFilter.cs         |   42 -
 .../Json/Linq/JsonPath/FieldMultipleFilter.cs |   38 -
 .../Newtonsoft/Json/Linq/JsonPath/JPath.cs    |  671 ------
 .../Json/Linq/JsonPath/PathFilter.cs          |   56 -
 .../Json/Linq/JsonPath/QueryExpression.cs     |   10 -
 .../Json/Linq/JsonPath/QueryFilter.cs         |   25 -
 .../Json/Linq/JsonPath/QueryOperator.cs       |   18 -
 .../Json/Linq/JsonPath/QueryScanFilter.cs     |   30 -
 .../Json/Linq/JsonPath/RootFilter.cs          |   22 -
 .../Json/Linq/JsonPath/ScanFilter.cs          |   44 -
 .../Json/Linq/JsonPath/ScanMultipleFilter.cs  |   40 -
 .../Newtonsoft/Json/Linq/LineInfoHandling.cs  |    9 -
 .../Json/Linq/MergeArrayHandling.cs           |   11 -
 .../Json/Linq/MergeNullValueHandling.cs       |   12 -
 .../Newtonsoft/Json/MemberSerialization.cs    |   10 -
 .../Json/MetadataPropertyHandling.cs          |   10 -
 .../Newtonsoft/Json/MissingMemberHandling.cs  |    9 -
 .../Newtonsoft/Json/NullValueHandling.cs      |    9 -
 .../Newtonsoft/Json/ObjectCreationHandling.cs |   10 -
 .../Json/PreserveReferencesHandling.cs        |   14 -
 MSHALTester/Newtonsoft/Json/ReadType.cs       |   17 -
 .../Newtonsoft/Json/ReferenceLoopHandling.cs  |   10 -
 MSHALTester/Newtonsoft/Json/Required.cs       |   11 -
 .../Newtonsoft/Json/Schema/Extensions.cs      |   57 -
 .../Newtonsoft/Json/Schema/JsonSchema.cs      |  135 --
 .../Json/Schema/JsonSchemaBuilder.cs          |  364 ---
 .../Json/Schema/JsonSchemaConstants.cs        |   78 -
 .../Json/Schema/JsonSchemaException.cs        |   49 -
 .../Json/Schema/JsonSchemaGenerator.cs        |  336 ---
 .../Newtonsoft/Json/Schema/JsonSchemaModel.cs |  143 --
 .../Json/Schema/JsonSchemaModelBuilder.cs     |  134 --
 .../Newtonsoft/Json/Schema/JsonSchemaNode.cs  |   59 -
 .../Json/Schema/JsonSchemaNodeCollection.cs   |   12 -
 .../Json/Schema/JsonSchemaResolver.cs         |   20 -
 .../Newtonsoft/Json/Schema/JsonSchemaType.cs  |   20 -
 .../Json/Schema/JsonSchemaWriter.cs           |  208 --
 .../Json/Schema/UndefinedSchemaIdHandling.cs  |   13 -
 .../Json/Schema/ValidationEventArgs.cs        |   24 -
 .../Json/Schema/ValidationEventHandler.cs     |    8 -
 .../Serialization/CachedAttributeGetter`1.cs  |   16 -
 .../Serialization/CamelCaseNamingStrategy.cs  |   29 -
 .../CamelCasePropertyNamesContractResolver.cs |   46 -
 .../Serialization/DefaultContractResolver.cs  |  935 --------
 .../Serialization/DefaultNamingStrategy.cs    |    8 -
 .../Serialization/DefaultReferenceResolver.cs |   57 -
 .../DefaultSerializationBinder.cs             |  112 -
 .../Serialization/DiagnosticsTraceWriter.cs   |   48 -
 .../Serialization/DynamicValueProvider.cs     |   49 -
 .../Json/Serialization/ErrorContext.cs        |   28 -
 .../Json/Serialization/ErrorEventArgs.cs      |   18 -
 .../Json/Serialization/ExtensionDataGetter.cs |    7 -
 .../Json/Serialization/ExtensionDataSetter.cs |    5 -
 .../Json/Serialization/IAttributeProvider.cs  |   13 -
 .../Json/Serialization/IContractResolver.cs   |   10 -
 .../Json/Serialization/IReferenceResolver.cs  |   14 -
 .../Serialization/ISerializationBinder.cs     |   12 -
 .../Json/Serialization/ITraceWriter.cs        |   13 -
 .../Json/Serialization/IValueProvider.cs      |   10 -
 .../Json/Serialization/JsonArrayContract.cs   |  159 --
 .../Serialization/JsonContainerContract.cs    |   48 -
 .../Json/Serialization/JsonContract.cs        |  171 --
 .../Json/Serialization/JsonContractType.cs    |   16 -
 .../Serialization/JsonDictionaryContract.cs   |  114 -
 .../Serialization/JsonFormatterConverter.cs   |   80 -
 .../JsonISerializableContract.cs              |   16 -
 .../Json/Serialization/JsonLinqContract.cs    |   14 -
 .../Json/Serialization/JsonObjectContract.cs  |  112 -
 .../Serialization/JsonPrimitiveContract.cs    |   40 -
 .../Json/Serialization/JsonProperty.cs        |  134 --
 .../Serialization/JsonPropertyCollection.cs   |   83 -
 .../JsonSerializerInternalBase.cs             |   94 -
 .../JsonSerializerInternalReader.cs           | 1701 --------------
 .../JsonSerializerInternalWriter.cs           |  813 -------
 .../Json/Serialization/JsonSerializerProxy.cs |  241 --
 .../Json/Serialization/JsonStringContract.cs  |   14 -
 .../Json/Serialization/JsonTypeReflector.cs   |  299 ---
 .../Json/Serialization/MemoryTraceWriter.cs   |   58 -
 .../Json/Serialization/NamingStrategy.cs      |   29 -
 .../Json/Serialization/ObjectConstructor`1.cs |    5 -
 .../Json/Serialization/OnErrorAttribute.cs    |   10 -
 .../ReflectionAttributeProvider.cs            |   28 -
 .../Serialization/ReflectionValueProvider.cs  |   45 -
 .../Json/Serialization/ResolverContractKey.cs |   27 -
 .../SerializationBinderAdapter.cs             |   27 -
 .../Serialization/SerializationCallback.cs    |    7 -
 .../SerializationErrorCallback.cs             |   10 -
 .../Serialization/SnakeCaseNamingStrategy.cs  |   29 -
 .../Json/Serialization/TraceJsonReader.cs     |  126 -
 .../Json/Serialization/TraceJsonWriter.cs     |  467 ----
 .../Newtonsoft/Json/StringEscapeHandling.cs   |   10 -
 .../Json/TypeNameAssemblyFormatHandling.cs    |    9 -
 .../Newtonsoft/Json/TypeNameHandling.cs       |   15 -
 .../Json/Utilities/Base64Encoder.cs           |   95 -
 .../Utilities/BidirectionalDictionary`2.cs    |   61 -
 .../Newtonsoft/Json/Utilities/BufferUtils.cs  |   25 -
 .../Json/Utilities/CollectionUtils.cs         |  229 --
 .../Json/Utilities/CollectionWrapper`1.cs     |  194 --
 .../Newtonsoft/Json/Utilities/ConvertUtils.cs |  880 -------
 .../Newtonsoft/Json/Utilities/Creator`1.cs    |    5 -
 .../Json/Utilities/DateTimeParser.cs          |  196 --
 .../Json/Utilities/DateTimeUtils.cs           |  648 -----
 .../Json/Utilities/DictionaryWrapper`2.cs     |  307 ---
 .../DynamicReflectionDelegateFactory.cs       |  285 ---
 .../Newtonsoft/Json/Utilities/EnumInfo.cs     |   19 -
 .../Newtonsoft/Json/Utilities/EnumUtils.cs    |  251 --
 .../Json/Utilities/ILGeneratorExtensions.cs   |   52 -
 .../Json/Utilities/IWrappedCollection.cs      |   10 -
 .../Json/Utilities/IWrappedDictionary.cs      |   10 -
 .../Utilities/ImmutableCollectionsUtils.cs    |  143 --
 .../Json/Utilities/JavaScriptUtils.cs         |  233 --
 .../Json/Utilities/JsonTokenUtils.cs          |   50 -
 .../LateBoundReflectionDelegateFactory.cs     |   64 -
 .../Newtonsoft/Json/Utilities/MathUtils.cs    |   81 -
 .../Newtonsoft/Json/Utilities/MethodCall`2.cs |    5 -
 .../Json/Utilities/MiscellaneousUtils.cs      |  136 --
 .../Newtonsoft/Json/Utilities/ParseResult.cs  |   11 -
 .../Json/Utilities/ParserTimeZone.cs          |   11 -
 .../Json/Utilities/PrimitiveTypeCode.cs       |   49 -
 .../Json/Utilities/PropertyNameTable.cs       |  110 -
 .../Utilities/ReflectionDelegateFactory.cs    |   53 -
 .../Json/Utilities/ReflectionMember.cs        |   14 -
 .../Json/Utilities/ReflectionObject.cs        |  100 -
 .../Json/Utilities/ReflectionUtils.cs         |  624 -----
 .../Newtonsoft/Json/Utilities/StringBuffer.cs |   72 -
 .../Json/Utilities/StringReference.cs         |   20 -
 .../Utilities/StringReferenceExtensions.cs    |   41 -
 .../Newtonsoft/Json/Utilities/StringUtils.cs  |  250 --
 .../Json/Utilities/ThreadSafeStore`2.cs       |   51 -
 .../Json/Utilities/TypeExtensions.cs          |   90 -
 .../Json/Utilities/TypeInformation.cs         |   12 -
 .../Newtonsoft/Json/Utilities/TypeNameKey.cs  |   28 -
 .../Json/Utilities/ValidationUtils.cs         |   14 -
 MSHALTester/Newtonsoft/Json/WriteState.cs     |   14 -
 .../AbstractDirectShowFrameControl.cs         |    2 +-
 .../DirectShow/CameraControlProperty.cs       |    1 -
 .../Redbox/DirectShow/ControlConstants.cs     |    1 -
 .../DirectShow/DirectShowFrameControl.cs      |    2 +-
 .../DirectShow/DirectShowFrameControl_v2.cs   |    2 +-
 .../Redbox/DirectShow/FrameControls.cs        |    1 -
 MSHALTester/Redbox/DirectShow/IVideoSource.cs |    1 -
 .../Redbox/DirectShow/Interop/DsEvCode.cs     |    1 -
 .../Redbox/DirectShow/Interop/FilterState.cs  |    1 -
 .../Redbox/DirectShow/NewFrameEventHandler.cs |    1 -
 .../DirectShow/PhysicalConnectorType.cs       |    1 -
 .../DirectShow/PlayingFinishedEventHandler.cs |    1 -
 .../DirectShow/ReasonToFinishPlaying.cs       |    1 -
 .../Redbox/DirectShow/SampleGrabber.cs        |    2 +-
 MSHALTester/Redbox/DirectShow/VideoInput.cs   |    1 -
 .../VideoSourceErrorEventHandler.cs           |    1 -
 MSHALTester/Redbox/HAL/Client/Constants.cs    |    1 -
 .../HAL/Client/Executors/AdjacentBinTest.cs   |    1 -
 .../HAL/Client/Executors/BoardTestJob.cs      |    1 -
 .../Executors/ClearImagesFolderExecutor.cs    |    1 -
 .../HAL/Client/Executors/FraudSensorPost.cs   |    1 -
 .../Client/Executors/GetAndCenterResult.cs    |    1 -
 .../Client/Executors/GetAndReadExecutor.cs    |    1 -
 .../Executors/HardwareStatusExecutor.cs       |    1 -
 .../HAL/Client/Executors/IDeckConfig.cs       |    1 -
 .../Redbox/HAL/Client/Executors/InitJob.cs    |    1 -
 .../HAL/Client/Executors/InventoryStatsJob.cs |    1 -
 .../HAL/Client/Executors/MSPullInDvdJob.cs    |    1 -
 .../HAL/Client/Executors/OneDiskQuickTest.cs  |    1 -
 .../Executors/OneDiskRandomSyncExecutor.cs    |    1 -
 .../Executors/PowerCycleRouterExecutor.cs     |    1 -
 .../HAL/Client/Executors/PushInDvdJob.cs      |    1 -
 .../Executors/PutDiskInPickerInBinJob.cs      |    1 -
 .../Client/Executors/PutInEmptySlotResult.cs  |    1 -
 .../Client/Executors/PutInLocationResult.cs   |    1 -
 .../HAL/Client/Executors/QlmTestSyncJob.cs    |    1 -
 .../Client/Executors/RandomSyncExecutor.cs    |    1 -
 .../Client/Executors/ReadFraudDiskExecutor.cs |    1 -
 .../Executors/RebuildInventoryExecutor.cs     |    1 -
 .../Client/Executors/ResetControlSystemJob.cs |    1 -
 .../Client/Executors/ResetFraudSensorJob.cs   |    1 -
 .../Executors/ResetMotionControlExecutor.cs   |    1 -
 .../HAL/Client/Executors/ReturnExecutor.cs    |    1 -
 .../Client/Executors/ReturnUnknownExecutor.cs |    1 -
 .../HAL/Client/Executors/TakeDiskAtDoorJob.cs |    1 -
 .../Executors/TestAndResetCCRExecutor.cs      |    1 -
 .../HAL/Client/Executors/TestRetrofitDeck.cs  |    1 -
 .../HAL/Client/Executors/UpdateQREEPROMJob.cs |    1 -
 .../Client/Executors/VendDiskInPickerJob.cs   |    1 -
 .../HAL/Client/Executors/VerticalSync.cs      |    1 -
 .../HAL/Client/HardwareJobConnectionState.cs  |    1 -
 .../Redbox/HAL/Client/HardwareJobPriority.cs  |    1 -
 .../Redbox/HAL/Client/HardwareJobStatus.cs    |    1 -
 .../HAL/Client/HardwareStatusChangeEvent.cs   |    1 -
 .../Redbox/HAL/Client/IClientOutputSink.cs    |    1 -
 MSHALTester/Redbox/HAL/Client/Location.cs     |    1 -
 MSHALTester/Redbox/HAL/Client/NullSink.cs     |    1 -
 .../Redbox/HAL/Client/Services/CameraState.cs |    1 -
 .../Client/Services/ExecuteServiceCommand.cs  |    1 -
 .../ExecuteStatementImmediateCommand.cs       |    1 -
 .../Client/Services/ImmediateCommandResult.cs |    1 -
 MSHALTester/Redbox/HAL/Client/SpeakerState.cs |    1 -
 MSHALTester/Redbox/HAL/Client/SyncRange.cs    |    1 -
 .../GUI/Functions/ISessionUserService.cs      |    1 -
 .../HAL/Component/Model/AirExchangerStatus.cs |    1 -
 .../HAL/Component/Model/AudioChannelState.cs  |    1 -
 .../Redbox/HAL/Component/Model/AuxInputs.cs   |    1 -
 .../Redbox/HAL/Component/Model/Axis.cs        |    1 -
 .../HAL/Component/Model/BackupAction.cs       |    1 -
 .../HAL/Component/Model/BarcodeServices.cs    |    1 -
 .../HAL/Component/Model/CameraGeneration.cs   |    1 -
 .../HAL/Component/Model/CenterDiskMethod.cs   |    1 -
 .../Redbox/HAL/Component/Model/ChannelType.cs |    1 -
 .../HAL/Component/Model/CommPortReadModes.cs  |    1 -
 .../CompressionAlgorithmFactory.cs            |    1 -
 .../Compression/NullCompressionAlgorithm.cs   |    1 -
 .../HAL/Component/Model/CompressionType.cs    |    1 -
 .../HAL/Component/Model/Configurations.cs     |    1 -
 .../HAL/Component/Model/ConnectionState.cs    |    1 -
 .../HAL/Component/Model/ControlBoards.cs      |    1 -
 .../HAL/Component/Model/ConversionResult.cs   |    1 -
 .../HAL/Component/Model/DecodeResult.cs       |    1 -
 .../Redbox/HAL/Component/Model/DeviceClass.cs |    1 -
 .../Redbox/HAL/Component/Model/DeviceState.cs |    1 -
 .../HAL/Component/Model/DoorSensorResult.cs   |    1 -
 .../HAL/Component/Model/DriverMatchType.cs    |    1 -
 .../Redbox/HAL/Component/Model/ErrorCodes.cs  |    1 -
 .../HAL/Component/Model/ExchangerFanStatus.cs |    1 -
 .../Component/Model/ExecutionContextStatus.cs |    1 -
 .../Component/Model/FraudValidationResult.cs  |    1 -
 .../HAL/Component/Model/GripperFingerState.cs |    1 -
 .../Model/HardwareCorrectionStatistic.cs      |    1 -
 .../Component/Model/IAirExchangerService.cs   |    1 -
 .../HAL/Component/Model/IBarcodeReader.cs     |    1 -
 .../Component/Model/IBarcodeReaderFactory.cs  |    1 -
 .../Model/IBarcodeValidatorService.cs         |    1 -
 .../Component/Model/IBoardVersionResponse.cs  |    1 -
 .../HAL/Component/Model/ICloneable`1.cs       |    1 -
 .../Model/ICommChannelConfiguration.cs        |    1 -
 .../Model/IComponentErrorThreshold.cs         |    1 -
 .../Model/IComponentErrorThresholdService.cs  |    1 -
 .../Component/Model/ICompressionAlgorithm.cs  |    1 -
 .../HAL/Component/Model/IConfigurationFile.cs |    1 -
 .../Component/Model/IConfigurationObserver.cs |    1 -
 .../Component/Model/IConfigurationService.cs  |    1 -
 .../HAL/Component/Model/IContextSymbol.cs     |    1 -
 .../HAL/Component/Model/IControlResponse.cs   |    1 -
 .../HAL/Component/Model/IControlSystem.cs     |    1 -
 .../Component/Model/IControlSystemObserver.cs |    1 -
 .../Component/Model/IControlSystemRevision.cs |    1 -
 .../Component/Model/IControlSystemService.cs  |    1 -
 .../Component/Model/IControllerPosition.cs    |    1 -
 .../Component/Model/IDataTableDescriptor.cs   |    1 -
 .../HAL/Component/Model/IDataTableService.cs  |    1 -
 .../HAL/Component/Model/IDecodeResult.cs      |    1 -
 .../HAL/Component/Model/IDeviceDescriptor.cs  |    1 -
 .../Model/IDeviceSetupClassFactory.cs         |    1 -
 .../HAL/Component/Model/IDoorSensorService.cs |    1 -
 .../Component/Model/IDuplicateSearchResult.cs |    1 -
 .../Model/IEmptySearchPatternService.cs       |    1 -
 .../IExcludeEmptySearchLocationObserver.cs    |    1 -
 .../HAL/Component/Model/IFormattedLog.cs      |    1 -
 .../Model/IFormattedLogFactoryService.cs      |    1 -
 .../HAL/Component/Model/IFraudService.cs      |    1 -
 .../HAL/Component/Model/IGetFromObserver.cs   |    1 -
 .../HAL/Component/Model/IGetFromResult.cs     |    1 -
 .../HAL/Component/Model/IGetObserver.cs       |    1 -
 .../Model/IHardwareCorrectionObserver.cs      |    1 -
 .../Redbox/HAL/Component/Model/IHostInfo.cs   |    1 -
 .../HAL/Component/Model/IInventoryObserver.cs |    1 -
 .../HAL/Component/Model/IIpcProtocol.cs       |    1 -
 .../Component/Model/IIpcProtocolFactory.cs    |    1 -
 .../HAL/Component/Model/IIpcServiceHost.cs    |    1 -
 .../Component/Model/IKioskConfiguration.cs    |    1 -
 .../HAL/Component/Model/IMessageSink.cs       |    1 -
 .../Component/Model/IMotionControlLimit.cs    |    1 -
 .../Model/IMotionControlLimitResponse.cs      |    1 -
 .../Component/Model/IMotionControlService.cs  |    1 -
 .../Redbox/HAL/Component/Model/IMoveVeto.cs   |    1 -
 .../Redbox/HAL/Component/Model/IPeekResult.cs |    1 -
 .../HAL/Component/Model/IPersistentCounter.cs |    1 -
 .../Model/IPersistentCounterService.cs        |    1 -
 .../HAL/Component/Model/IPersistentMap.cs     |    1 -
 .../Component/Model/IPersistentMapService.cs  |    1 -
 .../HAL/Component/Model/IPersistentOption.cs  |    1 -
 .../Model/IPickerSensorReadResult.cs          |    1 -
 .../HAL/Component/Model/IPowerCycleDevice.cs  |    1 -
 .../Model/IPowerCycleDeviceService.cs         |    1 -
 .../Component/Model/IPowerEventObserver.cs    |    1 -
 .../HAL/Component/Model/IPowerEventService.cs |    1 -
 .../HAL/Component/Model/IPutObserver.cs       |    1 -
 .../Redbox/HAL/Component/Model/IPutResult.cs  |    1 -
 .../HAL/Component/Model/IPutToObserver.cs     |    1 -
 .../HAL/Component/Model/IPutToResult.cs       |    1 -
 .../Redbox/HAL/Component/Model/IQuadrant.cs   |    1 -
 .../Component/Model/IQueryUsbDeviceResult.cs  |    1 -
 .../Redbox/HAL/Component/Model/IRange`1.cs    |    1 -
 .../Component/Model/ITouchscreenDescriptor.cs |    1 -
 .../HAL/Component/Model/ITransferResult.cs    |    1 -
 .../HAL/Component/Model/IVendItemResult.cs    |    1 -
 .../Redbox/HAL/Component/Model/InputState.cs  |    1 -
 .../HAL/Component/Model/IpcHostVersion.cs     |    1 -
 .../HAL/Component/Model/KioskConfiguration.cs |    1 -
 .../HAL/Component/Model/LogEntryType.cs       |    1 -
 .../Redbox/HAL/Component/Model/MerchFlags.cs  |    1 -
 .../HAL/Component/Model/MessageSeverity.cs    |    1 -
 .../Redbox/HAL/Component/Model/MessageType.cs |    1 -
 .../Component/Model/MotionControlLimits.cs    |    1 -
 .../Redbox/HAL/Component/Model/MoveMode.cs    |    1 -
 .../HAL/Component/Model/OffsetMoveData.cs     |    1 -
 .../HAL/Component/Model/PickerInputs.cs       |    1 -
 .../Redbox/HAL/Component/Model/Platform.cs    |    1 -
 .../HAL/Component/Model/PowerCycleDevices.cs  |    1 -
 .../HAL/Component/Model/ProgramPriority.cs    |    1 -
 .../Redbox/HAL/Component/Model/QlmStatus.cs   |    1 -
 .../Model/RedboxHardwareErrorThreshold.cs     |    1 -
 .../HAL/Component/Model/RollerPosition.cs     |    1 -
 .../Redbox/HAL/Component/Model/RollerState.cs |    1 -
 .../HAL/Component/Model/ScannerServices.cs    |    1 -
 .../Redbox/HAL/Component/Model/StackEnd.cs    |    1 -
 .../Component/Model/SystemConfigurations.cs   |    1 -
 .../HAL/Component/Model/TimeoutCounters.cs    |    1 -
 .../Component/Model/Tokenizer/StateResult.cs  |    1 -
 .../Component/Model/Tokenizer/TokenType.cs    |    1 -
 .../Component/Model/Tokenizer/Tokenizer`1.cs  |    1 -
 .../Redbox/HAL/Component/Model/TrackState.cs  |    1 -
 .../Redbox/HAL/Component/Model/UnzipResult.cs |    1 -
 .../HAL/Component/Model/VendDoorState.cs      |    1 -
 .../Redbox/HAL/Component/Model/ZipResult.cs   |    1 -
 .../HAL/Configuration/GampBackupResult.cs     |    1 -
 .../Redbox/HAL/Configuration/PlatterType.cs   |    1 -
 .../Core/Descriptors/_3mHardResetCommand.cs   |    1 -
 .../Core/Descriptors/_3mSoftResetCommand.cs   |    1 -
 MSHALTester/Redbox/HAL/Core/NumberBases.cs    |    1 -
 .../Redbox/HAL/Core/NumberingSchemes.cs       |    1 -
 MSHALTester/Redbox/HAL/Core/StateResult.cs    |    1 -
 MSHALTester/Redbox/HAL/Core/TokenType.cs      |    1 -
 MSHALTester/Redbox/HAL/Core/Tokenizer`1.cs    |    1 -
 .../HAL/IPC/Framework/BinaryEncoding.cs       |    1 -
 .../HAL/IPC/Framework/CommandParserState.cs   |    1 -
 .../IPC/Framework/CommunicationsConstants.cs  |    1 -
 .../HAL/IPC/Framework/FormMethodHandler.cs    |    1 -
 .../IPC/Framework/Pipes/NamedPipeServer.cs    |    2 +-
 .../HAL/IPC/Framework/ServerResponse.cs       |    1 -
 .../HAL/IPC/Framework/SessionConstants.cs     |    1 -
 .../Redbox/HAL/MSHALTester/CommonFunctions.cs |    3 +-
 .../Redbox/HAL/MSHALTester/Configuration.cs   |    1 -
 .../HAL/MSHALTester/ConfiguredDevicesForm.cs  |   18 +-
 .../MSHALTester/DeckConfigurationColumns.cs   |    1 -
 .../DeckConfigurationDetailColumns.cs         |    1 -
 MSHALTester/Redbox/HAL/MSHALTester/Form1.cs   |    3 +-
 .../HAL/MSHALTester/KioskFunctionTest.cs      |    3 +-
 .../Redbox/HAL/MSHALTester/TestState.cs       |    1 -
 .../HAL/MSHALTester/TransferLocation.cs       |    1 -
 MSHALTester/SevenZip/CRC.cs                   |   56 -
 MSHALTester/SevenZip/CoderPropID.cs           |   22 -
 .../SevenZip/Compression/LZ/BinTree.cs        |  370 ---
 .../Compression/LZ/IInWindowStream.cs         |   20 -
 .../SevenZip/Compression/LZ/IMatchFinder.cs   |   16 -
 .../SevenZip/Compression/LZ/InWindow.cs       |  127 -
 .../SevenZip/Compression/LZ/OutWindow.cs      |   86 -
 MSHALTester/SevenZip/Compression/LZMA/Base.cs |   65 -
 .../SevenZip/Compression/LZMA/Decoder.cs      |  349 ---
 .../SevenZip/Compression/LZMA/Encoder.cs      | 1336 -----------
 .../Compression/LZMA/SevenZipHelper.cs        |    1 -
 .../Compression/RangeCoder/BitDecoder.cs      |   46 -
 .../Compression/RangeCoder/BitEncoder.cs      |   66 -
 .../Compression/RangeCoder/BitTreeDecoder.cs  |   55 -
 .../Compression/RangeCoder/BitTreeEncoder.cs  |  106 -
 .../Compression/RangeCoder/Decoder.cs         |   90 -
 .../Compression/RangeCoder/Encoder.cs         |  106 -
 MSHALTester/SevenZip/DataErrorException.cs    |   13 -
 MSHALTester/SevenZip/ICodeProgress.cs         |   11 -
 MSHALTester/SevenZip/ICoder.cs                |   17 -
 MSHALTester/SevenZip/ISetCoderProperties.cs   |   11 -
 MSHALTester/SevenZip/ISetDecoderProperties.cs |   11 -
 MSHALTester/SevenZip/IWriteCoderProperties.cs |   12 -
 MSHALTester/SevenZip/InvalidParamException.cs |   13 -
 .../log4net/Appender/AdoNetAppender.cs        |  299 ---
 .../Appender/AdoNetAppenderParameter.cs       |   85 -
 .../Appender/AnsiColorTerminalAppender.cs     |  133 --
 .../log4net/Appender/AppenderCollection.cs    |  403 ----
 .../log4net/Appender/AppenderSkeleton.cs      |  209 --
 .../log4net/Appender/AspNetTraceAppender.cs   |   21 -
 .../Appender/BufferingAppenderSkeleton.cs     |  135 --
 .../Appender/BufferingForwardingAppender.cs   |   95 -
 .../Appender/ColoredConsoleAppender.cs        |  178 --
 .../log4net/Appender/ConsoleAppender.cs       |   54 -
 MSHALTester/log4net/Appender/DebugAppender.cs |   36 -
 .../log4net/Appender/EventLogAppender.cs      |  156 --
 MSHALTester/log4net/Appender/FileAppender.cs  |  497 ----
 .../log4net/Appender/ForwardingAppender.cs    |   93 -
 MSHALTester/log4net/Appender/IAppender.cs     |   14 -
 .../log4net/Appender/LocalSyslogAppender.cs   |  150 --
 .../log4net/Appender/MemoryAppender.cs        |   47 -
 .../log4net/Appender/NetSendAppender.cs       |   75 -
 .../Appender/OutputDebugStringAppender.cs     |   19 -
 .../log4net/Appender/RemoteSyslogAppender.cs  |  153 --
 .../log4net/Appender/RemotingAppender.cs      |   81 -
 .../log4net/Appender/RollingFileAppender.cs   |  546 -----
 MSHALTester/log4net/Appender/SmtpAppender.cs  |  132 --
 .../log4net/Appender/SmtpPickupDirAppender.cs |  102 -
 .../log4net/Appender/TelnetAppender.cs        |  237 --
 .../log4net/Appender/TextWriterAppender.cs    |  167 --
 MSHALTester/log4net/Appender/TraceAppender.cs |   36 -
 MSHALTester/log4net/Appender/UdpAppender.cs   |  162 --
 .../log4net/Config/AliasDomainAttribute.cs    |   12 -
 .../Config/AliasRepositoryAttribute.cs        |   20 -
 .../log4net/Config/BasicConfigurator.cs       |   45 -
 .../log4net/Config/ConfiguratorAttribute.cs   |   31 -
 MSHALTester/log4net/Config/DOMConfigurator.cs |   77 -
 .../Config/DOMConfiguratorAttribute.cs        |   12 -
 MSHALTester/log4net/Config/DomainAttribute.cs |   20 -
 .../Log4NetConfigurationSectionHandler.cs     |   11 -
 MSHALTester/log4net/Config/PluginAttribute.cs |   31 -
 .../log4net/Config/RepositoryAttribute.cs     |   31 -
 .../SecurityContextProviderAttribute.cs       |   44 -
 MSHALTester/log4net/Config/XmlConfigurator.cs |  302 ---
 .../Config/XmlConfiguratorAttribute.cs        |  117 -
 .../log4net/Core/CompactRepositorySelector.cs |  105 -
 .../log4net/Core/DefaultRepositorySelector.cs |  274 ---
 MSHALTester/log4net/Core/ErrorCode.cs         |   14 -
 MSHALTester/log4net/Core/FixFlags.cs          |   23 -
 .../log4net/Core/IAppenderAttachable.cs       |   20 -
 MSHALTester/log4net/Core/IErrorHandler.cs     |   14 -
 MSHALTester/log4net/Core/IFixingRequired.cs   |    8 -
 MSHALTester/log4net/Core/ILogger.cs           |   23 -
 MSHALTester/log4net/Core/ILoggerWrapper.cs    |    8 -
 MSHALTester/log4net/Core/IOptionHandler.cs    |    8 -
 .../log4net/Core/IRepositorySelector.cs       |   24 -
 .../log4net/Core/ITriggeringEventEvaluator.cs |    8 -
 MSHALTester/log4net/Core/Level.cs             |   92 -
 MSHALTester/log4net/Core/LevelCollection.cs   |  384 ---
 MSHALTester/log4net/Core/LevelEvaluator.cs    |   33 -
 MSHALTester/log4net/Core/LevelMap.cs          |   74 -
 MSHALTester/log4net/Core/LocationInfo.cs      |   87 -
 MSHALTester/log4net/Core/LogException.cs      |   29 -
 MSHALTester/log4net/Core/LogImpl.cs           |  151 --
 MSHALTester/log4net/Core/LoggerManager.cs     |  229 --
 .../Core/LoggerRepositoryCreationEventArgs.cs |   18 -
 .../LoggerRepositoryCreationEventHandler.cs   |    7 -
 MSHALTester/log4net/Core/LoggerWrapperImpl.cs |   12 -
 MSHALTester/log4net/Core/LoggingEvent.cs      |  382 ---
 MSHALTester/log4net/Core/LoggingEventData.cs  |   21 -
 MSHALTester/log4net/Core/SecurityContext.cs   |   10 -
 .../log4net/Core/SecurityContextProvider.cs   |   25 -
 .../log4net/Core/WrapperCreationHandler.cs    |    5 -
 MSHALTester/log4net/Core/WrapperMap.cs        |   65 -
 .../AbsoluteTimeDateFormatter.cs              |   64 -
 .../DateFormatter/DateTimeDateFormatter.cs    |   28 -
 .../log4net/DateFormatter/IDateFormatter.cs   |   11 -
 .../DateFormatter/Iso8601DateFormatter.cs     |   26 -
 .../DateFormatter/SimpleDateFormatter.cs      |   19 -
 MSHALTester/log4net/Filter/DenyAllFilter.cs   |   10 -
 MSHALTester/log4net/Filter/FilterDecision.cs  |   10 -
 MSHALTester/log4net/Filter/FilterSkeleton.cs  |   22 -
 MSHALTester/log4net/Filter/IFilter.cs         |   12 -
 .../log4net/Filter/LevelMatchFilter.cs        |   36 -
 .../log4net/Filter/LevelRangeFilter.cs        |   40 -
 .../log4net/Filter/LoggerMatchFilter.cs       |   33 -
 MSHALTester/log4net/Filter/MdcFilter.cs       |    7 -
 MSHALTester/log4net/Filter/NdcFilter.cs       |    8 -
 MSHALTester/log4net/Filter/PropertyFilter.cs  |   38 -
 .../log4net/Filter/StringMatchFilter.cs       |   56 -
 MSHALTester/log4net/GlobalContext.cs          |   21 -
 MSHALTester/log4net/ILog.cs                   |   59 -
 MSHALTester/log4net/Layout/ExceptionLayout.cs |   23 -
 MSHALTester/log4net/Layout/ILayout.cs         |   19 -
 MSHALTester/log4net/Layout/IRawLayout.cs      |   12 -
 .../log4net/Layout/Layout2RawLayoutAdapter.cs |   22 -
 MSHALTester/log4net/Layout/LayoutSkeleton.cs  |   37 -
 .../Pattern/AppDomainPatternConverter.cs      |   14 -
 .../Layout/Pattern/DatePatternConverter.cs    |   52 -
 .../Pattern/ExceptionPatternConverter.cs      |   19 -
 .../Pattern/FileLocationPatternConverter.cs   |   14 -
 .../Pattern/FullLocationPatternConverter.cs   |   14 -
 .../Pattern/IdentityPatternConverter.cs       |   14 -
 .../Layout/Pattern/LevelPatternConverter.cs   |   14 -
 .../Pattern/LineLocationPatternConverter.cs   |   14 -
 .../Layout/Pattern/LoggerPatternConverter.cs  |   13 -
 .../Layout/Pattern/MessagePatternConverter.cs |   14 -
 .../Pattern/MethodLocationPatternConverter.cs |   14 -
 .../Layout/Pattern/NamedPatternConverter.cs   |   58 -
 .../Layout/Pattern/NdcPatternConverter.cs     |   15 -
 .../Layout/Pattern/PatternLayoutConverter.cs  |   28 -
 .../Pattern/PropertyPatternConverter.cs       |   19 -
 .../Pattern/RelativeTimePatternConverter.cs   |   21 -
 .../Layout/Pattern/ThreadPatternConverter.cs  |   14 -
 .../Pattern/TypeNamePatternConverter.cs       |   13 -
 .../Pattern/UserNamePatternConverter.cs       |   14 -
 .../Layout/Pattern/UtcDatePatternConverter.cs |   23 -
 MSHALTester/log4net/Layout/PatternLayout.cs   |  153 --
 .../log4net/Layout/RawLayoutConverter.cs      |   16 -
 .../log4net/Layout/RawPropertyLayout.cs       |   21 -
 .../log4net/Layout/RawTimeStampLayout.cs      |   10 -
 .../log4net/Layout/RawUtcTimeStampLayout.cs   |   13 -
 MSHALTester/log4net/Layout/SimpleLayout.cs    |   26 -
 MSHALTester/log4net/Layout/XmlLayout.cs       |  120 -
 MSHALTester/log4net/Layout/XmlLayoutBase.cs   |   55 -
 .../log4net/Layout/XmlLayoutSchemaLog4j.cs    |   97 -
 MSHALTester/log4net/LogManager.cs             |  208 --
 MSHALTester/log4net/LogicalThreadContext.cs   |   19 -
 MSHALTester/log4net/MDC.cs                    |   21 -
 MSHALTester/log4net/NDC.cs                    |   52 -
 .../log4net/ObjectRenderer/DefaultRenderer.cs |   93 -
 .../log4net/ObjectRenderer/IObjectRenderer.cs |   10 -
 .../log4net/ObjectRenderer/RendererMap.cs     |  118 -
 MSHALTester/log4net/Plugin/IPlugin.cs         |   14 -
 MSHALTester/log4net/Plugin/IPluginFactory.cs  |    8 -
 .../log4net/Plugin/PluginCollection.cs        |  387 ---
 MSHALTester/log4net/Plugin/PluginMap.cs       |   57 -
 MSHALTester/log4net/Plugin/PluginSkeleton.cs  |   31 -
 .../Plugin/RemoteLoggingServerPlugin.cs       |   74 -
 .../Hierarchy/DefaultLoggerFactory.cs         |   25 -
 .../log4net/Repository/Hierarchy/Hierarchy.cs |  337 ---
 .../Repository/Hierarchy/ILoggerFactory.cs    |    8 -
 .../log4net/Repository/Hierarchy/Logger.cs    |  269 ---
 .../Hierarchy/LoggerCreationEventArgs.cs      |   14 -
 .../Hierarchy/LoggerCreationEventHandler.cs   |    5 -
 .../log4net/Repository/Hierarchy/LoggerKey.cs |   24 -
 .../Repository/Hierarchy/ProvisionNode.cs     |   10 -
 .../Repository/Hierarchy/RootLogger.cs        |   30 -
 .../Hierarchy/XmlHierarchyConfigurator.cs     |  534 -----
 .../IBasicRepositoryConfigurator.cs           |   10 -
 .../log4net/Repository/ILoggerRepository.cs   |   46 -
 .../Repository/IXmlRepositoryConfigurator.cs  |   10 -
 ...ositoryConfigurationChangedEventHandler.cs |    7 -
 ...epositoryConfigurationResetEventHandler.cs |    7 -
 .../LoggerRepositoryShutdownEventHandler.cs   |    7 -
 .../Repository/LoggerRepositorySkeleton.cs    |  186 --
 MSHALTester/log4net/ThreadContext.cs          |   19 -
 .../log4net/Util/AppenderAttachedImpl.cs      |  101 -
 .../log4net/Util/CompositeProperties.cs       |   51 -
 .../log4net/Util/ContextPropertiesBase.cs     |    8 -
 .../log4net/Util/CountingQuietTextWriter.cs   |   41 -
 MSHALTester/log4net/Util/CyclicBuffer.cs      |  111 -
 MSHALTester/log4net/Util/EmptyCollection.cs   |   30 -
 MSHALTester/log4net/Util/EmptyDictionary.cs   |   57 -
 MSHALTester/log4net/Util/FormattingInfo.cs    |   39 -
 .../log4net/Util/GlobalContextProperties.cs   |   47 -
 MSHALTester/log4net/Util/LevelMapping.cs      |   46 -
 MSHALTester/log4net/Util/LevelMappingEntry.cs |   20 -
 MSHALTester/log4net/Util/LogLog.cs            |  114 -
 .../Util/LogicalThreadContextProperties.cs    |   33 -
 MSHALTester/log4net/Util/NativeError.cs       |   70 -
 .../log4net/Util/NullDictionaryEnumerator.cs  |   31 -
 MSHALTester/log4net/Util/NullEnumerator.cs    |   25 -
 .../log4net/Util/NullSecurityContext.cs       |   17 -
 .../log4net/Util/OnlyOnceErrorHandler.cs      |   50 -
 MSHALTester/log4net/Util/OptionConverter.cs   |  190 --
 MSHALTester/log4net/Util/PatternConverter.cs  |  134 --
 MSHALTester/log4net/Util/PatternParser.cs     |  165 --
 MSHALTester/log4net/Util/PatternString.cs     |  113 -
 .../AppDomainPatternConverter.cs              |   13 -
 .../DatePatternConverter.cs                   |   51 -
 .../EnvironmentPatternConverter.cs            |   31 -
 .../IdentityPatternConverter.cs               |   25 -
 .../LiteralPatternConverter.cs                |   24 -
 .../NewLinePatternConverter.cs                |   19 -
 .../ProcessIdPatternConverter.cs              |   23 -
 .../PropertyPatternConverter.cs               |   26 -
 .../RandomStringPatternConverter.cs           |   55 -
 .../UserNamePatternConverter.cs               |   26 -
 .../UtcDatePatternConverter.cs                |   21 -
 .../log4net/Util/PropertiesDictionary.cs      |   83 -
 .../log4net/Util/ProtectCloseTextWriter.cs    |   14 -
 MSHALTester/log4net/Util/QuietTextWriter.cs   |   72 -
 .../Util/ReadOnlyPropertiesDictionary.cs      |  110 -
 MSHALTester/log4net/Util/ReaderWriterLock.cs  |   18 -
 .../log4net/Util/ReusableStringWriter.cs      |   23 -
 MSHALTester/log4net/Util/SystemInfo.cs        |  279 ---
 MSHALTester/log4net/Util/TextWriterAdapter.cs |   55 -
 .../log4net/Util/ThreadContextProperties.cs   |   36 -
 .../log4net/Util/ThreadContextStack.cs        |   97 -
 .../log4net/Util/ThreadContextStacks.cs       |   40 -
 MSHALTester/log4net/Util/Transform.cs         |   71 -
 .../Util/TypeConverters/BooleanConverter.cs   |   15 -
 .../ConversionNotSupportedException.cs        |   44 -
 .../Util/TypeConverters/ConverterRegistry.cs  |   91 -
 .../Util/TypeConverters/EncodingConverter.cs  |   16 -
 .../Util/TypeConverters/IConvertFrom.cs       |   12 -
 .../log4net/Util/TypeConverters/IConvertTo.cs |   12 -
 .../Util/TypeConverters/IPAddressConverter.cs |   82 -
 .../TypeConverters/PatternLayoutConverter.cs  |   16 -
 .../TypeConverters/PatternStringConverter.cs  |   24 -
 .../Util/TypeConverters/TypeConverter.cs      |   15 -
 .../TypeConverters/TypeConverterAttribute.cs  |   28 -
 .../log4net/Util/WindowsSecurityContext.cs    |  125 -
 .../_003CPrivateImplementationDetails_003E.cs |   12 -
 MSHALTester/packages.config                   |    7 +
 790 files changed, 106 insertions(+), 64088 deletions(-)
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2Constants.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2Exception.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2InputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2OutputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Checksums/Adler32.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Checksums/Crc32.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Checksums/IChecksum.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Checksums/StrangeCRC.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/DirectoryEventArgs.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/DirectoryFailureDelegate.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/ExtendedPathFilter.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/FileFailureDelegate.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/FileSystemScanner.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/INameTransform.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/IScanFilter.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/NameAndSizeFilter.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/NameFilter.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/PathFilter.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/ProcessDirectoryDelegate.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/ProcessFileDelegate.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/ScanEventArgs.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/ScanFailureEventArgs.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Core/StreamUtils.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassic.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicCryptoBase.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicDecryptCryptoTransform.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicEncryptCryptoTransform.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicManaged.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipConstants.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipException.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipInputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipOutputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/SharpZipBaseException.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/InvalidHeaderException.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/ProgressMessageHandler.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/TarArchive.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/TarBuffer.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/TarEntry.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/TarException.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/TarHeader.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/TarInputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Tar/TarOutputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/BaseArchiveStorage.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflateStrategy.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Deflater.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterConstants.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterEngine.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterHuffman.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterPending.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Inflater.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/InflaterDynHeader.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/PendingBuffer.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputBuffer.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/CompressionMethod.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/DiskArchiveStorage.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/DynamicDiskDataSource.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/EncryptionAlgorithm.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/FastZip.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/FastZipEvents.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/FileUpdateMode.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/GeneralBitFlags.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/HostSystemID.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/IArchiveStorage.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/IDynamicDataSource.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/IEntryFactory.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/IStaticDataSource.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/KeysRequiredEventArgs.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/MemoryArchiveStorage.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/StaticDiskDataSource.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/TestOperation.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/TestStatus.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/TestStrategy.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/UseZip64.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipConstants.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipEntry.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipEntryFactory.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipException.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipExtraData.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipFile.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipHelperStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipInputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipNameTransform.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipOutputStream.cs
 delete mode 100644 MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipTestResultHandler.cs
 delete mode 100644 MSHALTester/LzmaAlone/Properties/Settings.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonArray.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonBinary.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonBinaryType.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonBinaryWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonBoolean.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonEmpty.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonObject.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonObjectId.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonProperty.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonReader.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonRegex.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonString.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonToken.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonType.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonValue.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Bson/BsonWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/ConstructorHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/BinaryConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/BsonObjectIdConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/CustomCreationConverter`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/DataSetConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/DataTableConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/DateTimeConverterBase.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/EntityKeyMemberConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/IXmlDeclaration.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/IXmlDocument.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/IXmlDocumentType.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/IXmlElement.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/IXmlNode.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/IsoDateTimeConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/JavaScriptDateTimeConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/KeyValuePairConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/RegexConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/StringEnumConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/UnixDateTimeConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/VersionConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XAttributeWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XCommentWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XContainerWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XDeclarationWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XDocumentTypeWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XDocumentWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XElementWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XObjectWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XProcessingInstructionWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XTextWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XmlDeclarationWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XmlDocumentTypeWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XmlDocumentWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XmlElementWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XmlNodeConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Converters/XmlNodeWrapper.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/DateFormatHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/DateParseHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/DateTimeZoneHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/DefaultValueHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/FloatFormatHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/FloatParseHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Formatting.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/IArrayPool`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/IJsonLineInfo.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonArrayAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonConstructorAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonContainerAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonContainerType.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonConvert.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonConverterAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonConverterCollection.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonConverter`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonDictionaryAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonException.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonExtensionDataAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonIgnoreAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonObjectAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonPosition.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonPropertyAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonReader.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonReaderException.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonRequiredAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonSerializationException.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonSerializer.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonSerializerSettings.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonTextReader.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonTextWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonToken.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonValidatingReader.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/JsonWriterException.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/CommentHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/Extensions.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/IJEnumerable`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JArray.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JConstructor.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JContainer.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JEnumerable`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JObject.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JProperty.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JPropertyDescriptor.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JPropertyKeyedCollection.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JRaw.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JToken.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JTokenEqualityComparer.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JTokenReader.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JTokenType.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JTokenWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JValue.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonLoadSettings.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonMergeSettings.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArrayIndexFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArrayMultipleIndexFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArraySliceFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/BooleanQueryExpression.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/CompositeExpression.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/FieldFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/FieldMultipleFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/JPath.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/PathFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryExpression.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryOperator.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryScanFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/RootFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/ScanFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/JsonPath/ScanMultipleFilter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/LineInfoHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/MergeArrayHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Linq/MergeNullValueHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/MemberSerialization.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/MetadataPropertyHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/MissingMemberHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/NullValueHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/ObjectCreationHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/PreserveReferencesHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/ReadType.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/ReferenceLoopHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Required.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/Extensions.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchema.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaBuilder.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaConstants.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaException.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaGenerator.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaModel.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaModelBuilder.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaNode.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaNodeCollection.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaResolver.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaType.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/JsonSchemaWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/UndefinedSchemaIdHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/ValidationEventArgs.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Schema/ValidationEventHandler.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/CachedAttributeGetter`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/CamelCaseNamingStrategy.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/CamelCasePropertyNamesContractResolver.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/DefaultContractResolver.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/DefaultNamingStrategy.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/DefaultReferenceResolver.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/DefaultSerializationBinder.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/DiagnosticsTraceWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/DynamicValueProvider.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ErrorContext.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ErrorEventArgs.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ExtensionDataGetter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ExtensionDataSetter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/IAttributeProvider.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/IContractResolver.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/IReferenceResolver.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ISerializationBinder.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ITraceWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/IValueProvider.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonArrayContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonContainerContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonContractType.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonDictionaryContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonFormatterConverter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonISerializableContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonLinqContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonObjectContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonPrimitiveContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonProperty.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonPropertyCollection.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalBase.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalReader.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerProxy.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonStringContract.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/JsonTypeReflector.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/MemoryTraceWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/NamingStrategy.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ObjectConstructor`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/OnErrorAttribute.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ReflectionAttributeProvider.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ReflectionValueProvider.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/ResolverContractKey.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/SerializationBinderAdapter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/SerializationCallback.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/SerializationErrorCallback.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/SnakeCaseNamingStrategy.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/TraceJsonReader.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Serialization/TraceJsonWriter.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/StringEscapeHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/TypeNameAssemblyFormatHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/TypeNameHandling.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/Base64Encoder.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/BidirectionalDictionary`2.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/BufferUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/CollectionUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/CollectionWrapper`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ConvertUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/Creator`1.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/DateTimeParser.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/DateTimeUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/DictionaryWrapper`2.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/DynamicReflectionDelegateFactory.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/EnumInfo.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/EnumUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ILGeneratorExtensions.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/IWrappedCollection.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/IWrappedDictionary.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ImmutableCollectionsUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/JavaScriptUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/JsonTokenUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/LateBoundReflectionDelegateFactory.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/MathUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/MethodCall`2.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/MiscellaneousUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ParseResult.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ParserTimeZone.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/PrimitiveTypeCode.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/PropertyNameTable.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ReflectionDelegateFactory.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ReflectionMember.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ReflectionObject.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ReflectionUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/StringBuffer.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/StringReference.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/StringReferenceExtensions.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/StringUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ThreadSafeStore`2.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/TypeExtensions.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/TypeInformation.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/TypeNameKey.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/Utilities/ValidationUtils.cs
 delete mode 100644 MSHALTester/Newtonsoft/Json/WriteState.cs
 delete mode 100644 MSHALTester/SevenZip/CRC.cs
 delete mode 100644 MSHALTester/SevenZip/CoderPropID.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/LZ/BinTree.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/LZ/IInWindowStream.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/LZ/IMatchFinder.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/LZ/InWindow.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/LZ/OutWindow.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/LZMA/Base.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/LZMA/Decoder.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/LZMA/Encoder.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/RangeCoder/BitDecoder.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/RangeCoder/BitEncoder.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/RangeCoder/BitTreeDecoder.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/RangeCoder/BitTreeEncoder.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/RangeCoder/Decoder.cs
 delete mode 100644 MSHALTester/SevenZip/Compression/RangeCoder/Encoder.cs
 delete mode 100644 MSHALTester/SevenZip/DataErrorException.cs
 delete mode 100644 MSHALTester/SevenZip/ICodeProgress.cs
 delete mode 100644 MSHALTester/SevenZip/ICoder.cs
 delete mode 100644 MSHALTester/SevenZip/ISetCoderProperties.cs
 delete mode 100644 MSHALTester/SevenZip/ISetDecoderProperties.cs
 delete mode 100644 MSHALTester/SevenZip/IWriteCoderProperties.cs
 delete mode 100644 MSHALTester/SevenZip/InvalidParamException.cs
 delete mode 100644 MSHALTester/log4net/Appender/AdoNetAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/AdoNetAppenderParameter.cs
 delete mode 100644 MSHALTester/log4net/Appender/AnsiColorTerminalAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/AppenderCollection.cs
 delete mode 100644 MSHALTester/log4net/Appender/AppenderSkeleton.cs
 delete mode 100644 MSHALTester/log4net/Appender/AspNetTraceAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/BufferingAppenderSkeleton.cs
 delete mode 100644 MSHALTester/log4net/Appender/BufferingForwardingAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/ColoredConsoleAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/ConsoleAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/DebugAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/EventLogAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/FileAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/ForwardingAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/IAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/LocalSyslogAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/MemoryAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/NetSendAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/OutputDebugStringAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/RemoteSyslogAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/RemotingAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/RollingFileAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/SmtpAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/SmtpPickupDirAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/TelnetAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/TextWriterAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/TraceAppender.cs
 delete mode 100644 MSHALTester/log4net/Appender/UdpAppender.cs
 delete mode 100644 MSHALTester/log4net/Config/AliasDomainAttribute.cs
 delete mode 100644 MSHALTester/log4net/Config/AliasRepositoryAttribute.cs
 delete mode 100644 MSHALTester/log4net/Config/BasicConfigurator.cs
 delete mode 100644 MSHALTester/log4net/Config/ConfiguratorAttribute.cs
 delete mode 100644 MSHALTester/log4net/Config/DOMConfigurator.cs
 delete mode 100644 MSHALTester/log4net/Config/DOMConfiguratorAttribute.cs
 delete mode 100644 MSHALTester/log4net/Config/DomainAttribute.cs
 delete mode 100644 MSHALTester/log4net/Config/Log4NetConfigurationSectionHandler.cs
 delete mode 100644 MSHALTester/log4net/Config/PluginAttribute.cs
 delete mode 100644 MSHALTester/log4net/Config/RepositoryAttribute.cs
 delete mode 100644 MSHALTester/log4net/Config/SecurityContextProviderAttribute.cs
 delete mode 100644 MSHALTester/log4net/Config/XmlConfigurator.cs
 delete mode 100644 MSHALTester/log4net/Config/XmlConfiguratorAttribute.cs
 delete mode 100644 MSHALTester/log4net/Core/CompactRepositorySelector.cs
 delete mode 100644 MSHALTester/log4net/Core/DefaultRepositorySelector.cs
 delete mode 100644 MSHALTester/log4net/Core/ErrorCode.cs
 delete mode 100644 MSHALTester/log4net/Core/FixFlags.cs
 delete mode 100644 MSHALTester/log4net/Core/IAppenderAttachable.cs
 delete mode 100644 MSHALTester/log4net/Core/IErrorHandler.cs
 delete mode 100644 MSHALTester/log4net/Core/IFixingRequired.cs
 delete mode 100644 MSHALTester/log4net/Core/ILogger.cs
 delete mode 100644 MSHALTester/log4net/Core/ILoggerWrapper.cs
 delete mode 100644 MSHALTester/log4net/Core/IOptionHandler.cs
 delete mode 100644 MSHALTester/log4net/Core/IRepositorySelector.cs
 delete mode 100644 MSHALTester/log4net/Core/ITriggeringEventEvaluator.cs
 delete mode 100644 MSHALTester/log4net/Core/Level.cs
 delete mode 100644 MSHALTester/log4net/Core/LevelCollection.cs
 delete mode 100644 MSHALTester/log4net/Core/LevelEvaluator.cs
 delete mode 100644 MSHALTester/log4net/Core/LevelMap.cs
 delete mode 100644 MSHALTester/log4net/Core/LocationInfo.cs
 delete mode 100644 MSHALTester/log4net/Core/LogException.cs
 delete mode 100644 MSHALTester/log4net/Core/LogImpl.cs
 delete mode 100644 MSHALTester/log4net/Core/LoggerManager.cs
 delete mode 100644 MSHALTester/log4net/Core/LoggerRepositoryCreationEventArgs.cs
 delete mode 100644 MSHALTester/log4net/Core/LoggerRepositoryCreationEventHandler.cs
 delete mode 100644 MSHALTester/log4net/Core/LoggerWrapperImpl.cs
 delete mode 100644 MSHALTester/log4net/Core/LoggingEvent.cs
 delete mode 100644 MSHALTester/log4net/Core/LoggingEventData.cs
 delete mode 100644 MSHALTester/log4net/Core/SecurityContext.cs
 delete mode 100644 MSHALTester/log4net/Core/SecurityContextProvider.cs
 delete mode 100644 MSHALTester/log4net/Core/WrapperCreationHandler.cs
 delete mode 100644 MSHALTester/log4net/Core/WrapperMap.cs
 delete mode 100644 MSHALTester/log4net/DateFormatter/AbsoluteTimeDateFormatter.cs
 delete mode 100644 MSHALTester/log4net/DateFormatter/DateTimeDateFormatter.cs
 delete mode 100644 MSHALTester/log4net/DateFormatter/IDateFormatter.cs
 delete mode 100644 MSHALTester/log4net/DateFormatter/Iso8601DateFormatter.cs
 delete mode 100644 MSHALTester/log4net/DateFormatter/SimpleDateFormatter.cs
 delete mode 100644 MSHALTester/log4net/Filter/DenyAllFilter.cs
 delete mode 100644 MSHALTester/log4net/Filter/FilterDecision.cs
 delete mode 100644 MSHALTester/log4net/Filter/FilterSkeleton.cs
 delete mode 100644 MSHALTester/log4net/Filter/IFilter.cs
 delete mode 100644 MSHALTester/log4net/Filter/LevelMatchFilter.cs
 delete mode 100644 MSHALTester/log4net/Filter/LevelRangeFilter.cs
 delete mode 100644 MSHALTester/log4net/Filter/LoggerMatchFilter.cs
 delete mode 100644 MSHALTester/log4net/Filter/MdcFilter.cs
 delete mode 100644 MSHALTester/log4net/Filter/NdcFilter.cs
 delete mode 100644 MSHALTester/log4net/Filter/PropertyFilter.cs
 delete mode 100644 MSHALTester/log4net/Filter/StringMatchFilter.cs
 delete mode 100644 MSHALTester/log4net/GlobalContext.cs
 delete mode 100644 MSHALTester/log4net/ILog.cs
 delete mode 100644 MSHALTester/log4net/Layout/ExceptionLayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/ILayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/IRawLayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/Layout2RawLayoutAdapter.cs
 delete mode 100644 MSHALTester/log4net/Layout/LayoutSkeleton.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/AppDomainPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/DatePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/ExceptionPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/FileLocationPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/FullLocationPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/IdentityPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/LevelPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/LineLocationPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/LoggerPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/MessagePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/MethodLocationPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/NamedPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/NdcPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/PatternLayoutConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/PropertyPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/RelativeTimePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/ThreadPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/TypeNamePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/UserNamePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/Pattern/UtcDatePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/PatternLayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/RawLayoutConverter.cs
 delete mode 100644 MSHALTester/log4net/Layout/RawPropertyLayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/RawTimeStampLayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/RawUtcTimeStampLayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/SimpleLayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/XmlLayout.cs
 delete mode 100644 MSHALTester/log4net/Layout/XmlLayoutBase.cs
 delete mode 100644 MSHALTester/log4net/Layout/XmlLayoutSchemaLog4j.cs
 delete mode 100644 MSHALTester/log4net/LogManager.cs
 delete mode 100644 MSHALTester/log4net/LogicalThreadContext.cs
 delete mode 100644 MSHALTester/log4net/MDC.cs
 delete mode 100644 MSHALTester/log4net/NDC.cs
 delete mode 100644 MSHALTester/log4net/ObjectRenderer/DefaultRenderer.cs
 delete mode 100644 MSHALTester/log4net/ObjectRenderer/IObjectRenderer.cs
 delete mode 100644 MSHALTester/log4net/ObjectRenderer/RendererMap.cs
 delete mode 100644 MSHALTester/log4net/Plugin/IPlugin.cs
 delete mode 100644 MSHALTester/log4net/Plugin/IPluginFactory.cs
 delete mode 100644 MSHALTester/log4net/Plugin/PluginCollection.cs
 delete mode 100644 MSHALTester/log4net/Plugin/PluginMap.cs
 delete mode 100644 MSHALTester/log4net/Plugin/PluginSkeleton.cs
 delete mode 100644 MSHALTester/log4net/Plugin/RemoteLoggingServerPlugin.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/DefaultLoggerFactory.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/Hierarchy.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/ILoggerFactory.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/Logger.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/LoggerCreationEventArgs.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/LoggerCreationEventHandler.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/LoggerKey.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/ProvisionNode.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/RootLogger.cs
 delete mode 100644 MSHALTester/log4net/Repository/Hierarchy/XmlHierarchyConfigurator.cs
 delete mode 100644 MSHALTester/log4net/Repository/IBasicRepositoryConfigurator.cs
 delete mode 100644 MSHALTester/log4net/Repository/ILoggerRepository.cs
 delete mode 100644 MSHALTester/log4net/Repository/IXmlRepositoryConfigurator.cs
 delete mode 100644 MSHALTester/log4net/Repository/LoggerRepositoryConfigurationChangedEventHandler.cs
 delete mode 100644 MSHALTester/log4net/Repository/LoggerRepositoryConfigurationResetEventHandler.cs
 delete mode 100644 MSHALTester/log4net/Repository/LoggerRepositoryShutdownEventHandler.cs
 delete mode 100644 MSHALTester/log4net/Repository/LoggerRepositorySkeleton.cs
 delete mode 100644 MSHALTester/log4net/ThreadContext.cs
 delete mode 100644 MSHALTester/log4net/Util/AppenderAttachedImpl.cs
 delete mode 100644 MSHALTester/log4net/Util/CompositeProperties.cs
 delete mode 100644 MSHALTester/log4net/Util/ContextPropertiesBase.cs
 delete mode 100644 MSHALTester/log4net/Util/CountingQuietTextWriter.cs
 delete mode 100644 MSHALTester/log4net/Util/CyclicBuffer.cs
 delete mode 100644 MSHALTester/log4net/Util/EmptyCollection.cs
 delete mode 100644 MSHALTester/log4net/Util/EmptyDictionary.cs
 delete mode 100644 MSHALTester/log4net/Util/FormattingInfo.cs
 delete mode 100644 MSHALTester/log4net/Util/GlobalContextProperties.cs
 delete mode 100644 MSHALTester/log4net/Util/LevelMapping.cs
 delete mode 100644 MSHALTester/log4net/Util/LevelMappingEntry.cs
 delete mode 100644 MSHALTester/log4net/Util/LogLog.cs
 delete mode 100644 MSHALTester/log4net/Util/LogicalThreadContextProperties.cs
 delete mode 100644 MSHALTester/log4net/Util/NativeError.cs
 delete mode 100644 MSHALTester/log4net/Util/NullDictionaryEnumerator.cs
 delete mode 100644 MSHALTester/log4net/Util/NullEnumerator.cs
 delete mode 100644 MSHALTester/log4net/Util/NullSecurityContext.cs
 delete mode 100644 MSHALTester/log4net/Util/OnlyOnceErrorHandler.cs
 delete mode 100644 MSHALTester/log4net/Util/OptionConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternParser.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternString.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/AppDomainPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/DatePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/EnvironmentPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/IdentityPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/LiteralPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/NewLinePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/ProcessIdPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/PropertyPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/RandomStringPatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/UserNamePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PatternStringConverters/UtcDatePatternConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/PropertiesDictionary.cs
 delete mode 100644 MSHALTester/log4net/Util/ProtectCloseTextWriter.cs
 delete mode 100644 MSHALTester/log4net/Util/QuietTextWriter.cs
 delete mode 100644 MSHALTester/log4net/Util/ReadOnlyPropertiesDictionary.cs
 delete mode 100644 MSHALTester/log4net/Util/ReaderWriterLock.cs
 delete mode 100644 MSHALTester/log4net/Util/ReusableStringWriter.cs
 delete mode 100644 MSHALTester/log4net/Util/SystemInfo.cs
 delete mode 100644 MSHALTester/log4net/Util/TextWriterAdapter.cs
 delete mode 100644 MSHALTester/log4net/Util/ThreadContextProperties.cs
 delete mode 100644 MSHALTester/log4net/Util/ThreadContextStack.cs
 delete mode 100644 MSHALTester/log4net/Util/ThreadContextStacks.cs
 delete mode 100644 MSHALTester/log4net/Util/Transform.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/BooleanConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/ConversionNotSupportedException.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/ConverterRegistry.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/EncodingConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/IConvertFrom.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/IConvertTo.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/IPAddressConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/PatternLayoutConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/PatternStringConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/TypeConverter.cs
 delete mode 100644 MSHALTester/log4net/Util/TypeConverters/TypeConverterAttribute.cs
 delete mode 100644 MSHALTester/log4net/Util/WindowsSecurityContext.cs
 delete mode 100644 MSHALTester/log4net630819/_003CPrivateImplementationDetails_003E.cs
 create mode 100644 MSHALTester/packages.config

diff --git a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2.cs b/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2.cs
deleted file mode 100644
index a043772..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2.cs
+++ /dev/null
@@ -1,45 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  public sealed class BZip2
-  {
-    public static void Decompress(Stream inStream, Stream outStream)
-    {
-      if (inStream == null)
-        throw new ArgumentNullException(nameof (inStream));
-      if (outStream == null)
-        throw new ArgumentNullException(nameof (outStream));
-      using (outStream)
-      {
-        using (BZip2InputStream bzip2InputStream = new BZip2InputStream(inStream))
-        {
-          for (int index = bzip2InputStream.ReadByte(); index != -1; index = bzip2InputStream.ReadByte())
-            outStream.WriteByte((byte) index);
-        }
-      }
-    }
-
-    public static void Compress(Stream inStream, Stream outStream, int blockSize)
-    {
-      if (inStream == null)
-        throw new ArgumentNullException(nameof (inStream));
-      if (outStream == null)
-        throw new ArgumentNullException(nameof (outStream));
-      using (inStream)
-      {
-        using (BZip2OutputStream bzip2OutputStream = new BZip2OutputStream(outStream, blockSize))
-        {
-          for (int index = inStream.ReadByte(); index != -1; index = inStream.ReadByte())
-            bzip2OutputStream.WriteByte((byte) index);
-        }
-      }
-    }
-
-    private BZip2()
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2Constants.cs b/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2Constants.cs
deleted file mode 100644
index f539327..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2Constants.cs
+++ /dev/null
@@ -1,536 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  public sealed class BZip2Constants
-  {
-    public const int baseBlockSize = 100000;
-    public const int MAX_ALPHA_SIZE = 258;
-    public const int MAX_CODE_LEN = 23;
-    public const int RUNA = 0;
-    public const int RUNB = 1;
-    public const int N_GROUPS = 6;
-    public const int G_SIZE = 50;
-    public const int N_ITERS = 4;
-    public const int MAX_SELECTORS = 18002;
-    public const int NUM_OVERSHOOT_BYTES = 20;
-    public static readonly int[] rNums = new int[512]
-    {
-      619,
-      720,
-      (int) sbyte.MaxValue,
-      481,
-      931,
-      816,
-      813,
-      233,
-      566,
-      247,
-      985,
-      724,
-      205,
-      454,
-      863,
-      491,
-      741,
-      242,
-      949,
-      214,
-      733,
-      859,
-      335,
-      708,
-      621,
-      574,
-      73,
-      654,
-      730,
-      472,
-      419,
-      436,
-      278,
-      496,
-      867,
-      210,
-      399,
-      680,
-      480,
-      51,
-      878,
-      465,
-      811,
-      169,
-      869,
-      675,
-      611,
-      697,
-      867,
-      561,
-      862,
-      687,
-      507,
-      283,
-      482,
-      129,
-      807,
-      591,
-      733,
-      623,
-      150,
-      238,
-      59,
-      379,
-      684,
-      877,
-      625,
-      169,
-      643,
-      105,
-      170,
-      607,
-      520,
-      932,
-      727,
-      476,
-      693,
-      425,
-      174,
-      647,
-      73,
-      122,
-      335,
-      530,
-      442,
-      853,
-      695,
-      249,
-      445,
-      515,
-      909,
-      545,
-      703,
-      919,
-      874,
-      474,
-      882,
-      500,
-      594,
-      612,
-      641,
-      801,
-      220,
-      162,
-      819,
-      984,
-      589,
-      513,
-      495,
-      799,
-      161,
-      604,
-      958,
-      533,
-      221,
-      400,
-      386,
-      867,
-      600,
-      782,
-      382,
-      596,
-      414,
-      171,
-      516,
-      375,
-      682,
-      485,
-      911,
-      276,
-      98,
-      553,
-      163,
-      354,
-      666,
-      933,
-      424,
-      341,
-      533,
-      870,
-      227,
-      730,
-      475,
-      186,
-      263,
-      647,
-      537,
-      686,
-      600,
-      224,
-      469,
-      68,
-      770,
-      919,
-      190,
-      373,
-      294,
-      822,
-      808,
-      206,
-      184,
-      943,
-      795,
-      384,
-      383,
-      461,
-      404,
-      758,
-      839,
-      887,
-      715,
-      67,
-      618,
-      276,
-      204,
-      918,
-      873,
-      777,
-      604,
-      560,
-      951,
-      160,
-      578,
-      722,
-      79,
-      804,
-      96,
-      409,
-      713,
-      940,
-      652,
-      934,
-      970,
-      447,
-      318,
-      353,
-      859,
-      672,
-      112,
-      785,
-      645,
-      863,
-      803,
-      350,
-      139,
-      93,
-      354,
-      99,
-      820,
-      908,
-      609,
-      772,
-      154,
-      274,
-      580,
-      184,
-      79,
-      626,
-      630,
-      742,
-      653,
-      282,
-      762,
-      623,
-      680,
-      81,
-      927,
-      626,
-      789,
-      125,
-      411,
-      521,
-      938,
-      300,
-      821,
-      78,
-      343,
-      175,
-      128,
-      250,
-      170,
-      774,
-      972,
-      275,
-      999,
-      639,
-      495,
-      78,
-      352,
-      126,
-      857,
-      956,
-      358,
-      619,
-      580,
-      124,
-      737,
-      594,
-      701,
-      612,
-      669,
-      112,
-      134,
-      694,
-      363,
-      992,
-      809,
-      743,
-      168,
-      974,
-      944,
-      375,
-      748,
-      52,
-      600,
-      747,
-      642,
-      182,
-      862,
-      81,
-      344,
-      805,
-      988,
-      739,
-      511,
-      655,
-      814,
-      334,
-      249,
-      515,
-      897,
-      955,
-      664,
-      981,
-      649,
-      113,
-      974,
-      459,
-      893,
-      228,
-      433,
-      837,
-      553,
-      268,
-      926,
-      240,
-      102,
-      654,
-      459,
-      51,
-      686,
-      754,
-      806,
-      760,
-      493,
-      403,
-      415,
-      394,
-      687,
-      700,
-      946,
-      670,
-      656,
-      610,
-      738,
-      392,
-      760,
-      799,
-      887,
-      653,
-      978,
-      321,
-      576,
-      617,
-      626,
-      502,
-      894,
-      679,
-      243,
-      440,
-      680,
-      879,
-      194,
-      572,
-      640,
-      724,
-      926,
-      56,
-      204,
-      700,
-      707,
-      151,
-      457,
-      449,
-      797,
-      195,
-      791,
-      558,
-      945,
-      679,
-      297,
-      59,
-      87,
-      824,
-      713,
-      663,
-      412,
-      693,
-      342,
-      606,
-      134,
-      108,
-      571,
-      364,
-      631,
-      212,
-      174,
-      643,
-      304,
-      329,
-      343,
-      97,
-      430,
-      751,
-      497,
-      314,
-      983,
-      374,
-      822,
-      928,
-      140,
-      206,
-      73,
-      263,
-      980,
-      736,
-      876,
-      478,
-      430,
-      305,
-      170,
-      514,
-      364,
-      692,
-      829,
-      82,
-      855,
-      953,
-      676,
-      246,
-      369,
-      970,
-      294,
-      750,
-      807,
-      827,
-      150,
-      790,
-      288,
-      923,
-      804,
-      378,
-      215,
-      828,
-      592,
-      281,
-      565,
-      555,
-      710,
-      82,
-      896,
-      831,
-      547,
-      261,
-      524,
-      462,
-      293,
-      465,
-      502,
-      56,
-      661,
-      821,
-      976,
-      991,
-      658,
-      869,
-      905,
-      758,
-      745,
-      193,
-      768,
-      550,
-      608,
-      933,
-      378,
-      286,
-      215,
-      979,
-      792,
-      961,
-      61,
-      688,
-      793,
-      644,
-      986,
-      403,
-      106,
-      366,
-      905,
-      644,
-      372,
-      567,
-      466,
-      434,
-      645,
-      210,
-      389,
-      550,
-      919,
-      135,
-      780,
-      773,
-      635,
-      389,
-      707,
-      100,
-      626,
-      958,
-      165,
-      504,
-      920,
-      176,
-      193,
-      713,
-      857,
-      265,
-      203,
-      50,
-      668,
-      108,
-      645,
-      990,
-      626,
-      197,
-      510,
-      357,
-      358,
-      850,
-      858,
-      364,
-      936,
-      638
-    };
-
-    private BZip2Constants()
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2Exception.cs b/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2Exception.cs
deleted file mode 100644
index 26555bd..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2Exception.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  [Serializable]
-  public class BZip2Exception : SharpZipBaseException
-  {
-    protected BZip2Exception(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public BZip2Exception()
-    {
-    }
-
-    public BZip2Exception(string message)
-      : base(message)
-    {
-    }
-
-    public BZip2Exception(string message, Exception exception)
-      : base(message, exception)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2InputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2InputStream.cs
deleted file mode 100644
index 204a11d..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2InputStream.cs
+++ /dev/null
@@ -1,715 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  public class BZip2InputStream : Stream
-  {
-    private const int START_BLOCK_STATE = 1;
-    private const int RAND_PART_A_STATE = 2;
-    private const int RAND_PART_B_STATE = 3;
-    private const int RAND_PART_C_STATE = 4;
-    private const int NO_RAND_PART_A_STATE = 5;
-    private const int NO_RAND_PART_B_STATE = 6;
-    private const int NO_RAND_PART_C_STATE = 7;
-    private int last;
-    private int origPtr;
-    private int blockSize100k;
-    private bool blockRandomised;
-    private int bsBuff;
-    private int bsLive;
-    private IChecksum mCrc = (IChecksum) new StrangeCRC();
-    private bool[] inUse = new bool[256];
-    private int nInUse;
-    private byte[] seqToUnseq = new byte[256];
-    private byte[] unseqToSeq = new byte[256];
-    private byte[] selector = new byte[18002];
-    private byte[] selectorMtf = new byte[18002];
-    private int[] tt;
-    private byte[] ll8;
-    private int[] unzftab = new int[256];
-    private int[][] limit = new int[6][];
-    private int[][] baseArray = new int[6][];
-    private int[][] perm = new int[6][];
-    private int[] minLens = new int[6];
-    private Stream baseStream;
-    private bool streamEnd;
-    private int currentChar = -1;
-    private int currentState = 1;
-    private int storedBlockCRC;
-    private int storedCombinedCRC;
-    private int computedBlockCRC;
-    private uint computedCombinedCRC;
-    private int count;
-    private int chPrev;
-    private int ch2;
-    private int tPos;
-    private int rNToGo;
-    private int rTPos;
-    private int i2;
-    private int j2;
-    private byte z;
-    private bool isStreamOwner = true;
-
-    public BZip2InputStream(Stream stream)
-    {
-      for (int index = 0; index < 6; ++index)
-      {
-        this.limit[index] = new int[258];
-        this.baseArray[index] = new int[258];
-        this.perm[index] = new int[258];
-      }
-      this.BsSetStream(stream);
-      this.Initialize();
-      this.InitBlock();
-      this.SetupBlock();
-    }
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public override bool CanRead => this.baseStream.CanRead;
-
-    public override bool CanSeek => this.baseStream.CanSeek;
-
-    public override bool CanWrite => false;
-
-    public override long Length => this.baseStream.Length;
-
-    public override long Position
-    {
-      get => this.baseStream.Position;
-      set => throw new NotSupportedException("BZip2InputStream position cannot be set");
-    }
-
-    public override void Flush()
-    {
-      if (this.baseStream == null)
-        return;
-      this.baseStream.Flush();
-    }
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("BZip2InputStream Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("BZip2InputStream SetLength not supported");
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("BZip2InputStream Write not supported");
-    }
-
-    public override void WriteByte(byte value)
-    {
-      throw new NotSupportedException("BZip2InputStream WriteByte not supported");
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      for (int index = 0; index < count; ++index)
-      {
-        int num = this.ReadByte();
-        if (num == -1)
-          return index;
-        buffer[offset + index] = (byte) num;
-      }
-      return count;
-    }
-
-    public override void Close()
-    {
-      if (!this.IsStreamOwner || this.baseStream == null)
-        return;
-      this.baseStream.Close();
-    }
-
-    public override int ReadByte()
-    {
-      if (this.streamEnd)
-        return -1;
-      int currentChar = this.currentChar;
-      switch (this.currentState)
-      {
-        case 3:
-          this.SetupRandPartB();
-          break;
-        case 4:
-          this.SetupRandPartC();
-          break;
-        case 6:
-          this.SetupNoRandPartB();
-          break;
-        case 7:
-          this.SetupNoRandPartC();
-          break;
-      }
-      return currentChar;
-    }
-
-    private void MakeMaps()
-    {
-      this.nInUse = 0;
-      for (int index = 0; index < 256; ++index)
-      {
-        if (this.inUse[index])
-        {
-          this.seqToUnseq[this.nInUse] = (byte) index;
-          this.unseqToSeq[index] = (byte) this.nInUse;
-          ++this.nInUse;
-        }
-      }
-    }
-
-    private void Initialize()
-    {
-      char uchar1 = this.BsGetUChar();
-      char uchar2 = this.BsGetUChar();
-      char uchar3 = this.BsGetUChar();
-      char uchar4 = this.BsGetUChar();
-      if (uchar1 != 'B' || uchar2 != 'Z' || uchar3 != 'h' || uchar4 < '1' || uchar4 > '9')
-      {
-        this.streamEnd = true;
-      }
-      else
-      {
-        this.SetDecompressStructureSizes((int) uchar4 - 48);
-        this.computedCombinedCRC = 0U;
-      }
-    }
-
-    private void InitBlock()
-    {
-      char uchar1 = this.BsGetUChar();
-      char uchar2 = this.BsGetUChar();
-      char uchar3 = this.BsGetUChar();
-      char uchar4 = this.BsGetUChar();
-      char uchar5 = this.BsGetUChar();
-      char uchar6 = this.BsGetUChar();
-      if (uchar1 == '\u0017' && uchar2 == 'r' && uchar3 == 'E' && uchar4 == '8' && uchar5 == 'P' && uchar6 == '\u0090')
-        this.Complete();
-      else if (uchar1 != '1' || uchar2 != 'A' || uchar3 != 'Y' || uchar4 != '&' || uchar5 != 'S' || uchar6 != 'Y')
-      {
-        BZip2InputStream.BadBlockHeader();
-        this.streamEnd = true;
-      }
-      else
-      {
-        this.storedBlockCRC = this.BsGetInt32();
-        this.blockRandomised = this.BsR(1) == 1;
-        this.GetAndMoveToFrontDecode();
-        this.mCrc.Reset();
-        this.currentState = 1;
-      }
-    }
-
-    private void EndBlock()
-    {
-      this.computedBlockCRC = (int) this.mCrc.Value;
-      if (this.storedBlockCRC != this.computedBlockCRC)
-        BZip2InputStream.CrcError();
-      this.computedCombinedCRC = (uint) ((int) this.computedCombinedCRC << 1 & -1) | this.computedCombinedCRC >> 31;
-      this.computedCombinedCRC ^= (uint) this.computedBlockCRC;
-    }
-
-    private void Complete()
-    {
-      this.storedCombinedCRC = this.BsGetInt32();
-      if (this.storedCombinedCRC != (int) this.computedCombinedCRC)
-        BZip2InputStream.CrcError();
-      this.streamEnd = true;
-    }
-
-    private void BsSetStream(Stream stream)
-    {
-      this.baseStream = stream;
-      this.bsLive = 0;
-      this.bsBuff = 0;
-    }
-
-    private void FillBuffer()
-    {
-      int num = 0;
-      try
-      {
-        num = this.baseStream.ReadByte();
-      }
-      catch (Exception ex)
-      {
-        BZip2InputStream.CompressedStreamEOF();
-      }
-      if (num == -1)
-        BZip2InputStream.CompressedStreamEOF();
-      this.bsBuff = this.bsBuff << 8 | num & (int) byte.MaxValue;
-      this.bsLive += 8;
-    }
-
-    private int BsR(int n)
-    {
-      while (this.bsLive < n)
-        this.FillBuffer();
-      int num = this.bsBuff >> this.bsLive - n & (1 << n) - 1;
-      this.bsLive -= n;
-      return num;
-    }
-
-    private char BsGetUChar() => (char) this.BsR(8);
-
-    private int BsGetint()
-    {
-      return ((this.BsR(8) << 8 | this.BsR(8)) << 8 | this.BsR(8)) << 8 | this.BsR(8);
-    }
-
-    private int BsGetIntVS(int numBits) => this.BsR(numBits);
-
-    private int BsGetInt32() => this.BsGetint();
-
-    private void RecvDecodingTables()
-    {
-      char[][] chArray = new char[6][];
-      for (int index = 0; index < 6; ++index)
-        chArray[index] = new char[258];
-      bool[] flagArray = new bool[16];
-      for (int index = 0; index < 16; ++index)
-        flagArray[index] = this.BsR(1) == 1;
-      for (int index1 = 0; index1 < 16; ++index1)
-      {
-        if (flagArray[index1])
-        {
-          for (int index2 = 0; index2 < 16; ++index2)
-            this.inUse[index1 * 16 + index2] = this.BsR(1) == 1;
-        }
-        else
-        {
-          for (int index3 = 0; index3 < 16; ++index3)
-            this.inUse[index1 * 16 + index3] = false;
-        }
-      }
-      this.MakeMaps();
-      int alphaSize = this.nInUse + 2;
-      int num1 = this.BsR(3);
-      int num2 = this.BsR(15);
-      for (int index = 0; index < num2; ++index)
-      {
-        int num3 = 0;
-        while (this.BsR(1) == 1)
-          ++num3;
-        this.selectorMtf[index] = (byte) num3;
-      }
-      byte[] numArray = new byte[6];
-      for (int index = 0; index < num1; ++index)
-        numArray[index] = (byte) index;
-      for (int index4 = 0; index4 < num2; ++index4)
-      {
-        int index5 = (int) this.selectorMtf[index4];
-        byte num4 = numArray[index5];
-        for (; index5 > 0; --index5)
-          numArray[index5] = numArray[index5 - 1];
-        numArray[0] = num4;
-        this.selector[index4] = num4;
-      }
-      for (int index6 = 0; index6 < num1; ++index6)
-      {
-        int num5 = this.BsR(5);
-        for (int index7 = 0; index7 < alphaSize; ++index7)
-        {
-          while (this.BsR(1) == 1)
-          {
-            if (this.BsR(1) == 0)
-              ++num5;
-            else
-              --num5;
-          }
-          chArray[index6][index7] = (char) num5;
-        }
-      }
-      for (int index8 = 0; index8 < num1; ++index8)
-      {
-        int num6 = 32;
-        int num7 = 0;
-        for (int index9 = 0; index9 < alphaSize; ++index9)
-        {
-          num7 = Math.Max(num7, (int) chArray[index8][index9]);
-          num6 = Math.Min(num6, (int) chArray[index8][index9]);
-        }
-        BZip2InputStream.HbCreateDecodeTables(this.limit[index8], this.baseArray[index8], this.perm[index8], chArray[index8], num6, num7, alphaSize);
-        this.minLens[index8] = num6;
-      }
-    }
-
-    private void GetAndMoveToFrontDecode()
-    {
-      byte[] numArray = new byte[256];
-      int num1 = 100000 * this.blockSize100k;
-      this.origPtr = this.BsGetIntVS(24);
-      this.RecvDecodingTables();
-      int num2 = this.nInUse + 1;
-      int index1 = -1;
-      int num3 = 0;
-      for (int index2 = 0; index2 <= (int) byte.MaxValue; ++index2)
-        this.unzftab[index2] = 0;
-      for (int index3 = 0; index3 <= (int) byte.MaxValue; ++index3)
-        numArray[index3] = (byte) index3;
-      this.last = -1;
-      if (num3 == 0)
-      {
-        ++index1;
-        num3 = 50;
-      }
-      int num4 = num3 - 1;
-      int index4 = (int) this.selector[index1];
-      int minLen1 = this.minLens[index4];
-      int num5;
-      int num6;
-      for (num5 = this.BsR(minLen1); num5 > this.limit[index4][minLen1]; num5 = num5 << 1 | num6)
-      {
-        if (minLen1 > 20)
-          throw new BZip2Exception("Bzip data error");
-        ++minLen1;
-        while (this.bsLive < 1)
-          this.FillBuffer();
-        num6 = this.bsBuff >> this.bsLive - 1 & 1;
-        --this.bsLive;
-      }
-      if (num5 - this.baseArray[index4][minLen1] < 0 || num5 - this.baseArray[index4][minLen1] >= 258)
-        throw new BZip2Exception("Bzip data error");
-      int num7 = this.perm[index4][num5 - this.baseArray[index4][minLen1]];
-      while (num7 != num2)
-      {
-        if (num7 == 0 || num7 == 1)
-        {
-          int num8 = -1;
-          int num9 = 1;
-label_22:
-          if (num7 == 0)
-            num8 += num9;
-          else if (num7 == 1)
-            num8 += 2 * num9;
-          num9 <<= 1;
-          if (num4 == 0)
-          {
-            ++index1;
-            num4 = 50;
-          }
-          --num4;
-          int index5 = (int) this.selector[index1];
-          int minLen2 = this.minLens[index5];
-          int num10;
-          int num11;
-          for (num10 = this.BsR(minLen2); num10 > this.limit[index5][minLen2]; num10 = num10 << 1 | num11)
-          {
-            ++minLen2;
-            while (this.bsLive < 1)
-              this.FillBuffer();
-            num11 = this.bsBuff >> this.bsLive - 1 & 1;
-            --this.bsLive;
-          }
-          num7 = this.perm[index5][num10 - this.baseArray[index5][minLen2]];
-          switch (num7)
-          {
-            case 0:
-            case 1:
-              goto label_22;
-            default:
-              int num12 = num8 + 1;
-              byte index6 = this.seqToUnseq[(int) numArray[0]];
-              this.unzftab[(int) index6] += num12;
-              for (; num12 > 0; --num12)
-              {
-                ++this.last;
-                this.ll8[this.last] = index6;
-              }
-              if (this.last >= num1)
-              {
-                BZip2InputStream.BlockOverrun();
-                continue;
-              }
-              continue;
-          }
-        }
-        else
-        {
-          ++this.last;
-          if (this.last >= num1)
-            BZip2InputStream.BlockOverrun();
-          byte index7 = numArray[num7 - 1];
-          ++this.unzftab[(int) this.seqToUnseq[(int) index7]];
-          this.ll8[this.last] = this.seqToUnseq[(int) index7];
-          for (int index8 = num7 - 1; index8 > 0; --index8)
-            numArray[index8] = numArray[index8 - 1];
-          numArray[0] = index7;
-          if (num4 == 0)
-          {
-            ++index1;
-            num4 = 50;
-          }
-          --num4;
-          int index9 = (int) this.selector[index1];
-          int minLen3 = this.minLens[index9];
-          int num13;
-          int num14;
-          for (num13 = this.BsR(minLen3); num13 > this.limit[index9][minLen3]; num13 = num13 << 1 | num14)
-          {
-            ++minLen3;
-            while (this.bsLive < 1)
-              this.FillBuffer();
-            num14 = this.bsBuff >> this.bsLive - 1 & 1;
-            --this.bsLive;
-          }
-          num7 = this.perm[index9][num13 - this.baseArray[index9][minLen3]];
-        }
-      }
-    }
-
-    private void SetupBlock()
-    {
-      int[] destinationArray = new int[257];
-      destinationArray[0] = 0;
-      Array.Copy((Array) this.unzftab, 0, (Array) destinationArray, 1, 256);
-      for (int index = 1; index <= 256; ++index)
-        destinationArray[index] += destinationArray[index - 1];
-      for (int index1 = 0; index1 <= this.last; ++index1)
-      {
-        byte index2 = this.ll8[index1];
-        this.tt[destinationArray[(int) index2]] = index1;
-        ++destinationArray[(int) index2];
-      }
-      this.tPos = this.tt[this.origPtr];
-      this.count = 0;
-      this.i2 = 0;
-      this.ch2 = 256;
-      if (this.blockRandomised)
-      {
-        this.rNToGo = 0;
-        this.rTPos = 0;
-        this.SetupRandPartA();
-      }
-      else
-        this.SetupNoRandPartA();
-    }
-
-    private void SetupRandPartA()
-    {
-      if (this.i2 <= this.last)
-      {
-        this.chPrev = this.ch2;
-        this.ch2 = (int) this.ll8[this.tPos];
-        this.tPos = this.tt[this.tPos];
-        if (this.rNToGo == 0)
-        {
-          this.rNToGo = BZip2Constants.rNums[this.rTPos];
-          ++this.rTPos;
-          if (this.rTPos == 512)
-            this.rTPos = 0;
-        }
-        --this.rNToGo;
-        this.ch2 ^= this.rNToGo == 1 ? 1 : 0;
-        ++this.i2;
-        this.currentChar = this.ch2;
-        this.currentState = 3;
-        this.mCrc.Update(this.ch2);
-      }
-      else
-      {
-        this.EndBlock();
-        this.InitBlock();
-        this.SetupBlock();
-      }
-    }
-
-    private void SetupNoRandPartA()
-    {
-      if (this.i2 <= this.last)
-      {
-        this.chPrev = this.ch2;
-        this.ch2 = (int) this.ll8[this.tPos];
-        this.tPos = this.tt[this.tPos];
-        ++this.i2;
-        this.currentChar = this.ch2;
-        this.currentState = 6;
-        this.mCrc.Update(this.ch2);
-      }
-      else
-      {
-        this.EndBlock();
-        this.InitBlock();
-        this.SetupBlock();
-      }
-    }
-
-    private void SetupRandPartB()
-    {
-      if (this.ch2 != this.chPrev)
-      {
-        this.currentState = 2;
-        this.count = 1;
-        this.SetupRandPartA();
-      }
-      else
-      {
-        ++this.count;
-        if (this.count >= 4)
-        {
-          this.z = this.ll8[this.tPos];
-          this.tPos = this.tt[this.tPos];
-          if (this.rNToGo == 0)
-          {
-            this.rNToGo = BZip2Constants.rNums[this.rTPos];
-            ++this.rTPos;
-            if (this.rTPos == 512)
-              this.rTPos = 0;
-          }
-          --this.rNToGo;
-          this.z ^= this.rNToGo == 1 ? (byte) 1 : (byte) 0;
-          this.j2 = 0;
-          this.currentState = 4;
-          this.SetupRandPartC();
-        }
-        else
-        {
-          this.currentState = 2;
-          this.SetupRandPartA();
-        }
-      }
-    }
-
-    private void SetupRandPartC()
-    {
-      if (this.j2 < (int) this.z)
-      {
-        this.currentChar = this.ch2;
-        this.mCrc.Update(this.ch2);
-        ++this.j2;
-      }
-      else
-      {
-        this.currentState = 2;
-        ++this.i2;
-        this.count = 0;
-        this.SetupRandPartA();
-      }
-    }
-
-    private void SetupNoRandPartB()
-    {
-      if (this.ch2 != this.chPrev)
-      {
-        this.currentState = 5;
-        this.count = 1;
-        this.SetupNoRandPartA();
-      }
-      else
-      {
-        ++this.count;
-        if (this.count >= 4)
-        {
-          this.z = this.ll8[this.tPos];
-          this.tPos = this.tt[this.tPos];
-          this.currentState = 7;
-          this.j2 = 0;
-          this.SetupNoRandPartC();
-        }
-        else
-        {
-          this.currentState = 5;
-          this.SetupNoRandPartA();
-        }
-      }
-    }
-
-    private void SetupNoRandPartC()
-    {
-      if (this.j2 < (int) this.z)
-      {
-        this.currentChar = this.ch2;
-        this.mCrc.Update(this.ch2);
-        ++this.j2;
-      }
-      else
-      {
-        this.currentState = 5;
-        ++this.i2;
-        this.count = 0;
-        this.SetupNoRandPartA();
-      }
-    }
-
-    private void SetDecompressStructureSizes(int newSize100k)
-    {
-      this.blockSize100k = 0 <= newSize100k && newSize100k <= 9 && 0 <= this.blockSize100k && this.blockSize100k <= 9 ? newSize100k : throw new BZip2Exception("Invalid block size");
-      if (newSize100k == 0)
-        return;
-      int length = 100000 * newSize100k;
-      this.ll8 = new byte[length];
-      this.tt = new int[length];
-    }
-
-    private static void CompressedStreamEOF()
-    {
-      throw new EndOfStreamException("BZip2 input stream end of compressed stream");
-    }
-
-    private static void BlockOverrun()
-    {
-      throw new BZip2Exception("BZip2 input stream block overrun");
-    }
-
-    private static void BadBlockHeader()
-    {
-      throw new BZip2Exception("BZip2 input stream bad block header");
-    }
-
-    private static void CrcError() => throw new BZip2Exception("BZip2 input stream crc error");
-
-    private static void HbCreateDecodeTables(
-      int[] limit,
-      int[] baseArray,
-      int[] perm,
-      char[] length,
-      int minLen,
-      int maxLen,
-      int alphaSize)
-    {
-      int index1 = 0;
-      for (int index2 = minLen; index2 <= maxLen; ++index2)
-      {
-        for (int index3 = 0; index3 < alphaSize; ++index3)
-        {
-          if ((int) length[index3] == index2)
-          {
-            perm[index1] = index3;
-            ++index1;
-          }
-        }
-      }
-      for (int index4 = 0; index4 < 23; ++index4)
-        baseArray[index4] = 0;
-      for (int index5 = 0; index5 < alphaSize; ++index5)
-        ++baseArray[(int) length[index5] + 1];
-      for (int index6 = 1; index6 < 23; ++index6)
-        baseArray[index6] += baseArray[index6 - 1];
-      for (int index7 = 0; index7 < 23; ++index7)
-        limit[index7] = 0;
-      int num1 = 0;
-      for (int index8 = minLen; index8 <= maxLen; ++index8)
-      {
-        int num2 = num1 + (baseArray[index8 + 1] - baseArray[index8]);
-        limit[index8] = num2 - 1;
-        num1 = num2 << 1;
-      }
-      for (int index9 = minLen + 1; index9 <= maxLen; ++index9)
-        baseArray[index9] = (limit[index9 - 1] + 1 << 1) - baseArray[index9];
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2OutputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2OutputStream.cs
deleted file mode 100644
index e3e3216..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/BZip2/BZip2OutputStream.cs
+++ /dev/null
@@ -1,1326 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  public class BZip2OutputStream : Stream
-  {
-    private const int SETMASK = 2097152;
-    private const int CLEARMASK = -2097153;
-    private const int GREATER_ICOST = 15;
-    private const int LESSER_ICOST = 0;
-    private const int SMALL_THRESH = 20;
-    private const int DEPTH_THRESH = 10;
-    private const int QSORT_STACK_SIZE = 1000;
-    private readonly int[] increments = new int[14]
-    {
-      1,
-      4,
-      13,
-      40,
-      121,
-      364,
-      1093,
-      3280,
-      9841,
-      29524,
-      88573,
-      265720,
-      797161,
-      2391484
-    };
-    private bool isStreamOwner = true;
-    private int last;
-    private int origPtr;
-    private int blockSize100k;
-    private bool blockRandomised;
-    private int bytesOut;
-    private int bsBuff;
-    private int bsLive;
-    private IChecksum mCrc = (IChecksum) new StrangeCRC();
-    private bool[] inUse = new bool[256];
-    private int nInUse;
-    private char[] seqToUnseq = new char[256];
-    private char[] unseqToSeq = new char[256];
-    private char[] selector = new char[18002];
-    private char[] selectorMtf = new char[18002];
-    private byte[] block;
-    private int[] quadrant;
-    private int[] zptr;
-    private short[] szptr;
-    private int[] ftab;
-    private int nMTF;
-    private int[] mtfFreq = new int[258];
-    private int workFactor;
-    private int workDone;
-    private int workLimit;
-    private bool firstAttempt;
-    private int nBlocksRandomised;
-    private int currentChar = -1;
-    private int runLength;
-    private uint blockCRC;
-    private uint combinedCRC;
-    private int allowableBlockSize;
-    private Stream baseStream;
-    private bool disposed_;
-
-    public BZip2OutputStream(Stream stream)
-      : this(stream, 9)
-    {
-    }
-
-    public BZip2OutputStream(Stream stream, int blockSize)
-    {
-      this.BsSetStream(stream);
-      this.workFactor = 50;
-      if (blockSize > 9)
-        blockSize = 9;
-      if (blockSize < 1)
-        blockSize = 1;
-      this.blockSize100k = blockSize;
-      this.AllocateCompressStructures();
-      this.Initialize();
-      this.InitBlock();
-    }
-
-    ~BZip2OutputStream() => this.Dispose(false);
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public override bool CanRead => false;
-
-    public override bool CanSeek => false;
-
-    public override bool CanWrite => this.baseStream.CanWrite;
-
-    public override long Length => this.baseStream.Length;
-
-    public override long Position
-    {
-      get => this.baseStream.Position;
-      set => throw new NotSupportedException("BZip2OutputStream position cannot be set");
-    }
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("BZip2OutputStream Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("BZip2OutputStream SetLength not supported");
-    }
-
-    public override int ReadByte()
-    {
-      throw new NotSupportedException("BZip2OutputStream ReadByte not supported");
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("BZip2OutputStream Read not supported");
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (buffer.Length - offset < count)
-        throw new ArgumentException("Offset/count out of range");
-      for (int index = 0; index < count; ++index)
-        this.WriteByte(buffer[offset + index]);
-    }
-
-    public override void WriteByte(byte value)
-    {
-      int num = (256 + (int) value) % 256;
-      if (this.currentChar != -1)
-      {
-        if (this.currentChar == num)
-        {
-          ++this.runLength;
-          if (this.runLength <= 254)
-            return;
-          this.WriteRun();
-          this.currentChar = -1;
-          this.runLength = 0;
-        }
-        else
-        {
-          this.WriteRun();
-          this.runLength = 1;
-          this.currentChar = num;
-        }
-      }
-      else
-      {
-        this.currentChar = num;
-        ++this.runLength;
-      }
-    }
-
-    public override void Close()
-    {
-      this.Dispose(true);
-      GC.SuppressFinalize((object) this);
-    }
-
-    private void MakeMaps()
-    {
-      this.nInUse = 0;
-      for (int index = 0; index < 256; ++index)
-      {
-        if (this.inUse[index])
-        {
-          this.seqToUnseq[this.nInUse] = (char) index;
-          this.unseqToSeq[index] = (char) this.nInUse;
-          ++this.nInUse;
-        }
-      }
-    }
-
-    private void WriteRun()
-    {
-      if (this.last < this.allowableBlockSize)
-      {
-        this.inUse[this.currentChar] = true;
-        for (int index = 0; index < this.runLength; ++index)
-          this.mCrc.Update(this.currentChar);
-        switch (this.runLength)
-        {
-          case 1:
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            break;
-          case 2:
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            break;
-          case 3:
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            break;
-          default:
-            this.inUse[this.runLength - 4] = true;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) (this.runLength - 4);
-            break;
-        }
-      }
-      else
-      {
-        this.EndBlock();
-        this.InitBlock();
-        this.WriteRun();
-      }
-    }
-
-    public int BytesWritten => this.bytesOut;
-
-    protected override void Dispose(bool disposing)
-    {
-      base.Dispose(disposing);
-      if (this.disposed_)
-        return;
-      this.disposed_ = true;
-      if (this.runLength > 0)
-        this.WriteRun();
-      this.currentChar = -1;
-      this.EndBlock();
-      this.EndCompression();
-      this.Flush();
-      if (!disposing || !this.IsStreamOwner)
-        return;
-      this.baseStream.Close();
-    }
-
-    public override void Flush() => this.baseStream.Flush();
-
-    private void Initialize()
-    {
-      this.bytesOut = 0;
-      this.nBlocksRandomised = 0;
-      this.BsPutUChar(66);
-      this.BsPutUChar(90);
-      this.BsPutUChar(104);
-      this.BsPutUChar(48 + this.blockSize100k);
-      this.combinedCRC = 0U;
-    }
-
-    private void InitBlock()
-    {
-      this.mCrc.Reset();
-      this.last = -1;
-      for (int index = 0; index < 256; ++index)
-        this.inUse[index] = false;
-      this.allowableBlockSize = 100000 * this.blockSize100k - 20;
-    }
-
-    private void EndBlock()
-    {
-      if (this.last < 0)
-        return;
-      this.blockCRC = (uint) this.mCrc.Value;
-      this.combinedCRC = this.combinedCRC << 1 | this.combinedCRC >> 31;
-      this.combinedCRC ^= this.blockCRC;
-      this.DoReversibleTransformation();
-      this.BsPutUChar(49);
-      this.BsPutUChar(65);
-      this.BsPutUChar(89);
-      this.BsPutUChar(38);
-      this.BsPutUChar(83);
-      this.BsPutUChar(89);
-      this.BsPutint((int) this.blockCRC);
-      if (this.blockRandomised)
-      {
-        this.BsW(1, 1);
-        ++this.nBlocksRandomised;
-      }
-      else
-        this.BsW(1, 0);
-      this.MoveToFrontCodeAndSend();
-    }
-
-    private void EndCompression()
-    {
-      this.BsPutUChar(23);
-      this.BsPutUChar(114);
-      this.BsPutUChar(69);
-      this.BsPutUChar(56);
-      this.BsPutUChar(80);
-      this.BsPutUChar(144);
-      this.BsPutint((int) this.combinedCRC);
-      this.BsFinishedWithStream();
-    }
-
-    private void BsSetStream(Stream stream)
-    {
-      this.baseStream = stream;
-      this.bsLive = 0;
-      this.bsBuff = 0;
-      this.bytesOut = 0;
-    }
-
-    private void BsFinishedWithStream()
-    {
-      while (this.bsLive > 0)
-      {
-        this.baseStream.WriteByte((byte) (this.bsBuff >> 24));
-        this.bsBuff <<= 8;
-        this.bsLive -= 8;
-        ++this.bytesOut;
-      }
-    }
-
-    private void BsW(int n, int v)
-    {
-      while (this.bsLive >= 8)
-      {
-        this.baseStream.WriteByte((byte) (this.bsBuff >> 24));
-        this.bsBuff <<= 8;
-        this.bsLive -= 8;
-        ++this.bytesOut;
-      }
-      this.bsBuff |= v << 32 - this.bsLive - n;
-      this.bsLive += n;
-    }
-
-    private void BsPutUChar(int c) => this.BsW(8, c);
-
-    private void BsPutint(int u)
-    {
-      this.BsW(8, u >> 24 & (int) byte.MaxValue);
-      this.BsW(8, u >> 16 & (int) byte.MaxValue);
-      this.BsW(8, u >> 8 & (int) byte.MaxValue);
-      this.BsW(8, u & (int) byte.MaxValue);
-    }
-
-    private void BsPutIntVS(int numBits, int c) => this.BsW(numBits, c);
-
-    private void SendMTFValues()
-    {
-      char[][] chArray1 = new char[6][];
-      for (int index = 0; index < 6; ++index)
-        chArray1[index] = new char[258];
-      int v1 = 0;
-      int alphaSize = this.nInUse + 2;
-      for (int index1 = 0; index1 < 6; ++index1)
-      {
-        for (int index2 = 0; index2 < alphaSize; ++index2)
-          chArray1[index1][index2] = '\u000F';
-      }
-      if (this.nMTF <= 0)
-        BZip2OutputStream.Panic();
-      int v2 = this.nMTF >= 200 ? (this.nMTF >= 600 ? (this.nMTF >= 1200 ? (this.nMTF >= 2400 ? 6 : 5) : 4) : 3) : 2;
-      int num1 = v2;
-      int nMtf = this.nMTF;
-      int num2 = 0;
-      while (num1 > 0)
-      {
-        int num3 = nMtf / num1;
-        int num4 = 0;
-        int index3;
-        for (index3 = num2 - 1; num4 < num3 && index3 < alphaSize - 1; num4 += this.mtfFreq[index3])
-          ++index3;
-        if (index3 > num2 && num1 != v2 && num1 != 1 && (v2 - num1) % 2 == 1)
-        {
-          num4 -= this.mtfFreq[index3];
-          --index3;
-        }
-        for (int index4 = 0; index4 < alphaSize; ++index4)
-          chArray1[num1 - 1][index4] = index4 < num2 || index4 > index3 ? '\u000F' : char.MinValue;
-        --num1;
-        num2 = index3 + 1;
-        nMtf -= num4;
-      }
-      int[][] numArray1 = new int[6][];
-      for (int index = 0; index < 6; ++index)
-        numArray1[index] = new int[258];
-      int[] numArray2 = new int[6];
-      short[] numArray3 = new short[6];
-      for (int index5 = 0; index5 < 4; ++index5)
-      {
-        for (int index6 = 0; index6 < v2; ++index6)
-          numArray2[index6] = 0;
-        for (int index7 = 0; index7 < v2; ++index7)
-        {
-          for (int index8 = 0; index8 < alphaSize; ++index8)
-            numArray1[index7][index8] = 0;
-        }
-        v1 = 0;
-        int num5 = 0;
-        int num6;
-        for (int index9 = 0; index9 < this.nMTF; index9 = num6 + 1)
-        {
-          num6 = index9 + 50 - 1;
-          if (num6 >= this.nMTF)
-            num6 = this.nMTF - 1;
-          for (int index10 = 0; index10 < v2; ++index10)
-            numArray3[index10] = (short) 0;
-          if (v2 == 6)
-          {
-            int num7;
-            short num8 = (short) (num7 = 0);
-            short num9 = (short) num7;
-            short num10 = (short) num7;
-            short num11 = (short) num7;
-            short num12 = (short) num7;
-            short num13 = (short) num7;
-            for (int index11 = index9; index11 <= num6; ++index11)
-            {
-              short index12 = this.szptr[index11];
-              num13 += (short) chArray1[0][(int) index12];
-              num12 += (short) chArray1[1][(int) index12];
-              num11 += (short) chArray1[2][(int) index12];
-              num10 += (short) chArray1[3][(int) index12];
-              num9 += (short) chArray1[4][(int) index12];
-              num8 += (short) chArray1[5][(int) index12];
-            }
-            numArray3[0] = num13;
-            numArray3[1] = num12;
-            numArray3[2] = num11;
-            numArray3[3] = num10;
-            numArray3[4] = num9;
-            numArray3[5] = num8;
-          }
-          else
-          {
-            for (int index13 = index9; index13 <= num6; ++index13)
-            {
-              short index14 = this.szptr[index13];
-              for (int index15 = 0; index15 < v2; ++index15)
-                numArray3[index15] += (short) chArray1[index15][(int) index14];
-            }
-          }
-          int num14 = 999999999;
-          int index16 = -1;
-          for (int index17 = 0; index17 < v2; ++index17)
-          {
-            if ((int) numArray3[index17] < num14)
-            {
-              num14 = (int) numArray3[index17];
-              index16 = index17;
-            }
-          }
-          num5 += num14;
-          ++numArray2[index16];
-          this.selector[v1] = (char) index16;
-          ++v1;
-          for (int index18 = index9; index18 <= num6; ++index18)
-            ++numArray1[index16][(int) this.szptr[index18]];
-        }
-        for (int index19 = 0; index19 < v2; ++index19)
-          BZip2OutputStream.HbMakeCodeLengths(chArray1[index19], numArray1[index19], alphaSize, 20);
-      }
-      if (v2 >= 8)
-        BZip2OutputStream.Panic();
-      if (v1 >= 32768 || v1 > 18002)
-        BZip2OutputStream.Panic();
-      char[] chArray2 = new char[6];
-      for (int index = 0; index < v2; ++index)
-        chArray2[index] = (char) index;
-      for (int index20 = 0; index20 < v1; ++index20)
-      {
-        char ch1 = this.selector[index20];
-        int index21 = 0;
-        char ch2 = chArray2[index21];
-        while ((int) ch1 != (int) ch2)
-        {
-          ++index21;
-          char ch3 = ch2;
-          ch2 = chArray2[index21];
-          chArray2[index21] = ch3;
-        }
-        chArray2[0] = ch2;
-        this.selectorMtf[index20] = (char) index21;
-      }
-      int[][] numArray4 = new int[6][];
-      for (int index = 0; index < 6; ++index)
-        numArray4[index] = new int[258];
-      for (int index22 = 0; index22 < v2; ++index22)
-      {
-        int minLen = 32;
-        int maxLen = 0;
-        for (int index23 = 0; index23 < alphaSize; ++index23)
-        {
-          if ((int) chArray1[index22][index23] > maxLen)
-            maxLen = (int) chArray1[index22][index23];
-          if ((int) chArray1[index22][index23] < minLen)
-            minLen = (int) chArray1[index22][index23];
-        }
-        if (maxLen > 20)
-          BZip2OutputStream.Panic();
-        if (minLen < 1)
-          BZip2OutputStream.Panic();
-        BZip2OutputStream.HbAssignCodes(numArray4[index22], chArray1[index22], minLen, maxLen, alphaSize);
-      }
-      bool[] flagArray = new bool[16];
-      for (int index24 = 0; index24 < 16; ++index24)
-      {
-        flagArray[index24] = false;
-        for (int index25 = 0; index25 < 16; ++index25)
-        {
-          if (this.inUse[index24 * 16 + index25])
-            flagArray[index24] = true;
-        }
-      }
-      for (int index = 0; index < 16; ++index)
-      {
-        if (flagArray[index])
-          this.BsW(1, 1);
-        else
-          this.BsW(1, 0);
-      }
-      for (int index26 = 0; index26 < 16; ++index26)
-      {
-        if (flagArray[index26])
-        {
-          for (int index27 = 0; index27 < 16; ++index27)
-          {
-            if (this.inUse[index26 * 16 + index27])
-              this.BsW(1, 1);
-            else
-              this.BsW(1, 0);
-          }
-        }
-      }
-      this.BsW(3, v2);
-      this.BsW(15, v1);
-      for (int index28 = 0; index28 < v1; ++index28)
-      {
-        for (int index29 = 0; index29 < (int) this.selectorMtf[index28]; ++index29)
-          this.BsW(1, 1);
-        this.BsW(1, 0);
-      }
-      for (int index30 = 0; index30 < v2; ++index30)
-      {
-        int v3 = (int) chArray1[index30][0];
-        this.BsW(5, v3);
-        for (int index31 = 0; index31 < alphaSize; ++index31)
-        {
-          for (; v3 < (int) chArray1[index30][index31]; ++v3)
-            this.BsW(2, 2);
-          for (; v3 > (int) chArray1[index30][index31]; --v3)
-            this.BsW(2, 3);
-          this.BsW(1, 0);
-        }
-      }
-      int index32 = 0;
-      int num15 = 0;
-      while (num15 < this.nMTF)
-      {
-        int num16 = num15 + 50 - 1;
-        if (num16 >= this.nMTF)
-          num16 = this.nMTF - 1;
-        for (int index33 = num15; index33 <= num16; ++index33)
-          this.BsW((int) chArray1[(int) this.selector[index32]][(int) this.szptr[index33]], numArray4[(int) this.selector[index32]][(int) this.szptr[index33]]);
-        num15 = num16 + 1;
-        ++index32;
-      }
-      if (index32 == v1)
-        return;
-      BZip2OutputStream.Panic();
-    }
-
-    private void MoveToFrontCodeAndSend()
-    {
-      this.BsPutIntVS(24, this.origPtr);
-      this.GenerateMTFValues();
-      this.SendMTFValues();
-    }
-
-    private void SimpleSort(int lo, int hi, int d)
-    {
-      int num1 = hi - lo + 1;
-      if (num1 < 2)
-        return;
-      int index1 = 0;
-      while (this.increments[index1] < num1)
-        ++index1;
-      for (int index2 = index1 - 1; index2 >= 0; --index2)
-      {
-        int increment = this.increments[index2];
-        int index3 = lo + increment;
-        while (index3 <= hi)
-        {
-          int num2 = this.zptr[index3];
-          int index4 = index3;
-          while (this.FullGtU(this.zptr[index4 - increment] + d, num2 + d))
-          {
-            this.zptr[index4] = this.zptr[index4 - increment];
-            index4 -= increment;
-            if (index4 <= lo + increment - 1)
-              break;
-          }
-          this.zptr[index4] = num2;
-          int index5 = index3 + 1;
-          if (index5 <= hi)
-          {
-            int num3 = this.zptr[index5];
-            int index6 = index5;
-            while (this.FullGtU(this.zptr[index6 - increment] + d, num3 + d))
-            {
-              this.zptr[index6] = this.zptr[index6 - increment];
-              index6 -= increment;
-              if (index6 <= lo + increment - 1)
-                break;
-            }
-            this.zptr[index6] = num3;
-            int index7 = index5 + 1;
-            if (index7 <= hi)
-            {
-              int num4 = this.zptr[index7];
-              int index8 = index7;
-              while (this.FullGtU(this.zptr[index8 - increment] + d, num4 + d))
-              {
-                this.zptr[index8] = this.zptr[index8 - increment];
-                index8 -= increment;
-                if (index8 <= lo + increment - 1)
-                  break;
-              }
-              this.zptr[index8] = num4;
-              index3 = index7 + 1;
-              if (this.workDone > this.workLimit && this.firstAttempt)
-                return;
-            }
-            else
-              break;
-          }
-          else
-            break;
-        }
-      }
-    }
-
-    private void Vswap(int p1, int p2, int n)
-    {
-      for (; n > 0; --n)
-      {
-        int num = this.zptr[p1];
-        this.zptr[p1] = this.zptr[p2];
-        this.zptr[p2] = num;
-        ++p1;
-        ++p2;
-      }
-    }
-
-    private void QSort3(int loSt, int hiSt, int dSt)
-    {
-      BZip2OutputStream.StackElement[] stackElementArray = new BZip2OutputStream.StackElement[1000];
-      for (int index = 0; index < 1000; ++index)
-        stackElementArray[index] = new BZip2OutputStream.StackElement();
-      int index1 = 0;
-      stackElementArray[index1].ll = loSt;
-      stackElementArray[index1].hh = hiSt;
-      stackElementArray[index1].dd = dSt;
-      int index2 = index1 + 1;
-      while (index2 > 0)
-      {
-        if (index2 >= 1000)
-          BZip2OutputStream.Panic();
-        --index2;
-        int ll = stackElementArray[index2].ll;
-        int hh = stackElementArray[index2].hh;
-        int dd = stackElementArray[index2].dd;
-        if (hh - ll < 20 || dd > 10)
-        {
-          this.SimpleSort(ll, hh, dd);
-          if (this.workDone > this.workLimit && this.firstAttempt)
-            break;
-        }
-        else
-        {
-          int num1 = (int) BZip2OutputStream.Med3(this.block[this.zptr[ll] + dd + 1], this.block[this.zptr[hh] + dd + 1], this.block[this.zptr[ll + hh >> 1] + dd + 1]);
-          int index3;
-          int p1 = index3 = ll;
-          int index4;
-          int index5 = index4 = hh;
-          while (true)
-          {
-            while (p1 <= index5)
-            {
-              int num2 = (int) this.block[this.zptr[p1] + dd + 1] - num1;
-              if (num2 == 0)
-              {
-                int num3 = this.zptr[p1];
-                this.zptr[p1] = this.zptr[index3];
-                this.zptr[index3] = num3;
-                ++index3;
-                ++p1;
-              }
-              else if (num2 <= 0)
-                ++p1;
-              else
-                break;
-            }
-            while (p1 <= index5)
-            {
-              int num4 = (int) this.block[this.zptr[index5] + dd + 1] - num1;
-              if (num4 == 0)
-              {
-                int num5 = this.zptr[index5];
-                this.zptr[index5] = this.zptr[index4];
-                this.zptr[index4] = num5;
-                --index4;
-                --index5;
-              }
-              else if (num4 >= 0)
-                --index5;
-              else
-                break;
-            }
-            if (p1 <= index5)
-            {
-              int num6 = this.zptr[p1];
-              this.zptr[p1] = this.zptr[index5];
-              this.zptr[index5] = num6;
-              ++p1;
-              --index5;
-            }
-            else
-              break;
-          }
-          if (index4 < index3)
-          {
-            stackElementArray[index2].ll = ll;
-            stackElementArray[index2].hh = hh;
-            stackElementArray[index2].dd = dd + 1;
-            ++index2;
-          }
-          else
-          {
-            int n1 = index3 - ll < p1 - index3 ? index3 - ll : p1 - index3;
-            this.Vswap(ll, p1 - n1, n1);
-            int n2 = hh - index4 < index4 - index5 ? hh - index4 : index4 - index5;
-            this.Vswap(p1, hh - n2 + 1, n2);
-            int num7 = ll + p1 - index3 - 1;
-            int num8 = hh - (index4 - index5) + 1;
-            stackElementArray[index2].ll = ll;
-            stackElementArray[index2].hh = num7;
-            stackElementArray[index2].dd = dd;
-            int index6 = index2 + 1;
-            stackElementArray[index6].ll = num7 + 1;
-            stackElementArray[index6].hh = num8 - 1;
-            stackElementArray[index6].dd = dd + 1;
-            int index7 = index6 + 1;
-            stackElementArray[index7].ll = num8;
-            stackElementArray[index7].hh = hh;
-            stackElementArray[index7].dd = dd;
-            index2 = index7 + 1;
-          }
-        }
-      }
-    }
-
-    private void MainSort()
-    {
-      int[] numArray1 = new int[256];
-      int[] numArray2 = new int[256];
-      bool[] flagArray = new bool[256];
-      for (int index = 0; index < 20; ++index)
-        this.block[this.last + index + 2] = this.block[index % (this.last + 1) + 1];
-      for (int index = 0; index <= this.last + 20; ++index)
-        this.quadrant[index] = 0;
-      this.block[0] = this.block[this.last + 1];
-      if (this.last < 4000)
-      {
-        for (int index = 0; index <= this.last; ++index)
-          this.zptr[index] = index;
-        this.firstAttempt = false;
-        this.workDone = this.workLimit = 0;
-        this.SimpleSort(0, this.last, 0);
-      }
-      else
-      {
-        int num1 = 0;
-        for (int index = 0; index <= (int) byte.MaxValue; ++index)
-          flagArray[index] = false;
-        for (int index = 0; index <= 65536; ++index)
-          this.ftab[index] = 0;
-        int num2 = (int) this.block[0];
-        for (int index = 0; index <= this.last; ++index)
-        {
-          int num3 = (int) this.block[index + 1];
-          ++this.ftab[(num2 << 8) + num3];
-          num2 = num3;
-        }
-        for (int index = 1; index <= 65536; ++index)
-          this.ftab[index] += this.ftab[index - 1];
-        int num4 = (int) this.block[1];
-        for (int index1 = 0; index1 < this.last; ++index1)
-        {
-          int num5 = (int) this.block[index1 + 2];
-          int index2 = (num4 << 8) + num5;
-          num4 = num5;
-          --this.ftab[index2];
-          this.zptr[this.ftab[index2]] = index1;
-        }
-        int index3 = ((int) this.block[this.last + 1] << 8) + (int) this.block[1];
-        --this.ftab[index3];
-        this.zptr[this.ftab[index3]] = this.last;
-        for (int index4 = 0; index4 <= (int) byte.MaxValue; ++index4)
-          numArray1[index4] = index4;
-        int num6 = 1;
-        do
-        {
-          num6 = 3 * num6 + 1;
-        }
-        while (num6 <= 256);
-        do
-        {
-          num6 /= 3;
-          for (int index5 = num6; index5 <= (int) byte.MaxValue; ++index5)
-          {
-            int num7 = numArray1[index5];
-            int index6 = index5;
-            while (this.ftab[numArray1[index6 - num6] + 1 << 8] - this.ftab[numArray1[index6 - num6] << 8] > this.ftab[num7 + 1 << 8] - this.ftab[num7 << 8])
-            {
-              numArray1[index6] = numArray1[index6 - num6];
-              index6 -= num6;
-              if (index6 <= num6 - 1)
-                break;
-            }
-            numArray1[index6] = num7;
-          }
-        }
-        while (num6 != 1);
-        for (int index7 = 0; index7 <= (int) byte.MaxValue; ++index7)
-        {
-          int index8 = numArray1[index7];
-          for (int index9 = 0; index9 <= (int) byte.MaxValue; ++index9)
-          {
-            int index10 = (index8 << 8) + index9;
-            if ((this.ftab[index10] & 2097152) != 2097152)
-            {
-              int loSt = this.ftab[index10] & -2097153;
-              int hiSt = (this.ftab[index10 + 1] & -2097153) - 1;
-              if (hiSt > loSt)
-              {
-                this.QSort3(loSt, hiSt, 2);
-                num1 += hiSt - loSt + 1;
-                if (this.workDone > this.workLimit && this.firstAttempt)
-                  return;
-              }
-              this.ftab[index10] |= 2097152;
-            }
-          }
-          flagArray[index8] = true;
-          if (index7 < (int) byte.MaxValue)
-          {
-            int num8 = this.ftab[index8 << 8] & -2097153;
-            int num9 = (this.ftab[index8 + 1 << 8] & -2097153) - num8;
-            int num10 = 0;
-            while (num9 >> num10 > 65534)
-              ++num10;
-            for (int index11 = 0; index11 < num9; ++index11)
-            {
-              int index12 = this.zptr[num8 + index11];
-              int num11 = index11 >> num10;
-              this.quadrant[index12] = num11;
-              if (index12 < 20)
-                this.quadrant[index12 + this.last + 1] = num11;
-            }
-            if (num9 - 1 >> num10 > (int) ushort.MaxValue)
-              BZip2OutputStream.Panic();
-          }
-          for (int index13 = 0; index13 <= (int) byte.MaxValue; ++index13)
-            numArray2[index13] = this.ftab[(index13 << 8) + index8] & -2097153;
-          for (int index14 = this.ftab[index8 << 8] & -2097153; index14 < (this.ftab[index8 + 1 << 8] & -2097153); ++index14)
-          {
-            int index15 = (int) this.block[this.zptr[index14]];
-            if (!flagArray[index15])
-            {
-              this.zptr[numArray2[index15]] = this.zptr[index14] == 0 ? this.last : this.zptr[index14] - 1;
-              ++numArray2[index15];
-            }
-          }
-          for (int index16 = 0; index16 <= (int) byte.MaxValue; ++index16)
-            this.ftab[(index16 << 8) + index8] |= 2097152;
-        }
-      }
-    }
-
-    private void RandomiseBlock()
-    {
-      int num = 0;
-      int index1 = 0;
-      for (int index2 = 0; index2 < 256; ++index2)
-        this.inUse[index2] = false;
-      for (int index3 = 0; index3 <= this.last; ++index3)
-      {
-        if (num == 0)
-        {
-          num = BZip2Constants.rNums[index1];
-          ++index1;
-          if (index1 == 512)
-            index1 = 0;
-        }
-        --num;
-        this.block[index3 + 1] ^= num == 1 ? (byte) 1 : (byte) 0;
-        this.block[index3 + 1] &= byte.MaxValue;
-        this.inUse[(int) this.block[index3 + 1]] = true;
-      }
-    }
-
-    private void DoReversibleTransformation()
-    {
-      this.workLimit = this.workFactor * this.last;
-      this.workDone = 0;
-      this.blockRandomised = false;
-      this.firstAttempt = true;
-      this.MainSort();
-      if (this.workDone > this.workLimit && this.firstAttempt)
-      {
-        this.RandomiseBlock();
-        this.workLimit = this.workDone = 0;
-        this.blockRandomised = true;
-        this.firstAttempt = false;
-        this.MainSort();
-      }
-      this.origPtr = -1;
-      for (int index = 0; index <= this.last; ++index)
-      {
-        if (this.zptr[index] == 0)
-        {
-          this.origPtr = index;
-          break;
-        }
-      }
-      if (this.origPtr != -1)
-        return;
-      BZip2OutputStream.Panic();
-    }
-
-    private bool FullGtU(int i1, int i2)
-    {
-      byte num1 = this.block[i1 + 1];
-      byte num2 = this.block[i2 + 1];
-      if ((int) num1 != (int) num2)
-        return (int) num1 > (int) num2;
-      ++i1;
-      ++i2;
-      byte num3 = this.block[i1 + 1];
-      byte num4 = this.block[i2 + 1];
-      if ((int) num3 != (int) num4)
-        return (int) num3 > (int) num4;
-      ++i1;
-      ++i2;
-      byte num5 = this.block[i1 + 1];
-      byte num6 = this.block[i2 + 1];
-      if ((int) num5 != (int) num6)
-        return (int) num5 > (int) num6;
-      ++i1;
-      ++i2;
-      byte num7 = this.block[i1 + 1];
-      byte num8 = this.block[i2 + 1];
-      if ((int) num7 != (int) num8)
-        return (int) num7 > (int) num8;
-      ++i1;
-      ++i2;
-      byte num9 = this.block[i1 + 1];
-      byte num10 = this.block[i2 + 1];
-      if ((int) num9 != (int) num10)
-        return (int) num9 > (int) num10;
-      ++i1;
-      ++i2;
-      byte num11 = this.block[i1 + 1];
-      byte num12 = this.block[i2 + 1];
-      if ((int) num11 != (int) num12)
-        return (int) num11 > (int) num12;
-      ++i1;
-      ++i2;
-      int num13 = this.last + 1;
-      do
-      {
-        byte num14 = this.block[i1 + 1];
-        byte num15 = this.block[i2 + 1];
-        if ((int) num14 != (int) num15)
-          return (int) num14 > (int) num15;
-        int num16 = this.quadrant[i1];
-        int num17 = this.quadrant[i2];
-        if (num16 != num17)
-          return num16 > num17;
-        ++i1;
-        ++i2;
-        byte num18 = this.block[i1 + 1];
-        byte num19 = this.block[i2 + 1];
-        if ((int) num18 != (int) num19)
-          return (int) num18 > (int) num19;
-        int num20 = this.quadrant[i1];
-        int num21 = this.quadrant[i2];
-        if (num20 != num21)
-          return num20 > num21;
-        ++i1;
-        ++i2;
-        byte num22 = this.block[i1 + 1];
-        byte num23 = this.block[i2 + 1];
-        if ((int) num22 != (int) num23)
-          return (int) num22 > (int) num23;
-        int num24 = this.quadrant[i1];
-        int num25 = this.quadrant[i2];
-        if (num24 != num25)
-          return num24 > num25;
-        ++i1;
-        ++i2;
-        byte num26 = this.block[i1 + 1];
-        byte num27 = this.block[i2 + 1];
-        if ((int) num26 != (int) num27)
-          return (int) num26 > (int) num27;
-        int num28 = this.quadrant[i1];
-        int num29 = this.quadrant[i2];
-        if (num28 != num29)
-          return num28 > num29;
-        ++i1;
-        ++i2;
-        if (i1 > this.last)
-        {
-          i1 -= this.last;
-          --i1;
-        }
-        if (i2 > this.last)
-        {
-          i2 -= this.last;
-          --i2;
-        }
-        num13 -= 4;
-        ++this.workDone;
-      }
-      while (num13 >= 0);
-      return false;
-    }
-
-    private void AllocateCompressStructures()
-    {
-      int length = 100000 * this.blockSize100k;
-      this.block = new byte[length + 1 + 20];
-      this.quadrant = new int[length + 20];
-      this.zptr = new int[length];
-      this.ftab = new int[65537];
-      if (this.block != null && this.quadrant != null && this.zptr != null)
-      {
-        int[] ftab = this.ftab;
-      }
-      this.szptr = new short[2 * length];
-    }
-
-    private void GenerateMTFValues()
-    {
-      char[] chArray = new char[256];
-      this.MakeMaps();
-      int index1 = this.nInUse + 1;
-      for (int index2 = 0; index2 <= index1; ++index2)
-        this.mtfFreq[index2] = 0;
-      int index3 = 0;
-      int num1 = 0;
-      for (int index4 = 0; index4 < this.nInUse; ++index4)
-        chArray[index4] = (char) index4;
-      for (int index5 = 0; index5 <= this.last; ++index5)
-      {
-        char ch1 = this.unseqToSeq[(int) this.block[this.zptr[index5]]];
-        int index6 = 0;
-        char ch2 = chArray[index6];
-        while ((int) ch1 != (int) ch2)
-        {
-          ++index6;
-          char ch3 = ch2;
-          ch2 = chArray[index6];
-          chArray[index6] = ch3;
-        }
-        chArray[0] = ch2;
-        if (index6 == 0)
-        {
-          ++num1;
-        }
-        else
-        {
-          if (num1 > 0)
-          {
-            int num2 = num1 - 1;
-            while (true)
-            {
-              switch (num2 % 2)
-              {
-                case 0:
-                  this.szptr[index3] = (short) 0;
-                  ++index3;
-                  ++this.mtfFreq[0];
-                  break;
-                case 1:
-                  this.szptr[index3] = (short) 1;
-                  ++index3;
-                  ++this.mtfFreq[1];
-                  break;
-              }
-              if (num2 >= 2)
-                num2 = (num2 - 2) / 2;
-              else
-                break;
-            }
-            num1 = 0;
-          }
-          this.szptr[index3] = (short) (index6 + 1);
-          ++index3;
-          ++this.mtfFreq[index6 + 1];
-        }
-      }
-      if (num1 > 0)
-      {
-        int num3 = num1 - 1;
-        while (true)
-        {
-          switch (num3 % 2)
-          {
-            case 0:
-              this.szptr[index3] = (short) 0;
-              ++index3;
-              ++this.mtfFreq[0];
-              break;
-            case 1:
-              this.szptr[index3] = (short) 1;
-              ++index3;
-              ++this.mtfFreq[1];
-              break;
-          }
-          if (num3 >= 2)
-            num3 = (num3 - 2) / 2;
-          else
-            break;
-        }
-      }
-      this.szptr[index3] = (short) index1;
-      int num4 = index3 + 1;
-      ++this.mtfFreq[index1];
-      this.nMTF = num4;
-    }
-
-    private static void Panic() => throw new BZip2Exception("BZip2 output stream panic");
-
-    private static void HbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen)
-    {
-      int[] numArray1 = new int[260];
-      int[] numArray2 = new int[516];
-      int[] numArray3 = new int[516];
-      for (int index = 0; index < alphaSize; ++index)
-        numArray2[index + 1] = (freq[index] == 0 ? 1 : freq[index]) << 8;
-label_3:
-      int index1 = alphaSize;
-      int index2 = 0;
-      numArray1[0] = 0;
-      numArray2[0] = 0;
-      numArray3[0] = -2;
-      for (int index3 = 1; index3 <= alphaSize; ++index3)
-      {
-        numArray3[index3] = -1;
-        ++index2;
-        numArray1[index2] = index3;
-        int index4 = index2;
-        int index5;
-        for (index5 = numArray1[index4]; numArray2[index5] < numArray2[numArray1[index4 >> 1]]; index4 >>= 1)
-          numArray1[index4] = numArray1[index4 >> 1];
-        numArray1[index4] = index5;
-      }
-      if (index2 >= 260)
-        BZip2OutputStream.Panic();
-      while (index2 > 1)
-      {
-        int index6 = numArray1[1];
-        numArray1[1] = numArray1[index2];
-        int index7 = index2 - 1;
-        int index8 = 1;
-        int num1 = 0;
-        int index9 = numArray1[index8];
-        while (true)
-        {
-          int index10 = index8 << 1;
-          if (index10 <= index7)
-          {
-            if (index10 < index7 && numArray2[numArray1[index10 + 1]] < numArray2[numArray1[index10]])
-              ++index10;
-            if (numArray2[index9] >= numArray2[numArray1[index10]])
-            {
-              numArray1[index8] = numArray1[index10];
-              index8 = index10;
-            }
-            else
-              break;
-          }
-          else
-            break;
-        }
-        numArray1[index8] = index9;
-        int index11 = numArray1[1];
-        numArray1[1] = numArray1[index7];
-        int num2 = index7 - 1;
-        int index12 = 1;
-        num1 = 0;
-        int index13 = numArray1[index12];
-        while (true)
-        {
-          int index14 = index12 << 1;
-          if (index14 <= num2)
-          {
-            if (index14 < num2 && numArray2[numArray1[index14 + 1]] < numArray2[numArray1[index14]])
-              ++index14;
-            if (numArray2[index13] >= numArray2[numArray1[index14]])
-            {
-              numArray1[index12] = numArray1[index14];
-              index12 = index14;
-            }
-            else
-              break;
-          }
-          else
-            break;
-        }
-        numArray1[index12] = index13;
-        ++index1;
-        numArray3[index6] = numArray3[index11] = index1;
-        numArray2[index1] = (int) (((long) numArray2[index6] & 4294967040L) + ((long) numArray2[index11] & 4294967040L)) | 1 + ((numArray2[index6] & (int) byte.MaxValue) > (numArray2[index11] & (int) byte.MaxValue) ? numArray2[index6] & (int) byte.MaxValue : numArray2[index11] & (int) byte.MaxValue);
-        numArray3[index1] = -1;
-        index2 = num2 + 1;
-        numArray1[index2] = index1;
-        int index15 = index2;
-        int index16;
-        for (index16 = numArray1[index15]; numArray2[index16] < numArray2[numArray1[index15 >> 1]]; index15 >>= 1)
-          numArray1[index15] = numArray1[index15 >> 1];
-        numArray1[index15] = index16;
-      }
-      if (index1 >= 516)
-        BZip2OutputStream.Panic();
-      bool flag = false;
-      for (int index17 = 1; index17 <= alphaSize; ++index17)
-      {
-        int num = 0;
-        int index18 = index17;
-        while (numArray3[index18] >= 0)
-        {
-          index18 = numArray3[index18];
-          ++num;
-        }
-        len[index17 - 1] = (char) num;
-        if (num > maxLen)
-          flag = true;
-      }
-      if (!flag)
-        return;
-      for (int index19 = 1; index19 < alphaSize; ++index19)
-      {
-        int num = 1 + (numArray2[index19] >> 8) / 2;
-        numArray2[index19] = num << 8;
-      }
-      goto label_3;
-    }
-
-    private static void HbAssignCodes(
-      int[] code,
-      char[] length,
-      int minLen,
-      int maxLen,
-      int alphaSize)
-    {
-      int num = 0;
-      for (int index1 = minLen; index1 <= maxLen; ++index1)
-      {
-        for (int index2 = 0; index2 < alphaSize; ++index2)
-        {
-          if ((int) length[index2] == index1)
-          {
-            code[index2] = num;
-            ++num;
-          }
-        }
-        num <<= 1;
-      }
-    }
-
-    private static byte Med3(byte a, byte b, byte c)
-    {
-      if ((int) a > (int) b)
-      {
-        byte num = a;
-        a = b;
-        b = num;
-      }
-      if ((int) b > (int) c)
-      {
-        byte num = b;
-        b = c;
-        c = num;
-      }
-      if ((int) a > (int) b)
-        b = a;
-      return b;
-    }
-
-    private class StackElement
-    {
-      public int ll;
-      public int hh;
-      public int dd;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Checksums/Adler32.cs b/MSHALTester/ICSharpCode/SharpZipLib/Checksums/Adler32.cs
deleted file mode 100644
index 00bfafc..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Checksums/Adler32.cs
+++ /dev/null
@@ -1,63 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Checksums
-{
-  public sealed class Adler32 : IChecksum
-  {
-    private const uint BASE = 65521;
-    private uint checksum;
-
-    public long Value => (long) this.checksum;
-
-    public Adler32() => this.Reset();
-
-    public void Reset() => this.checksum = 1U;
-
-    public void Update(int value)
-    {
-      uint num1 = this.checksum & (uint) ushort.MaxValue;
-      uint num2 = this.checksum >> 16;
-      uint num3 = (num1 + (uint) (value & (int) byte.MaxValue)) % 65521U;
-      this.checksum = ((num3 + num2) % 65521U << 16) + num3;
-    }
-
-    public void Update(byte[] buffer)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      this.Update(buffer, 0, buffer.Length);
-    }
-
-    public void Update(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "cannot be negative");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "cannot be negative");
-      if (offset >= buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (offset), "not a valid index into buffer");
-      if (offset + count > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count), "exceeds buffer size");
-      uint num1 = this.checksum & (uint) ushort.MaxValue;
-      uint num2 = this.checksum >> 16;
-      while (count > 0)
-      {
-        int num3 = 3800;
-        if (num3 > count)
-          num3 = count;
-        count -= num3;
-        while (--num3 >= 0)
-        {
-          num1 += (uint) buffer[offset++] & (uint) byte.MaxValue;
-          num2 += num1;
-        }
-        num1 %= 65521U;
-        num2 %= 65521U;
-      }
-      this.checksum = num2 << 16 | num1;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Checksums/Crc32.cs b/MSHALTester/ICSharpCode/SharpZipLib/Checksums/Crc32.cs
deleted file mode 100644
index 79a43e5..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Checksums/Crc32.cs
+++ /dev/null
@@ -1,311 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Checksums
-{
-  public sealed class Crc32 : IChecksum
-  {
-    private static readonly uint CrcSeed = uint.MaxValue;
-    private static readonly uint[] CrcTable = new uint[256]
-    {
-      0U,
-      1996959894U,
-      3993919788U,
-      2567524794U,
-      124634137U,
-      1886057615U,
-      3915621685U,
-      2657392035U,
-      249268274U,
-      2044508324U,
-      3772115230U,
-      2547177864U,
-      162941995U,
-      2125561021U,
-      3887607047U,
-      2428444049U,
-      498536548U,
-      1789927666U,
-      4089016648U,
-      2227061214U,
-      450548861U,
-      1843258603U,
-      4107580753U,
-      2211677639U,
-      325883990U,
-      1684777152U,
-      4251122042U,
-      2321926636U,
-      335633487U,
-      1661365465U,
-      4195302755U,
-      2366115317U,
-      997073096U,
-      1281953886U,
-      3579855332U,
-      2724688242U,
-      1006888145U,
-      1258607687U,
-      3524101629U,
-      2768942443U,
-      901097722U,
-      1119000684U,
-      3686517206U,
-      2898065728U,
-      853044451U,
-      1172266101U,
-      3705015759U,
-      2882616665U,
-      651767980U,
-      1373503546U,
-      3369554304U,
-      3218104598U,
-      565507253U,
-      1454621731U,
-      3485111705U,
-      3099436303U,
-      671266974U,
-      1594198024U,
-      3322730930U,
-      2970347812U,
-      795835527U,
-      1483230225U,
-      3244367275U,
-      3060149565U,
-      1994146192U,
-      31158534U,
-      2563907772U,
-      4023717930U,
-      1907459465U,
-      112637215U,
-      2680153253U,
-      3904427059U,
-      2013776290U,
-      251722036U,
-      2517215374U,
-      3775830040U,
-      2137656763U,
-      141376813U,
-      2439277719U,
-      3865271297U,
-      1802195444U,
-      476864866U,
-      2238001368U,
-      4066508878U,
-      1812370925U,
-      453092731U,
-      2181625025U,
-      4111451223U,
-      1706088902U,
-      314042704U,
-      2344532202U,
-      4240017532U,
-      1658658271U,
-      366619977U,
-      2362670323U,
-      4224994405U,
-      1303535960U,
-      984961486U,
-      2747007092U,
-      3569037538U,
-      1256170817U,
-      1037604311U,
-      2765210733U,
-      3554079995U,
-      1131014506U,
-      879679996U,
-      2909243462U,
-      3663771856U,
-      1141124467U,
-      855842277U,
-      2852801631U,
-      3708648649U,
-      1342533948U,
-      654459306U,
-      3188396048U,
-      3373015174U,
-      1466479909U,
-      544179635U,
-      3110523913U,
-      3462522015U,
-      1591671054U,
-      702138776U,
-      2966460450U,
-      3352799412U,
-      1504918807U,
-      783551873U,
-      3082640443U,
-      3233442989U,
-      3988292384U,
-      2596254646U,
-      62317068U,
-      1957810842U,
-      3939845945U,
-      2647816111U,
-      81470997U,
-      1943803523U,
-      3814918930U,
-      2489596804U,
-      225274430U,
-      2053790376U,
-      3826175755U,
-      2466906013U,
-      167816743U,
-      2097651377U,
-      4027552580U,
-      2265490386U,
-      503444072U,
-      1762050814U,
-      4150417245U,
-      2154129355U,
-      426522225U,
-      1852507879U,
-      4275313526U,
-      2312317920U,
-      282753626U,
-      1742555852U,
-      4189708143U,
-      2394877945U,
-      397917763U,
-      1622183637U,
-      3604390888U,
-      2714866558U,
-      953729732U,
-      1340076626U,
-      3518719985U,
-      2797360999U,
-      1068828381U,
-      1219638859U,
-      3624741850U,
-      2936675148U,
-      906185462U,
-      1090812512U,
-      3747672003U,
-      2825379669U,
-      829329135U,
-      1181335161U,
-      3412177804U,
-      3160834842U,
-      628085408U,
-      1382605366U,
-      3423369109U,
-      3138078467U,
-      570562233U,
-      1426400815U,
-      3317316542U,
-      2998733608U,
-      733239954U,
-      1555261956U,
-      3268935591U,
-      3050360625U,
-      752459403U,
-      1541320221U,
-      2607071920U,
-      3965973030U,
-      1969922972U,
-      40735498U,
-      2617837225U,
-      3943577151U,
-      1913087877U,
-      83908371U,
-      2512341634U,
-      3803740692U,
-      2075208622U,
-      213261112U,
-      2463272603U,
-      3855990285U,
-      2094854071U,
-      198958881U,
-      2262029012U,
-      4057260610U,
-      1759359992U,
-      534414190U,
-      2176718541U,
-      4139329115U,
-      1873836001U,
-      414664567U,
-      2282248934U,
-      4279200368U,
-      1711684554U,
-      285281116U,
-      2405801727U,
-      4167216745U,
-      1634467795U,
-      376229701U,
-      2685067896U,
-      3608007406U,
-      1308918612U,
-      956543938U,
-      2808555105U,
-      3495958263U,
-      1231636301U,
-      1047427035U,
-      2932959818U,
-      3654703836U,
-      1088359270U,
-      936918000U,
-      2847714899U,
-      3736837829U,
-      1202900863U,
-      817233897U,
-      3183342108U,
-      3401237130U,
-      1404277552U,
-      615818150U,
-      3134207493U,
-      3453421203U,
-      1423857449U,
-      601450431U,
-      3009837614U,
-      3294710456U,
-      1567103746U,
-      711928724U,
-      3020668471U,
-      3272380065U,
-      1510334235U,
-      755167117U
-    };
-    private uint crc;
-
-    internal static uint ComputeCrc32(uint oldCrc, byte value)
-    {
-      return Crc32.CrcTable[(IntPtr) (uint) (((int) oldCrc ^ (int) value) & (int) byte.MaxValue)] ^ oldCrc >> 8;
-    }
-
-    public long Value
-    {
-      get => (long) this.crc;
-      set => this.crc = (uint) value;
-    }
-
-    public void Reset() => this.crc = 0U;
-
-    public void Update(int value)
-    {
-      this.crc ^= Crc32.CrcSeed;
-      this.crc = Crc32.CrcTable[((long) this.crc ^ (long) value) & (long) byte.MaxValue] ^ this.crc >> 8;
-      this.crc ^= Crc32.CrcSeed;
-    }
-
-    public void Update(byte[] buffer)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      this.Update(buffer, 0, buffer.Length);
-    }
-
-    public void Update(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Count cannot be less than zero");
-      if (offset < 0 || offset + count > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      this.crc ^= Crc32.CrcSeed;
-      while (--count >= 0)
-        this.crc = Crc32.CrcTable[(IntPtr) (uint) (((int) this.crc ^ (int) buffer[offset++]) & (int) byte.MaxValue)] ^ this.crc >> 8;
-      this.crc ^= Crc32.CrcSeed;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Checksums/IChecksum.cs b/MSHALTester/ICSharpCode/SharpZipLib/Checksums/IChecksum.cs
deleted file mode 100644
index fd3cb22..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Checksums/IChecksum.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Checksums
-{
-  public interface IChecksum
-  {
-    long Value { get; }
-
-    void Reset();
-
-    void Update(int value);
-
-    void Update(byte[] buffer);
-
-    void Update(byte[] buffer, int offset, int count);
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Checksums/StrangeCRC.cs b/MSHALTester/ICSharpCode/SharpZipLib/Checksums/StrangeCRC.cs
deleted file mode 100644
index 32a528c..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Checksums/StrangeCRC.cs
+++ /dev/null
@@ -1,304 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Checksums
-{
-  public class StrangeCRC : IChecksum
-  {
-    private static readonly uint[] crc32Table = new uint[256]
-    {
-      0U,
-      79764919U,
-      159529838U,
-      222504665U,
-      319059676U,
-      398814059U,
-      445009330U,
-      507990021U,
-      638119352U,
-      583659535U,
-      797628118U,
-      726387553U,
-      890018660U,
-      835552979U,
-      1015980042U,
-      944750013U,
-      1276238704U,
-      1221641927U,
-      1167319070U,
-      1095957929U,
-      1595256236U,
-      1540665371U,
-      1452775106U,
-      1381403509U,
-      1780037320U,
-      1859660671U,
-      1671105958U,
-      1733955601U,
-      2031960084U,
-      2111593891U,
-      1889500026U,
-      1952343757U,
-      2552477408U,
-      2632100695U,
-      2443283854U,
-      2506133561U,
-      2334638140U,
-      2414271883U,
-      2191915858U,
-      2254759653U,
-      3190512472U,
-      3135915759U,
-      3081330742U,
-      3009969537U,
-      2905550212U,
-      2850959411U,
-      2762807018U,
-      2691435357U,
-      3560074640U,
-      3505614887U,
-      3719321342U,
-      3648080713U,
-      3342211916U,
-      3287746299U,
-      3467911202U,
-      3396681109U,
-      4063920168U,
-      4143685023U,
-      4223187782U,
-      4286162673U,
-      3779000052U,
-      3858754371U,
-      3904687514U,
-      3967668269U,
-      881225847U,
-      809987520U,
-      1023691545U,
-      969234094U,
-      662832811U,
-      591600412U,
-      771767749U,
-      717299826U,
-      311336399U,
-      374308984U,
-      453813921U,
-      533576470U,
-      25881363U,
-      88864420U,
-      134795389U,
-      214552010U,
-      2023205639U,
-      2086057648U,
-      1897238633U,
-      1976864222U,
-      1804852699U,
-      1867694188U,
-      1645340341U,
-      1724971778U,
-      1587496639U,
-      1516133128U,
-      1461550545U,
-      1406951526U,
-      1302016099U,
-      1230646740U,
-      1142491917U,
-      1087903418U,
-      2896545431U,
-      2825181984U,
-      2770861561U,
-      2716262478U,
-      3215044683U,
-      3143675388U,
-      3055782693U,
-      3001194130U,
-      2326604591U,
-      2389456536U,
-      2200899649U,
-      2280525302U,
-      2578013683U,
-      2640855108U,
-      2418763421U,
-      2498394922U,
-      3769900519U,
-      3832873040U,
-      3912640137U,
-      3992402750U,
-      4088425275U,
-      4151408268U,
-      4197601365U,
-      4277358050U,
-      3334271071U,
-      3263032808U,
-      3476998961U,
-      3422541446U,
-      3585640067U,
-      3514407732U,
-      3694837229U,
-      3640369242U,
-      1762451694U,
-      1842216281U,
-      1619975040U,
-      1682949687U,
-      2047383090U,
-      2127137669U,
-      1938468188U,
-      2001449195U,
-      1325665622U,
-      1271206113U,
-      1183200824U,
-      1111960463U,
-      1543535498U,
-      1489069629U,
-      1434599652U,
-      1363369299U,
-      622672798U,
-      568075817U,
-      748617968U,
-      677256519U,
-      907627842U,
-      853037301U,
-      1067152940U,
-      995781531U,
-      51762726U,
-      131386257U,
-      177728840U,
-      240578815U,
-      269590778U,
-      349224269U,
-      429104020U,
-      491947555U,
-      4046411278U,
-      4126034873U,
-      4172115296U,
-      4234965207U,
-      3794477266U,
-      3874110821U,
-      3953728444U,
-      4016571915U,
-      3609705398U,
-      3555108353U,
-      3735388376U,
-      3664026991U,
-      3290680682U,
-      3236090077U,
-      3449943556U,
-      3378572211U,
-      3174993278U,
-      3120533705U,
-      3032266256U,
-      2961025959U,
-      2923101090U,
-      2868635157U,
-      2813903052U,
-      2742672763U,
-      2604032198U,
-      2683796849U,
-      2461293480U,
-      2524268063U,
-      2284983834U,
-      2364738477U,
-      2175806836U,
-      2238787779U,
-      1569362073U,
-      1498123566U,
-      1409854455U,
-      1355396672U,
-      1317987909U,
-      1246755826U,
-      1192025387U,
-      1137557660U,
-      2072149281U,
-      2135122070U,
-      1912620623U,
-      1992383480U,
-      1753615357U,
-      1816598090U,
-      1627664531U,
-      1707420964U,
-      295390185U,
-      358241886U,
-      404320391U,
-      483945776U,
-      43990325U,
-      106832002U,
-      186451547U,
-      266083308U,
-      932423249U,
-      861060070U,
-      1041341759U,
-      986742920U,
-      613929101U,
-      542559546U,
-      756411363U,
-      701822548U,
-      3316196985U,
-      3244833742U,
-      3425377559U,
-      3370778784U,
-      3601682597U,
-      3530312978U,
-      3744426955U,
-      3689838204U,
-      3819031489U,
-      3881883254U,
-      3928223919U,
-      4007849240U,
-      4037393693U,
-      4100235434U,
-      4180117107U,
-      4259748804U,
-      2310601993U,
-      2373574846U,
-      2151335527U,
-      2231098320U,
-      2596047829U,
-      2659030626U,
-      2470359227U,
-      2550115596U,
-      2947551409U,
-      2876312838U,
-      2788305887U,
-      2733848168U,
-      3165939309U,
-      3094707162U,
-      3040238851U,
-      2985771188U
-    };
-    private int globalCrc;
-
-    public StrangeCRC() => this.Reset();
-
-    public void Reset() => this.globalCrc = -1;
-
-    public long Value => (long) ~this.globalCrc;
-
-    public void Update(int value)
-    {
-      int index = this.globalCrc >> 24 ^ value;
-      if (index < 0)
-        index = 256 + index;
-      this.globalCrc = (int) ((long) (this.globalCrc << 8) ^ (long) StrangeCRC.crc32Table[index]);
-    }
-
-    public void Update(byte[] buffer)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      this.Update(buffer, 0, buffer.Length);
-    }
-
-    public void Update(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "cannot be less than zero");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "cannot be less than zero");
-      if (offset + count > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      for (int index = 0; index < count; ++index)
-        this.Update((int) buffer[offset++]);
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/DirectoryEventArgs.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/DirectoryEventArgs.cs
deleted file mode 100644
index e3b2085..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/DirectoryEventArgs.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class DirectoryEventArgs : ScanEventArgs
-  {
-    private bool hasMatchingFiles_;
-
-    public DirectoryEventArgs(string name, bool hasMatchingFiles)
-      : base(name)
-    {
-      this.hasMatchingFiles_ = hasMatchingFiles;
-    }
-
-    public bool HasMatchingFiles => this.hasMatchingFiles_;
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/DirectoryFailureDelegate.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/DirectoryFailureDelegate.cs
deleted file mode 100644
index 74d404b..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/DirectoryFailureDelegate.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public delegate void DirectoryFailureDelegate(object sender, ScanFailureEventArgs e);
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/ExtendedPathFilter.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/ExtendedPathFilter.cs
deleted file mode 100644
index 4910a60..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/ExtendedPathFilter.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class ExtendedPathFilter : PathFilter
-  {
-    private long minSize_;
-    private long maxSize_ = long.MaxValue;
-    private DateTime minDate_ = DateTime.MinValue;
-    private DateTime maxDate_ = DateTime.MaxValue;
-
-    public ExtendedPathFilter(string filter, long minSize, long maxSize)
-      : base(filter)
-    {
-      this.MinSize = minSize;
-      this.MaxSize = maxSize;
-    }
-
-    public ExtendedPathFilter(string filter, DateTime minDate, DateTime maxDate)
-      : base(filter)
-    {
-      this.MinDate = minDate;
-      this.MaxDate = maxDate;
-    }
-
-    public ExtendedPathFilter(
-      string filter,
-      long minSize,
-      long maxSize,
-      DateTime minDate,
-      DateTime maxDate)
-      : base(filter)
-    {
-      this.MinSize = minSize;
-      this.MaxSize = maxSize;
-      this.MinDate = minDate;
-      this.MaxDate = maxDate;
-    }
-
-    public override bool IsMatch(string name)
-    {
-      bool flag = base.IsMatch(name);
-      if (flag)
-      {
-        FileInfo fileInfo = new FileInfo(name);
-        flag = this.MinSize <= fileInfo.Length && this.MaxSize >= fileInfo.Length && this.MinDate <= fileInfo.LastWriteTime && this.MaxDate >= fileInfo.LastWriteTime;
-      }
-      return flag;
-    }
-
-    public long MinSize
-    {
-      get => this.minSize_;
-      set
-      {
-        this.minSize_ = value >= 0L && this.maxSize_ >= value ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public long MaxSize
-    {
-      get => this.maxSize_;
-      set
-      {
-        this.maxSize_ = value >= 0L && this.minSize_ <= value ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public DateTime MinDate
-    {
-      get => this.minDate_;
-      set
-      {
-        this.minDate_ = !(value > this.maxDate_) ? value : throw new ArgumentException("Exceeds MaxDate", nameof (value));
-      }
-    }
-
-    public DateTime MaxDate
-    {
-      get => this.maxDate_;
-      set
-      {
-        this.maxDate_ = !(this.minDate_ > value) ? value : throw new ArgumentException("Exceeds MinDate", nameof (value));
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/FileFailureDelegate.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/FileFailureDelegate.cs
deleted file mode 100644
index 5efc7e7..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/FileFailureDelegate.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public delegate void FileFailureDelegate(object sender, ScanFailureEventArgs e);
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/FileSystemScanner.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/FileSystemScanner.cs
deleted file mode 100644
index a95e269..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/FileSystemScanner.cs
+++ /dev/null
@@ -1,151 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class FileSystemScanner
-  {
-    public ProcessDirectoryDelegate ProcessDirectory;
-    public ProcessFileDelegate ProcessFile;
-    public DirectoryFailureDelegate DirectoryFailure;
-    public FileFailureDelegate FileFailure;
-    private IScanFilter fileFilter_;
-    private IScanFilter directoryFilter_;
-    private bool alive_;
-
-    public FileSystemScanner(string filter)
-    {
-      this.fileFilter_ = (IScanFilter) new PathFilter(filter);
-    }
-
-    public FileSystemScanner(string fileFilter, string directoryFilter)
-    {
-      this.fileFilter_ = (IScanFilter) new PathFilter(fileFilter);
-      this.directoryFilter_ = (IScanFilter) new PathFilter(directoryFilter);
-    }
-
-    public FileSystemScanner(IScanFilter fileFilter) => this.fileFilter_ = fileFilter;
-
-    public FileSystemScanner(IScanFilter fileFilter, IScanFilter directoryFilter)
-    {
-      this.fileFilter_ = fileFilter;
-      this.directoryFilter_ = directoryFilter;
-    }
-
-    public void OnDirectoryFailure(string directory, Exception e)
-    {
-      if (this.DirectoryFailure == null)
-      {
-        this.alive_ = false;
-      }
-      else
-      {
-        ScanFailureEventArgs e1 = new ScanFailureEventArgs(directory, e);
-        this.DirectoryFailure((object) this, e1);
-        this.alive_ = e1.ContinueRunning;
-      }
-    }
-
-    public void OnFileFailure(string file, Exception e)
-    {
-      if (this.FileFailure == null)
-      {
-        this.alive_ = false;
-      }
-      else
-      {
-        ScanFailureEventArgs e1 = new ScanFailureEventArgs(file, e);
-        this.FileFailure((object) this, e1);
-        this.alive_ = e1.ContinueRunning;
-      }
-    }
-
-    public void OnProcessFile(string file)
-    {
-      if (this.ProcessFile == null)
-        return;
-      ScanEventArgs e = new ScanEventArgs(file);
-      this.ProcessFile((object) this, e);
-      this.alive_ = e.ContinueRunning;
-    }
-
-    public void OnProcessDirectory(string directory, bool hasMatchingFiles)
-    {
-      if (this.ProcessDirectory == null)
-        return;
-      DirectoryEventArgs e = new DirectoryEventArgs(directory, hasMatchingFiles);
-      this.ProcessDirectory((object) this, e);
-      this.alive_ = e.ContinueRunning;
-    }
-
-    public void Scan(string directory, bool recurse)
-    {
-      this.alive_ = true;
-      this.ScanDir(directory, recurse);
-    }
-
-    private void ScanDir(string directory, bool recurse)
-    {
-      try
-      {
-        string[] files = Directory.GetFiles(directory);
-        bool hasMatchingFiles = false;
-        for (int index = 0; index < files.Length; ++index)
-        {
-          if (!this.fileFilter_.IsMatch(files[index]))
-            files[index] = (string) null;
-          else
-            hasMatchingFiles = true;
-        }
-        this.OnProcessDirectory(directory, hasMatchingFiles);
-        if (this.alive_)
-        {
-          if (hasMatchingFiles)
-          {
-            foreach (string file in files)
-            {
-              try
-              {
-                if (file != null)
-                {
-                  this.OnProcessFile(file);
-                  if (!this.alive_)
-                    break;
-                }
-              }
-              catch (Exception ex)
-              {
-                this.OnFileFailure(file, ex);
-              }
-            }
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        this.OnDirectoryFailure(directory, ex);
-      }
-      if (!this.alive_)
-        return;
-      if (!recurse)
-        return;
-      try
-      {
-        foreach (string directory1 in Directory.GetDirectories(directory))
-        {
-          if (this.directoryFilter_ == null || this.directoryFilter_.IsMatch(directory1))
-          {
-            this.ScanDir(directory1, true);
-            if (!this.alive_)
-              break;
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        this.OnDirectoryFailure(directory, ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/INameTransform.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/INameTransform.cs
deleted file mode 100644
index 737bb8e..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/INameTransform.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public interface INameTransform
-  {
-    string TransformFile(string name);
-
-    string TransformDirectory(string name);
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/IScanFilter.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/IScanFilter.cs
deleted file mode 100644
index 4187819..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/IScanFilter.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public interface IScanFilter
-  {
-    bool IsMatch(string name);
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/NameAndSizeFilter.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/NameAndSizeFilter.cs
deleted file mode 100644
index aee51f6..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/NameAndSizeFilter.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  [Obsolete("Use ExtendedPathFilter instead")]
-  public class NameAndSizeFilter : PathFilter
-  {
-    private long minSize_;
-    private long maxSize_ = long.MaxValue;
-
-    public NameAndSizeFilter(string filter, long minSize, long maxSize)
-      : base(filter)
-    {
-      this.MinSize = minSize;
-      this.MaxSize = maxSize;
-    }
-
-    public override bool IsMatch(string name)
-    {
-      bool flag = base.IsMatch(name);
-      if (flag)
-      {
-        long length = new FileInfo(name).Length;
-        flag = this.MinSize <= length && this.MaxSize >= length;
-      }
-      return flag;
-    }
-
-    public long MinSize
-    {
-      get => this.minSize_;
-      set
-      {
-        this.minSize_ = value >= 0L && this.maxSize_ >= value ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public long MaxSize
-    {
-      get => this.maxSize_;
-      set
-      {
-        this.maxSize_ = value >= 0L && this.minSize_ <= value ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/NameFilter.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/NameFilter.cs
deleted file mode 100644
index ec66dee..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/NameFilter.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-using System;
-using System.Collections;
-using System.Text.RegularExpressions;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class NameFilter : IScanFilter
-  {
-    private string filter_;
-    private ArrayList inclusions_;
-    private ArrayList exclusions_;
-
-    public NameFilter(string filter)
-    {
-      this.filter_ = filter;
-      this.inclusions_ = new ArrayList();
-      this.exclusions_ = new ArrayList();
-      this.Compile();
-    }
-
-    public static bool IsValidExpression(string expression)
-    {
-      bool flag = true;
-      try
-      {
-        Regex regex = new Regex(expression, RegexOptions.IgnoreCase | RegexOptions.Singleline);
-      }
-      catch
-      {
-        flag = false;
-      }
-      return flag;
-    }
-
-    public static bool IsValidFilterExpression(string toTest)
-    {
-      if (toTest == null)
-        throw new ArgumentNullException(nameof (toTest));
-      bool flag = true;
-      try
-      {
-        string[] strArray = toTest.Split(';');
-        for (int index = 0; index < strArray.Length; ++index)
-        {
-          if (strArray[index] != null && strArray[index].Length > 0)
-          {
-            Regex regex = new Regex(strArray[index][0] != '+' ? (strArray[index][0] != '-' ? strArray[index] : strArray[index].Substring(1, strArray[index].Length - 1)) : strArray[index].Substring(1, strArray[index].Length - 1), RegexOptions.IgnoreCase | RegexOptions.Singleline);
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        flag = false;
-      }
-      return flag;
-    }
-
-    public override string ToString() => this.filter_;
-
-    public bool IsIncluded(string name)
-    {
-      bool flag = false;
-      if (this.inclusions_.Count == 0)
-      {
-        flag = true;
-      }
-      else
-      {
-        foreach (Regex inclusion in this.inclusions_)
-        {
-          if (inclusion.IsMatch(name))
-          {
-            flag = true;
-            break;
-          }
-        }
-      }
-      return flag;
-    }
-
-    public bool IsExcluded(string name)
-    {
-      bool flag = false;
-      foreach (Regex exclusion in this.exclusions_)
-      {
-        if (exclusion.IsMatch(name))
-        {
-          flag = true;
-          break;
-        }
-      }
-      return flag;
-    }
-
-    public bool IsMatch(string name) => this.IsIncluded(name) && !this.IsExcluded(name);
-
-    private void Compile()
-    {
-      if (this.filter_ == null)
-        return;
-      string[] strArray = this.filter_.Split(';');
-      for (int index = 0; index < strArray.Length; ++index)
-      {
-        if (strArray[index] != null && strArray[index].Length > 0)
-        {
-          bool flag = strArray[index][0] != '-';
-          string pattern = strArray[index][0] != '+' ? (strArray[index][0] != '-' ? strArray[index] : strArray[index].Substring(1, strArray[index].Length - 1)) : strArray[index].Substring(1, strArray[index].Length - 1);
-          if (flag)
-            this.inclusions_.Add((object) new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
-          else
-            this.exclusions_.Add((object) new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/PathFilter.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/PathFilter.cs
deleted file mode 100644
index 16a32e8..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/PathFilter.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class PathFilter : IScanFilter
-  {
-    private NameFilter nameFilter_;
-
-    public PathFilter(string filter) => this.nameFilter_ = new NameFilter(filter);
-
-    public virtual bool IsMatch(string name)
-    {
-      bool flag = false;
-      if (name != null)
-        flag = this.nameFilter_.IsMatch(name.Length > 0 ? Path.GetFullPath(name) : "");
-      return flag;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/ProcessDirectoryDelegate.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/ProcessDirectoryDelegate.cs
deleted file mode 100644
index c35e903..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/ProcessDirectoryDelegate.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public delegate void ProcessDirectoryDelegate(object sender, DirectoryEventArgs e);
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/ProcessFileDelegate.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/ProcessFileDelegate.cs
deleted file mode 100644
index dfd684b..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/ProcessFileDelegate.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public delegate void ProcessFileDelegate(object sender, ScanEventArgs e);
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/ScanEventArgs.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/ScanEventArgs.cs
deleted file mode 100644
index 1194b82..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/ScanEventArgs.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class ScanEventArgs : EventArgs
-  {
-    private string name_;
-    private bool continueRunning_ = true;
-
-    public ScanEventArgs(string name) => this.name_ = name;
-
-    public string Name => this.name_;
-
-    public bool ContinueRunning
-    {
-      get => this.continueRunning_;
-      set => this.continueRunning_ = value;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/ScanFailureEventArgs.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/ScanFailureEventArgs.cs
deleted file mode 100644
index 43a0804..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/ScanFailureEventArgs.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class ScanFailureEventArgs
-  {
-    private string name_;
-    private Exception exception_;
-    private bool continueRunning_;
-
-    public ScanFailureEventArgs(string name, Exception e)
-    {
-      this.name_ = name;
-      this.exception_ = e;
-      this.continueRunning_ = true;
-    }
-
-    public string Name => this.name_;
-
-    public Exception Exception => this.exception_;
-
-    public bool ContinueRunning
-    {
-      get => this.continueRunning_;
-      set => this.continueRunning_ = value;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Core/StreamUtils.cs b/MSHALTester/ICSharpCode/SharpZipLib/Core/StreamUtils.cs
deleted file mode 100644
index c750a95..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Core/StreamUtils.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public sealed class StreamUtils
-  {
-    public static void ReadFully(Stream stream, byte[] buffer)
-    {
-      StreamUtils.ReadFully(stream, buffer, 0, buffer.Length);
-    }
-
-    public static void ReadFully(Stream stream, byte[] buffer, int offset, int count)
-    {
-      if (stream == null)
-        throw new ArgumentNullException(nameof (stream));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0 || offset > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      if (count < 0 || offset + count > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      int num;
-      for (; count > 0; count -= num)
-      {
-        num = stream.Read(buffer, offset, count);
-        if (num <= 0)
-          throw new EndOfStreamException();
-        offset += num;
-      }
-    }
-
-    public static void Copy(Stream source, Stream destination, byte[] buffer)
-    {
-      if (source == null)
-        throw new ArgumentNullException(nameof (source));
-      if (destination == null)
-        throw new ArgumentNullException(nameof (destination));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (buffer.Length < 128)
-        throw new ArgumentException("Buffer is too small", nameof (buffer));
-      bool flag = true;
-      while (flag)
-      {
-        int count = source.Read(buffer, 0, buffer.Length);
-        if (count > 0)
-        {
-          destination.Write(buffer, 0, count);
-        }
-        else
-        {
-          destination.Flush();
-          flag = false;
-        }
-      }
-    }
-
-    private StreamUtils()
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassic.cs b/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassic.cs
deleted file mode 100644
index a1cf9f4..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassic.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-using System.Security.Cryptography;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  public abstract class PkzipClassic : SymmetricAlgorithm
-  {
-    public static byte[] GenerateKeys(byte[] seed)
-    {
-      if (seed == null)
-        throw new ArgumentNullException(nameof (seed));
-      if (seed.Length == 0)
-        throw new ArgumentException("Length is zero", nameof (seed));
-      uint[] numArray = new uint[3]
-      {
-        305419896U,
-        591751049U,
-        878082192U
-      };
-      for (int index = 0; index < seed.Length; ++index)
-      {
-        numArray[0] = Crc32.ComputeCrc32(numArray[0], seed[index]);
-        numArray[1] = numArray[1] + (uint) (byte) numArray[0];
-        numArray[1] = (uint) ((int) numArray[1] * 134775813 + 1);
-        numArray[2] = Crc32.ComputeCrc32(numArray[2], (byte) (numArray[1] >> 24));
-      }
-      return new byte[12]
-      {
-        (byte) (numArray[0] & (uint) byte.MaxValue),
-        (byte) (numArray[0] >> 8 & (uint) byte.MaxValue),
-        (byte) (numArray[0] >> 16 & (uint) byte.MaxValue),
-        (byte) (numArray[0] >> 24 & (uint) byte.MaxValue),
-        (byte) (numArray[1] & (uint) byte.MaxValue),
-        (byte) (numArray[1] >> 8 & (uint) byte.MaxValue),
-        (byte) (numArray[1] >> 16 & (uint) byte.MaxValue),
-        (byte) (numArray[1] >> 24 & (uint) byte.MaxValue),
-        (byte) (numArray[2] & (uint) byte.MaxValue),
-        (byte) (numArray[2] >> 8 & (uint) byte.MaxValue),
-        (byte) (numArray[2] >> 16 & (uint) byte.MaxValue),
-        (byte) (numArray[2] >> 24 & (uint) byte.MaxValue)
-      };
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicCryptoBase.cs b/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicCryptoBase.cs
deleted file mode 100644
index c5c66ab..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicCryptoBase.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  internal class PkzipClassicCryptoBase
-  {
-    private uint[] keys;
-
-    protected byte TransformByte()
-    {
-      uint num = (uint) ((int) this.keys[2] & (int) ushort.MaxValue | 2);
-      return (byte) (num * (num ^ 1U) >> 8);
-    }
-
-    protected void SetKeys(byte[] keyData)
-    {
-      if (keyData == null)
-        throw new ArgumentNullException(nameof (keyData));
-      if (keyData.Length != 12)
-        throw new InvalidOperationException("Key length is not valid");
-      this.keys = new uint[3];
-      this.keys[0] = (uint) ((int) keyData[3] << 24 | (int) keyData[2] << 16 | (int) keyData[1] << 8) | (uint) keyData[0];
-      this.keys[1] = (uint) ((int) keyData[7] << 24 | (int) keyData[6] << 16 | (int) keyData[5] << 8) | (uint) keyData[4];
-      this.keys[2] = (uint) ((int) keyData[11] << 24 | (int) keyData[10] << 16 | (int) keyData[9] << 8) | (uint) keyData[8];
-    }
-
-    protected void UpdateKeys(byte ch)
-    {
-      this.keys[0] = Crc32.ComputeCrc32(this.keys[0], ch);
-      this.keys[1] = this.keys[1] + (uint) (byte) this.keys[0];
-      this.keys[1] = (uint) ((int) this.keys[1] * 134775813 + 1);
-      this.keys[2] = Crc32.ComputeCrc32(this.keys[2], (byte) (this.keys[1] >> 24));
-    }
-
-    protected void Reset()
-    {
-      this.keys[0] = 0U;
-      this.keys[1] = 0U;
-      this.keys[2] = 0U;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicDecryptCryptoTransform.cs b/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicDecryptCryptoTransform.cs
deleted file mode 100644
index 1ace87d..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicDecryptCryptoTransform.cs
+++ /dev/null
@@ -1,47 +0,0 @@
-using System;
-using System.Security.Cryptography;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  internal class PkzipClassicDecryptCryptoTransform : 
-    PkzipClassicCryptoBase,
-    ICryptoTransform,
-    IDisposable
-  {
-    internal PkzipClassicDecryptCryptoTransform(byte[] keyBlock) => this.SetKeys(keyBlock);
-
-    public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
-    {
-      byte[] outputBuffer = new byte[inputCount];
-      this.TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, 0);
-      return outputBuffer;
-    }
-
-    public int TransformBlock(
-      byte[] inputBuffer,
-      int inputOffset,
-      int inputCount,
-      byte[] outputBuffer,
-      int outputOffset)
-    {
-      for (int index = inputOffset; index < inputOffset + inputCount; ++index)
-      {
-        byte ch = (byte) ((uint) inputBuffer[index] ^ (uint) this.TransformByte());
-        outputBuffer[outputOffset++] = ch;
-        this.UpdateKeys(ch);
-      }
-      return inputCount;
-    }
-
-    public bool CanReuseTransform => true;
-
-    public int InputBlockSize => 1;
-
-    public int OutputBlockSize => 1;
-
-    public bool CanTransformMultipleBlocks => true;
-
-    public void Dispose() => this.Reset();
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicEncryptCryptoTransform.cs b/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicEncryptCryptoTransform.cs
deleted file mode 100644
index 5ae51f9..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicEncryptCryptoTransform.cs
+++ /dev/null
@@ -1,47 +0,0 @@
-using System;
-using System.Security.Cryptography;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  internal class PkzipClassicEncryptCryptoTransform : 
-    PkzipClassicCryptoBase,
-    ICryptoTransform,
-    IDisposable
-  {
-    internal PkzipClassicEncryptCryptoTransform(byte[] keyBlock) => this.SetKeys(keyBlock);
-
-    public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
-    {
-      byte[] outputBuffer = new byte[inputCount];
-      this.TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, 0);
-      return outputBuffer;
-    }
-
-    public int TransformBlock(
-      byte[] inputBuffer,
-      int inputOffset,
-      int inputCount,
-      byte[] outputBuffer,
-      int outputOffset)
-    {
-      for (int index = inputOffset; index < inputOffset + inputCount; ++index)
-      {
-        byte ch = inputBuffer[index];
-        outputBuffer[outputOffset++] = (byte) ((uint) inputBuffer[index] ^ (uint) this.TransformByte());
-        this.UpdateKeys(ch);
-      }
-      return inputCount;
-    }
-
-    public bool CanReuseTransform => true;
-
-    public int InputBlockSize => 1;
-
-    public int OutputBlockSize => 1;
-
-    public bool CanTransformMultipleBlocks => true;
-
-    public void Dispose() => this.Reset();
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicManaged.cs b/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicManaged.cs
deleted file mode 100644
index 3b1b05f..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Encryption/PkzipClassicManaged.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-using System;
-using System.Security.Cryptography;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  public sealed class PkzipClassicManaged : PkzipClassic
-  {
-    private byte[] key_;
-
-    public override int BlockSize
-    {
-      get => 8;
-      set
-      {
-        if (value != 8)
-          throw new CryptographicException("Block size is invalid");
-      }
-    }
-
-    public override KeySizes[] LegalKeySizes
-    {
-      get => new KeySizes[1]{ new KeySizes(96, 96, 0) };
-    }
-
-    public override void GenerateIV()
-    {
-    }
-
-    public override KeySizes[] LegalBlockSizes
-    {
-      get => new KeySizes[1]{ new KeySizes(8, 8, 0) };
-    }
-
-    public override byte[] Key
-    {
-      get
-      {
-        if (this.key_ == null)
-          this.GenerateKey();
-        return (byte[]) this.key_.Clone();
-      }
-      set
-      {
-        if (value == null)
-          throw new ArgumentNullException(nameof (value));
-        this.key_ = value.Length == 12 ? (byte[]) value.Clone() : throw new CryptographicException("Key size is illegal");
-      }
-    }
-
-    public override void GenerateKey()
-    {
-      this.key_ = new byte[12];
-      new Random().NextBytes(this.key_);
-    }
-
-    public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
-    {
-      this.key_ = rgbKey;
-      return (ICryptoTransform) new PkzipClassicEncryptCryptoTransform(this.Key);
-    }
-
-    public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
-    {
-      this.key_ = rgbKey;
-      return (ICryptoTransform) new PkzipClassicDecryptCryptoTransform(this.Key);
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipConstants.cs b/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipConstants.cs
deleted file mode 100644
index 37892ba..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipConstants.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.GZip
-{
-  public sealed class GZipConstants
-  {
-    public const int GZIP_MAGIC = 8075;
-    public const int FTEXT = 1;
-    public const int FHCRC = 2;
-    public const int FEXTRA = 4;
-    public const int FNAME = 8;
-    public const int FCOMMENT = 16;
-
-    private GZipConstants()
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipException.cs b/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipException.cs
deleted file mode 100644
index 95dedbd..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.GZip
-{
-  [Serializable]
-  public class GZipException : SharpZipBaseException
-  {
-    protected GZipException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public GZipException()
-    {
-    }
-
-    public GZipException(string message)
-      : base(message)
-    {
-    }
-
-    public GZipException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipInputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipInputStream.cs
deleted file mode 100644
index 4ae06ec..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipInputStream.cs
+++ /dev/null
@@ -1,147 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.GZip
-{
-  public class GZipInputStream(Stream baseInputStream, int size) : InflaterInputStream(baseInputStream, new Inflater(true), size)
-  {
-    protected Crc32 crc = new Crc32();
-    protected bool eos;
-    private bool readGZIPHeader;
-
-    public GZipInputStream(Stream baseInputStream)
-      : this(baseInputStream, 4096)
-    {
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (!this.readGZIPHeader)
-        this.ReadHeader();
-      if (this.eos)
-        return 0;
-      int count1 = base.Read(buffer, offset, count);
-      if (count1 > 0)
-        this.crc.Update(buffer, offset, count1);
-      if (this.inf.IsFinished)
-        this.ReadFooter();
-      return count1;
-    }
-
-    private void ReadHeader()
-    {
-      Crc32 crc32 = new Crc32();
-      int num1 = this.baseInputStream.ReadByte();
-      if (num1 < 0)
-        throw new EndOfStreamException("EOS reading GZIP header");
-      crc32.Update(num1);
-      if (num1 != 31)
-        throw new GZipException("Error GZIP header, first magic byte doesn't match");
-      int num2 = this.baseInputStream.ReadByte();
-      if (num2 < 0)
-        throw new EndOfStreamException("EOS reading GZIP header");
-      if (num2 != 139)
-        throw new GZipException("Error GZIP header,  second magic byte doesn't match");
-      crc32.Update(num2);
-      int num3 = this.baseInputStream.ReadByte();
-      if (num3 < 0)
-        throw new EndOfStreamException("EOS reading GZIP header");
-      if (num3 != 8)
-        throw new GZipException("Error GZIP header, data not deflate format");
-      crc32.Update(num3);
-      int num4 = this.baseInputStream.ReadByte();
-      if (num4 < 0)
-        throw new EndOfStreamException("EOS reading GZIP header");
-      crc32.Update(num4);
-      if ((num4 & 208) != 0)
-        throw new GZipException("Reserved flag bits in GZIP header != 0");
-      for (int index = 0; index < 6; ++index)
-      {
-        int num5 = this.baseInputStream.ReadByte();
-        if (num5 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        crc32.Update(num5);
-      }
-      if ((num4 & 4) != 0)
-      {
-        for (int index = 0; index < 2; ++index)
-        {
-          int num6 = this.baseInputStream.ReadByte();
-          if (num6 < 0)
-            throw new EndOfStreamException("EOS reading GZIP header");
-          crc32.Update(num6);
-        }
-        int num7 = this.baseInputStream.ReadByte() >= 0 && this.baseInputStream.ReadByte() >= 0 ? this.baseInputStream.ReadByte() : throw new EndOfStreamException("EOS reading GZIP header");
-        int num8 = this.baseInputStream.ReadByte();
-        if (num7 < 0 || num8 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        crc32.Update(num7);
-        crc32.Update(num8);
-        int num9 = num7 << 8 | num8;
-        for (int index = 0; index < num9; ++index)
-        {
-          int num10 = this.baseInputStream.ReadByte();
-          if (num10 < 0)
-            throw new EndOfStreamException("EOS reading GZIP header");
-          crc32.Update(num10);
-        }
-      }
-      if ((num4 & 8) != 0)
-      {
-        int num11;
-        while ((num11 = this.baseInputStream.ReadByte()) > 0)
-          crc32.Update(num11);
-        if (num11 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        crc32.Update(num11);
-      }
-      if ((num4 & 16) != 0)
-      {
-        int num12;
-        while ((num12 = this.baseInputStream.ReadByte()) > 0)
-          crc32.Update(num12);
-        if (num12 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        crc32.Update(num12);
-      }
-      if ((num4 & 2) != 0)
-      {
-        int num13 = this.baseInputStream.ReadByte();
-        if (num13 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        int num14 = this.baseInputStream.ReadByte();
-        if (num14 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        if ((num13 << 8 | num14) != ((int) crc32.Value & (int) ushort.MaxValue))
-          throw new GZipException("Header CRC value mismatch");
-      }
-      this.readGZIPHeader = true;
-    }
-
-    private void ReadFooter()
-    {
-      byte[] numArray = new byte[8];
-      int length = this.inf.RemainingInput;
-      if (length > 8)
-        length = 8;
-      Array.Copy((Array) this.inputBuffer.RawData, this.inputBuffer.RawLength - this.inf.RemainingInput, (Array) numArray, 0, length);
-      int num1;
-      for (int count = 8 - length; count > 0; count -= num1)
-      {
-        num1 = this.baseInputStream.Read(numArray, 8 - count, count);
-        if (num1 <= 0)
-          throw new EndOfStreamException("EOS reading GZIP footer");
-      }
-      int num2 = (int) numArray[0] & (int) byte.MaxValue | ((int) numArray[1] & (int) byte.MaxValue) << 8 | ((int) numArray[2] & (int) byte.MaxValue) << 16 | (int) numArray[3] << 24;
-      if (num2 != (int) this.crc.Value)
-        throw new GZipException("GZIP crc sum mismatch, theirs \"" + (object) num2 + "\" and ours \"" + (object) (int) this.crc.Value);
-      if ((long) ((int) numArray[4] & (int) byte.MaxValue | ((int) numArray[5] & (int) byte.MaxValue) << 8 | ((int) numArray[6] & (int) byte.MaxValue) << 16 | (int) numArray[7] << 24) != this.inf.TotalOut)
-        throw new GZipException("Number of bytes mismatch in footer");
-      this.eos = true;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipOutputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipOutputStream.cs
deleted file mode 100644
index ebf5932..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/GZip/GZipOutputStream.cs
+++ /dev/null
@@ -1,88 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.GZip
-{
-  public class GZipOutputStream(Stream baseOutputStream, int size) : DeflaterOutputStream(baseOutputStream, new Deflater(-1, true), size)
-  {
-    protected Crc32 crc = new Crc32();
-    private bool headerWritten_;
-
-    public GZipOutputStream(Stream baseOutputStream)
-      : this(baseOutputStream, 4096)
-    {
-    }
-
-    public void SetLevel(int level)
-    {
-      if (level < 1)
-        throw new ArgumentOutOfRangeException(nameof (level));
-      this.def.SetLevel(level);
-    }
-
-    public int GetLevel() => this.def.GetLevel();
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      if (!this.headerWritten_)
-        this.WriteHeader();
-      this.crc.Update(buffer, offset, count);
-      base.Write(buffer, offset, count);
-    }
-
-    public override void Close()
-    {
-      this.Finish();
-      if (!this.IsStreamOwner)
-        return;
-      this.baseOutputStream.Close();
-    }
-
-    public override void Finish()
-    {
-      if (!this.headerWritten_)
-        this.WriteHeader();
-      base.Finish();
-      int totalIn = this.def.TotalIn;
-      int num = (int) (this.crc.Value & (long) uint.MaxValue);
-      byte[] buffer = new byte[8]
-      {
-        (byte) num,
-        (byte) (num >> 8),
-        (byte) (num >> 16),
-        (byte) (num >> 24),
-        (byte) totalIn,
-        (byte) (totalIn >> 8),
-        (byte) (totalIn >> 16),
-        (byte) (totalIn >> 24)
-      };
-      this.baseOutputStream.Write(buffer, 0, buffer.Length);
-    }
-
-    private void WriteHeader()
-    {
-      if (this.headerWritten_)
-        return;
-      this.headerWritten_ = true;
-      int num = (int) ((DateTime.Now.Ticks - new DateTime(1970, 1, 1).Ticks) / 10000000L);
-      byte[] buffer = new byte[10]
-      {
-        (byte) 31,
-        (byte) 139,
-        (byte) 8,
-        (byte) 0,
-        (byte) num,
-        (byte) (num >> 8),
-        (byte) (num >> 16),
-        (byte) (num >> 24),
-        (byte) 0,
-        byte.MaxValue
-      };
-      this.baseOutputStream.Write(buffer, 0, buffer.Length);
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/SharpZipBaseException.cs b/MSHALTester/ICSharpCode/SharpZipLib/SharpZipBaseException.cs
deleted file mode 100644
index efcd8ab..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/SharpZipBaseException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib
-{
-  [Serializable]
-  public class SharpZipBaseException : ApplicationException
-  {
-    protected SharpZipBaseException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public SharpZipBaseException()
-    {
-    }
-
-    public SharpZipBaseException(string message)
-      : base(message)
-    {
-    }
-
-    public SharpZipBaseException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/InvalidHeaderException.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/InvalidHeaderException.cs
deleted file mode 100644
index 732ddfb..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/InvalidHeaderException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  [Serializable]
-  public class InvalidHeaderException : TarException
-  {
-    protected InvalidHeaderException(SerializationInfo information, StreamingContext context)
-      : base(information, context)
-    {
-    }
-
-    public InvalidHeaderException()
-    {
-    }
-
-    public InvalidHeaderException(string message)
-      : base(message)
-    {
-    }
-
-    public InvalidHeaderException(string message, Exception exception)
-      : base(message, exception)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/ProgressMessageHandler.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/ProgressMessageHandler.cs
deleted file mode 100644
index 1444f7a..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/ProgressMessageHandler.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public delegate void ProgressMessageHandler(TarArchive archive, TarEntry entry, string message);
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarArchive.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarArchive.cs
deleted file mode 100644
index e2a9ffe..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarArchive.cs
+++ /dev/null
@@ -1,467 +0,0 @@
-using System;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarArchive : IDisposable
-  {
-    private bool keepOldFiles;
-    private bool asciiTranslate;
-    private int userId;
-    private string userName = string.Empty;
-    private int groupId;
-    private string groupName = string.Empty;
-    private string rootPath;
-    private string pathPrefix;
-    private bool applyUserInfoOverrides;
-    private TarInputStream tarIn;
-    private TarOutputStream tarOut;
-    private bool isDisposed;
-
-    public event ProgressMessageHandler ProgressMessageEvent;
-
-    protected virtual void OnProgressMessageEvent(TarEntry entry, string message)
-    {
-      if (this.ProgressMessageEvent == null)
-        return;
-      this.ProgressMessageEvent(this, entry, message);
-    }
-
-    protected TarArchive()
-    {
-    }
-
-    protected TarArchive(TarInputStream stream)
-    {
-      this.tarIn = stream != null ? stream : throw new ArgumentNullException(nameof (stream));
-    }
-
-    protected TarArchive(TarOutputStream stream)
-    {
-      this.tarOut = stream != null ? stream : throw new ArgumentNullException(nameof (stream));
-    }
-
-    public static TarArchive CreateInputTarArchive(Stream inputStream)
-    {
-      return inputStream != null ? TarArchive.CreateInputTarArchive(inputStream, 20) : throw new ArgumentNullException(nameof (inputStream));
-    }
-
-    public static TarArchive CreateInputTarArchive(Stream inputStream, int blockFactor)
-    {
-      return inputStream != null ? new TarArchive(new TarInputStream(inputStream, blockFactor)) : throw new ArgumentNullException(nameof (inputStream));
-    }
-
-    public static TarArchive CreateOutputTarArchive(Stream outputStream)
-    {
-      return outputStream != null ? TarArchive.CreateOutputTarArchive(outputStream, 20) : throw new ArgumentNullException(nameof (outputStream));
-    }
-
-    public static TarArchive CreateOutputTarArchive(Stream outputStream, int blockFactor)
-    {
-      return outputStream != null ? new TarArchive(new TarOutputStream(outputStream, blockFactor)) : throw new ArgumentNullException(nameof (outputStream));
-    }
-
-    public void SetKeepOldFiles(bool keepOldFiles)
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      this.keepOldFiles = keepOldFiles;
-    }
-
-    public bool AsciiTranslate
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.asciiTranslate;
-      }
-      set
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        this.asciiTranslate = value;
-      }
-    }
-
-    [Obsolete("Use the AsciiTranslate property")]
-    public void SetAsciiTranslation(bool asciiTranslate)
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      this.asciiTranslate = asciiTranslate;
-    }
-
-    public string PathPrefix
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.pathPrefix;
-      }
-      set
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        this.pathPrefix = value;
-      }
-    }
-
-    public string RootPath
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.rootPath;
-      }
-      set
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        this.rootPath = value;
-      }
-    }
-
-    public void SetUserInfo(int userId, string userName, int groupId, string groupName)
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      this.userId = userId;
-      this.userName = userName;
-      this.groupId = groupId;
-      this.groupName = groupName;
-      this.applyUserInfoOverrides = true;
-    }
-
-    public bool ApplyUserInfoOverrides
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.applyUserInfoOverrides;
-      }
-      set
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        this.applyUserInfoOverrides = value;
-      }
-    }
-
-    public int UserId
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.userId;
-      }
-    }
-
-    public string UserName
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.userName;
-      }
-    }
-
-    public int GroupId
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.groupId;
-      }
-    }
-
-    public string GroupName
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.groupName;
-      }
-    }
-
-    public int RecordSize
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        if (this.tarIn != null)
-          return this.tarIn.RecordSize;
-        return this.tarOut != null ? this.tarOut.RecordSize : 10240;
-      }
-    }
-
-    [Obsolete("Use Close instead")]
-    public void CloseArchive() => this.Close();
-
-    public void ListContents()
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      while (true)
-      {
-        TarEntry nextEntry = this.tarIn.GetNextEntry();
-        if (nextEntry != null)
-          this.OnProgressMessageEvent(nextEntry, (string) null);
-        else
-          break;
-      }
-    }
-
-    public void ExtractContents(string destinationDirectory)
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      while (true)
-      {
-        TarEntry nextEntry = this.tarIn.GetNextEntry();
-        if (nextEntry != null)
-          this.ExtractEntry(destinationDirectory, nextEntry);
-        else
-          break;
-      }
-    }
-
-    private void ExtractEntry(string destDir, TarEntry entry)
-    {
-      this.OnProgressMessageEvent(entry, (string) null);
-      string path = entry.Name;
-      if (Path.IsPathRooted(path))
-        path = path.Substring(Path.GetPathRoot(path).Length);
-      string path2 = path.Replace('/', Path.DirectorySeparatorChar);
-      string str1 = Path.Combine(destDir, path2);
-      if (entry.IsDirectory)
-      {
-        TarArchive.EnsureDirectoryExists(str1);
-      }
-      else
-      {
-        TarArchive.EnsureDirectoryExists(Path.GetDirectoryName(str1));
-        bool flag1 = true;
-        FileInfo fileInfo = new FileInfo(str1);
-        if (fileInfo.Exists)
-        {
-          if (this.keepOldFiles)
-          {
-            this.OnProgressMessageEvent(entry, "Destination file already exists");
-            flag1 = false;
-          }
-          else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != (FileAttributes) 0)
-          {
-            this.OnProgressMessageEvent(entry, "Destination file already exists, and is read-only");
-            flag1 = false;
-          }
-        }
-        if (!flag1)
-          return;
-        bool flag2 = false;
-        Stream stream = (Stream) File.Create(str1);
-        if (this.asciiTranslate)
-          flag2 = !TarArchive.IsBinary(str1);
-        StreamWriter streamWriter = (StreamWriter) null;
-        if (flag2)
-          streamWriter = new StreamWriter(stream);
-        byte[] numArray = new byte[32768];
-label_15:
-        int count;
-        while (true)
-        {
-          count = this.tarIn.Read(numArray, 0, numArray.Length);
-          if (count > 0)
-          {
-            if (!flag2)
-              stream.Write(numArray, 0, count);
-            else
-              break;
-          }
-          else
-            goto label_24;
-        }
-        int index1 = 0;
-        for (int index2 = 0; index2 < count; ++index2)
-        {
-          if (numArray[index2] == (byte) 10)
-          {
-            string str2 = Encoding.ASCII.GetString(numArray, index1, index2 - index1);
-            streamWriter.WriteLine(str2);
-            index1 = index2 + 1;
-          }
-        }
-        goto label_15;
-label_24:
-        if (flag2)
-          streamWriter.Close();
-        else
-          stream.Close();
-      }
-    }
-
-    public void WriteEntry(TarEntry sourceEntry, bool recurse)
-    {
-      if (sourceEntry == null)
-        throw new ArgumentNullException(nameof (sourceEntry));
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      try
-      {
-        if (recurse)
-          TarHeader.SetValueDefaults(sourceEntry.UserId, sourceEntry.UserName, sourceEntry.GroupId, sourceEntry.GroupName);
-        this.InternalWriteEntry(sourceEntry, recurse);
-      }
-      finally
-      {
-        if (recurse)
-          TarHeader.RestoreSetValues();
-      }
-    }
-
-    private void InternalWriteEntry(TarEntry sourceEntry, bool recurse)
-    {
-      string str1 = (string) null;
-      string str2 = sourceEntry.File;
-      TarEntry entry = (TarEntry) sourceEntry.Clone();
-      if (this.applyUserInfoOverrides)
-      {
-        entry.GroupId = this.groupId;
-        entry.GroupName = this.groupName;
-        entry.UserId = this.userId;
-        entry.UserName = this.userName;
-      }
-      this.OnProgressMessageEvent(entry, (string) null);
-      if (this.asciiTranslate && !entry.IsDirectory && !TarArchive.IsBinary(str2))
-      {
-        str1 = Path.GetTempFileName();
-        using (StreamReader streamReader = File.OpenText(str2))
-        {
-          using (Stream stream = (Stream) File.Create(str1))
-          {
-            while (true)
-            {
-              string s = streamReader.ReadLine();
-              if (s != null)
-              {
-                byte[] bytes = Encoding.ASCII.GetBytes(s);
-                stream.Write(bytes, 0, bytes.Length);
-                stream.WriteByte((byte) 10);
-              }
-              else
-                break;
-            }
-            stream.Flush();
-          }
-        }
-        entry.Size = new FileInfo(str1).Length;
-        str2 = str1;
-      }
-      string str3 = (string) null;
-      if (this.rootPath != null && entry.Name.StartsWith(this.rootPath))
-        str3 = entry.Name.Substring(this.rootPath.Length + 1);
-      if (this.pathPrefix != null)
-        str3 = str3 == null ? this.pathPrefix + "/" + entry.Name : this.pathPrefix + "/" + str3;
-      if (str3 != null)
-        entry.Name = str3;
-      this.tarOut.PutNextEntry(entry);
-      if (entry.IsDirectory)
-      {
-        if (!recurse)
-          return;
-        foreach (TarEntry directoryEntry in entry.GetDirectoryEntries())
-          this.InternalWriteEntry(directoryEntry, recurse);
-      }
-      else
-      {
-        using (Stream stream = (Stream) File.OpenRead(str2))
-        {
-          int num = 0;
-          byte[] buffer = new byte[32768];
-          while (true)
-          {
-            int count = stream.Read(buffer, 0, buffer.Length);
-            if (count > 0)
-            {
-              this.tarOut.Write(buffer, 0, count);
-              num += count;
-            }
-            else
-              break;
-          }
-        }
-        if (str1 != null && str1.Length > 0)
-          File.Delete(str1);
-        this.tarOut.CloseEntry();
-      }
-    }
-
-    protected virtual void Dispose(bool disposing)
-    {
-      if (this.isDisposed)
-        return;
-      this.isDisposed = true;
-      if (!disposing)
-        return;
-      if (this.tarOut != null)
-      {
-        this.tarOut.Flush();
-        this.tarOut.Close();
-      }
-      if (this.tarIn == null)
-        return;
-      this.tarIn.Close();
-    }
-
-    public virtual void Close()
-    {
-      this.Dispose(true);
-      GC.SuppressFinalize((object) this);
-    }
-
-    ~TarArchive() => this.Dispose(false);
-
-    void IDisposable.Dispose() => this.Close();
-
-    private static void EnsureDirectoryExists(string directoryName)
-    {
-      if (Directory.Exists(directoryName))
-        return;
-      try
-      {
-        Directory.CreateDirectory(directoryName);
-      }
-      catch (Exception ex)
-      {
-        throw new TarException("Exception creating directory '" + directoryName + "', " + ex.Message, ex);
-      }
-    }
-
-    private static bool IsBinary(string filename)
-    {
-      using (FileStream fileStream = File.OpenRead(filename))
-      {
-        int count = Math.Min(4096, (int) fileStream.Length);
-        byte[] buffer = new byte[count];
-        int num1 = fileStream.Read(buffer, 0, count);
-        for (int index = 0; index < num1; ++index)
-        {
-          byte num2 = buffer[index];
-          if (num2 < (byte) 8 || num2 > (byte) 13 && num2 < (byte) 32 || num2 == byte.MaxValue)
-            return true;
-        }
-      }
-      return false;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarBuffer.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarBuffer.cs
deleted file mode 100644
index 73800f9..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarBuffer.cs
+++ /dev/null
@@ -1,221 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarBuffer
-  {
-    public const int BlockSize = 512;
-    public const int DefaultBlockFactor = 20;
-    public const int DefaultRecordSize = 10240;
-    private Stream inputStream;
-    private Stream outputStream;
-    private byte[] recordBuffer;
-    private int currentBlockIndex;
-    private int currentRecordIndex;
-    private int recordSize = 10240;
-    private int blockFactor = 20;
-
-    public int RecordSize => this.recordSize;
-
-    [Obsolete("Use RecordSize property instead")]
-    public int GetRecordSize() => this.recordSize;
-
-    public int BlockFactor => this.blockFactor;
-
-    [Obsolete("Use BlockFactor property instead")]
-    public int GetBlockFactor() => this.blockFactor;
-
-    protected TarBuffer()
-    {
-    }
-
-    public static TarBuffer CreateInputTarBuffer(Stream inputStream)
-    {
-      return inputStream != null ? TarBuffer.CreateInputTarBuffer(inputStream, 20) : throw new ArgumentNullException(nameof (inputStream));
-    }
-
-    public static TarBuffer CreateInputTarBuffer(Stream inputStream, int blockFactor)
-    {
-      if (inputStream == null)
-        throw new ArgumentNullException(nameof (inputStream));
-      if (blockFactor <= 0)
-        throw new ArgumentOutOfRangeException(nameof (blockFactor), "Factor cannot be negative");
-      TarBuffer inputTarBuffer = new TarBuffer();
-      inputTarBuffer.inputStream = inputStream;
-      inputTarBuffer.outputStream = (Stream) null;
-      inputTarBuffer.Initialize(blockFactor);
-      return inputTarBuffer;
-    }
-
-    public static TarBuffer CreateOutputTarBuffer(Stream outputStream)
-    {
-      return outputStream != null ? TarBuffer.CreateOutputTarBuffer(outputStream, 20) : throw new ArgumentNullException(nameof (outputStream));
-    }
-
-    public static TarBuffer CreateOutputTarBuffer(Stream outputStream, int blockFactor)
-    {
-      if (outputStream == null)
-        throw new ArgumentNullException(nameof (outputStream));
-      if (blockFactor <= 0)
-        throw new ArgumentOutOfRangeException(nameof (blockFactor), "Factor cannot be negative");
-      TarBuffer outputTarBuffer = new TarBuffer();
-      outputTarBuffer.inputStream = (Stream) null;
-      outputTarBuffer.outputStream = outputStream;
-      outputTarBuffer.Initialize(blockFactor);
-      return outputTarBuffer;
-    }
-
-    private void Initialize(int blockFactor)
-    {
-      this.blockFactor = blockFactor;
-      this.recordSize = blockFactor * 512;
-      this.recordBuffer = new byte[this.RecordSize];
-      if (this.inputStream != null)
-      {
-        this.currentRecordIndex = -1;
-        this.currentBlockIndex = this.BlockFactor;
-      }
-      else
-      {
-        this.currentRecordIndex = 0;
-        this.currentBlockIndex = 0;
-      }
-    }
-
-    public bool IsEOFBlock(byte[] block)
-    {
-      if (block == null)
-        throw new ArgumentNullException(nameof (block));
-      if (block.Length != 512)
-        throw new ArgumentException("block length is invalid");
-      for (int index = 0; index < 512; ++index)
-      {
-        if (block[index] != (byte) 0)
-          return false;
-      }
-      return true;
-    }
-
-    public void SkipBlock()
-    {
-      if (this.inputStream == null)
-        throw new TarException("no input stream defined");
-      if (this.currentBlockIndex >= this.BlockFactor && !this.ReadRecord())
-        throw new TarException("Failed to read a record");
-      ++this.currentBlockIndex;
-    }
-
-    public byte[] ReadBlock()
-    {
-      if (this.inputStream == null)
-        throw new TarException("TarBuffer.ReadBlock - no input stream defined");
-      if (this.currentBlockIndex >= this.BlockFactor && !this.ReadRecord())
-        throw new TarException("Failed to read a record");
-      byte[] destinationArray = new byte[512];
-      Array.Copy((Array) this.recordBuffer, this.currentBlockIndex * 512, (Array) destinationArray, 0, 512);
-      ++this.currentBlockIndex;
-      return destinationArray;
-    }
-
-    private bool ReadRecord()
-    {
-      if (this.inputStream == null)
-        throw new TarException("no input stream stream defined");
-      this.currentBlockIndex = 0;
-      int offset = 0;
-      long num;
-      for (int recordSize = this.RecordSize; recordSize > 0; recordSize -= (int) num)
-      {
-        num = (long) this.inputStream.Read(this.recordBuffer, offset, recordSize);
-        if (num > 0L)
-          offset += (int) num;
-        else
-          break;
-      }
-      ++this.currentRecordIndex;
-      return true;
-    }
-
-    public int CurrentBlock => this.currentBlockIndex;
-
-    [Obsolete("Use CurrentBlock property instead")]
-    public int GetCurrentBlockNum() => this.currentBlockIndex;
-
-    public int CurrentRecord => this.currentRecordIndex;
-
-    [Obsolete("Use CurrentRecord property instead")]
-    public int GetCurrentRecordNum() => this.currentRecordIndex;
-
-    public void WriteBlock(byte[] block)
-    {
-      if (block == null)
-        throw new ArgumentNullException(nameof (block));
-      if (this.outputStream == null)
-        throw new TarException("TarBuffer.WriteBlock - no output stream defined");
-      if (block.Length != 512)
-        throw new TarException(string.Format("TarBuffer.WriteBlock - block to write has length '{0}' which is not the block size of '{1}'", (object) block.Length, (object) 512));
-      if (this.currentBlockIndex >= this.BlockFactor)
-        this.WriteRecord();
-      Array.Copy((Array) block, 0, (Array) this.recordBuffer, this.currentBlockIndex * 512, 512);
-      ++this.currentBlockIndex;
-    }
-
-    public void WriteBlock(byte[] buffer, int offset)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (this.outputStream == null)
-        throw new TarException("TarBuffer.WriteBlock - no output stream stream defined");
-      if (offset < 0 || offset >= buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      if (offset + 512 > buffer.Length)
-        throw new TarException(string.Format("TarBuffer.WriteBlock - record has length '{0}' with offset '{1}' which is less than the record size of '{2}'", (object) buffer.Length, (object) offset, (object) this.recordSize));
-      if (this.currentBlockIndex >= this.BlockFactor)
-        this.WriteRecord();
-      Array.Copy((Array) buffer, offset, (Array) this.recordBuffer, this.currentBlockIndex * 512, 512);
-      ++this.currentBlockIndex;
-    }
-
-    private void WriteRecord()
-    {
-      if (this.outputStream == null)
-        throw new TarException("TarBuffer.WriteRecord no output stream defined");
-      this.outputStream.Write(this.recordBuffer, 0, this.RecordSize);
-      this.outputStream.Flush();
-      this.currentBlockIndex = 0;
-      ++this.currentRecordIndex;
-    }
-
-    private void Flush()
-    {
-      if (this.outputStream == null)
-        throw new TarException("TarBuffer.Flush no output stream defined");
-      if (this.currentBlockIndex > 0)
-      {
-        int index = this.currentBlockIndex * 512;
-        Array.Clear((Array) this.recordBuffer, index, this.RecordSize - index);
-        this.WriteRecord();
-      }
-      this.outputStream.Flush();
-    }
-
-    public void Close()
-    {
-      if (this.outputStream != null)
-      {
-        this.Flush();
-        this.outputStream.Close();
-        this.outputStream = (Stream) null;
-      }
-      else
-      {
-        if (this.inputStream == null)
-          return;
-        this.inputStream.Close();
-        this.inputStream = (Stream) null;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarEntry.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarEntry.cs
deleted file mode 100644
index 4b93051..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarEntry.cs
+++ /dev/null
@@ -1,199 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarEntry : ICloneable
-  {
-    private string file;
-    private TarHeader header;
-
-    private TarEntry() => this.header = new TarHeader();
-
-    public TarEntry(byte[] headerBuffer)
-    {
-      this.header = new TarHeader();
-      this.header.ParseBuffer(headerBuffer);
-    }
-
-    public TarEntry(TarHeader header)
-    {
-      this.header = header != null ? (TarHeader) header.Clone() : throw new ArgumentNullException(nameof (header));
-    }
-
-    public object Clone()
-    {
-      return (object) new TarEntry()
-      {
-        file = this.file,
-        header = (TarHeader) this.header.Clone(),
-        Name = this.Name
-      };
-    }
-
-    public static TarEntry CreateTarEntry(string name)
-    {
-      TarEntry tarEntry = new TarEntry();
-      TarEntry.NameTarHeader(tarEntry.header, name);
-      return tarEntry;
-    }
-
-    public static TarEntry CreateEntryFromFile(string fileName)
-    {
-      TarEntry entryFromFile = new TarEntry();
-      entryFromFile.GetFileTarHeader(entryFromFile.header, fileName);
-      return entryFromFile;
-    }
-
-    public override bool Equals(object obj)
-    {
-      return obj is TarEntry tarEntry && this.Name.Equals(tarEntry.Name);
-    }
-
-    public override int GetHashCode() => this.Name.GetHashCode();
-
-    public bool IsDescendent(TarEntry toTest)
-    {
-      return toTest != null ? toTest.Name.StartsWith(this.Name) : throw new ArgumentNullException(nameof (toTest));
-    }
-
-    public TarHeader TarHeader => this.header;
-
-    public string Name
-    {
-      get => this.header.Name;
-      set => this.header.Name = value;
-    }
-
-    public int UserId
-    {
-      get => this.header.UserId;
-      set => this.header.UserId = value;
-    }
-
-    public int GroupId
-    {
-      get => this.header.GroupId;
-      set => this.header.GroupId = value;
-    }
-
-    public string UserName
-    {
-      get => this.header.UserName;
-      set => this.header.UserName = value;
-    }
-
-    public string GroupName
-    {
-      get => this.header.GroupName;
-      set => this.header.GroupName = value;
-    }
-
-    public void SetIds(int userId, int groupId)
-    {
-      this.UserId = userId;
-      this.GroupId = groupId;
-    }
-
-    public void SetNames(string userName, string groupName)
-    {
-      this.UserName = userName;
-      this.GroupName = groupName;
-    }
-
-    public DateTime ModTime
-    {
-      get => this.header.ModTime;
-      set => this.header.ModTime = value;
-    }
-
-    public string File => this.file;
-
-    public long Size
-    {
-      get => this.header.Size;
-      set => this.header.Size = value;
-    }
-
-    public bool IsDirectory
-    {
-      get
-      {
-        if (this.file != null)
-          return Directory.Exists(this.file);
-        return this.header != null && (this.header.TypeFlag == (byte) 53 || this.Name.EndsWith("/"));
-      }
-    }
-
-    public void GetFileTarHeader(TarHeader header, string file)
-    {
-      if (header == null)
-        throw new ArgumentNullException(nameof (header));
-      this.file = file != null ? file : throw new ArgumentNullException(nameof (file));
-      string str1 = file;
-      if (str1.IndexOf(Environment.CurrentDirectory) == 0)
-        str1 = str1.Substring(Environment.CurrentDirectory.Length);
-      string str2 = str1.Replace(Path.DirectorySeparatorChar, '/');
-      while (str2.StartsWith("/"))
-        str2 = str2.Substring(1);
-      header.LinkName = string.Empty;
-      header.Name = str2;
-      if (Directory.Exists(file))
-      {
-        header.Mode = 1003;
-        header.TypeFlag = (byte) 53;
-        if (header.Name.Length == 0 || header.Name[header.Name.Length - 1] != '/')
-          header.Name += "/";
-        header.Size = 0L;
-      }
-      else
-      {
-        header.Mode = 33216;
-        header.TypeFlag = (byte) 48;
-        header.Size = new FileInfo(file.Replace('/', Path.DirectorySeparatorChar)).Length;
-      }
-      header.ModTime = System.IO.File.GetLastWriteTime(file.Replace('/', Path.DirectorySeparatorChar)).ToUniversalTime();
-      header.DevMajor = 0;
-      header.DevMinor = 0;
-    }
-
-    public TarEntry[] GetDirectoryEntries()
-    {
-      if (this.file == null || !Directory.Exists(this.file))
-        return new TarEntry[0];
-      string[] fileSystemEntries = Directory.GetFileSystemEntries(this.file);
-      TarEntry[] directoryEntries = new TarEntry[fileSystemEntries.Length];
-      for (int index = 0; index < fileSystemEntries.Length; ++index)
-        directoryEntries[index] = TarEntry.CreateEntryFromFile(fileSystemEntries[index]);
-      return directoryEntries;
-    }
-
-    public void WriteEntryHeader(byte[] outBuffer) => this.header.WriteHeader(outBuffer);
-
-    public static void AdjustEntryName(byte[] buffer, string newName)
-    {
-      int offset = 0;
-      TarHeader.GetNameBytes(newName, buffer, offset, 100);
-    }
-
-    public static void NameTarHeader(TarHeader header, string name)
-    {
-      if (header == null)
-        throw new ArgumentNullException(nameof (header));
-      bool flag = name != null ? name.EndsWith("/") : throw new ArgumentNullException(nameof (name));
-      header.Name = name;
-      header.Mode = flag ? 1003 : 33216;
-      header.UserId = 0;
-      header.GroupId = 0;
-      header.Size = 0L;
-      header.ModTime = DateTime.UtcNow;
-      header.TypeFlag = flag ? (byte) 53 : (byte) 48;
-      header.LinkName = string.Empty;
-      header.UserName = string.Empty;
-      header.GroupName = string.Empty;
-      header.DevMajor = 0;
-      header.DevMinor = 0;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarException.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarException.cs
deleted file mode 100644
index 650e92f..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  [Serializable]
-  public class TarException : SharpZipBaseException
-  {
-    protected TarException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public TarException()
-    {
-    }
-
-    public TarException(string message)
-      : base(message)
-    {
-    }
-
-    public TarException(string message, Exception exception)
-      : base(message, exception)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarHeader.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarHeader.cs
deleted file mode 100644
index 80026d0..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarHeader.cs
+++ /dev/null
@@ -1,486 +0,0 @@
-using System;
-using System.Text;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarHeader : ICloneable
-  {
-    public const int NAMELEN = 100;
-    public const int MODELEN = 8;
-    public const int UIDLEN = 8;
-    public const int GIDLEN = 8;
-    public const int CHKSUMLEN = 8;
-    public const int CHKSUMOFS = 148;
-    public const int SIZELEN = 12;
-    public const int MAGICLEN = 6;
-    public const int VERSIONLEN = 2;
-    public const int MODTIMELEN = 12;
-    public const int UNAMELEN = 32;
-    public const int GNAMELEN = 32;
-    public const int DEVLEN = 8;
-    public const byte LF_OLDNORM = 0;
-    public const byte LF_NORMAL = 48;
-    public const byte LF_LINK = 49;
-    public const byte LF_SYMLINK = 50;
-    public const byte LF_CHR = 51;
-    public const byte LF_BLK = 52;
-    public const byte LF_DIR = 53;
-    public const byte LF_FIFO = 54;
-    public const byte LF_CONTIG = 55;
-    public const byte LF_GHDR = 103;
-    public const byte LF_XHDR = 120;
-    public const byte LF_ACL = 65;
-    public const byte LF_GNU_DUMPDIR = 68;
-    public const byte LF_EXTATTR = 69;
-    public const byte LF_META = 73;
-    public const byte LF_GNU_LONGLINK = 75;
-    public const byte LF_GNU_LONGNAME = 76;
-    public const byte LF_GNU_MULTIVOL = 77;
-    public const byte LF_GNU_NAMES = 78;
-    public const byte LF_GNU_SPARSE = 83;
-    public const byte LF_GNU_VOLHDR = 86;
-    public const string TMAGIC = "ustar ";
-    public const string GNU_TMAGIC = "ustar  ";
-    private const long timeConversionFactor = 10000000;
-    private static readonly DateTime dateTime1970 = new DateTime(1970, 1, 1, 0, 0, 0, 0);
-    private string name;
-    private int mode;
-    private int userId;
-    private int groupId;
-    private long size;
-    private DateTime modTime;
-    private int checksum;
-    private bool isChecksumValid;
-    private byte typeFlag;
-    private string linkName;
-    private string magic;
-    private string version;
-    private string userName;
-    private string groupName;
-    private int devMajor;
-    private int devMinor;
-    internal static int userIdAsSet;
-    internal static int groupIdAsSet;
-    internal static string userNameAsSet;
-    internal static string groupNameAsSet = "None";
-    internal static int defaultUserId;
-    internal static int defaultGroupId;
-    internal static string defaultGroupName = "None";
-    internal static string defaultUser;
-
-    public TarHeader()
-    {
-      this.Magic = "ustar ";
-      this.Version = " ";
-      this.Name = "";
-      this.LinkName = "";
-      this.UserId = TarHeader.defaultUserId;
-      this.GroupId = TarHeader.defaultGroupId;
-      this.UserName = TarHeader.defaultUser;
-      this.GroupName = TarHeader.defaultGroupName;
-      this.Size = 0L;
-    }
-
-    public string Name
-    {
-      get => this.name;
-      set => this.name = value != null ? value : throw new ArgumentNullException(nameof (value));
-    }
-
-    [Obsolete("Use the Name property instead", true)]
-    public string GetName() => this.name;
-
-    public int Mode
-    {
-      get => this.mode;
-      set => this.mode = value;
-    }
-
-    public int UserId
-    {
-      get => this.userId;
-      set => this.userId = value;
-    }
-
-    public int GroupId
-    {
-      get => this.groupId;
-      set => this.groupId = value;
-    }
-
-    public long Size
-    {
-      get => this.size;
-      set
-      {
-        this.size = value >= 0L ? value : throw new ArgumentOutOfRangeException(nameof (value), "Cannot be less than zero");
-      }
-    }
-
-    public DateTime ModTime
-    {
-      get => this.modTime;
-      set
-      {
-        if (value < TarHeader.dateTime1970)
-          throw new ArgumentOutOfRangeException(nameof (value), "ModTime cannot be before Jan 1st 1970");
-        this.modTime = new DateTime(value.Year, value.Month, value.Day, value.Hour, value.Minute, value.Second);
-      }
-    }
-
-    public int Checksum => this.checksum;
-
-    public bool IsChecksumValid => this.isChecksumValid;
-
-    public byte TypeFlag
-    {
-      get => this.typeFlag;
-      set => this.typeFlag = value;
-    }
-
-    public string LinkName
-    {
-      get => this.linkName;
-      set
-      {
-        this.linkName = value != null ? value : throw new ArgumentNullException(nameof (value));
-      }
-    }
-
-    public string Magic
-    {
-      get => this.magic;
-      set => this.magic = value != null ? value : throw new ArgumentNullException(nameof (value));
-    }
-
-    public string Version
-    {
-      get => this.version;
-      set => this.version = value != null ? value : throw new ArgumentNullException(nameof (value));
-    }
-
-    public string UserName
-    {
-      get => this.userName;
-      set
-      {
-        if (value != null)
-        {
-          this.userName = value.Substring(0, Math.Min(32, value.Length));
-        }
-        else
-        {
-          string str = Environment.UserName;
-          if (str.Length > 32)
-            str = str.Substring(0, 32);
-          this.userName = str;
-        }
-      }
-    }
-
-    public string GroupName
-    {
-      get => this.groupName;
-      set
-      {
-        if (value == null)
-          this.groupName = "None";
-        else
-          this.groupName = value;
-      }
-    }
-
-    public int DevMajor
-    {
-      get => this.devMajor;
-      set => this.devMajor = value;
-    }
-
-    public int DevMinor
-    {
-      get => this.devMinor;
-      set => this.devMinor = value;
-    }
-
-    public object Clone() => this.MemberwiseClone();
-
-    public void ParseBuffer(byte[] header)
-    {
-      if (header == null)
-        throw new ArgumentNullException(nameof (header));
-      int offset1 = 0;
-      this.name = TarHeader.ParseName(header, offset1, 100).ToString();
-      int offset2 = offset1 + 100;
-      this.mode = (int) TarHeader.ParseOctal(header, offset2, 8);
-      int offset3 = offset2 + 8;
-      this.UserId = (int) TarHeader.ParseOctal(header, offset3, 8);
-      int offset4 = offset3 + 8;
-      this.GroupId = (int) TarHeader.ParseOctal(header, offset4, 8);
-      int offset5 = offset4 + 8;
-      this.Size = TarHeader.ParseOctal(header, offset5, 12);
-      int offset6 = offset5 + 12;
-      this.ModTime = TarHeader.GetDateTimeFromCTime(TarHeader.ParseOctal(header, offset6, 12));
-      int offset7 = offset6 + 12;
-      this.checksum = (int) TarHeader.ParseOctal(header, offset7, 8);
-      int num = offset7 + 8;
-      byte[] numArray = header;
-      int index = num;
-      int offset8 = index + 1;
-      this.TypeFlag = numArray[index];
-      this.LinkName = TarHeader.ParseName(header, offset8, 100).ToString();
-      int offset9 = offset8 + 100;
-      this.Magic = TarHeader.ParseName(header, offset9, 6).ToString();
-      int offset10 = offset9 + 6;
-      this.Version = TarHeader.ParseName(header, offset10, 2).ToString();
-      int offset11 = offset10 + 2;
-      this.UserName = TarHeader.ParseName(header, offset11, 32).ToString();
-      int offset12 = offset11 + 32;
-      this.GroupName = TarHeader.ParseName(header, offset12, 32).ToString();
-      int offset13 = offset12 + 32;
-      this.DevMajor = (int) TarHeader.ParseOctal(header, offset13, 8);
-      int offset14 = offset13 + 8;
-      this.DevMinor = (int) TarHeader.ParseOctal(header, offset14, 8);
-      this.isChecksumValid = this.Checksum == TarHeader.MakeCheckSum(header);
-    }
-
-    public void WriteHeader(byte[] outBuffer)
-    {
-      if (outBuffer == null)
-        throw new ArgumentNullException(nameof (outBuffer));
-      int offset1 = 0;
-      int nameBytes1 = TarHeader.GetNameBytes(this.Name, outBuffer, offset1, 100);
-      int octalBytes1 = TarHeader.GetOctalBytes((long) this.mode, outBuffer, nameBytes1, 8);
-      int octalBytes2 = TarHeader.GetOctalBytes((long) this.UserId, outBuffer, octalBytes1, 8);
-      int octalBytes3 = TarHeader.GetOctalBytes((long) this.GroupId, outBuffer, octalBytes2, 8);
-      int longOctalBytes1 = TarHeader.GetLongOctalBytes(this.Size, outBuffer, octalBytes3, 12);
-      int longOctalBytes2 = TarHeader.GetLongOctalBytes((long) TarHeader.GetCTime(this.ModTime), outBuffer, longOctalBytes1, 12);
-      int offset2 = longOctalBytes2;
-      for (int index = 0; index < 8; ++index)
-        outBuffer[longOctalBytes2++] = (byte) 32;
-      byte[] numArray = outBuffer;
-      int index1 = longOctalBytes2;
-      int offset3 = index1 + 1;
-      int typeFlag = (int) this.TypeFlag;
-      numArray[index1] = (byte) typeFlag;
-      int nameBytes2 = TarHeader.GetNameBytes(this.LinkName, outBuffer, offset3, 100);
-      int asciiBytes = TarHeader.GetAsciiBytes(this.Magic, 0, outBuffer, nameBytes2, 6);
-      int nameBytes3 = TarHeader.GetNameBytes(this.Version, outBuffer, asciiBytes, 2);
-      int nameBytes4 = TarHeader.GetNameBytes(this.UserName, outBuffer, nameBytes3, 32);
-      int offset4 = TarHeader.GetNameBytes(this.GroupName, outBuffer, nameBytes4, 32);
-      if (this.TypeFlag == (byte) 51 || this.TypeFlag == (byte) 52)
-      {
-        int octalBytes4 = TarHeader.GetOctalBytes((long) this.DevMajor, outBuffer, offset4, 8);
-        offset4 = TarHeader.GetOctalBytes((long) this.DevMinor, outBuffer, octalBytes4, 8);
-      }
-      while (offset4 < outBuffer.Length)
-        outBuffer[offset4++] = (byte) 0;
-      this.checksum = TarHeader.ComputeCheckSum(outBuffer);
-      TarHeader.GetCheckSumOctalBytes((long) this.checksum, outBuffer, offset2, 8);
-      this.isChecksumValid = true;
-    }
-
-    public override int GetHashCode() => this.Name.GetHashCode();
-
-    public override bool Equals(object obj)
-    {
-      return obj is TarHeader tarHeader && this.name == tarHeader.name && this.mode == tarHeader.mode && this.UserId == tarHeader.UserId && this.GroupId == tarHeader.GroupId && this.Size == tarHeader.Size && this.ModTime == tarHeader.ModTime && this.Checksum == tarHeader.Checksum && (int) this.TypeFlag == (int) tarHeader.TypeFlag && this.LinkName == tarHeader.LinkName && this.Magic == tarHeader.Magic && this.Version == tarHeader.Version && this.UserName == tarHeader.UserName && this.GroupName == tarHeader.GroupName && this.DevMajor == tarHeader.DevMajor && this.DevMinor == tarHeader.DevMinor;
-    }
-
-    internal static void SetValueDefaults(
-      int userId,
-      string userName,
-      int groupId,
-      string groupName)
-    {
-      TarHeader.defaultUserId = TarHeader.userIdAsSet = userId;
-      TarHeader.defaultUser = TarHeader.userNameAsSet = userName;
-      TarHeader.defaultGroupId = TarHeader.groupIdAsSet = groupId;
-      TarHeader.defaultGroupName = TarHeader.groupNameAsSet = groupName;
-    }
-
-    internal static void RestoreSetValues()
-    {
-      TarHeader.defaultUserId = TarHeader.userIdAsSet;
-      TarHeader.defaultUser = TarHeader.userNameAsSet;
-      TarHeader.defaultGroupId = TarHeader.groupIdAsSet;
-      TarHeader.defaultGroupName = TarHeader.groupNameAsSet;
-    }
-
-    public static long ParseOctal(byte[] header, int offset, int length)
-    {
-      if (header == null)
-        throw new NullReferenceException(nameof (header));
-      long octal = 0;
-      bool flag = true;
-      int num = offset + length;
-      for (int index = offset; index < num && header[index] != (byte) 0; ++index)
-      {
-        if (header[index] == (byte) 32 || header[index] == (byte) 48)
-        {
-          if (!flag)
-          {
-            if (header[index] == (byte) 32)
-              break;
-          }
-          else
-            continue;
-        }
-        flag = false;
-        octal = (octal << 3) + (long) ((int) header[index] - 48);
-      }
-      return octal;
-    }
-
-    public static StringBuilder ParseName(byte[] header, int offset, int length)
-    {
-      if (header == null)
-        throw new ArgumentNullException(nameof (header));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be less than zero");
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length), "Cannot be less than zero");
-      if (offset + length > header.Length)
-        throw new ArgumentException("Exceeds header size", nameof (length));
-      StringBuilder name = new StringBuilder(length);
-      for (int index = offset; index < offset + length && header[index] != (byte) 0; ++index)
-        name.Append((char) header[index]);
-      return name;
-    }
-
-    public static int GetNameBytes(
-      StringBuilder name,
-      int nameOffset,
-      byte[] buffer,
-      int bufferOffset,
-      int length)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      return TarHeader.GetNameBytes(name.ToString(), nameOffset, buffer, bufferOffset, length);
-    }
-
-    public static int GetNameBytes(
-      string name,
-      int nameOffset,
-      byte[] buffer,
-      int bufferOffset,
-      int length)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      int num;
-      for (num = 0; num < length - 1 && nameOffset + num < name.Length; ++num)
-        buffer[bufferOffset + num] = (byte) name[nameOffset + num];
-      for (; num < length; ++num)
-        buffer[bufferOffset + num] = (byte) 0;
-      return bufferOffset + length;
-    }
-
-    public static int GetNameBytes(StringBuilder name, byte[] buffer, int offset, int length)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      return TarHeader.GetNameBytes(name.ToString(), 0, buffer, offset, length);
-    }
-
-    public static int GetNameBytes(string name, byte[] buffer, int offset, int length)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      return TarHeader.GetNameBytes(name, 0, buffer, offset, length);
-    }
-
-    public static int GetAsciiBytes(
-      string toAdd,
-      int nameOffset,
-      byte[] buffer,
-      int bufferOffset,
-      int length)
-    {
-      if (toAdd == null)
-        throw new ArgumentNullException(nameof (toAdd));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      for (int index = 0; index < length && nameOffset + index < toAdd.Length; ++index)
-        buffer[bufferOffset + index] = (byte) toAdd[nameOffset + index];
-      return bufferOffset + length;
-    }
-
-    public static int GetOctalBytes(long value, byte[] buffer, int offset, int length)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      int num1 = length - 1;
-      buffer[offset + num1] = (byte) 0;
-      int num2 = num1 - 1;
-      if (value > 0L)
-      {
-        for (long index = value; num2 >= 0 && index > 0L; --num2)
-        {
-          buffer[offset + num2] = (byte) (48U + (uint) (byte) ((ulong) index & 7UL));
-          index >>= 3;
-        }
-      }
-      for (; num2 >= 0; --num2)
-        buffer[offset + num2] = (byte) 48;
-      return offset + length;
-    }
-
-    public static int GetLongOctalBytes(long value, byte[] buffer, int offset, int length)
-    {
-      return TarHeader.GetOctalBytes(value, buffer, offset, length);
-    }
-
-    private static int GetCheckSumOctalBytes(long value, byte[] buffer, int offset, int length)
-    {
-      TarHeader.GetOctalBytes(value, buffer, offset, length - 1);
-      return offset + length;
-    }
-
-    private static int ComputeCheckSum(byte[] buffer)
-    {
-      int checkSum = 0;
-      for (int index = 0; index < buffer.Length; ++index)
-        checkSum += (int) buffer[index];
-      return checkSum;
-    }
-
-    private static int MakeCheckSum(byte[] buffer)
-    {
-      int num = 0;
-      for (int index = 0; index < 148; ++index)
-        num += (int) buffer[index];
-      for (int index = 0; index < 8; ++index)
-        num += 32;
-      for (int index = 156; index < buffer.Length; ++index)
-        num += (int) buffer[index];
-      return num;
-    }
-
-    private static int GetCTime(DateTime dateTime)
-    {
-      return (int) ((dateTime.Ticks - TarHeader.dateTime1970.Ticks) / 10000000L);
-    }
-
-    private static DateTime GetDateTimeFromCTime(long ticks)
-    {
-      try
-      {
-        return new DateTime(TarHeader.dateTime1970.Ticks + ticks * 10000000L);
-      }
-      catch (ArgumentOutOfRangeException ex)
-      {
-        return TarHeader.dateTime1970;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarInputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarInputStream.cs
deleted file mode 100644
index 3c65e2c..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarInputStream.cs
+++ /dev/null
@@ -1,290 +0,0 @@
-using System;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarInputStream : Stream
-  {
-    protected bool hasHitEOF;
-    protected long entrySize;
-    protected long entryOffset;
-    protected byte[] readBuffer;
-    protected TarBuffer buffer;
-    private TarEntry currentEntry;
-    protected TarInputStream.IEntryFactory entryFactory;
-    private Stream inputStream;
-
-    public TarInputStream(Stream inputStream)
-      : this(inputStream, 20)
-    {
-    }
-
-    public TarInputStream(Stream inputStream, int blockFactor)
-    {
-      this.inputStream = inputStream;
-      this.buffer = TarBuffer.CreateInputTarBuffer(inputStream, blockFactor);
-    }
-
-    public override bool CanRead => this.inputStream.CanRead;
-
-    public override bool CanSeek => false;
-
-    public override bool CanWrite => false;
-
-    public override long Length => this.inputStream.Length;
-
-    public override long Position
-    {
-      get => this.inputStream.Position;
-      set => throw new NotSupportedException("TarInputStream Seek not supported");
-    }
-
-    public override void Flush() => this.inputStream.Flush();
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("TarInputStream Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("TarInputStream SetLength not supported");
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("TarInputStream Write not supported");
-    }
-
-    public override void WriteByte(byte value)
-    {
-      throw new NotSupportedException("TarInputStream WriteByte not supported");
-    }
-
-    public override int ReadByte()
-    {
-      byte[] buffer = new byte[1];
-      return this.Read(buffer, 0, 1) <= 0 ? -1 : (int) buffer[0];
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      int num1 = 0;
-      if (this.entryOffset >= this.entrySize)
-        return 0;
-      long num2 = (long) count;
-      if (num2 + this.entryOffset > this.entrySize)
-        num2 = this.entrySize - this.entryOffset;
-      if (this.readBuffer != null)
-      {
-        int num3 = num2 > (long) this.readBuffer.Length ? this.readBuffer.Length : (int) num2;
-        Array.Copy((Array) this.readBuffer, 0, (Array) buffer, offset, num3);
-        if (num3 >= this.readBuffer.Length)
-        {
-          this.readBuffer = (byte[]) null;
-        }
-        else
-        {
-          int length = this.readBuffer.Length - num3;
-          byte[] destinationArray = new byte[length];
-          Array.Copy((Array) this.readBuffer, num3, (Array) destinationArray, 0, length);
-          this.readBuffer = destinationArray;
-        }
-        num1 += num3;
-        num2 -= (long) num3;
-        offset += num3;
-      }
-      while (num2 > 0L)
-      {
-        byte[] sourceArray = this.buffer.ReadBlock();
-        if (sourceArray == null)
-          throw new TarException("unexpected EOF with " + (object) num2 + " bytes unread");
-        int num4 = (int) num2;
-        int length = sourceArray.Length;
-        if (length > num4)
-        {
-          Array.Copy((Array) sourceArray, 0, (Array) buffer, offset, num4);
-          this.readBuffer = new byte[length - num4];
-          Array.Copy((Array) sourceArray, num4, (Array) this.readBuffer, 0, length - num4);
-        }
-        else
-        {
-          num4 = length;
-          Array.Copy((Array) sourceArray, 0, (Array) buffer, offset, length);
-        }
-        num1 += num4;
-        num2 -= (long) num4;
-        offset += num4;
-      }
-      this.entryOffset += (long) num1;
-      return num1;
-    }
-
-    public override void Close() => this.buffer.Close();
-
-    public void SetEntryFactory(TarInputStream.IEntryFactory factory)
-    {
-      this.entryFactory = factory;
-    }
-
-    public int RecordSize => this.buffer.RecordSize;
-
-    [Obsolete("Use RecordSize property instead")]
-    public int GetRecordSize() => this.buffer.RecordSize;
-
-    public long Available => this.entrySize - this.entryOffset;
-
-    public void Skip(long skipCount)
-    {
-      byte[] buffer = new byte[8192];
-      int num;
-      for (long index = skipCount; index > 0L; index -= (long) num)
-      {
-        int count = index > (long) buffer.Length ? buffer.Length : (int) index;
-        num = this.Read(buffer, 0, count);
-        if (num == -1)
-          break;
-      }
-    }
-
-    public bool IsMarkSupported => false;
-
-    public void Mark(int markLimit)
-    {
-    }
-
-    public void Reset()
-    {
-    }
-
-    public TarEntry GetNextEntry()
-    {
-      if (this.hasHitEOF)
-        return (TarEntry) null;
-      if (this.currentEntry != null)
-        this.SkipToNextEntry();
-      byte[] numArray1 = this.buffer.ReadBlock();
-      if (numArray1 == null)
-        this.hasHitEOF = true;
-      else if (this.buffer.IsEOFBlock(numArray1))
-        this.hasHitEOF = true;
-      if (this.hasHitEOF)
-      {
-        this.currentEntry = (TarEntry) null;
-      }
-      else
-      {
-        try
-        {
-          TarHeader tarHeader = new TarHeader();
-          tarHeader.ParseBuffer(numArray1);
-          if (!tarHeader.IsChecksumValid)
-            throw new TarException("Header checksum is invalid");
-          this.entryOffset = 0L;
-          this.entrySize = tarHeader.Size;
-          StringBuilder stringBuilder = (StringBuilder) null;
-          if (tarHeader.TypeFlag == (byte) 76)
-          {
-            byte[] numArray2 = new byte[512];
-            long entrySize = this.entrySize;
-            stringBuilder = new StringBuilder();
-            int length;
-            for (; entrySize > 0L; entrySize -= (long) length)
-            {
-              length = this.Read(numArray2, 0, entrySize > (long) numArray2.Length ? numArray2.Length : (int) entrySize);
-              if (length == -1)
-                throw new InvalidHeaderException("Failed to read long name entry");
-              stringBuilder.Append(TarHeader.ParseName(numArray2, 0, length).ToString());
-            }
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          else if (tarHeader.TypeFlag == (byte) 103)
-          {
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          else if (tarHeader.TypeFlag == (byte) 120)
-          {
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          else if (tarHeader.TypeFlag == (byte) 86)
-          {
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          else if (tarHeader.TypeFlag != (byte) 48 && tarHeader.TypeFlag != (byte) 0 && tarHeader.TypeFlag != (byte) 53)
-          {
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          if (this.entryFactory == null)
-          {
-            this.currentEntry = new TarEntry(numArray1);
-            if (stringBuilder != null)
-              this.currentEntry.Name = stringBuilder.ToString();
-          }
-          else
-            this.currentEntry = this.entryFactory.CreateEntry(numArray1);
-          this.entryOffset = 0L;
-          this.entrySize = this.currentEntry.Size;
-        }
-        catch (InvalidHeaderException ex)
-        {
-          this.entrySize = 0L;
-          this.entryOffset = 0L;
-          this.currentEntry = (TarEntry) null;
-          throw new InvalidHeaderException(string.Format("Bad header in record {0} block {1} {2}", (object) this.buffer.CurrentRecord, (object) this.buffer.CurrentBlock, (object) ex.Message));
-        }
-      }
-      return this.currentEntry;
-    }
-
-    public void CopyEntryContents(Stream outputStream)
-    {
-      byte[] buffer = new byte[32768];
-      while (true)
-      {
-        int count = this.Read(buffer, 0, buffer.Length);
-        if (count > 0)
-          outputStream.Write(buffer, 0, count);
-        else
-          break;
-      }
-    }
-
-    private void SkipToNextEntry()
-    {
-      long skipCount = this.entrySize - this.entryOffset;
-      if (skipCount > 0L)
-        this.Skip(skipCount);
-      this.readBuffer = (byte[]) null;
-    }
-
-    public interface IEntryFactory
-    {
-      TarEntry CreateEntry(string name);
-
-      TarEntry CreateEntryFromFile(string fileName);
-
-      TarEntry CreateEntry(byte[] headerBuf);
-    }
-
-    public class EntryFactoryAdapter : TarInputStream.IEntryFactory
-    {
-      public TarEntry CreateEntry(string name) => TarEntry.CreateTarEntry(name);
-
-      public TarEntry CreateEntryFromFile(string fileName)
-      {
-        return TarEntry.CreateEntryFromFile(fileName);
-      }
-
-      public TarEntry CreateEntry(byte[] headerBuf) => new TarEntry(headerBuf);
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarOutputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarOutputStream.cs
deleted file mode 100644
index aeb97b6..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Tar/TarOutputStream.cs
+++ /dev/null
@@ -1,191 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarOutputStream : Stream
-  {
-    private long currBytes;
-    private int assemblyBufferLength;
-    private bool isClosed;
-    protected long currSize;
-    protected byte[] blockBuffer;
-    protected byte[] assemblyBuffer;
-    protected TarBuffer buffer;
-    protected Stream outputStream;
-
-    public TarOutputStream(Stream outputStream)
-      : this(outputStream, 20)
-    {
-    }
-
-    public TarOutputStream(Stream outputStream, int blockFactor)
-    {
-      this.outputStream = outputStream != null ? outputStream : throw new ArgumentNullException(nameof (outputStream));
-      this.buffer = TarBuffer.CreateOutputTarBuffer(outputStream, blockFactor);
-      this.assemblyBuffer = new byte[512];
-      this.blockBuffer = new byte[512];
-    }
-
-    public override bool CanRead => this.outputStream.CanRead;
-
-    public override bool CanSeek => this.outputStream.CanSeek;
-
-    public override bool CanWrite => this.outputStream.CanWrite;
-
-    public override long Length => this.outputStream.Length;
-
-    public override long Position
-    {
-      get => this.outputStream.Position;
-      set => this.outputStream.Position = value;
-    }
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      return this.outputStream.Seek(offset, origin);
-    }
-
-    public override void SetLength(long value) => this.outputStream.SetLength(value);
-
-    public override int ReadByte() => this.outputStream.ReadByte();
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      return this.outputStream.Read(buffer, offset, count);
-    }
-
-    public override void Flush() => this.outputStream.Flush();
-
-    public void Finish()
-    {
-      if (this.IsEntryOpen)
-        this.CloseEntry();
-      this.WriteEofBlock();
-    }
-
-    public override void Close()
-    {
-      if (this.isClosed)
-        return;
-      this.isClosed = true;
-      this.Finish();
-      this.buffer.Close();
-    }
-
-    public int RecordSize => this.buffer.RecordSize;
-
-    [Obsolete("Use RecordSize property instead")]
-    public int GetRecordSize() => this.buffer.RecordSize;
-
-    private bool IsEntryOpen => this.currBytes < this.currSize;
-
-    public void PutNextEntry(TarEntry entry)
-    {
-      if (entry == null)
-        throw new ArgumentNullException(nameof (entry));
-      if (entry.TarHeader.Name.Length >= 100)
-      {
-        TarHeader tarHeader = new TarHeader()
-        {
-          TypeFlag = 76
-        };
-        tarHeader.Name += "././@LongLink";
-        tarHeader.UserId = 0;
-        tarHeader.GroupId = 0;
-        tarHeader.GroupName = "";
-        tarHeader.UserName = "";
-        tarHeader.LinkName = "";
-        tarHeader.Size = (long) entry.TarHeader.Name.Length;
-        tarHeader.WriteHeader(this.blockBuffer);
-        this.buffer.WriteBlock(this.blockBuffer);
-        int nameOffset = 0;
-        while (nameOffset < entry.TarHeader.Name.Length)
-        {
-          Array.Clear((Array) this.blockBuffer, 0, this.blockBuffer.Length);
-          TarHeader.GetAsciiBytes(entry.TarHeader.Name, nameOffset, this.blockBuffer, 0, 512);
-          nameOffset += 512;
-          this.buffer.WriteBlock(this.blockBuffer);
-        }
-      }
-      entry.WriteEntryHeader(this.blockBuffer);
-      this.buffer.WriteBlock(this.blockBuffer);
-      this.currBytes = 0L;
-      this.currSize = entry.IsDirectory ? 0L : entry.Size;
-    }
-
-    public void CloseEntry()
-    {
-      if (this.assemblyBufferLength > 0)
-      {
-        Array.Clear((Array) this.assemblyBuffer, this.assemblyBufferLength, this.assemblyBuffer.Length - this.assemblyBufferLength);
-        this.buffer.WriteBlock(this.assemblyBuffer);
-        this.currBytes += (long) this.assemblyBufferLength;
-        this.assemblyBufferLength = 0;
-      }
-      if (this.currBytes < this.currSize)
-        throw new TarException(string.Format("Entry closed at '{0}' before the '{1}' bytes specified in the header were written", (object) this.currBytes, (object) this.currSize));
-    }
-
-    public override void WriteByte(byte value)
-    {
-      this.Write(new byte[1]{ value }, 0, 1);
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be negative");
-      if (buffer.Length - offset < count)
-        throw new ArgumentException("offset and count combination is invalid");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be negative");
-      if (this.currBytes + (long) count > this.currSize)
-        throw new ArgumentOutOfRangeException(nameof (count), string.Format("request to write '{0}' bytes exceeds size in header of '{1}' bytes", (object) count, (object) this.currSize));
-      if (this.assemblyBufferLength > 0)
-      {
-        if (this.assemblyBufferLength + count >= this.blockBuffer.Length)
-        {
-          int length = this.blockBuffer.Length - this.assemblyBufferLength;
-          Array.Copy((Array) this.assemblyBuffer, 0, (Array) this.blockBuffer, 0, this.assemblyBufferLength);
-          Array.Copy((Array) buffer, offset, (Array) this.blockBuffer, this.assemblyBufferLength, length);
-          this.buffer.WriteBlock(this.blockBuffer);
-          this.currBytes += (long) this.blockBuffer.Length;
-          offset += length;
-          count -= length;
-          this.assemblyBufferLength = 0;
-        }
-        else
-        {
-          Array.Copy((Array) buffer, offset, (Array) this.assemblyBuffer, this.assemblyBufferLength, count);
-          offset += count;
-          this.assemblyBufferLength += count;
-          count -= count;
-        }
-      }
-      while (count > 0)
-      {
-        if (count < this.blockBuffer.Length)
-        {
-          Array.Copy((Array) buffer, offset, (Array) this.assemblyBuffer, this.assemblyBufferLength, count);
-          this.assemblyBufferLength += count;
-          break;
-        }
-        this.buffer.WriteBlock(buffer, offset);
-        int length = this.blockBuffer.Length;
-        this.currBytes += (long) length;
-        count -= length;
-        offset += length;
-      }
-    }
-
-    private void WriteEofBlock()
-    {
-      Array.Clear((Array) this.blockBuffer, 0, this.blockBuffer.Length);
-      this.buffer.WriteBlock(this.blockBuffer);
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/BaseArchiveStorage.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/BaseArchiveStorage.cs
deleted file mode 100644
index 111e8f5..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/BaseArchiveStorage.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public abstract class BaseArchiveStorage : IArchiveStorage
-  {
-    private FileUpdateMode updateMode_;
-
-    public BaseArchiveStorage(FileUpdateMode updateMode) => this.updateMode_ = updateMode;
-
-    public abstract Stream GetTemporaryOutput();
-
-    public abstract Stream ConvertTemporaryToFinal();
-
-    public abstract Stream MakeTemporaryCopy(Stream stream);
-
-    public abstract Stream OpenForDirectUpdate(Stream stream);
-
-    public abstract void Dispose();
-
-    public FileUpdateMode UpdateMode => this.updateMode_;
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflateStrategy.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflateStrategy.cs
deleted file mode 100644
index 4ed0941..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflateStrategy.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public enum DeflateStrategy
-  {
-    Default,
-    Filtered,
-    HuffmanOnly,
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Deflater.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Deflater.cs
deleted file mode 100644
index e52cf2a..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Deflater.cs
+++ /dev/null
@@ -1,178 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class Deflater
-  {
-    public const int BEST_COMPRESSION = 9;
-    public const int BEST_SPEED = 1;
-    public const int DEFAULT_COMPRESSION = -1;
-    public const int NO_COMPRESSION = 0;
-    public const int DEFLATED = 8;
-    private const int IS_SETDICT = 1;
-    private const int IS_FLUSHING = 4;
-    private const int IS_FINISHING = 8;
-    private const int INIT_STATE = 0;
-    private const int SETDICT_STATE = 1;
-    private const int BUSY_STATE = 16;
-    private const int FLUSHING_STATE = 20;
-    private const int FINISHING_STATE = 28;
-    private const int FINISHED_STATE = 30;
-    private const int CLOSED_STATE = 127;
-    private int level;
-    private bool noZlibHeaderOrFooter;
-    private int state;
-    private long totalOut;
-    private DeflaterPending pending;
-    private DeflaterEngine engine;
-
-    public Deflater()
-      : this(-1, false)
-    {
-    }
-
-    public Deflater(int level)
-      : this(level, false)
-    {
-    }
-
-    public Deflater(int level, bool noZlibHeaderOrFooter)
-    {
-      if (level == -1)
-        level = 6;
-      else if (level < 0 || level > 9)
-        throw new ArgumentOutOfRangeException(nameof (level));
-      this.pending = new DeflaterPending();
-      this.engine = new DeflaterEngine(this.pending);
-      this.noZlibHeaderOrFooter = noZlibHeaderOrFooter;
-      this.SetStrategy(DeflateStrategy.Default);
-      this.SetLevel(level);
-      this.Reset();
-    }
-
-    public void Reset()
-    {
-      this.state = this.noZlibHeaderOrFooter ? 16 : 0;
-      this.totalOut = 0L;
-      this.pending.Reset();
-      this.engine.Reset();
-    }
-
-    public int Adler => this.engine.Adler;
-
-    public int TotalIn => this.engine.TotalIn;
-
-    public long TotalOut => this.totalOut;
-
-    public void Flush() => this.state |= 4;
-
-    public void Finish() => this.state |= 12;
-
-    public bool IsFinished => this.state == 30 && this.pending.IsFlushed;
-
-    public bool IsNeedingInput => this.engine.NeedsInput();
-
-    public void SetInput(byte[] input) => this.SetInput(input, 0, input.Length);
-
-    public void SetInput(byte[] input, int offset, int count)
-    {
-      if ((this.state & 8) != 0)
-        throw new InvalidOperationException("Finish() already called");
-      this.engine.SetInput(input, offset, count);
-    }
-
-    public void SetLevel(int level)
-    {
-      if (level == -1)
-        level = 6;
-      else if (level < 0 || level > 9)
-        throw new ArgumentOutOfRangeException(nameof (level));
-      if (this.level == level)
-        return;
-      this.level = level;
-      this.engine.SetLevel(level);
-    }
-
-    public int GetLevel() => this.level;
-
-    public void SetStrategy(DeflateStrategy strategy) => this.engine.Strategy = strategy;
-
-    public int Deflate(byte[] output) => this.Deflate(output, 0, output.Length);
-
-    public int Deflate(byte[] output, int offset, int length)
-    {
-      int num1 = length;
-      if (this.state == (int) sbyte.MaxValue)
-        throw new InvalidOperationException("Deflater closed");
-      if (this.state < 16)
-      {
-        int num2 = 30720;
-        int num3 = this.level - 1 >> 1;
-        if (num3 < 0 || num3 > 3)
-          num3 = 3;
-        int num4 = num2 | num3 << 6;
-        if ((this.state & 1) != 0)
-          num4 |= 32;
-        this.pending.WriteShortMSB(num4 + (31 - num4 % 31));
-        if ((this.state & 1) != 0)
-        {
-          int adler = this.engine.Adler;
-          this.engine.ResetAdler();
-          this.pending.WriteShortMSB(adler >> 16);
-          this.pending.WriteShortMSB(adler & (int) ushort.MaxValue);
-        }
-        this.state = 16 | this.state & 12;
-      }
-      while (true)
-      {
-        do
-        {
-          do
-          {
-            int num5 = this.pending.Flush(output, offset, length);
-            offset += num5;
-            this.totalOut += (long) num5;
-            length -= num5;
-            if (length == 0 || this.state == 30)
-              goto label_24;
-          }
-          while (this.engine.Deflate((this.state & 4) != 0, (this.state & 8) != 0));
-          if (this.state == 16)
-            return num1 - length;
-          if (this.state == 20)
-          {
-            if (this.level != 0)
-            {
-              for (int index = 8 + (-this.pending.BitCount & 7); index > 0; index -= 10)
-                this.pending.WriteBits(2, 10);
-            }
-            this.state = 16;
-          }
-        }
-        while (this.state != 28);
-        this.pending.AlignToByte();
-        if (!this.noZlibHeaderOrFooter)
-        {
-          int adler = this.engine.Adler;
-          this.pending.WriteShortMSB(adler >> 16);
-          this.pending.WriteShortMSB(adler & (int) ushort.MaxValue);
-        }
-        this.state = 30;
-      }
-label_24:
-      return num1 - length;
-    }
-
-    public void SetDictionary(byte[] dictionary)
-    {
-      this.SetDictionary(dictionary, 0, dictionary.Length);
-    }
-
-    public void SetDictionary(byte[] dictionary, int index, int count)
-    {
-      this.state = this.state == 0 ? 1 : throw new InvalidOperationException();
-      this.engine.SetDictionary(dictionary, index, count);
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterConstants.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterConstants.cs
deleted file mode 100644
index f330f7e..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterConstants.cs
+++ /dev/null
@@ -1,96 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class DeflaterConstants
-  {
-    public const bool DEBUGGING = false;
-    public const int STORED_BLOCK = 0;
-    public const int STATIC_TREES = 1;
-    public const int DYN_TREES = 2;
-    public const int PRESET_DICT = 32;
-    public const int DEFAULT_MEM_LEVEL = 8;
-    public const int MAX_MATCH = 258;
-    public const int MIN_MATCH = 3;
-    public const int MAX_WBITS = 15;
-    public const int WSIZE = 32768;
-    public const int WMASK = 32767;
-    public const int HASH_BITS = 15;
-    public const int HASH_SIZE = 32768;
-    public const int HASH_MASK = 32767;
-    public const int HASH_SHIFT = 5;
-    public const int MIN_LOOKAHEAD = 262;
-    public const int MAX_DIST = 32506;
-    public const int PENDING_BUF_SIZE = 65536;
-    public const int DEFLATE_STORED = 0;
-    public const int DEFLATE_FAST = 1;
-    public const int DEFLATE_SLOW = 2;
-    public static int MAX_BLOCK_SIZE = Math.Min((int) ushort.MaxValue, 65531);
-    public static int[] GOOD_LENGTH = new int[10]
-    {
-      0,
-      4,
-      4,
-      4,
-      4,
-      8,
-      8,
-      8,
-      32,
-      32
-    };
-    public static int[] MAX_LAZY = new int[10]
-    {
-      0,
-      4,
-      5,
-      6,
-      4,
-      16,
-      16,
-      32,
-      128,
-      258
-    };
-    public static int[] NICE_LENGTH = new int[10]
-    {
-      0,
-      8,
-      16,
-      32,
-      16,
-      32,
-      128,
-      128,
-      258,
-      258
-    };
-    public static int[] MAX_CHAIN = new int[10]
-    {
-      0,
-      4,
-      8,
-      32,
-      16,
-      32,
-      128,
-      256,
-      1024,
-      4096
-    };
-    public static int[] COMPR_FUNC = new int[10]
-    {
-      0,
-      1,
-      1,
-      1,
-      1,
-      2,
-      2,
-      2,
-      2,
-      2
-    };
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterEngine.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterEngine.cs
deleted file mode 100644
index b6579c4..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterEngine.cs
+++ /dev/null
@@ -1,426 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class DeflaterEngine : DeflaterConstants
-  {
-    private const int TooFar = 4096;
-    private int ins_h;
-    private short[] head;
-    private short[] prev;
-    private int matchStart;
-    private int matchLen;
-    private bool prevAvailable;
-    private int blockStart;
-    private int strstart;
-    private int lookahead;
-    private byte[] window;
-    private DeflateStrategy strategy;
-    private int max_chain;
-    private int max_lazy;
-    private int niceLength;
-    private int goodLength;
-    private int compressionFunction;
-    private byte[] inputBuf;
-    private int totalIn;
-    private int inputOff;
-    private int inputEnd;
-    private DeflaterPending pending;
-    private DeflaterHuffman huffman;
-    private Adler32 adler;
-
-    public DeflaterEngine(DeflaterPending pending)
-    {
-      this.pending = pending;
-      this.huffman = new DeflaterHuffman(pending);
-      this.adler = new Adler32();
-      this.window = new byte[65536];
-      this.head = new short[32768];
-      this.prev = new short[32768];
-      this.blockStart = this.strstart = 1;
-    }
-
-    public bool Deflate(bool flush, bool finish)
-    {
-      bool flag;
-      do
-      {
-        this.FillWindow();
-        bool flush1 = flush && this.inputOff == this.inputEnd;
-        switch (this.compressionFunction)
-        {
-          case 0:
-            flag = this.DeflateStored(flush1, finish);
-            break;
-          case 1:
-            flag = this.DeflateFast(flush1, finish);
-            break;
-          case 2:
-            flag = this.DeflateSlow(flush1, finish);
-            break;
-          default:
-            throw new InvalidOperationException("unknown compressionFunction");
-        }
-      }
-      while (this.pending.IsFlushed && flag);
-      return flag;
-    }
-
-    public void SetInput(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (this.inputOff < this.inputEnd)
-        throw new InvalidOperationException("Old input was not completely processed");
-      int num = offset + count;
-      if (offset > num || num > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      this.inputBuf = buffer;
-      this.inputOff = offset;
-      this.inputEnd = num;
-    }
-
-    public bool NeedsInput() => this.inputEnd == this.inputOff;
-
-    public void SetDictionary(byte[] buffer, int offset, int length)
-    {
-      this.adler.Update(buffer, offset, length);
-      if (length < 3)
-        return;
-      if (length > 32506)
-      {
-        offset += length - 32506;
-        length = 32506;
-      }
-      Array.Copy((Array) buffer, offset, (Array) this.window, this.strstart, length);
-      this.UpdateHash();
-      --length;
-      while (--length > 0)
-      {
-        this.InsertString();
-        ++this.strstart;
-      }
-      this.strstart += 2;
-      this.blockStart = this.strstart;
-    }
-
-    public void Reset()
-    {
-      this.huffman.Reset();
-      this.adler.Reset();
-      this.blockStart = this.strstart = 1;
-      this.lookahead = 0;
-      this.totalIn = 0;
-      this.prevAvailable = false;
-      this.matchLen = 2;
-      for (int index = 0; index < 32768; ++index)
-        this.head[index] = (short) 0;
-      for (int index = 0; index < 32768; ++index)
-        this.prev[index] = (short) 0;
-    }
-
-    public void ResetAdler() => this.adler.Reset();
-
-    public int Adler => (int) this.adler.Value;
-
-    public int TotalIn => this.totalIn;
-
-    public DeflateStrategy Strategy
-    {
-      get => this.strategy;
-      set => this.strategy = value;
-    }
-
-    public void SetLevel(int level)
-    {
-      this.goodLength = level >= 0 && level <= 9 ? DeflaterConstants.GOOD_LENGTH[level] : throw new ArgumentOutOfRangeException(nameof (level));
-      this.max_lazy = DeflaterConstants.MAX_LAZY[level];
-      this.niceLength = DeflaterConstants.NICE_LENGTH[level];
-      this.max_chain = DeflaterConstants.MAX_CHAIN[level];
-      if (DeflaterConstants.COMPR_FUNC[level] == this.compressionFunction)
-        return;
-      switch (this.compressionFunction)
-      {
-        case 0:
-          if (this.strstart > this.blockStart)
-          {
-            this.huffman.FlushStoredBlock(this.window, this.blockStart, this.strstart - this.blockStart, false);
-            this.blockStart = this.strstart;
-          }
-          this.UpdateHash();
-          break;
-        case 1:
-          if (this.strstart > this.blockStart)
-          {
-            this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, false);
-            this.blockStart = this.strstart;
-            break;
-          }
-          break;
-        case 2:
-          if (this.prevAvailable)
-            this.huffman.TallyLit((int) this.window[this.strstart - 1] & (int) byte.MaxValue);
-          if (this.strstart > this.blockStart)
-          {
-            this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, false);
-            this.blockStart = this.strstart;
-          }
-          this.prevAvailable = false;
-          this.matchLen = 2;
-          break;
-      }
-      this.compressionFunction = DeflaterConstants.COMPR_FUNC[level];
-    }
-
-    public void FillWindow()
-    {
-      if (this.strstart >= 65274)
-        this.SlideWindow();
-      int num;
-      for (; this.lookahead < 262 && this.inputOff < this.inputEnd; this.lookahead += num)
-      {
-        num = 65536 - this.lookahead - this.strstart;
-        if (num > this.inputEnd - this.inputOff)
-          num = this.inputEnd - this.inputOff;
-        Array.Copy((Array) this.inputBuf, this.inputOff, (Array) this.window, this.strstart + this.lookahead, num);
-        this.adler.Update(this.inputBuf, this.inputOff, num);
-        this.inputOff += num;
-        this.totalIn += num;
-      }
-      if (this.lookahead < 3)
-        return;
-      this.UpdateHash();
-    }
-
-    private void UpdateHash()
-    {
-      this.ins_h = (int) this.window[this.strstart] << 5 ^ (int) this.window[this.strstart + 1];
-    }
-
-    private int InsertString()
-    {
-      int index = (this.ins_h << 5 ^ (int) this.window[this.strstart + 2]) & (int) short.MaxValue;
-      short num;
-      this.prev[this.strstart & (int) short.MaxValue] = num = this.head[index];
-      this.head[index] = (short) this.strstart;
-      this.ins_h = index;
-      return (int) num & (int) ushort.MaxValue;
-    }
-
-    private void SlideWindow()
-    {
-      Array.Copy((Array) this.window, 32768, (Array) this.window, 0, 32768);
-      this.matchStart -= 32768;
-      this.strstart -= 32768;
-      this.blockStart -= 32768;
-      for (int index = 0; index < 32768; ++index)
-      {
-        int num = (int) this.head[index] & (int) ushort.MaxValue;
-        this.head[index] = num >= 32768 ? (short) (num - 32768) : (short) 0;
-      }
-      for (int index = 0; index < 32768; ++index)
-      {
-        int num = (int) this.prev[index] & (int) ushort.MaxValue;
-        this.prev[index] = num >= 32768 ? (short) (num - 32768) : (short) 0;
-      }
-    }
-
-    private bool FindLongestMatch(int curMatch)
-    {
-      int maxChain = this.max_chain;
-      int num1 = this.niceLength;
-      short[] prev = this.prev;
-      int strstart = this.strstart;
-      int index = this.strstart + this.matchLen;
-      int val1 = Math.Max(this.matchLen, 2);
-      int num2 = Math.Max(this.strstart - 32506, 0);
-      int num3 = this.strstart + 258 - 1;
-      byte num4 = this.window[index - 1];
-      byte num5 = this.window[index];
-      if (val1 >= this.goodLength)
-        maxChain >>= 2;
-      if (num1 > this.lookahead)
-        num1 = this.lookahead;
-      do
-      {
-        if ((int) this.window[curMatch + val1] == (int) num5 && (int) this.window[curMatch + val1 - 1] == (int) num4 && (int) this.window[curMatch] == (int) this.window[strstart] && (int) this.window[curMatch + 1] == (int) this.window[strstart + 1])
-        {
-          int num6 = curMatch + 2;
-          int num7 = strstart + 2;
-          int num8;
-          int num9;
-          int num10;
-          int num11;
-          int num12;
-          int num13;
-          int num14;
-          do
-            ;
-          while ((int) this.window[++num7] == (int) this.window[num8 = num6 + 1] && (int) this.window[++num7] == (int) this.window[num9 = num8 + 1] && (int) this.window[++num7] == (int) this.window[num10 = num9 + 1] && (int) this.window[++num7] == (int) this.window[num11 = num10 + 1] && (int) this.window[++num7] == (int) this.window[num12 = num11 + 1] && (int) this.window[++num7] == (int) this.window[num13 = num12 + 1] && (int) this.window[++num7] == (int) this.window[num14 = num13 + 1] && (int) this.window[++num7] == (int) this.window[num6 = num14 + 1] && num7 < num3);
-          if (num7 > index)
-          {
-            this.matchStart = curMatch;
-            index = num7;
-            val1 = num7 - this.strstart;
-            if (val1 < num1)
-            {
-              num4 = this.window[index - 1];
-              num5 = this.window[index];
-            }
-            else
-              break;
-          }
-          strstart = this.strstart;
-        }
-      }
-      while ((curMatch = (int) prev[curMatch & (int) short.MaxValue] & (int) ushort.MaxValue) > num2 && --maxChain != 0);
-      this.matchLen = Math.Min(val1, this.lookahead);
-      return this.matchLen >= 3;
-    }
-
-    private bool DeflateStored(bool flush, bool finish)
-    {
-      if (!flush && this.lookahead == 0)
-        return false;
-      this.strstart += this.lookahead;
-      this.lookahead = 0;
-      int storedLength = this.strstart - this.blockStart;
-      if (storedLength < DeflaterConstants.MAX_BLOCK_SIZE && (this.blockStart >= 32768 || storedLength < 32506) && !flush)
-        return true;
-      bool lastBlock = finish;
-      if (storedLength > DeflaterConstants.MAX_BLOCK_SIZE)
-      {
-        storedLength = DeflaterConstants.MAX_BLOCK_SIZE;
-        lastBlock = false;
-      }
-      this.huffman.FlushStoredBlock(this.window, this.blockStart, storedLength, lastBlock);
-      this.blockStart += storedLength;
-      return !lastBlock;
-    }
-
-    private bool DeflateFast(bool flush, bool finish)
-    {
-      if (this.lookahead < 262 && !flush)
-        return false;
-      while (this.lookahead >= 262 || flush)
-      {
-        if (this.lookahead == 0)
-        {
-          this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, finish);
-          this.blockStart = this.strstart;
-          return false;
-        }
-        if (this.strstart > 65274)
-          this.SlideWindow();
-        int curMatch;
-        if (this.lookahead >= 3 && (curMatch = this.InsertString()) != 0 && this.strategy != DeflateStrategy.HuffmanOnly && this.strstart - curMatch <= 32506 && this.FindLongestMatch(curMatch))
-        {
-          bool flag = this.huffman.TallyDist(this.strstart - this.matchStart, this.matchLen);
-          this.lookahead -= this.matchLen;
-          if (this.matchLen <= this.max_lazy && this.lookahead >= 3)
-          {
-            while (--this.matchLen > 0)
-            {
-              ++this.strstart;
-              this.InsertString();
-            }
-            ++this.strstart;
-          }
-          else
-          {
-            this.strstart += this.matchLen;
-            if (this.lookahead >= 2)
-              this.UpdateHash();
-          }
-          this.matchLen = 2;
-          if (!flag)
-            continue;
-        }
-        else
-        {
-          this.huffman.TallyLit((int) this.window[this.strstart] & (int) byte.MaxValue);
-          ++this.strstart;
-          --this.lookahead;
-        }
-        if (this.huffman.IsFull())
-        {
-          bool lastBlock = finish && this.lookahead == 0;
-          this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, lastBlock);
-          this.blockStart = this.strstart;
-          return !lastBlock;
-        }
-      }
-      return true;
-    }
-
-    private bool DeflateSlow(bool flush, bool finish)
-    {
-      if (this.lookahead < 262 && !flush)
-        return false;
-      while (this.lookahead >= 262 || flush)
-      {
-        if (this.lookahead == 0)
-        {
-          if (this.prevAvailable)
-            this.huffman.TallyLit((int) this.window[this.strstart - 1] & (int) byte.MaxValue);
-          this.prevAvailable = false;
-          this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, finish);
-          this.blockStart = this.strstart;
-          return false;
-        }
-        if (this.strstart >= 65274)
-          this.SlideWindow();
-        int matchStart = this.matchStart;
-        int matchLen = this.matchLen;
-        if (this.lookahead >= 3)
-        {
-          int curMatch = this.InsertString();
-          if (this.strategy != DeflateStrategy.HuffmanOnly && curMatch != 0 && this.strstart - curMatch <= 32506 && this.FindLongestMatch(curMatch) && this.matchLen <= 5 && (this.strategy == DeflateStrategy.Filtered || this.matchLen == 3 && this.strstart - this.matchStart > 4096))
-            this.matchLen = 2;
-        }
-        if (matchLen >= 3 && this.matchLen <= matchLen)
-        {
-          this.huffman.TallyDist(this.strstart - 1 - matchStart, matchLen);
-          int num = matchLen - 2;
-          do
-          {
-            ++this.strstart;
-            --this.lookahead;
-            if (this.lookahead >= 3)
-              this.InsertString();
-          }
-          while (--num > 0);
-          ++this.strstart;
-          --this.lookahead;
-          this.prevAvailable = false;
-          this.matchLen = 2;
-        }
-        else
-        {
-          if (this.prevAvailable)
-            this.huffman.TallyLit((int) this.window[this.strstart - 1] & (int) byte.MaxValue);
-          this.prevAvailable = true;
-          ++this.strstart;
-          --this.lookahead;
-        }
-        if (this.huffman.IsFull())
-        {
-          int storedLength = this.strstart - this.blockStart;
-          if (this.prevAvailable)
-            --storedLength;
-          bool lastBlock = finish && this.lookahead == 0 && !this.prevAvailable;
-          this.huffman.FlushBlock(this.window, this.blockStart, storedLength, lastBlock);
-          this.blockStart += storedLength;
-          return !lastBlock;
-        }
-      }
-      return true;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterHuffman.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterHuffman.cs
deleted file mode 100644
index 1c25feb..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterHuffman.cs
+++ /dev/null
@@ -1,582 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class DeflaterHuffman
-  {
-    private const int BUFSIZE = 16384;
-    private const int LITERAL_NUM = 286;
-    private const int DIST_NUM = 30;
-    private const int BITLEN_NUM = 19;
-    private const int REP_3_6 = 16;
-    private const int REP_3_10 = 17;
-    private const int REP_11_138 = 18;
-    private const int EOF_SYMBOL = 256;
-    private static readonly int[] BL_ORDER = new int[19]
-    {
-      16,
-      17,
-      18,
-      0,
-      8,
-      7,
-      9,
-      6,
-      10,
-      5,
-      11,
-      4,
-      12,
-      3,
-      13,
-      2,
-      14,
-      1,
-      15
-    };
-    private static readonly byte[] bit4Reverse = new byte[16]
-    {
-      (byte) 0,
-      (byte) 8,
-      (byte) 4,
-      (byte) 12,
-      (byte) 2,
-      (byte) 10,
-      (byte) 6,
-      (byte) 14,
-      (byte) 1,
-      (byte) 9,
-      (byte) 5,
-      (byte) 13,
-      (byte) 3,
-      (byte) 11,
-      (byte) 7,
-      (byte) 15
-    };
-    private static short[] staticLCodes = new short[286];
-    private static byte[] staticLLength = new byte[286];
-    private static short[] staticDCodes;
-    private static byte[] staticDLength;
-    public DeflaterPending pending;
-    private DeflaterHuffman.Tree literalTree;
-    private DeflaterHuffman.Tree distTree;
-    private DeflaterHuffman.Tree blTree;
-    private short[] d_buf;
-    private byte[] l_buf;
-    private int last_lit;
-    private int extra_bits;
-
-    static DeflaterHuffman()
-    {
-      int index1;
-      for (index1 = 0; index1 < 144; DeflaterHuffman.staticLLength[index1++] = (byte) 8)
-        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(48 + index1 << 8);
-      for (; index1 < 256; DeflaterHuffman.staticLLength[index1++] = (byte) 9)
-        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(256 + index1 << 7);
-      for (; index1 < 280; DeflaterHuffman.staticLLength[index1++] = (byte) 7)
-        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(index1 - 256 << 9);
-      for (; index1 < 286; DeflaterHuffman.staticLLength[index1++] = (byte) 8)
-        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(index1 - 88 << 8);
-      DeflaterHuffman.staticDCodes = new short[30];
-      DeflaterHuffman.staticDLength = new byte[30];
-      for (int index2 = 0; index2 < 30; ++index2)
-      {
-        DeflaterHuffman.staticDCodes[index2] = DeflaterHuffman.BitReverse(index2 << 11);
-        DeflaterHuffman.staticDLength[index2] = (byte) 5;
-      }
-    }
-
-    public DeflaterHuffman(DeflaterPending pending)
-    {
-      this.pending = pending;
-      this.literalTree = new DeflaterHuffman.Tree(this, 286, 257, 15);
-      this.distTree = new DeflaterHuffman.Tree(this, 30, 1, 15);
-      this.blTree = new DeflaterHuffman.Tree(this, 19, 4, 7);
-      this.d_buf = new short[16384];
-      this.l_buf = new byte[16384];
-    }
-
-    public void Reset()
-    {
-      this.last_lit = 0;
-      this.extra_bits = 0;
-      this.literalTree.Reset();
-      this.distTree.Reset();
-      this.blTree.Reset();
-    }
-
-    public void SendAllTrees(int blTreeCodes)
-    {
-      this.blTree.BuildCodes();
-      this.literalTree.BuildCodes();
-      this.distTree.BuildCodes();
-      this.pending.WriteBits(this.literalTree.numCodes - 257, 5);
-      this.pending.WriteBits(this.distTree.numCodes - 1, 5);
-      this.pending.WriteBits(blTreeCodes - 4, 4);
-      for (int index = 0; index < blTreeCodes; ++index)
-        this.pending.WriteBits((int) this.blTree.length[DeflaterHuffman.BL_ORDER[index]], 3);
-      this.literalTree.WriteTree(this.blTree);
-      this.distTree.WriteTree(this.blTree);
-    }
-
-    public void CompressBlock()
-    {
-      for (int index = 0; index < this.last_lit; ++index)
-      {
-        int num1 = (int) this.l_buf[index] & (int) byte.MaxValue;
-        int num2 = (int) this.d_buf[index];
-        int distance = num2 - 1;
-        if (num2 != 0)
-        {
-          int code1 = DeflaterHuffman.Lcode(num1);
-          this.literalTree.WriteSymbol(code1);
-          int count1 = (code1 - 261) / 4;
-          if (count1 > 0 && count1 <= 5)
-            this.pending.WriteBits(num1 & (1 << count1) - 1, count1);
-          int code2 = DeflaterHuffman.Dcode(distance);
-          this.distTree.WriteSymbol(code2);
-          int count2 = code2 / 2 - 1;
-          if (count2 > 0)
-            this.pending.WriteBits(distance & (1 << count2) - 1, count2);
-        }
-        else
-          this.literalTree.WriteSymbol(num1);
-      }
-      this.literalTree.WriteSymbol(256);
-    }
-
-    public void FlushStoredBlock(
-      byte[] stored,
-      int storedOffset,
-      int storedLength,
-      bool lastBlock)
-    {
-      this.pending.WriteBits(lastBlock ? 1 : 0, 3);
-      this.pending.AlignToByte();
-      this.pending.WriteShort(storedLength);
-      this.pending.WriteShort(~storedLength);
-      this.pending.WriteBlock(stored, storedOffset, storedLength);
-      this.Reset();
-    }
-
-    public void FlushBlock(byte[] stored, int storedOffset, int storedLength, bool lastBlock)
-    {
-      ++this.literalTree.freqs[256];
-      this.literalTree.BuildTree();
-      this.distTree.BuildTree();
-      this.literalTree.CalcBLFreq(this.blTree);
-      this.distTree.CalcBLFreq(this.blTree);
-      this.blTree.BuildTree();
-      int blTreeCodes = 4;
-      for (int index = 18; index > blTreeCodes; --index)
-      {
-        if (this.blTree.length[DeflaterHuffman.BL_ORDER[index]] > (byte) 0)
-          blTreeCodes = index + 1;
-      }
-      int num = 14 + blTreeCodes * 3 + this.blTree.GetEncodedLength() + this.literalTree.GetEncodedLength() + this.distTree.GetEncodedLength() + this.extra_bits;
-      int extraBits = this.extra_bits;
-      for (int index = 0; index < 286; ++index)
-        extraBits += (int) this.literalTree.freqs[index] * (int) DeflaterHuffman.staticLLength[index];
-      for (int index = 0; index < 30; ++index)
-        extraBits += (int) this.distTree.freqs[index] * (int) DeflaterHuffman.staticDLength[index];
-      if (num >= extraBits)
-        num = extraBits;
-      if (storedOffset >= 0 && storedLength + 4 < num >> 3)
-        this.FlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
-      else if (num == extraBits)
-      {
-        this.pending.WriteBits(2 + (lastBlock ? 1 : 0), 3);
-        this.literalTree.SetStaticCodes(DeflaterHuffman.staticLCodes, DeflaterHuffman.staticLLength);
-        this.distTree.SetStaticCodes(DeflaterHuffman.staticDCodes, DeflaterHuffman.staticDLength);
-        this.CompressBlock();
-        this.Reset();
-      }
-      else
-      {
-        this.pending.WriteBits(4 + (lastBlock ? 1 : 0), 3);
-        this.SendAllTrees(blTreeCodes);
-        this.CompressBlock();
-        this.Reset();
-      }
-    }
-
-    public bool IsFull() => this.last_lit >= 16384;
-
-    public bool TallyLit(int literal)
-    {
-      this.d_buf[this.last_lit] = (short) 0;
-      this.l_buf[this.last_lit++] = (byte) literal;
-      ++this.literalTree.freqs[literal];
-      return this.IsFull();
-    }
-
-    public bool TallyDist(int distance, int length)
-    {
-      this.d_buf[this.last_lit] = (short) distance;
-      this.l_buf[this.last_lit++] = (byte) (length - 3);
-      int index1 = DeflaterHuffman.Lcode(length - 3);
-      ++this.literalTree.freqs[index1];
-      if (index1 >= 265 && index1 < 285)
-        this.extra_bits += (index1 - 261) / 4;
-      int index2 = DeflaterHuffman.Dcode(distance - 1);
-      ++this.distTree.freqs[index2];
-      if (index2 >= 4)
-        this.extra_bits += index2 / 2 - 1;
-      return this.IsFull();
-    }
-
-    public static short BitReverse(int toReverse)
-    {
-      return (short) ((int) DeflaterHuffman.bit4Reverse[toReverse & 15] << 12 | (int) DeflaterHuffman.bit4Reverse[toReverse >> 4 & 15] << 8 | (int) DeflaterHuffman.bit4Reverse[toReverse >> 8 & 15] << 4 | (int) DeflaterHuffman.bit4Reverse[toReverse >> 12]);
-    }
-
-    private static int Lcode(int length)
-    {
-      if (length == (int) byte.MaxValue)
-        return 285;
-      int num = 257;
-      for (; length >= 8; length >>= 1)
-        num += 4;
-      return num + length;
-    }
-
-    private static int Dcode(int distance)
-    {
-      int num = 0;
-      for (; distance >= 4; distance >>= 1)
-        num += 2;
-      return num + distance;
-    }
-
-    private class Tree
-    {
-      public short[] freqs;
-      public byte[] length;
-      public int minNumCodes;
-      public int numCodes;
-      private short[] codes;
-      private int[] bl_counts;
-      private int maxLength;
-      private DeflaterHuffman dh;
-
-      public Tree(DeflaterHuffman dh, int elems, int minCodes, int maxLength)
-      {
-        this.dh = dh;
-        this.minNumCodes = minCodes;
-        this.maxLength = maxLength;
-        this.freqs = new short[elems];
-        this.bl_counts = new int[maxLength];
-      }
-
-      public void Reset()
-      {
-        for (int index = 0; index < this.freqs.Length; ++index)
-          this.freqs[index] = (short) 0;
-        this.codes = (short[]) null;
-        this.length = (byte[]) null;
-      }
-
-      public void WriteSymbol(int code)
-      {
-        this.dh.pending.WriteBits((int) this.codes[code] & (int) ushort.MaxValue, (int) this.length[code]);
-      }
-
-      public void CheckEmpty()
-      {
-        bool flag = true;
-        for (int index = 0; index < this.freqs.Length; ++index)
-        {
-          if (this.freqs[index] != (short) 0)
-            flag = false;
-        }
-        if (!flag)
-          throw new SharpZipBaseException("!Empty");
-      }
-
-      public void SetStaticCodes(short[] staticCodes, byte[] staticLengths)
-      {
-        this.codes = staticCodes;
-        this.length = staticLengths;
-      }
-
-      public void BuildCodes()
-      {
-        int length = this.freqs.Length;
-        int[] numArray = new int[this.maxLength];
-        int num1 = 0;
-        this.codes = new short[this.freqs.Length];
-        for (int index = 0; index < this.maxLength; ++index)
-        {
-          numArray[index] = num1;
-          num1 += this.bl_counts[index] << 15 - index;
-        }
-        for (int index = 0; index < this.numCodes; ++index)
-        {
-          int num2 = (int) this.length[index];
-          if (num2 > 0)
-          {
-            this.codes[index] = DeflaterHuffman.BitReverse(numArray[num2 - 1]);
-            numArray[num2 - 1] += 1 << 16 - num2;
-          }
-        }
-      }
-
-      public void BuildTree()
-      {
-        int length = this.freqs.Length;
-        int[] numArray1 = new int[length];
-        int num1 = 0;
-        int num2 = 0;
-        for (int index1 = 0; index1 < length; ++index1)
-        {
-          int freq = (int) this.freqs[index1];
-          if (freq != 0)
-          {
-            int index2;
-            int index3;
-            for (index2 = num1++; index2 > 0 && (int) this.freqs[numArray1[index3 = (index2 - 1) / 2]] > freq; index2 = index3)
-              numArray1[index2] = numArray1[index3];
-            numArray1[index2] = index1;
-            num2 = index1;
-          }
-        }
-        int num3;
-        for (; num1 < 2; numArray1[num1++] = num3)
-        {
-          int num4;
-          if (num2 >= 2)
-            num4 = 0;
-          else
-            num2 = num4 = num2 + 1;
-          num3 = num4;
-        }
-        this.numCodes = Math.Max(num2 + 1, this.minNumCodes);
-        int num5 = num1;
-        int[] childs = new int[4 * num1 - 2];
-        int[] numArray2 = new int[2 * num1 - 1];
-        int num6 = num5;
-        for (int index4 = 0; index4 < num1; ++index4)
-        {
-          int index5 = numArray1[index4];
-          childs[2 * index4] = index5;
-          childs[2 * index4 + 1] = -1;
-          numArray2[index4] = (int) this.freqs[index5] << 8;
-          numArray1[index4] = index4;
-        }
-        do
-        {
-          int index6 = numArray1[0];
-          int index7 = numArray1[--num1];
-          int index8 = 0;
-          for (int index9 = 1; index9 < num1; index9 = index9 * 2 + 1)
-          {
-            if (index9 + 1 < num1 && numArray2[numArray1[index9]] > numArray2[numArray1[index9 + 1]])
-              ++index9;
-            numArray1[index8] = numArray1[index9];
-            index8 = index9;
-          }
-          int num7 = numArray2[index7];
-          int index10;
-          while ((index10 = index8) > 0 && numArray2[numArray1[index8 = (index10 - 1) / 2]] > num7)
-            numArray1[index10] = numArray1[index8];
-          numArray1[index10] = index7;
-          int index11 = numArray1[0];
-          int index12 = num6++;
-          childs[2 * index12] = index6;
-          childs[2 * index12 + 1] = index11;
-          int num8 = Math.Min(numArray2[index6] & (int) byte.MaxValue, numArray2[index11] & (int) byte.MaxValue);
-          int num9;
-          numArray2[index12] = num9 = numArray2[index6] + numArray2[index11] - num8 + 1;
-          int index13 = 0;
-          for (int index14 = 1; index14 < num1; index14 = index13 * 2 + 1)
-          {
-            if (index14 + 1 < num1 && numArray2[numArray1[index14]] > numArray2[numArray1[index14 + 1]])
-              ++index14;
-            numArray1[index13] = numArray1[index14];
-            index13 = index14;
-          }
-          int index15;
-          while ((index15 = index13) > 0 && numArray2[numArray1[index13 = (index15 - 1) / 2]] > num9)
-            numArray1[index15] = numArray1[index13];
-          numArray1[index15] = index12;
-        }
-        while (num1 > 1);
-        if (numArray1[0] != childs.Length / 2 - 1)
-          throw new SharpZipBaseException("Heap invariant violated");
-        this.BuildLength(childs);
-      }
-
-      public int GetEncodedLength()
-      {
-        int encodedLength = 0;
-        for (int index = 0; index < this.freqs.Length; ++index)
-          encodedLength += (int) this.freqs[index] * (int) this.length[index];
-        return encodedLength;
-      }
-
-      public void CalcBLFreq(DeflaterHuffman.Tree blTree)
-      {
-        int index1 = -1;
-        int index2 = 0;
-        while (index2 < this.numCodes)
-        {
-          int num1 = 1;
-          int index3 = (int) this.length[index2];
-          int num2;
-          int num3;
-          if (index3 == 0)
-          {
-            num2 = 138;
-            num3 = 3;
-          }
-          else
-          {
-            num2 = 6;
-            num3 = 3;
-            if (index1 != index3)
-            {
-              ++blTree.freqs[index3];
-              num1 = 0;
-            }
-          }
-          index1 = index3;
-          ++index2;
-          while (index2 < this.numCodes && index1 == (int) this.length[index2])
-          {
-            ++index2;
-            if (++num1 >= num2)
-              break;
-          }
-          if (num1 < num3)
-            blTree.freqs[index1] += (short) num1;
-          else if (index1 != 0)
-            ++blTree.freqs[16];
-          else if (num1 <= 10)
-            ++blTree.freqs[17];
-          else
-            ++blTree.freqs[18];
-        }
-      }
-
-      public void WriteTree(DeflaterHuffman.Tree blTree)
-      {
-        int code1 = -1;
-        int index = 0;
-        while (index < this.numCodes)
-        {
-          int num1 = 1;
-          int code2 = (int) this.length[index];
-          int num2;
-          int num3;
-          if (code2 == 0)
-          {
-            num2 = 138;
-            num3 = 3;
-          }
-          else
-          {
-            num2 = 6;
-            num3 = 3;
-            if (code1 != code2)
-            {
-              blTree.WriteSymbol(code2);
-              num1 = 0;
-            }
-          }
-          code1 = code2;
-          ++index;
-          while (index < this.numCodes && code1 == (int) this.length[index])
-          {
-            ++index;
-            if (++num1 >= num2)
-              break;
-          }
-          if (num1 < num3)
-          {
-            while (num1-- > 0)
-              blTree.WriteSymbol(code1);
-          }
-          else if (code1 != 0)
-          {
-            blTree.WriteSymbol(16);
-            this.dh.pending.WriteBits(num1 - 3, 2);
-          }
-          else if (num1 <= 10)
-          {
-            blTree.WriteSymbol(17);
-            this.dh.pending.WriteBits(num1 - 3, 3);
-          }
-          else
-          {
-            blTree.WriteSymbol(18);
-            this.dh.pending.WriteBits(num1 - 11, 7);
-          }
-        }
-      }
-
-      private void BuildLength(int[] childs)
-      {
-        this.length = new byte[this.freqs.Length];
-        int length = childs.Length / 2;
-        int num1 = (length + 1) / 2;
-        int num2 = 0;
-        for (int index = 0; index < this.maxLength; ++index)
-          this.bl_counts[index] = 0;
-        int[] numArray = new int[length];
-        numArray[length - 1] = 0;
-        for (int index = length - 1; index >= 0; --index)
-        {
-          if (childs[2 * index + 1] != -1)
-          {
-            int num3 = numArray[index] + 1;
-            if (num3 > this.maxLength)
-            {
-              num3 = this.maxLength;
-              ++num2;
-            }
-            numArray[childs[2 * index]] = numArray[childs[2 * index + 1]] = num3;
-          }
-          else
-          {
-            ++this.bl_counts[numArray[index] - 1];
-            this.length[childs[2 * index]] = (byte) numArray[index];
-          }
-        }
-        if (num2 == 0)
-          return;
-        int index1 = this.maxLength - 1;
-        do
-        {
-          do
-            ;
-          while (this.bl_counts[--index1] == 0);
-          do
-          {
-            --this.bl_counts[index1];
-            ++this.bl_counts[++index1];
-            num2 -= 1 << this.maxLength - 1 - index1;
-          }
-          while (num2 > 0 && index1 < this.maxLength - 1);
-        }
-        while (num2 > 0);
-        this.bl_counts[this.maxLength - 1] += num2;
-        this.bl_counts[this.maxLength - 2] -= num2;
-        int num4 = 2 * num1;
-        for (int maxLength = this.maxLength; maxLength != 0; --maxLength)
-        {
-          int blCount = this.bl_counts[maxLength - 1];
-          while (blCount > 0)
-          {
-            int index2 = 2 * childs[num4++];
-            if (childs[index2 + 1] == -1)
-            {
-              this.length[childs[index2]] = (byte) maxLength;
-              --blCount;
-            }
-          }
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterPending.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterPending.cs
deleted file mode 100644
index 8b2c620..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterPending.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class DeflaterPending : PendingBuffer
-  {
-    public DeflaterPending()
-      : base(65536)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Inflater.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Inflater.cs
deleted file mode 100644
index 97c5e67..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Inflater.cs
+++ /dev/null
@@ -1,504 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class Inflater
-  {
-    private const int DECODE_HEADER = 0;
-    private const int DECODE_DICT = 1;
-    private const int DECODE_BLOCKS = 2;
-    private const int DECODE_STORED_LEN1 = 3;
-    private const int DECODE_STORED_LEN2 = 4;
-    private const int DECODE_STORED = 5;
-    private const int DECODE_DYN_HEADER = 6;
-    private const int DECODE_HUFFMAN = 7;
-    private const int DECODE_HUFFMAN_LENBITS = 8;
-    private const int DECODE_HUFFMAN_DIST = 9;
-    private const int DECODE_HUFFMAN_DISTBITS = 10;
-    private const int DECODE_CHKSUM = 11;
-    private const int FINISHED = 12;
-    private static readonly int[] CPLENS = new int[29]
-    {
-      3,
-      4,
-      5,
-      6,
-      7,
-      8,
-      9,
-      10,
-      11,
-      13,
-      15,
-      17,
-      19,
-      23,
-      27,
-      31,
-      35,
-      43,
-      51,
-      59,
-      67,
-      83,
-      99,
-      115,
-      131,
-      163,
-      195,
-      227,
-      258
-    };
-    private static readonly int[] CPLEXT = new int[29]
-    {
-      0,
-      0,
-      0,
-      0,
-      0,
-      0,
-      0,
-      0,
-      1,
-      1,
-      1,
-      1,
-      2,
-      2,
-      2,
-      2,
-      3,
-      3,
-      3,
-      3,
-      4,
-      4,
-      4,
-      4,
-      5,
-      5,
-      5,
-      5,
-      0
-    };
-    private static readonly int[] CPDIST = new int[30]
-    {
-      1,
-      2,
-      3,
-      4,
-      5,
-      7,
-      9,
-      13,
-      17,
-      25,
-      33,
-      49,
-      65,
-      97,
-      129,
-      193,
-      257,
-      385,
-      513,
-      769,
-      1025,
-      1537,
-      2049,
-      3073,
-      4097,
-      6145,
-      8193,
-      12289,
-      16385,
-      24577
-    };
-    private static readonly int[] CPDEXT = new int[30]
-    {
-      0,
-      0,
-      0,
-      0,
-      1,
-      1,
-      2,
-      2,
-      3,
-      3,
-      4,
-      4,
-      5,
-      5,
-      6,
-      6,
-      7,
-      7,
-      8,
-      8,
-      9,
-      9,
-      10,
-      10,
-      11,
-      11,
-      12,
-      12,
-      13,
-      13
-    };
-    private int mode;
-    private int readAdler;
-    private int neededBits;
-    private int repLength;
-    private int repDist;
-    private int uncomprLen;
-    private bool isLastBlock;
-    private long totalOut;
-    private long totalIn;
-    private bool noHeader;
-    private StreamManipulator input;
-    private OutputWindow outputWindow;
-    private InflaterDynHeader dynHeader;
-    private InflaterHuffmanTree litlenTree;
-    private InflaterHuffmanTree distTree;
-    private Adler32 adler;
-
-    public Inflater()
-      : this(false)
-    {
-    }
-
-    public Inflater(bool noHeader)
-    {
-      this.noHeader = noHeader;
-      this.adler = new Adler32();
-      this.input = new StreamManipulator();
-      this.outputWindow = new OutputWindow();
-      this.mode = noHeader ? 2 : 0;
-    }
-
-    public void Reset()
-    {
-      this.mode = this.noHeader ? 2 : 0;
-      this.totalIn = 0L;
-      this.totalOut = 0L;
-      this.input.Reset();
-      this.outputWindow.Reset();
-      this.dynHeader = (InflaterDynHeader) null;
-      this.litlenTree = (InflaterHuffmanTree) null;
-      this.distTree = (InflaterHuffmanTree) null;
-      this.isLastBlock = false;
-      this.adler.Reset();
-    }
-
-    private bool DecodeHeader()
-    {
-      int num1 = this.input.PeekBits(16);
-      if (num1 < 0)
-        return false;
-      this.input.DropBits(16);
-      int num2 = (num1 << 8 | num1 >> 8) & (int) ushort.MaxValue;
-      if (num2 % 31 != 0)
-        throw new SharpZipBaseException("Header checksum illegal");
-      if ((num2 & 3840) != 2048)
-        throw new SharpZipBaseException("Compression Method unknown");
-      if ((num2 & 32) == 0)
-      {
-        this.mode = 2;
-      }
-      else
-      {
-        this.mode = 1;
-        this.neededBits = 32;
-      }
-      return true;
-    }
-
-    private bool DecodeDict()
-    {
-      for (; this.neededBits > 0; this.neededBits -= 8)
-      {
-        int num = this.input.PeekBits(8);
-        if (num < 0)
-          return false;
-        this.input.DropBits(8);
-        this.readAdler = this.readAdler << 8 | num;
-      }
-      return false;
-    }
-
-    private bool DecodeHuffman()
-    {
-      int freeSpace = this.outputWindow.GetFreeSpace();
-      while (freeSpace >= 258)
-      {
-        switch (this.mode)
-        {
-          case 7:
-            int symbol1;
-            while (((symbol1 = this.litlenTree.GetSymbol(this.input)) & -256) == 0)
-            {
-              this.outputWindow.Write(symbol1);
-              if (--freeSpace < 258)
-                return true;
-            }
-            if (symbol1 < 257)
-            {
-              if (symbol1 < 0)
-                return false;
-              this.distTree = (InflaterHuffmanTree) null;
-              this.litlenTree = (InflaterHuffmanTree) null;
-              this.mode = 2;
-              return true;
-            }
-            try
-            {
-              this.repLength = Inflater.CPLENS[symbol1 - 257];
-              this.neededBits = Inflater.CPLEXT[symbol1 - 257];
-              goto case 8;
-            }
-            catch (Exception ex)
-            {
-              throw new SharpZipBaseException("Illegal rep length code");
-            }
-          case 8:
-            if (this.neededBits > 0)
-            {
-              this.mode = 8;
-              int num = this.input.PeekBits(this.neededBits);
-              if (num < 0)
-                return false;
-              this.input.DropBits(this.neededBits);
-              this.repLength += num;
-            }
-            this.mode = 9;
-            goto case 9;
-          case 9:
-            int symbol2 = this.distTree.GetSymbol(this.input);
-            if (symbol2 < 0)
-              return false;
-            try
-            {
-              this.repDist = Inflater.CPDIST[symbol2];
-              this.neededBits = Inflater.CPDEXT[symbol2];
-              goto case 10;
-            }
-            catch (Exception ex)
-            {
-              throw new SharpZipBaseException("Illegal rep dist code");
-            }
-          case 10:
-            if (this.neededBits > 0)
-            {
-              this.mode = 10;
-              int num = this.input.PeekBits(this.neededBits);
-              if (num < 0)
-                return false;
-              this.input.DropBits(this.neededBits);
-              this.repDist += num;
-            }
-            this.outputWindow.Repeat(this.repLength, this.repDist);
-            freeSpace -= this.repLength;
-            this.mode = 7;
-            continue;
-          default:
-            throw new SharpZipBaseException("Inflater unknown mode");
-        }
-      }
-      return true;
-    }
-
-    private bool DecodeChksum()
-    {
-      for (; this.neededBits > 0; this.neededBits -= 8)
-      {
-        int num = this.input.PeekBits(8);
-        if (num < 0)
-          return false;
-        this.input.DropBits(8);
-        this.readAdler = this.readAdler << 8 | num;
-      }
-      if ((int) this.adler.Value != this.readAdler)
-        throw new SharpZipBaseException("Adler chksum doesn't match: " + (object) (int) this.adler.Value + " vs. " + (object) this.readAdler);
-      this.mode = 12;
-      return false;
-    }
-
-    private bool Decode()
-    {
-      switch (this.mode)
-      {
-        case 0:
-          return this.DecodeHeader();
-        case 1:
-          return this.DecodeDict();
-        case 2:
-          if (this.isLastBlock)
-          {
-            if (this.noHeader)
-            {
-              this.mode = 12;
-              return false;
-            }
-            this.input.SkipToByteBoundary();
-            this.neededBits = 32;
-            this.mode = 11;
-            return true;
-          }
-          int num1 = this.input.PeekBits(3);
-          if (num1 < 0)
-            return false;
-          this.input.DropBits(3);
-          if ((num1 & 1) != 0)
-            this.isLastBlock = true;
-          switch (num1 >> 1)
-          {
-            case 0:
-              this.input.SkipToByteBoundary();
-              this.mode = 3;
-              break;
-            case 1:
-              this.litlenTree = InflaterHuffmanTree.defLitLenTree;
-              this.distTree = InflaterHuffmanTree.defDistTree;
-              this.mode = 7;
-              break;
-            case 2:
-              this.dynHeader = new InflaterDynHeader();
-              this.mode = 6;
-              break;
-            default:
-              throw new SharpZipBaseException("Unknown block type " + (object) num1);
-          }
-          return true;
-        case 3:
-          if ((this.uncomprLen = this.input.PeekBits(16)) < 0)
-            return false;
-          this.input.DropBits(16);
-          this.mode = 4;
-          goto case 4;
-        case 4:
-          int num2 = this.input.PeekBits(16);
-          if (num2 < 0)
-            return false;
-          this.input.DropBits(16);
-          if (num2 != (this.uncomprLen ^ (int) ushort.MaxValue))
-            throw new SharpZipBaseException("broken uncompressed block");
-          this.mode = 5;
-          goto case 5;
-        case 5:
-          this.uncomprLen -= this.outputWindow.CopyStored(this.input, this.uncomprLen);
-          if (this.uncomprLen != 0)
-            return !this.input.IsNeedingInput;
-          this.mode = 2;
-          return true;
-        case 6:
-          if (!this.dynHeader.Decode(this.input))
-            return false;
-          this.litlenTree = this.dynHeader.BuildLitLenTree();
-          this.distTree = this.dynHeader.BuildDistTree();
-          this.mode = 7;
-          goto case 7;
-        case 7:
-        case 8:
-        case 9:
-        case 10:
-          return this.DecodeHuffman();
-        case 11:
-          return this.DecodeChksum();
-        case 12:
-          return false;
-        default:
-          throw new SharpZipBaseException("Inflater.Decode unknown mode");
-      }
-    }
-
-    public void SetDictionary(byte[] buffer) => this.SetDictionary(buffer, 0, buffer.Length);
-
-    public void SetDictionary(byte[] buffer, int index, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (index < 0)
-        throw new ArgumentOutOfRangeException(nameof (index));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (!this.IsNeedingDictionary)
-        throw new InvalidOperationException("Dictionary is not needed");
-      this.adler.Update(buffer, index, count);
-      if ((int) this.adler.Value != this.readAdler)
-        throw new SharpZipBaseException("Wrong adler checksum");
-      this.adler.Reset();
-      this.outputWindow.CopyDict(buffer, index, count);
-      this.mode = 2;
-    }
-
-    public void SetInput(byte[] buffer) => this.SetInput(buffer, 0, buffer.Length);
-
-    public void SetInput(byte[] buffer, int index, int count)
-    {
-      this.input.SetInput(buffer, index, count);
-      this.totalIn += (long) count;
-    }
-
-    public int Inflate(byte[] buffer)
-    {
-      return buffer != null ? this.Inflate(buffer, 0, buffer.Length) : throw new ArgumentNullException(nameof (buffer));
-    }
-
-    public int Inflate(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "count cannot be negative");
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "offset cannot be negative");
-      if (offset + count > buffer.Length)
-        throw new ArgumentException("count exceeds buffer bounds");
-      if (count == 0)
-      {
-        if (!this.IsFinished)
-          this.Decode();
-        return 0;
-      }
-      int num = 0;
-      do
-      {
-        if (this.mode != 11)
-        {
-          int count1 = this.outputWindow.CopyOutput(buffer, offset, count);
-          if (count1 > 0)
-          {
-            this.adler.Update(buffer, offset, count1);
-            offset += count1;
-            num += count1;
-            this.totalOut += (long) count1;
-            count -= count1;
-            if (count == 0)
-              return num;
-          }
-        }
-      }
-      while (this.Decode() || this.outputWindow.GetAvailable() > 0 && this.mode != 11);
-      return num;
-    }
-
-    public bool IsNeedingInput => this.input.IsNeedingInput;
-
-    public bool IsNeedingDictionary => this.mode == 1 && this.neededBits == 0;
-
-    public bool IsFinished => this.mode == 12 && this.outputWindow.GetAvailable() == 0;
-
-    public int Adler => !this.IsNeedingDictionary ? (int) this.adler.Value : this.readAdler;
-
-    public long TotalOut => this.totalOut;
-
-    public long TotalIn => this.totalIn - (long) this.RemainingInput;
-
-    public int RemainingInput => this.input.AvailableBytes;
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/InflaterDynHeader.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/InflaterDynHeader.cs
deleted file mode 100644
index c8da1b9..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/InflaterDynHeader.cs
+++ /dev/null
@@ -1,197 +0,0 @@
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  internal class InflaterDynHeader
-  {
-    private const int LNUM = 0;
-    private const int DNUM = 1;
-    private const int BLNUM = 2;
-    private const int BLLENS = 3;
-    private const int LENS = 4;
-    private const int REPS = 5;
-    private static readonly int[] repMin = new int[3]
-    {
-      3,
-      3,
-      11
-    };
-    private static readonly int[] repBits = new int[3]
-    {
-      2,
-      3,
-      7
-    };
-    private static readonly int[] BL_ORDER = new int[19]
-    {
-      16,
-      17,
-      18,
-      0,
-      8,
-      7,
-      9,
-      6,
-      10,
-      5,
-      11,
-      4,
-      12,
-      3,
-      13,
-      2,
-      14,
-      1,
-      15
-    };
-    private byte[] blLens;
-    private byte[] litdistLens;
-    private InflaterHuffmanTree blTree;
-    private int mode;
-    private int lnum;
-    private int dnum;
-    private int blnum;
-    private int num;
-    private int repSymbol;
-    private byte lastLen;
-    private int ptr;
-
-    public bool Decode(StreamManipulator input)
-    {
-      while (true)
-      {
-        switch (this.mode)
-        {
-          case 0:
-            this.lnum = input.PeekBits(5);
-            if (this.lnum >= 0)
-            {
-              this.lnum += 257;
-              input.DropBits(5);
-              this.mode = 1;
-              goto case 1;
-            }
-            else
-              goto label_2;
-          case 1:
-            this.dnum = input.PeekBits(5);
-            if (this.dnum >= 0)
-            {
-              ++this.dnum;
-              input.DropBits(5);
-              this.num = this.lnum + this.dnum;
-              this.litdistLens = new byte[this.num];
-              this.mode = 2;
-              goto case 2;
-            }
-            else
-              goto label_5;
-          case 2:
-            this.blnum = input.PeekBits(4);
-            if (this.blnum >= 0)
-            {
-              this.blnum += 4;
-              input.DropBits(4);
-              this.blLens = new byte[19];
-              this.ptr = 0;
-              this.mode = 3;
-              goto case 3;
-            }
-            else
-              goto label_8;
-          case 3:
-            for (; this.ptr < this.blnum; ++this.ptr)
-            {
-              int num = input.PeekBits(3);
-              if (num < 0)
-                return false;
-              input.DropBits(3);
-              this.blLens[InflaterDynHeader.BL_ORDER[this.ptr]] = (byte) num;
-            }
-            this.blTree = new InflaterHuffmanTree(this.blLens);
-            this.blLens = (byte[]) null;
-            this.ptr = 0;
-            this.mode = 4;
-            goto case 4;
-          case 4:
-            int symbol;
-            while (((symbol = this.blTree.GetSymbol(input)) & -16) == 0)
-            {
-              this.litdistLens[this.ptr++] = this.lastLen = (byte) symbol;
-              if (this.ptr == this.num)
-                return true;
-            }
-            if (symbol >= 0)
-            {
-              if (symbol >= 17)
-                this.lastLen = (byte) 0;
-              else if (this.ptr == 0)
-                goto label_23;
-              this.repSymbol = symbol - 16;
-              this.mode = 5;
-              goto case 5;
-            }
-            else
-              goto label_19;
-          case 5:
-            int repBit = InflaterDynHeader.repBits[this.repSymbol];
-            int num1 = input.PeekBits(repBit);
-            if (num1 >= 0)
-            {
-              input.DropBits(repBit);
-              int num2 = num1 + InflaterDynHeader.repMin[this.repSymbol];
-              if (this.ptr + num2 <= this.num)
-              {
-                while (num2-- > 0)
-                  this.litdistLens[this.ptr++] = this.lastLen;
-                if (this.ptr != this.num)
-                {
-                  this.mode = 4;
-                  continue;
-                }
-                goto label_32;
-              }
-              else
-                goto label_28;
-            }
-            else
-              goto label_26;
-          default:
-            continue;
-        }
-      }
-label_2:
-      return false;
-label_5:
-      return false;
-label_8:
-      return false;
-label_19:
-      return false;
-label_23:
-      throw new SharpZipBaseException();
-label_26:
-      return false;
-label_28:
-      throw new SharpZipBaseException();
-label_32:
-      return true;
-    }
-
-    public InflaterHuffmanTree BuildLitLenTree()
-    {
-      byte[] numArray = new byte[this.lnum];
-      Array.Copy((Array) this.litdistLens, 0, (Array) numArray, 0, this.lnum);
-      return new InflaterHuffmanTree(numArray);
-    }
-
-    public InflaterHuffmanTree BuildDistTree()
-    {
-      byte[] numArray = new byte[this.dnum];
-      Array.Copy((Array) this.litdistLens, this.lnum, (Array) numArray, 0, this.dnum);
-      return new InflaterHuffmanTree(numArray);
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs
deleted file mode 100644
index cb713c6..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs
+++ /dev/null
@@ -1,147 +0,0 @@
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class InflaterHuffmanTree
-  {
-    private const int MAX_BITLEN = 15;
-    private short[] tree;
-    public static InflaterHuffmanTree defLitLenTree;
-    public static InflaterHuffmanTree defDistTree;
-
-    static InflaterHuffmanTree()
-    {
-      try
-      {
-        byte[] codeLengths1 = new byte[288];
-        int num1 = 0;
-        while (num1 < 144)
-          codeLengths1[num1++] = (byte) 8;
-        while (num1 < 256)
-          codeLengths1[num1++] = (byte) 9;
-        while (num1 < 280)
-          codeLengths1[num1++] = (byte) 7;
-        while (num1 < 288)
-          codeLengths1[num1++] = (byte) 8;
-        InflaterHuffmanTree.defLitLenTree = new InflaterHuffmanTree(codeLengths1);
-        byte[] codeLengths2 = new byte[32];
-        int num2 = 0;
-        while (num2 < 32)
-          codeLengths2[num2++] = (byte) 5;
-        InflaterHuffmanTree.defDistTree = new InflaterHuffmanTree(codeLengths2);
-      }
-      catch (Exception ex)
-      {
-        throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");
-      }
-    }
-
-    public InflaterHuffmanTree(byte[] codeLengths) => this.BuildTree(codeLengths);
-
-    private void BuildTree(byte[] codeLengths)
-    {
-      int[] numArray1 = new int[16];
-      int[] numArray2 = new int[16];
-      for (int index = 0; index < codeLengths.Length; ++index)
-      {
-        int codeLength = (int) codeLengths[index];
-        if (codeLength > 0)
-          ++numArray1[codeLength];
-      }
-      int num1 = 0;
-      int length = 512;
-      for (int index = 1; index <= 15; ++index)
-      {
-        numArray2[index] = num1;
-        num1 += numArray1[index] << 16 - index;
-        if (index >= 10)
-        {
-          int num2 = numArray2[index] & 130944;
-          int num3 = num1 & 130944;
-          length += num3 - num2 >> 16 - index;
-        }
-      }
-      this.tree = new short[length];
-      int num4 = 512;
-      for (int index = 15; index >= 10; --index)
-      {
-        int num5 = num1 & 130944;
-        num1 -= numArray1[index] << 16 - index;
-        for (int toReverse = num1 & 130944; toReverse < num5; toReverse += 128)
-        {
-          this.tree[(int) DeflaterHuffman.BitReverse(toReverse)] = (short) (-num4 << 4 | index);
-          num4 += 1 << index - 9;
-        }
-      }
-      for (int index1 = 0; index1 < codeLengths.Length; ++index1)
-      {
-        int codeLength = (int) codeLengths[index1];
-        if (codeLength != 0)
-        {
-          int toReverse = numArray2[codeLength];
-          int index2 = (int) DeflaterHuffman.BitReverse(toReverse);
-          if (codeLength <= 9)
-          {
-            do
-            {
-              this.tree[index2] = (short) (index1 << 4 | codeLength);
-              index2 += 1 << codeLength;
-            }
-            while (index2 < 512);
-          }
-          else
-          {
-            int num6 = (int) this.tree[index2 & 511];
-            int num7 = 1 << (num6 & 15);
-            int num8 = -(num6 >> 4);
-            do
-            {
-              this.tree[num8 | index2 >> 9] = (short) (index1 << 4 | codeLength);
-              index2 += 1 << codeLength;
-            }
-            while (index2 < num7);
-          }
-          numArray2[codeLength] = toReverse + (1 << 16 - codeLength);
-        }
-      }
-    }
-
-    public int GetSymbol(StreamManipulator input)
-    {
-      int index;
-      if ((index = input.PeekBits(9)) >= 0)
-      {
-        int num1;
-        if ((num1 = (int) this.tree[index]) >= 0)
-        {
-          input.DropBits(num1 & 15);
-          return num1 >> 4;
-        }
-        int num2 = -(num1 >> 4);
-        int bitCount = num1 & 15;
-        int num3;
-        if ((num3 = input.PeekBits(bitCount)) >= 0)
-        {
-          int num4 = (int) this.tree[num2 | num3 >> 9];
-          input.DropBits(num4 & 15);
-          return num4 >> 4;
-        }
-        int availableBits = input.AvailableBits;
-        int num5 = input.PeekBits(availableBits);
-        int num6 = (int) this.tree[num2 | num5 >> 9];
-        if ((num6 & 15) > availableBits)
-          return -1;
-        input.DropBits(num6 & 15);
-        return num6 >> 4;
-      }
-      int availableBits1 = input.AvailableBits;
-      int num = (int) this.tree[input.PeekBits(availableBits1)];
-      if (num < 0 || (num & 15) > availableBits1)
-        return -1;
-      input.DropBits(num & 15);
-      return num >> 4;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/PendingBuffer.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/PendingBuffer.cs
deleted file mode 100644
index 82c6733..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/PendingBuffer.cs
+++ /dev/null
@@ -1,111 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class PendingBuffer
-  {
-    private byte[] buffer_;
-    private int start;
-    private int end;
-    private uint bits;
-    private int bitCount;
-
-    public PendingBuffer()
-      : this(4096)
-    {
-    }
-
-    public PendingBuffer(int bufferSize) => this.buffer_ = new byte[bufferSize];
-
-    public void Reset() => this.start = this.end = this.bitCount = 0;
-
-    public void WriteByte(int value) => this.buffer_[this.end++] = (byte) value;
-
-    public void WriteShort(int value)
-    {
-      this.buffer_[this.end++] = (byte) value;
-      this.buffer_[this.end++] = (byte) (value >> 8);
-    }
-
-    public void WriteInt(int value)
-    {
-      this.buffer_[this.end++] = (byte) value;
-      this.buffer_[this.end++] = (byte) (value >> 8);
-      this.buffer_[this.end++] = (byte) (value >> 16);
-      this.buffer_[this.end++] = (byte) (value >> 24);
-    }
-
-    public void WriteBlock(byte[] block, int offset, int length)
-    {
-      Array.Copy((Array) block, offset, (Array) this.buffer_, this.end, length);
-      this.end += length;
-    }
-
-    public int BitCount => this.bitCount;
-
-    public void AlignToByte()
-    {
-      if (this.bitCount > 0)
-      {
-        this.buffer_[this.end++] = (byte) this.bits;
-        if (this.bitCount > 8)
-          this.buffer_[this.end++] = (byte) (this.bits >> 8);
-      }
-      this.bits = 0U;
-      this.bitCount = 0;
-    }
-
-    public void WriteBits(int b, int count)
-    {
-      this.bits |= (uint) (b << this.bitCount);
-      this.bitCount += count;
-      if (this.bitCount < 16)
-        return;
-      this.buffer_[this.end++] = (byte) this.bits;
-      this.buffer_[this.end++] = (byte) (this.bits >> 8);
-      this.bits >>= 16;
-      this.bitCount -= 16;
-    }
-
-    public void WriteShortMSB(int s)
-    {
-      this.buffer_[this.end++] = (byte) (s >> 8);
-      this.buffer_[this.end++] = (byte) s;
-    }
-
-    public bool IsFlushed => this.end == 0;
-
-    public int Flush(byte[] output, int offset, int length)
-    {
-      if (this.bitCount >= 8)
-      {
-        this.buffer_[this.end++] = (byte) this.bits;
-        this.bits >>= 8;
-        this.bitCount -= 8;
-      }
-      if (length > this.end - this.start)
-      {
-        length = this.end - this.start;
-        Array.Copy((Array) this.buffer_, this.start, (Array) output, offset, length);
-        this.start = 0;
-        this.end = 0;
-      }
-      else
-      {
-        Array.Copy((Array) this.buffer_, this.start, (Array) output, offset, length);
-        this.start += length;
-      }
-      return length;
-    }
-
-    public byte[] ToByteArray()
-    {
-      byte[] destinationArray = new byte[this.end - this.start];
-      Array.Copy((Array) this.buffer_, this.start, (Array) destinationArray, 0, destinationArray.Length);
-      this.start = 0;
-      this.end = 0;
-      return destinationArray;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs
deleted file mode 100644
index b115131..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs
+++ /dev/null
@@ -1,221 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class DeflaterOutputStream : Stream
-  {
-    private string password;
-    private uint[] keys;
-    private byte[] buffer_;
-    protected Deflater def;
-    protected Stream baseOutputStream;
-    private bool isClosed;
-    private bool isStreamOwner = true;
-
-    public DeflaterOutputStream(Stream baseOutputStream)
-      : this(baseOutputStream, new Deflater(), 512)
-    {
-    }
-
-    public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater)
-      : this(baseOutputStream, deflater, 512)
-    {
-    }
-
-    public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater, int bufferSize)
-    {
-      if (baseOutputStream == null)
-        throw new ArgumentNullException(nameof (baseOutputStream));
-      if (!baseOutputStream.CanWrite)
-        throw new ArgumentException("Must support writing", nameof (baseOutputStream));
-      if (deflater == null)
-        throw new ArgumentNullException(nameof (deflater));
-      if (bufferSize <= 0)
-        throw new ArgumentOutOfRangeException(nameof (bufferSize));
-      this.baseOutputStream = baseOutputStream;
-      this.buffer_ = new byte[bufferSize];
-      this.def = deflater;
-    }
-
-    public virtual void Finish()
-    {
-      this.def.Finish();
-      while (!this.def.IsFinished)
-      {
-        int num = this.def.Deflate(this.buffer_, 0, this.buffer_.Length);
-        if (num > 0)
-        {
-          if (this.keys != null)
-            this.EncryptBlock(this.buffer_, 0, num);
-          this.baseOutputStream.Write(this.buffer_, 0, num);
-        }
-        else
-          break;
-      }
-      if (!this.def.IsFinished)
-        throw new SharpZipBaseException("Can't deflate all input?");
-      this.baseOutputStream.Flush();
-      this.keys = (uint[]) null;
-    }
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public bool CanPatchEntries => this.baseOutputStream.CanSeek;
-
-    public string Password
-    {
-      get => this.password;
-      set
-      {
-        if (value != null && value.Length == 0)
-          this.password = (string) null;
-        else
-          this.password = value;
-      }
-    }
-
-    protected byte EncryptByte()
-    {
-      uint num = (uint) ((int) this.keys[2] & (int) ushort.MaxValue | 2);
-      return (byte) (num * (num ^ 1U) >> 8);
-    }
-
-    protected void EncryptBlock(byte[] buffer, int offset, int length)
-    {
-      for (int index = offset; index < offset + length; ++index)
-      {
-        byte ch = buffer[index];
-        buffer[index] ^= this.EncryptByte();
-        this.UpdateKeys(ch);
-      }
-    }
-
-    protected void InitializePassword(string password)
-    {
-      this.keys = new uint[3]
-      {
-        305419896U,
-        591751049U,
-        878082192U
-      };
-      foreach (byte ch in ZipConstants.ConvertToArray(password))
-        this.UpdateKeys(ch);
-    }
-
-    protected void UpdateKeys(byte ch)
-    {
-      this.keys[0] = Crc32.ComputeCrc32(this.keys[0], ch);
-      this.keys[1] = this.keys[1] + (uint) (byte) this.keys[0];
-      this.keys[1] = (uint) ((int) this.keys[1] * 134775813 + 1);
-      this.keys[2] = Crc32.ComputeCrc32(this.keys[2], (byte) (this.keys[1] >> 24));
-    }
-
-    protected void Deflate()
-    {
-      while (!this.def.IsNeedingInput)
-      {
-        int num = this.def.Deflate(this.buffer_, 0, this.buffer_.Length);
-        if (num > 0)
-        {
-          if (this.keys != null)
-            this.EncryptBlock(this.buffer_, 0, num);
-          this.baseOutputStream.Write(this.buffer_, 0, num);
-        }
-        else
-          break;
-      }
-      if (!this.def.IsNeedingInput)
-        throw new SharpZipBaseException("DeflaterOutputStream can't deflate all input?");
-    }
-
-    public override bool CanRead => false;
-
-    public override bool CanSeek => false;
-
-    public override bool CanWrite => this.baseOutputStream.CanWrite;
-
-    public override long Length => this.baseOutputStream.Length;
-
-    public override long Position
-    {
-      get => this.baseOutputStream.Position;
-      set => throw new NotSupportedException("Position property not supported");
-    }
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("DeflaterOutputStream Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("DeflaterOutputStream SetLength not supported");
-    }
-
-    public override int ReadByte()
-    {
-      throw new NotSupportedException("DeflaterOutputStream ReadByte not supported");
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("DeflaterOutputStream Read not supported");
-    }
-
-    public override IAsyncResult BeginRead(
-      byte[] buffer,
-      int offset,
-      int count,
-      AsyncCallback callback,
-      object state)
-    {
-      throw new NotSupportedException("DeflaterOutputStream BeginRead not currently supported");
-    }
-
-    public override IAsyncResult BeginWrite(
-      byte[] buffer,
-      int offset,
-      int count,
-      AsyncCallback callback,
-      object state)
-    {
-      throw new NotSupportedException("BeginWrite is not supported");
-    }
-
-    public override void Flush()
-    {
-      this.def.Flush();
-      this.Deflate();
-      this.baseOutputStream.Flush();
-    }
-
-    public override void Close()
-    {
-      if (this.isClosed)
-        return;
-      this.isClosed = true;
-      this.Finish();
-      if (!this.isStreamOwner)
-        return;
-      this.baseOutputStream.Close();
-    }
-
-    public override void WriteByte(byte value)
-    {
-      this.Write(new byte[1]{ value }, 0, 1);
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      this.def.SetInput(buffer, offset, count);
-      this.Deflate();
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputBuffer.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputBuffer.cs
deleted file mode 100644
index 285663a..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputBuffer.cs
+++ /dev/null
@@ -1,167 +0,0 @@
-using System;
-using System.IO;
-using System.Security.Cryptography;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class InflaterInputBuffer
-  {
-    private int rawLength;
-    private byte[] rawData;
-    private int clearTextLength;
-    private byte[] clearText;
-    private byte[] internalClearText;
-    private int available;
-    private ICryptoTransform cryptoTransform;
-    private Stream inputStream;
-
-    public InflaterInputBuffer(Stream stream)
-      : this(stream, 4096)
-    {
-    }
-
-    public InflaterInputBuffer(Stream stream, int bufferSize)
-    {
-      this.inputStream = stream;
-      if (bufferSize < 1024)
-        bufferSize = 1024;
-      this.rawData = new byte[bufferSize];
-      this.clearText = this.rawData;
-    }
-
-    public int RawLength => this.rawLength;
-
-    public byte[] RawData => this.rawData;
-
-    public int ClearTextLength => this.clearTextLength;
-
-    public byte[] ClearText => this.clearText;
-
-    public int Available
-    {
-      get => this.available;
-      set => this.available = value;
-    }
-
-    public void SetInflaterInput(Inflater inflater)
-    {
-      if (this.available <= 0)
-        return;
-      inflater.SetInput(this.clearText, this.clearTextLength - this.available, this.available);
-      this.available = 0;
-    }
-
-    public void Fill()
-    {
-      this.rawLength = 0;
-      int num;
-      for (int length = this.rawData.Length; length > 0; length -= num)
-      {
-        num = this.inputStream.Read(this.rawData, this.rawLength, length);
-        if (num <= 0)
-        {
-          if (this.rawLength == 0)
-            throw new SharpZipBaseException("Unexpected EOF");
-          break;
-        }
-        this.rawLength += num;
-      }
-      this.clearTextLength = this.cryptoTransform == null ? this.rawLength : this.cryptoTransform.TransformBlock(this.rawData, 0, this.rawLength, this.clearText, 0);
-      this.available = this.clearTextLength;
-    }
-
-    public int ReadRawBuffer(byte[] buffer) => this.ReadRawBuffer(buffer, 0, buffer.Length);
-
-    public int ReadRawBuffer(byte[] outBuffer, int offset, int length)
-    {
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length));
-      int destinationIndex = offset;
-      int val1 = length;
-      while (val1 > 0)
-      {
-        if (this.available <= 0)
-        {
-          this.Fill();
-          if (this.available <= 0)
-            return 0;
-        }
-        int length1 = Math.Min(val1, this.available);
-        Array.Copy((Array) this.rawData, this.rawLength - this.available, (Array) outBuffer, destinationIndex, length1);
-        destinationIndex += length1;
-        val1 -= length1;
-        this.available -= length1;
-      }
-      return length;
-    }
-
-    public int ReadClearTextBuffer(byte[] outBuffer, int offset, int length)
-    {
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length));
-      int destinationIndex = offset;
-      int val1 = length;
-      while (val1 > 0)
-      {
-        if (this.available <= 0)
-        {
-          this.Fill();
-          if (this.available <= 0)
-            return 0;
-        }
-        int length1 = Math.Min(val1, this.available);
-        Array.Copy((Array) this.clearText, this.clearTextLength - this.available, (Array) outBuffer, destinationIndex, length1);
-        destinationIndex += length1;
-        val1 -= length1;
-        this.available -= length1;
-      }
-      return length;
-    }
-
-    public int ReadLeByte()
-    {
-      if (this.available <= 0)
-      {
-        this.Fill();
-        if (this.available <= 0)
-          throw new ZipException("EOF in header");
-      }
-      byte num = (byte) ((uint) this.rawData[this.rawLength - this.available] & (uint) byte.MaxValue);
-      --this.available;
-      return (int) num;
-    }
-
-    public int ReadLeShort() => this.ReadLeByte() | this.ReadLeByte() << 8;
-
-    public int ReadLeInt() => this.ReadLeShort() | this.ReadLeShort() << 16;
-
-    public long ReadLeLong() => (long) (uint) this.ReadLeInt() | (long) this.ReadLeInt() << 32;
-
-    public ICryptoTransform CryptoTransform
-    {
-      set
-      {
-        this.cryptoTransform = value;
-        if (this.cryptoTransform != null)
-        {
-          if (this.rawData == this.clearText)
-          {
-            if (this.internalClearText == null)
-              this.internalClearText = new byte[4096];
-            this.clearText = this.internalClearText;
-          }
-          this.clearTextLength = this.rawLength;
-          if (this.available <= 0)
-            return;
-          this.cryptoTransform.TransformBlock(this.rawData, this.rawLength - this.available, this.available, this.clearText, this.rawLength - this.available);
-        }
-        else
-        {
-          this.clearText = this.rawData;
-          this.clearTextLength = this.rawLength;
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs
deleted file mode 100644
index 4dd45b0..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs
+++ /dev/null
@@ -1,153 +0,0 @@
-using System;
-using System.IO;
-using System.Security.Cryptography;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class InflaterInputStream : Stream
-  {
-    protected Inflater inf;
-    protected InflaterInputBuffer inputBuffer;
-    protected Stream baseInputStream;
-    protected long csize;
-    private bool isClosed;
-    private bool isStreamOwner = true;
-
-    public InflaterInputStream(Stream baseInputStream)
-      : this(baseInputStream, new Inflater(), 4096)
-    {
-    }
-
-    public InflaterInputStream(Stream baseInputStream, Inflater inf)
-      : this(baseInputStream, inf, 4096)
-    {
-    }
-
-    public InflaterInputStream(Stream baseInputStream, Inflater inflater, int bufferSize)
-    {
-      if (baseInputStream == null)
-        throw new ArgumentNullException(nameof (baseInputStream));
-      if (inflater == null)
-        throw new ArgumentNullException(nameof (inflater));
-      if (bufferSize <= 0)
-        throw new ArgumentOutOfRangeException(nameof (bufferSize));
-      this.baseInputStream = baseInputStream;
-      this.inf = inflater;
-      this.inputBuffer = new InflaterInputBuffer(baseInputStream, bufferSize);
-    }
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public long Skip(long count)
-    {
-      if (count < 0L)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (this.baseInputStream.CanSeek)
-      {
-        this.baseInputStream.Seek(count, SeekOrigin.Current);
-        return count;
-      }
-      int length = 2048;
-      if (count < (long) length)
-        length = (int) count;
-      byte[] buffer = new byte[length];
-      return (long) this.baseInputStream.Read(buffer, 0, buffer.Length);
-    }
-
-    protected void StopDecrypting() => this.inputBuffer.CryptoTransform = (ICryptoTransform) null;
-
-    public virtual int Available => !this.inf.IsFinished ? 1 : 0;
-
-    protected void Fill()
-    {
-      this.inputBuffer.Fill();
-      this.inputBuffer.SetInflaterInput(this.inf);
-    }
-
-    public override bool CanRead => this.baseInputStream.CanRead;
-
-    public override bool CanSeek => false;
-
-    public override bool CanWrite => false;
-
-    public override long Length => (long) this.inputBuffer.RawLength;
-
-    public override long Position
-    {
-      get => this.baseInputStream.Position;
-      set => throw new NotSupportedException("InflaterInputStream Position not supported");
-    }
-
-    public override void Flush() => this.baseInputStream.Flush();
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("InflaterInputStream SetLength not supported");
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("InflaterInputStream Write not supported");
-    }
-
-    public override void WriteByte(byte value)
-    {
-      throw new NotSupportedException("InflaterInputStream WriteByte not supported");
-    }
-
-    public override IAsyncResult BeginWrite(
-      byte[] buffer,
-      int offset,
-      int count,
-      AsyncCallback callback,
-      object state)
-    {
-      throw new NotSupportedException("InflaterInputStream BeginWrite not supported");
-    }
-
-    public override void Close()
-    {
-      if (this.isClosed)
-        return;
-      this.isClosed = true;
-      if (!this.isStreamOwner)
-        return;
-      this.baseInputStream.Close();
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (this.inf.IsNeedingDictionary)
-        throw new SharpZipBaseException("Need a dictionary");
-      int count1 = count;
-      int num;
-      do
-      {
-        num = this.inf.Inflate(buffer, offset, count1);
-        offset += num;
-        count1 -= num;
-        if (count1 != 0 && !this.inf.IsFinished)
-        {
-          if (this.inf.IsNeedingInput)
-            this.Fill();
-        }
-        else
-          goto label_8;
-      }
-      while (num != 0);
-      throw new ZipException("Dont know what to do");
-label_8:
-      return count - count1;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs
deleted file mode 100644
index 3eb6ab7..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs
+++ /dev/null
@@ -1,116 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class OutputWindow
-  {
-    private const int WindowSize = 32768;
-    private const int WindowMask = 32767;
-    private byte[] window = new byte[32768];
-    private int windowEnd;
-    private int windowFilled;
-
-    public void Write(int value)
-    {
-      if (this.windowFilled++ == 32768)
-        throw new InvalidOperationException("Window full");
-      this.window[this.windowEnd++] = (byte) value;
-      this.windowEnd &= (int) short.MaxValue;
-    }
-
-    private void SlowRepeat(int repStart, int length, int distance)
-    {
-      while (length-- > 0)
-      {
-        this.window[this.windowEnd++] = this.window[repStart++];
-        this.windowEnd &= (int) short.MaxValue;
-        repStart &= (int) short.MaxValue;
-      }
-    }
-
-    public void Repeat(int length, int distance)
-    {
-      if ((this.windowFilled += length) > 32768)
-        throw new InvalidOperationException("Window full");
-      int num1 = this.windowEnd - distance & (int) short.MaxValue;
-      int num2 = 32768 - length;
-      if (num1 <= num2 && this.windowEnd < num2)
-      {
-        if (length <= distance)
-        {
-          Array.Copy((Array) this.window, num1, (Array) this.window, this.windowEnd, length);
-          this.windowEnd += length;
-        }
-        else
-        {
-          while (length-- > 0)
-            this.window[this.windowEnd++] = this.window[num1++];
-        }
-      }
-      else
-        this.SlowRepeat(num1, length, distance);
-    }
-
-    public int CopyStored(StreamManipulator input, int length)
-    {
-      length = Math.Min(Math.Min(length, 32768 - this.windowFilled), input.AvailableBytes);
-      int length1 = 32768 - this.windowEnd;
-      int num;
-      if (length > length1)
-      {
-        num = input.CopyBytes(this.window, this.windowEnd, length1);
-        if (num == length1)
-          num += input.CopyBytes(this.window, 0, length - length1);
-      }
-      else
-        num = input.CopyBytes(this.window, this.windowEnd, length);
-      this.windowEnd = this.windowEnd + num & (int) short.MaxValue;
-      this.windowFilled += num;
-      return num;
-    }
-
-    public void CopyDict(byte[] dictionary, int offset, int length)
-    {
-      if (dictionary == null)
-        throw new ArgumentNullException(nameof (dictionary));
-      if (this.windowFilled > 0)
-        throw new InvalidOperationException();
-      if (length > 32768)
-      {
-        offset += length - 32768;
-        length = 32768;
-      }
-      Array.Copy((Array) dictionary, offset, (Array) this.window, 0, length);
-      this.windowEnd = length & (int) short.MaxValue;
-    }
-
-    public int GetFreeSpace() => 32768 - this.windowFilled;
-
-    public int GetAvailable() => this.windowFilled;
-
-    public int CopyOutput(byte[] output, int offset, int len)
-    {
-      int num1 = this.windowEnd;
-      if (len > this.windowFilled)
-        len = this.windowFilled;
-      else
-        num1 = this.windowEnd - this.windowFilled + len & (int) short.MaxValue;
-      int num2 = len;
-      int length = len - num1;
-      if (length > 0)
-      {
-        Array.Copy((Array) this.window, 32768 - length, (Array) output, offset, length);
-        offset += length;
-        len = num1;
-      }
-      Array.Copy((Array) this.window, num1 - len, (Array) output, offset, len);
-      this.windowFilled -= num2;
-      if (this.windowFilled < 0)
-        throw new InvalidOperationException();
-      return num2;
-    }
-
-    public void Reset() => this.windowFilled = this.windowEnd = 0;
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs
deleted file mode 100644
index 81bedd5..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs
+++ /dev/null
@@ -1,111 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class StreamManipulator
-  {
-    private byte[] window_;
-    private int windowStart_;
-    private int windowEnd_;
-    private uint buffer_;
-    private int bitsInBuffer_;
-
-    public int PeekBits(int bitCount)
-    {
-      if (this.bitsInBuffer_ < bitCount)
-      {
-        if (this.windowStart_ == this.windowEnd_)
-          return -1;
-        this.buffer_ |= (uint) (((int) this.window_[this.windowStart_++] & (int) byte.MaxValue | ((int) this.window_[this.windowStart_++] & (int) byte.MaxValue) << 8) << this.bitsInBuffer_);
-        this.bitsInBuffer_ += 16;
-      }
-      return (int) ((long) this.buffer_ & (long) ((1 << bitCount) - 1));
-    }
-
-    public void DropBits(int bitCount)
-    {
-      this.buffer_ >>= bitCount;
-      this.bitsInBuffer_ -= bitCount;
-    }
-
-    public int GetBits(int bitCount)
-    {
-      int bits = this.PeekBits(bitCount);
-      if (bits >= 0)
-        this.DropBits(bitCount);
-      return bits;
-    }
-
-    public int AvailableBits => this.bitsInBuffer_;
-
-    public int AvailableBytes => this.windowEnd_ - this.windowStart_ + (this.bitsInBuffer_ >> 3);
-
-    public void SkipToByteBoundary()
-    {
-      this.buffer_ >>= this.bitsInBuffer_ & 7;
-      this.bitsInBuffer_ &= -8;
-    }
-
-    public bool IsNeedingInput => this.windowStart_ == this.windowEnd_;
-
-    public int CopyBytes(byte[] output, int offset, int length)
-    {
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length));
-      if ((this.bitsInBuffer_ & 7) != 0)
-        throw new InvalidOperationException("Bit buffer is not byte aligned!");
-      int num1 = 0;
-      while (this.bitsInBuffer_ > 0 && length > 0)
-      {
-        output[offset++] = (byte) this.buffer_;
-        this.buffer_ >>= 8;
-        this.bitsInBuffer_ -= 8;
-        --length;
-        ++num1;
-      }
-      if (length == 0)
-        return num1;
-      int num2 = this.windowEnd_ - this.windowStart_;
-      if (length > num2)
-        length = num2;
-      Array.Copy((Array) this.window_, this.windowStart_, (Array) output, offset, length);
-      this.windowStart_ += length;
-      if ((this.windowStart_ - this.windowEnd_ & 1) != 0)
-      {
-        this.buffer_ = (uint) this.window_[this.windowStart_++] & (uint) byte.MaxValue;
-        this.bitsInBuffer_ = 8;
-      }
-      return num1 + length;
-    }
-
-    public void Reset()
-    {
-      this.buffer_ = 0U;
-      this.windowStart_ = this.windowEnd_ = this.bitsInBuffer_ = 0;
-    }
-
-    public void SetInput(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be negative");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be negative");
-      if (this.windowStart_ < this.windowEnd_)
-        throw new InvalidOperationException("Old input was not completely processed");
-      int num = offset + count;
-      if (offset > num || num > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if ((count & 1) != 0)
-      {
-        this.buffer_ |= (uint) (((int) buffer[offset++] & (int) byte.MaxValue) << this.bitsInBuffer_);
-        this.bitsInBuffer_ += 8;
-      }
-      this.window_ = buffer;
-      this.windowStart_ = offset;
-      this.windowEnd_ = num;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/CompressionMethod.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/CompressionMethod.cs
deleted file mode 100644
index 85cde98..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/CompressionMethod.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum CompressionMethod
-  {
-    Stored = 0,
-    Deflated = 8,
-    Deflate64 = 9,
-    BZip2 = 11, // 0x0000000B
-    WinZipAES = 99, // 0x00000063
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/DiskArchiveStorage.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/DiskArchiveStorage.cs
deleted file mode 100644
index c7a8806..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/DiskArchiveStorage.cs
+++ /dev/null
@@ -1,134 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class DiskArchiveStorage : BaseArchiveStorage
-  {
-    private Stream temporaryStream_;
-    private string fileName_;
-    private string temporaryName_;
-
-    public DiskArchiveStorage(ZipFile file, FileUpdateMode updateMode)
-      : base(updateMode)
-    {
-      this.fileName_ = file.Name != null ? file.Name : throw new ZipException("Cant handle non file archives");
-    }
-
-    public DiskArchiveStorage(ZipFile file)
-      : this(file, FileUpdateMode.Safe)
-    {
-    }
-
-    public override Stream GetTemporaryOutput()
-    {
-      if (this.temporaryName_ != null)
-      {
-        this.temporaryName_ = this.GetTempFileName(this.temporaryName_, true);
-        this.temporaryStream_ = (Stream) File.OpenWrite(this.temporaryName_);
-      }
-      else
-      {
-        this.temporaryName_ = Path.GetTempFileName();
-        this.temporaryStream_ = (Stream) File.OpenWrite(this.temporaryName_);
-      }
-      return this.temporaryStream_;
-    }
-
-    public override Stream ConvertTemporaryToFinal()
-    {
-      if (this.temporaryStream_ == null)
-        throw new ZipException("No temporary stream has been created");
-      Stream stream = (Stream) null;
-      string tempFileName = this.GetTempFileName(this.fileName_, false);
-      bool flag = false;
-      try
-      {
-        this.temporaryStream_.Close();
-        File.Move(this.fileName_, tempFileName);
-        File.Move(this.temporaryName_, this.fileName_);
-        flag = true;
-        File.Delete(tempFileName);
-        return (Stream) File.OpenRead(this.fileName_);
-      }
-      catch (Exception ex)
-      {
-        stream = (Stream) null;
-        if (!flag)
-        {
-          File.Move(tempFileName, this.fileName_);
-          File.Delete(this.temporaryName_);
-        }
-        throw;
-      }
-    }
-
-    public override Stream MakeTemporaryCopy(Stream stream)
-    {
-      stream.Close();
-      this.temporaryName_ = this.GetTempFileName(this.fileName_, true);
-      File.Copy(this.fileName_, this.temporaryName_, true);
-      this.temporaryStream_ = (Stream) new FileStream(this.temporaryName_, FileMode.Open, FileAccess.ReadWrite);
-      return this.temporaryStream_;
-    }
-
-    public override Stream OpenForDirectUpdate(Stream current)
-    {
-      Stream stream;
-      if (current == null || !current.CanWrite)
-      {
-        current?.Close();
-        stream = (Stream) new FileStream(this.fileName_, FileMode.Open, FileAccess.ReadWrite);
-      }
-      else
-        stream = current;
-      return stream;
-    }
-
-    public override void Dispose()
-    {
-      if (this.temporaryStream_ == null)
-        return;
-      this.temporaryStream_.Close();
-    }
-
-    private string GetTempFileName(string original, bool makeTempFile)
-    {
-      string tempFileName = (string) null;
-      if (original == null)
-      {
-        tempFileName = Path.GetTempFileName();
-      }
-      else
-      {
-        int num = 0;
-        int second = DateTime.Now.Second;
-        while (tempFileName == null)
-        {
-          ++num;
-          string path = string.Format("{0}.{1}{2}.tmp", (object) original, (object) second, (object) num);
-          if (!File.Exists(path))
-          {
-            if (makeTempFile)
-            {
-              try
-              {
-                using (File.Create(path))
-                  ;
-                tempFileName = path;
-              }
-              catch
-              {
-                second = DateTime.Now.Second;
-              }
-            }
-            else
-              tempFileName = path;
-          }
-        }
-      }
-      return tempFileName;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/DynamicDiskDataSource.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/DynamicDiskDataSource.cs
deleted file mode 100644
index 4ff11f1..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/DynamicDiskDataSource.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  internal class DynamicDiskDataSource : IDynamicDataSource
-  {
-    public Stream GetSource(ZipEntry entry, string name)
-    {
-      Stream source = (Stream) null;
-      if (name != null)
-        source = (Stream) File.OpenRead(name);
-      return source;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/EncryptionAlgorithm.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/EncryptionAlgorithm.cs
deleted file mode 100644
index 5efd2cc..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/EncryptionAlgorithm.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum EncryptionAlgorithm
-  {
-    None = 0,
-    PkzipClassic = 1,
-    Des = 26113, // 0x00006601
-    RC2 = 26114, // 0x00006602
-    TripleDes168 = 26115, // 0x00006603
-    TripleDes112 = 26121, // 0x00006609
-    Aes128 = 26126, // 0x0000660E
-    Aes192 = 26127, // 0x0000660F
-    Aes256 = 26128, // 0x00006610
-    RC2Corrected = 26370, // 0x00006702
-    Blowfish = 26400, // 0x00006720
-    Twofish = 26401, // 0x00006721
-    RC4 = 26625, // 0x00006801
-    Unknown = 65535, // 0x0000FFFF
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/FastZip.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/FastZip.cs
deleted file mode 100644
index 85c3c70..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/FastZip.cs
+++ /dev/null
@@ -1,293 +0,0 @@
-using ICSharpCode.SharpZipLib.Core;
-using System;
-using System.Collections;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class FastZip
-  {
-    private bool continueRunning_;
-    private byte[] buffer_;
-    private ZipOutputStream outputStream_;
-    private ZipFile zipFile_;
-    private string targetDirectory_;
-    private string sourceDirectory_;
-    private NameFilter fileFilter_;
-    private NameFilter directoryFilter_;
-    private FastZip.Overwrite overwrite_;
-    private FastZip.ConfirmOverwriteDelegate confirmDelegate_;
-    private bool restoreDateTimeOnExtract_;
-    private bool restoreAttributesOnExtract_;
-    private bool createEmptyDirectories_;
-    private FastZipEvents events_;
-    private IEntryFactory entryFactory_ = (IEntryFactory) new ZipEntryFactory();
-    private string password_;
-
-    public FastZip()
-    {
-    }
-
-    public FastZip(FastZipEvents events) => this.events_ = events;
-
-    public bool CreateEmptyDirectories
-    {
-      get => this.createEmptyDirectories_;
-      set => this.createEmptyDirectories_ = value;
-    }
-
-    public string Password
-    {
-      get => this.password_;
-      set => this.password_ = value;
-    }
-
-    public INameTransform NameTransform
-    {
-      get => this.entryFactory_.NameTransform;
-      set => this.entryFactory_.NameTransform = value;
-    }
-
-    public IEntryFactory EntryFactory
-    {
-      get => this.entryFactory_;
-      set
-      {
-        if (value == null)
-          this.entryFactory_ = (IEntryFactory) new ZipEntryFactory();
-        else
-          this.entryFactory_ = value;
-      }
-    }
-
-    public bool RestoreDateTimeOnExtract
-    {
-      get => this.restoreDateTimeOnExtract_;
-      set => this.restoreDateTimeOnExtract_ = value;
-    }
-
-    public bool RestoreAttributesOnExtract
-    {
-      get => this.restoreAttributesOnExtract_;
-      set => this.restoreAttributesOnExtract_ = value;
-    }
-
-    public void CreateZip(
-      string zipFileName,
-      string sourceDirectory,
-      bool recurse,
-      string fileFilter,
-      string directoryFilter)
-    {
-      this.CreateZip((Stream) File.Create(zipFileName), sourceDirectory, recurse, fileFilter, directoryFilter);
-    }
-
-    public void CreateZip(
-      string zipFileName,
-      string sourceDirectory,
-      bool recurse,
-      string fileFilter)
-    {
-      this.CreateZip((Stream) File.Create(zipFileName), sourceDirectory, recurse, fileFilter, (string) null);
-    }
-
-    public void CreateZip(
-      Stream outputStream,
-      string sourceDirectory,
-      bool recurse,
-      string fileFilter,
-      string directoryFilter)
-    {
-      this.NameTransform = (INameTransform) new ZipNameTransform(sourceDirectory);
-      this.sourceDirectory_ = sourceDirectory;
-      using (this.outputStream_ = new ZipOutputStream(outputStream))
-      {
-        if (this.password_ != null)
-          this.outputStream_.Password = this.password_;
-        FileSystemScanner fileSystemScanner = new FileSystemScanner(fileFilter, directoryFilter);
-        fileSystemScanner.ProcessFile += new ProcessFileDelegate(this.ProcessFile);
-        if (this.CreateEmptyDirectories)
-          fileSystemScanner.ProcessDirectory += new ProcessDirectoryDelegate(this.ProcessDirectory);
-        if (this.events_ != null)
-        {
-          if (this.events_.FileFailure != null)
-            fileSystemScanner.FileFailure += this.events_.FileFailure;
-          if (this.events_.DirectoryFailure != null)
-            fileSystemScanner.DirectoryFailure += this.events_.DirectoryFailure;
-        }
-        fileSystemScanner.Scan(sourceDirectory, recurse);
-      }
-    }
-
-    public void ExtractZip(string zipFileName, string targetDirectory, string fileFilter)
-    {
-      this.ExtractZip(zipFileName, targetDirectory, FastZip.Overwrite.Always, (FastZip.ConfirmOverwriteDelegate) null, fileFilter, (string) null, this.restoreDateTimeOnExtract_);
-    }
-
-    public void ExtractZip(
-      string zipFileName,
-      string targetDirectory,
-      FastZip.Overwrite overwrite,
-      FastZip.ConfirmOverwriteDelegate confirmDelegate,
-      string fileFilter,
-      string directoryFilter,
-      bool restoreDateTime)
-    {
-      if (overwrite == FastZip.Overwrite.Prompt && confirmDelegate == null)
-        throw new ArgumentNullException(nameof (confirmDelegate));
-      this.continueRunning_ = true;
-      this.overwrite_ = overwrite;
-      this.confirmDelegate_ = confirmDelegate;
-      this.targetDirectory_ = targetDirectory;
-      this.fileFilter_ = new NameFilter(fileFilter);
-      this.directoryFilter_ = new NameFilter(directoryFilter);
-      this.restoreDateTimeOnExtract_ = restoreDateTime;
-      using (this.zipFile_ = new ZipFile(zipFileName))
-      {
-        if (this.password_ != null)
-          this.zipFile_.Password = this.password_;
-        IEnumerator enumerator = this.zipFile_.GetEnumerator();
-        while (this.continueRunning_ && enumerator.MoveNext())
-        {
-          ZipEntry current = (ZipEntry) enumerator.Current;
-          if (current.IsFile)
-          {
-            if (this.directoryFilter_.IsMatch(Path.GetDirectoryName(current.Name)) && this.fileFilter_.IsMatch(current.Name))
-              this.ExtractEntry(current);
-          }
-          else if (current.IsDirectory && this.directoryFilter_.IsMatch(current.Name) && this.CreateEmptyDirectories)
-            this.ExtractEntry(current);
-        }
-      }
-    }
-
-    private void ProcessDirectory(object sender, DirectoryEventArgs e)
-    {
-      if (e.HasMatchingFiles || !this.CreateEmptyDirectories)
-        return;
-      if (this.events_ != null)
-        this.events_.OnProcessDirectory(e.Name, e.HasMatchingFiles);
-      if (!e.ContinueRunning || !(e.Name != this.sourceDirectory_))
-        return;
-      this.outputStream_.PutNextEntry(this.entryFactory_.MakeDirectoryEntry(e.Name));
-    }
-
-    private void ProcessFile(object sender, ScanEventArgs e)
-    {
-      if (this.events_ != null && this.events_.ProcessFile != null)
-        this.events_.ProcessFile(sender, e);
-      if (!e.ContinueRunning)
-        return;
-      this.outputStream_.PutNextEntry(this.entryFactory_.MakeFileEntry(e.Name));
-      this.AddFileContents(e.Name);
-    }
-
-    private void AddFileContents(string name)
-    {
-      if (this.buffer_ == null)
-        this.buffer_ = new byte[4096];
-      using (FileStream source = File.OpenRead(name))
-        StreamUtils.Copy((Stream) source, (Stream) this.outputStream_, this.buffer_);
-    }
-
-    private void ExtractFileEntry(ZipEntry entry, string targetName)
-    {
-      bool flag = true;
-      if (this.overwrite_ != FastZip.Overwrite.Always && File.Exists(targetName))
-        flag = this.overwrite_ == FastZip.Overwrite.Prompt && this.confirmDelegate_ != null && this.confirmDelegate_(targetName);
-      if (!flag)
-        return;
-      if (this.events_ != null)
-        this.continueRunning_ = this.events_.OnProcessFile(entry.Name);
-      if (!this.continueRunning_)
-        return;
-      try
-      {
-        using (FileStream destination = File.Create(targetName))
-        {
-          if (this.buffer_ == null)
-            this.buffer_ = new byte[4096];
-          StreamUtils.Copy(this.zipFile_.GetInputStream(entry), (Stream) destination, this.buffer_);
-        }
-        if (this.restoreDateTimeOnExtract_)
-          File.SetLastWriteTime(targetName, entry.DateTime);
-        if (!this.RestoreAttributesOnExtract || !entry.IsDOSEntry || entry.ExternalFileAttributes == -1)
-          return;
-        FileAttributes fileAttributes = (FileAttributes) (entry.ExternalFileAttributes & 163);
-        File.SetAttributes(targetName, fileAttributes);
-      }
-      catch (Exception ex)
-      {
-        if (this.events_ != null)
-          this.continueRunning_ = this.events_.OnFileFailure(targetName, ex);
-        else
-          this.continueRunning_ = false;
-      }
-    }
-
-    private void ExtractEntry(ZipEntry entry)
-    {
-      bool flag = false;
-      string str1 = entry.Name;
-      if (entry.IsFile)
-        flag = FastZip.NameIsValid(str1) && entry.IsCompressionMethodSupported();
-      else if (entry.IsDirectory)
-        flag = FastZip.NameIsValid(str1);
-      string path = (string) null;
-      string str2 = (string) null;
-      if (flag)
-      {
-        if (Path.IsPathRooted(str1))
-        {
-          string pathRoot = Path.GetPathRoot(str1);
-          str1 = str1.Substring(pathRoot.Length);
-        }
-        if (str1.Length > 0)
-        {
-          str2 = Path.Combine(this.targetDirectory_, str1);
-          path = !entry.IsDirectory ? Path.GetDirectoryName(Path.GetFullPath(str2)) : str2;
-        }
-        else
-          flag = false;
-      }
-      if (flag && !Directory.Exists(path))
-      {
-        if (entry.IsDirectory)
-        {
-          if (!this.CreateEmptyDirectories)
-            goto label_16;
-        }
-        try
-        {
-          Directory.CreateDirectory(path);
-        }
-        catch (Exception ex)
-        {
-          flag = false;
-          this.continueRunning_ = this.events_ != null && (!entry.IsDirectory ? this.events_.OnFileFailure(str2, ex) : this.events_.OnDirectoryFailure(str2, ex));
-        }
-      }
-label_16:
-      if (!flag || !entry.IsFile)
-        return;
-      this.ExtractFileEntry(entry, str2);
-    }
-
-    private static int MakeExternalAttributes(FileInfo info) => (int) info.Attributes;
-
-    private static bool NameIsValid(string name)
-    {
-      return name != null && name.Length > 0 && name.IndexOfAny(Path.GetInvalidPathChars()) < 0;
-    }
-
-    public enum Overwrite
-    {
-      Prompt,
-      Never,
-      Always,
-    }
-
-    public delegate bool ConfirmOverwriteDelegate(string fileName);
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/FastZipEvents.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/FastZipEvents.cs
deleted file mode 100644
index 2409d45..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/FastZipEvents.cs
+++ /dev/null
@@ -1,62 +0,0 @@
-using ICSharpCode.SharpZipLib.Core;
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class FastZipEvents
-  {
-    public ProcessDirectoryDelegate ProcessDirectory;
-    public ProcessFileDelegate ProcessFile;
-    public DirectoryFailureDelegate DirectoryFailure;
-    public FileFailureDelegate FileFailure;
-
-    public bool OnDirectoryFailure(string directory, Exception e)
-    {
-      bool flag = false;
-      if (this.DirectoryFailure != null)
-      {
-        ScanFailureEventArgs e1 = new ScanFailureEventArgs(directory, e);
-        this.DirectoryFailure((object) this, e1);
-        flag = e1.ContinueRunning;
-      }
-      return flag;
-    }
-
-    public bool OnFileFailure(string file, Exception e)
-    {
-      bool flag = false;
-      if (this.FileFailure != null)
-      {
-        ScanFailureEventArgs e1 = new ScanFailureEventArgs(file, e);
-        this.FileFailure((object) this, e1);
-        flag = e1.ContinueRunning;
-      }
-      return flag;
-    }
-
-    public bool OnProcessFile(string file)
-    {
-      bool flag = true;
-      if (this.ProcessFile != null)
-      {
-        ScanEventArgs e = new ScanEventArgs(file);
-        this.ProcessFile((object) this, e);
-        flag = e.ContinueRunning;
-      }
-      return flag;
-    }
-
-    public bool OnProcessDirectory(string directory, bool hasMatchingFiles)
-    {
-      bool flag = true;
-      if (this.ProcessDirectory != null)
-      {
-        DirectoryEventArgs e = new DirectoryEventArgs(directory, hasMatchingFiles);
-        this.ProcessDirectory((object) this, e);
-        flag = e.ContinueRunning;
-      }
-      return flag;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/FileUpdateMode.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/FileUpdateMode.cs
deleted file mode 100644
index 92a72cc..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/FileUpdateMode.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum FileUpdateMode
-  {
-    Safe,
-    Direct,
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/GeneralBitFlags.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/GeneralBitFlags.cs
deleted file mode 100644
index db1ca0d..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/GeneralBitFlags.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  [Flags]
-  public enum GeneralBitFlags
-  {
-    Encrypted = 1,
-    Method = 6,
-    Descriptor = 8,
-    ReservedPKware4 = 16, // 0x00000010
-    Patched = 32, // 0x00000020
-    StrongEncryption = 64, // 0x00000040
-    Unused7 = 128, // 0x00000080
-    Unused8 = 256, // 0x00000100
-    Unused9 = 512, // 0x00000200
-    Unused10 = 1024, // 0x00000400
-    UnicodeText = 2048, // 0x00000800
-    EnhancedCompress = 4096, // 0x00001000
-    HeaderMasked = 8192, // 0x00002000
-    ReservedPkware14 = 16384, // 0x00004000
-    ReservedPkware15 = 32768, // 0x00008000
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/HostSystemID.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/HostSystemID.cs
deleted file mode 100644
index 4ab0282..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/HostSystemID.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum HostSystemID
-  {
-    Msdos = 0,
-    Amiga = 1,
-    OpenVms = 2,
-    Unix = 3,
-    VMCms = 4,
-    AtariST = 5,
-    OS2 = 6,
-    Macintosh = 7,
-    ZSystem = 8,
-    Cpm = 9,
-    WindowsNT = 10, // 0x0000000A
-    MVS = 11, // 0x0000000B
-    Vse = 12, // 0x0000000C
-    AcornRisc = 13, // 0x0000000D
-    Vfat = 14, // 0x0000000E
-    AlternateMvs = 15, // 0x0000000F
-    BeOS = 16, // 0x00000010
-    Tandem = 17, // 0x00000011
-    OS400 = 18, // 0x00000012
-    OSX = 19, // 0x00000013
-    WinZipAES = 99, // 0x00000063
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/IArchiveStorage.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/IArchiveStorage.cs
deleted file mode 100644
index 22f473b..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/IArchiveStorage.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public interface IArchiveStorage
-  {
-    FileUpdateMode UpdateMode { get; }
-
-    Stream GetTemporaryOutput();
-
-    Stream ConvertTemporaryToFinal();
-
-    Stream MakeTemporaryCopy(Stream stream);
-
-    Stream OpenForDirectUpdate(Stream stream);
-
-    void Dispose();
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/IDynamicDataSource.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/IDynamicDataSource.cs
deleted file mode 100644
index 8a33a4e..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/IDynamicDataSource.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public interface IDynamicDataSource
-  {
-    Stream GetSource(ZipEntry entry, string name);
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/IEntryFactory.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/IEntryFactory.cs
deleted file mode 100644
index af26823..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/IEntryFactory.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using ICSharpCode.SharpZipLib.Core;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public interface IEntryFactory
-  {
-    ZipEntry MakeFileEntry(string fileName);
-
-    ZipEntry MakeDirectoryEntry(string directoryName);
-
-    INameTransform NameTransform { get; set; }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/IStaticDataSource.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/IStaticDataSource.cs
deleted file mode 100644
index 6cb6fc6..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/IStaticDataSource.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public interface IStaticDataSource
-  {
-    Stream GetSource();
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/KeysRequiredEventArgs.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/KeysRequiredEventArgs.cs
deleted file mode 100644
index 4a84a87..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/KeysRequiredEventArgs.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-using System;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class KeysRequiredEventArgs : EventArgs
-  {
-    private string fileName;
-    private byte[] key;
-
-    public KeysRequiredEventArgs(string name) => this.fileName = name;
-
-    public KeysRequiredEventArgs(string name, byte[] keyValue)
-    {
-      this.fileName = name;
-      this.key = keyValue;
-    }
-
-    public string FileName => this.fileName;
-
-    public byte[] Key
-    {
-      get => this.key;
-      set => this.key = value;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/MemoryArchiveStorage.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/MemoryArchiveStorage.cs
deleted file mode 100644
index f18e7ac..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/MemoryArchiveStorage.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-using ICSharpCode.SharpZipLib.Core;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class MemoryArchiveStorage : BaseArchiveStorage
-  {
-    private MemoryStream temporaryStream_;
-    private MemoryStream finalStream_;
-
-    public MemoryArchiveStorage()
-      : base(FileUpdateMode.Direct)
-    {
-    }
-
-    public MemoryArchiveStorage(FileUpdateMode updateMode)
-      : base(updateMode)
-    {
-    }
-
-    public MemoryStream FinalStream => this.finalStream_;
-
-    public override Stream GetTemporaryOutput()
-    {
-      this.temporaryStream_ = new MemoryStream();
-      return (Stream) this.temporaryStream_;
-    }
-
-    public override Stream ConvertTemporaryToFinal()
-    {
-      this.finalStream_ = this.temporaryStream_ != null ? new MemoryStream(this.temporaryStream_.ToArray()) : throw new ZipException("No temporary stream has been created");
-      return (Stream) this.finalStream_;
-    }
-
-    public override Stream MakeTemporaryCopy(Stream stream)
-    {
-      this.temporaryStream_ = new MemoryStream();
-      stream.Position = 0L;
-      StreamUtils.Copy(stream, (Stream) this.temporaryStream_, new byte[4096]);
-      return (Stream) this.temporaryStream_;
-    }
-
-    public override Stream OpenForDirectUpdate(Stream stream)
-    {
-      Stream destination;
-      if (stream == null || !stream.CanWrite)
-      {
-        destination = (Stream) new MemoryStream();
-        if (stream != null)
-        {
-          stream.Position = 0L;
-          StreamUtils.Copy(stream, destination, new byte[4096]);
-          stream.Close();
-        }
-      }
-      else
-        destination = stream;
-      return destination;
-    }
-
-    public override void Dispose()
-    {
-      if (this.temporaryStream_ == null)
-        return;
-      this.temporaryStream_.Close();
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/StaticDiskDataSource.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/StaticDiskDataSource.cs
deleted file mode 100644
index ef16037..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/StaticDiskDataSource.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  internal class StaticDiskDataSource : IStaticDataSource
-  {
-    private string fileName_;
-
-    public StaticDiskDataSource(string fileName) => this.fileName_ = fileName;
-
-    public Stream GetSource() => (Stream) File.OpenRead(this.fileName_);
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestOperation.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestOperation.cs
deleted file mode 100644
index c045d64..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestOperation.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum TestOperation
-  {
-    Initialising,
-    EntryHeader,
-    EntryData,
-    EntryComplete,
-    MiscellaneousTests,
-    Complete,
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestStatus.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestStatus.cs
deleted file mode 100644
index 83c345d..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestStatus.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class TestStatus
-  {
-    private ZipFile file_;
-    private ZipEntry entry_;
-    private bool entryValid_;
-    private int errorCount_;
-    private long bytesTested_;
-    private TestOperation operation_;
-
-    public TestStatus(ZipFile file) => this.file_ = file;
-
-    public TestOperation Operation => this.operation_;
-
-    public ZipFile File => this.file_;
-
-    public ZipEntry Entry => this.entry_;
-
-    public int ErrorCount => this.errorCount_;
-
-    public long BytesTested => this.bytesTested_;
-
-    public bool EntryValid => this.entryValid_;
-
-    internal void AddError()
-    {
-      ++this.errorCount_;
-      this.entryValid_ = false;
-    }
-
-    internal void SetOperation(TestOperation operation) => this.operation_ = operation;
-
-    internal void SetEntry(ZipEntry entry)
-    {
-      this.entry_ = entry;
-      this.entryValid_ = true;
-      this.bytesTested_ = 0L;
-    }
-
-    internal void SetBytesTested(long value) => this.bytesTested_ = value;
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestStrategy.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestStrategy.cs
deleted file mode 100644
index 3d77e57..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/TestStrategy.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum TestStrategy
-  {
-    FindFirstError,
-    FindAllErrors,
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/UseZip64.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/UseZip64.cs
deleted file mode 100644
index 3048437..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/UseZip64.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum UseZip64
-  {
-    Off,
-    On,
-    Dynamic,
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipConstants.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipConstants.cs
deleted file mode 100644
index f5260e5..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipConstants.cs
+++ /dev/null
@@ -1,107 +0,0 @@
-using System;
-using System.Text;
-using System.Threading;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public sealed class ZipConstants
-  {
-    public const int VersionMadeBy = 45;
-    [Obsolete("Use VersionMadeBy instead")]
-    public const int VERSION_MADE_BY = 45;
-    public const int VersionStrongEncryption = 50;
-    [Obsolete("Use VersionStrongEncryption instead")]
-    public const int VERSION_STRONG_ENCRYPTION = 50;
-    public const int VersionZip64 = 45;
-    public const int LocalHeaderBaseSize = 30;
-    [Obsolete("Use LocalHeaderBaseSize instead")]
-    public const int LOCHDR = 30;
-    public const int Zip64DataDescriptorSize = 24;
-    public const int DataDescriptorSize = 16;
-    [Obsolete("Use DataDescriptorSize instead")]
-    public const int EXTHDR = 16;
-    public const int CentralHeaderBaseSize = 46;
-    [Obsolete("Use CentralHeaderBaseSize instead")]
-    public const int CENHDR = 46;
-    public const int EndOfCentralRecordBaseSize = 22;
-    [Obsolete("Use EndOfCentralRecordBaseSize instead")]
-    public const int ENDHDR = 22;
-    public const int CryptoHeaderSize = 12;
-    [Obsolete("Use CryptoHeaderSize instead")]
-    public const int CRYPTO_HEADER_SIZE = 12;
-    public const int LocalHeaderSignature = 67324752;
-    [Obsolete("Use LocalHeaderSignature instead")]
-    public const int LOCSIG = 67324752;
-    public const int SpanningSignature = 134695760;
-    [Obsolete("Use SpanningSignature instead")]
-    public const int SPANNINGSIG = 134695760;
-    public const int SpanningTempSignature = 808471376;
-    [Obsolete("Use SpanningTempSignature instead")]
-    public const int SPANTEMPSIG = 808471376;
-    public const int DataDescriptorSignature = 134695760;
-    [Obsolete("Use DataDescriptorSignature instead")]
-    public const int EXTSIG = 134695760;
-    [Obsolete("Use CentralHeaderSignature instead")]
-    public const int CENSIG = 33639248;
-    public const int CentralHeaderSignature = 33639248;
-    public const int Zip64CentralFileHeaderSignature = 101075792;
-    [Obsolete("Use Zip64CentralFileHeaderSignature instead")]
-    public const int CENSIG64 = 101075792;
-    public const int Zip64CentralDirLocatorSignature = 117853008;
-    public const int ArchiveExtraDataSignature = 117853008;
-    public const int CentralHeaderDigitalSignature = 84233040;
-    [Obsolete("Use CentralHeaderDigitalSignaure instead")]
-    public const int CENDIGITALSIG = 84233040;
-    public const int EndOfCentralDirectorySignature = 101010256;
-    [Obsolete("Use EndOfCentralDirectorySignature instead")]
-    public const int ENDSIG = 101010256;
-    private static int defaultCodePage = Thread.CurrentThread.CurrentCulture.TextInfo.OEMCodePage;
-
-    public static int DefaultCodePage
-    {
-      get => ZipConstants.defaultCodePage;
-      set => ZipConstants.defaultCodePage = value;
-    }
-
-    public static string ConvertToString(byte[] data, int count)
-    {
-      return data == null ? string.Empty : Encoding.GetEncoding(ZipConstants.DefaultCodePage).GetString(data, 0, count);
-    }
-
-    public static string ConvertToString(byte[] data)
-    {
-      return data == null ? string.Empty : ZipConstants.ConvertToString(data, data.Length);
-    }
-
-    public static string ConvertToStringExt(int flags, byte[] data, int count)
-    {
-      if (data == null)
-        return string.Empty;
-      return (flags & 2048) != 0 ? Encoding.UTF8.GetString(data, 0, count) : ZipConstants.ConvertToString(data, count);
-    }
-
-    public static string ConvertToStringExt(int flags, byte[] data)
-    {
-      if (data == null)
-        return string.Empty;
-      return (flags & 2048) != 0 ? Encoding.UTF8.GetString(data, 0, data.Length) : ZipConstants.ConvertToString(data, data.Length);
-    }
-
-    public static byte[] ConvertToArray(string str)
-    {
-      return str == null ? new byte[0] : Encoding.GetEncoding(ZipConstants.DefaultCodePage).GetBytes(str);
-    }
-
-    public static byte[] ConvertToArray(int flags, string str)
-    {
-      if (str == null)
-        return new byte[0];
-      return (flags & 2048) != 0 ? Encoding.UTF8.GetBytes(str) : ZipConstants.ConvertToArray(str);
-    }
-
-    private ZipConstants()
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipEntry.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipEntry.cs
deleted file mode 100644
index 89de013..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipEntry.cs
+++ /dev/null
@@ -1,399 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipEntry : ICloneable
-  {
-    private ZipEntry.Known known;
-    private int externalFileAttributes = -1;
-    private ushort versionMadeBy;
-    private string name;
-    private ulong size;
-    private ulong compressedSize;
-    private ushort versionToExtract;
-    private uint crc;
-    private uint dosTime;
-    private CompressionMethod method = CompressionMethod.Deflated;
-    private byte[] extra;
-    private string comment;
-    private int flags;
-    private long zipFileIndex = -1;
-    private long offset;
-    private bool forceZip64_;
-    private byte cryptoCheckValue_;
-
-    public ZipEntry(string name)
-      : this(name, 0, 45, CompressionMethod.Deflated)
-    {
-    }
-
-    internal ZipEntry(string name, int versionRequiredToExtract)
-      : this(name, versionRequiredToExtract, 45, CompressionMethod.Deflated)
-    {
-    }
-
-    internal ZipEntry(
-      string name,
-      int versionRequiredToExtract,
-      int madeByInfo,
-      CompressionMethod method)
-    {
-      if (name == null)
-        throw new ArgumentNullException("ZipEntry name");
-      if (name.Length > (int) ushort.MaxValue)
-        throw new ArgumentException("Name is too long", nameof (name));
-      if (versionRequiredToExtract != 0 && versionRequiredToExtract < 10)
-        throw new ArgumentOutOfRangeException(nameof (versionRequiredToExtract));
-      this.DateTime = DateTime.Now;
-      this.name = name;
-      this.versionMadeBy = (ushort) madeByInfo;
-      this.versionToExtract = (ushort) versionRequiredToExtract;
-      this.method = method;
-    }
-
-    [Obsolete("Use Clone instead")]
-    public ZipEntry(ZipEntry entry)
-    {
-      this.known = entry != null ? entry.known : throw new ArgumentNullException(nameof (entry));
-      this.name = entry.name;
-      this.size = entry.size;
-      this.compressedSize = entry.compressedSize;
-      this.crc = entry.crc;
-      this.dosTime = entry.dosTime;
-      this.method = entry.method;
-      this.comment = entry.comment;
-      this.versionToExtract = entry.versionToExtract;
-      this.versionMadeBy = entry.versionMadeBy;
-      this.externalFileAttributes = entry.externalFileAttributes;
-      this.flags = entry.flags;
-      this.zipFileIndex = entry.zipFileIndex;
-      this.offset = entry.offset;
-      this.forceZip64_ = entry.forceZip64_;
-      if (entry.extra == null)
-        return;
-      this.extra = new byte[entry.extra.Length];
-      Array.Copy((Array) entry.extra, 0, (Array) this.extra, 0, entry.extra.Length);
-    }
-
-    public bool HasCrc => (this.known & ZipEntry.Known.Crc) != ZipEntry.Known.None;
-
-    public bool IsCrypted
-    {
-      get => (this.flags & 1) != 0;
-      set
-      {
-        if (value)
-          this.flags |= 1;
-        else
-          this.flags &= -2;
-      }
-    }
-
-    public bool IsUnicodeText
-    {
-      get => (this.flags & 2048) != 0;
-      set
-      {
-        if (value)
-          this.flags |= 2048;
-        else
-          this.flags &= -2049;
-      }
-    }
-
-    internal byte CryptoCheckValue
-    {
-      get => this.cryptoCheckValue_;
-      set => this.cryptoCheckValue_ = value;
-    }
-
-    public int Flags
-    {
-      get => this.flags;
-      set => this.flags = value;
-    }
-
-    public long ZipFileIndex
-    {
-      get => this.zipFileIndex;
-      set => this.zipFileIndex = value;
-    }
-
-    public long Offset
-    {
-      get => this.offset;
-      set => this.offset = value;
-    }
-
-    public int ExternalFileAttributes
-    {
-      get
-      {
-        return (this.known & ZipEntry.Known.ExternalAttributes) == ZipEntry.Known.None ? -1 : this.externalFileAttributes;
-      }
-      set
-      {
-        this.externalFileAttributes = value;
-        this.known |= ZipEntry.Known.ExternalAttributes;
-      }
-    }
-
-    public int VersionMadeBy => (int) this.versionMadeBy & (int) byte.MaxValue;
-
-    public bool IsDOSEntry => this.HostSystem == 0 || this.HostSystem == 10;
-
-    private bool HasDosAttributes(int attributes)
-    {
-      bool flag = false;
-      if ((this.known & ZipEntry.Known.ExternalAttributes) != ZipEntry.Known.None && (this.HostSystem == 0 || this.HostSystem == 10) && (this.ExternalFileAttributes & attributes) == attributes)
-        flag = true;
-      return flag;
-    }
-
-    public int HostSystem
-    {
-      get => (int) this.versionMadeBy >> 8 & (int) byte.MaxValue;
-      set
-      {
-        this.versionMadeBy &= (ushort) byte.MaxValue;
-        this.versionMadeBy |= (ushort) ((value & (int) byte.MaxValue) << 8);
-      }
-    }
-
-    public int Version
-    {
-      get
-      {
-        if (this.versionToExtract != (ushort) 0)
-          return (int) this.versionToExtract;
-        int version = 10;
-        if (this.CentralHeaderRequiresZip64)
-          version = 45;
-        else if (CompressionMethod.Deflated == this.method)
-          version = 20;
-        else if (this.IsDirectory)
-          version = 20;
-        else if (this.IsCrypted)
-          version = 20;
-        else if (this.HasDosAttributes(8))
-          version = 11;
-        return version;
-      }
-    }
-
-    public bool CanDecompress
-    {
-      get
-      {
-        return this.Version <= 45 && (this.Version == 10 || this.Version == 11 || this.Version == 20 || this.Version == 45) && this.IsCompressionMethodSupported();
-      }
-    }
-
-    public void ForceZip64() => this.forceZip64_ = true;
-
-    public bool IsZip64Forced() => this.forceZip64_;
-
-    public bool LocalHeaderRequiresZip64
-    {
-      get
-      {
-        bool headerRequiresZip64 = this.forceZip64_;
-        if (!headerRequiresZip64)
-        {
-          ulong compressedSize = this.compressedSize;
-          if (this.versionToExtract == (ushort) 0 && this.IsCrypted)
-            compressedSize += 12UL;
-          headerRequiresZip64 = (this.size >= (ulong) uint.MaxValue || compressedSize >= (ulong) uint.MaxValue) && (this.versionToExtract == (ushort) 0 || this.versionToExtract >= (ushort) 45);
-        }
-        return headerRequiresZip64;
-      }
-    }
-
-    public bool CentralHeaderRequiresZip64
-    {
-      get => this.LocalHeaderRequiresZip64 || this.offset >= (long) uint.MaxValue;
-    }
-
-    public long DosTime
-    {
-      get => (this.known & ZipEntry.Known.Time) == ZipEntry.Known.None ? 0L : (long) this.dosTime;
-      set
-      {
-        this.dosTime = (uint) value;
-        this.known |= ZipEntry.Known.Time;
-      }
-    }
-
-    public DateTime DateTime
-    {
-      get
-      {
-        return this.dosTime == 0U ? DateTime.Now : new DateTime(((int) (this.dosTime >> 25) & (int) sbyte.MaxValue) + 1980, (int) (this.dosTime >> 21 & 15U), (int) (this.dosTime >> 16 & 31U), (int) (this.dosTime >> 11 & 31U), (int) (this.dosTime >> 5 & 63U), 2 * ((int) this.dosTime & 31));
-      }
-      set
-      {
-        this.DosTime = (long) (uint) ((value.Year - 1980 & (int) sbyte.MaxValue) << 25 | value.Month << 21 | value.Day << 16 | value.Hour << 11 | value.Minute << 5 | value.Second >>> 1);
-      }
-    }
-
-    public string Name => this.name;
-
-    public long Size
-    {
-      get => (this.known & ZipEntry.Known.Size) == ZipEntry.Known.None ? -1L : (long) this.size;
-      set
-      {
-        this.size = (ulong) value;
-        this.known |= ZipEntry.Known.Size;
-      }
-    }
-
-    public long CompressedSize
-    {
-      get
-      {
-        return (this.known & ZipEntry.Known.CompressedSize) == ZipEntry.Known.None ? -1L : (long) this.compressedSize;
-      }
-      set
-      {
-        this.compressedSize = (ulong) value;
-        this.known |= ZipEntry.Known.CompressedSize;
-      }
-    }
-
-    public long Crc
-    {
-      get
-      {
-        return (this.known & ZipEntry.Known.Crc) == ZipEntry.Known.None ? -1L : (long) this.crc & (long) uint.MaxValue;
-      }
-      set
-      {
-        this.crc = ((long) this.crc & -4294967296L) == 0L ? (uint) value : throw new ArgumentOutOfRangeException(nameof (value));
-        this.known |= ZipEntry.Known.Crc;
-      }
-    }
-
-    public CompressionMethod CompressionMethod
-    {
-      get => this.method;
-      set
-      {
-        this.method = ZipEntry.IsCompressionMethodSupported(value) ? value : throw new NotSupportedException("Compression method not supported");
-      }
-    }
-
-    public byte[] ExtraData
-    {
-      get => this.extra;
-      set
-      {
-        if (value == null)
-        {
-          this.extra = (byte[]) null;
-        }
-        else
-        {
-          this.extra = value.Length <= (int) ushort.MaxValue ? new byte[value.Length] : throw new ArgumentOutOfRangeException(nameof (value));
-          Array.Copy((Array) value, 0, (Array) this.extra, 0, value.Length);
-        }
-      }
-    }
-
-    internal void ProcessExtraData(bool localHeader)
-    {
-      ZipExtraData zipExtraData = new ZipExtraData(this.extra);
-      if (zipExtraData.Find(1))
-      {
-        if (((int) this.versionToExtract & (int) byte.MaxValue) < 45)
-          throw new ZipException("Zip64 Extended information found but version is not valid");
-        this.forceZip64_ = true;
-        if (zipExtraData.ValueLength < 4)
-          throw new ZipException("Extra data extended Zip64 information length is invalid");
-        if (localHeader || this.size == (ulong) uint.MaxValue)
-          this.size = (ulong) zipExtraData.ReadLong();
-        if (localHeader || this.compressedSize == (ulong) uint.MaxValue)
-          this.compressedSize = (ulong) zipExtraData.ReadLong();
-        if (!localHeader && this.offset == (long) uint.MaxValue)
-          this.offset = zipExtraData.ReadLong();
-      }
-      else if (((int) this.versionToExtract & (int) byte.MaxValue) >= 45 && (this.size == (ulong) uint.MaxValue || this.compressedSize == (ulong) uint.MaxValue))
-        throw new ZipException("Zip64 Extended information required but is missing.");
-      if (!zipExtraData.Find(21589))
-        return;
-      int valueLength = zipExtraData.ValueLength;
-      if ((zipExtraData.ReadByte() & 1) == 0 || valueLength < 5)
-        return;
-      int seconds = zipExtraData.ReadInt();
-      this.DateTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() + new TimeSpan(0, 0, 0, seconds, 0)).ToLocalTime();
-    }
-
-    public string Comment
-    {
-      get => this.comment;
-      set
-      {
-        this.comment = value == null || value.Length <= (int) ushort.MaxValue ? value : throw new ArgumentOutOfRangeException(nameof (value), "cannot exceed 65535");
-      }
-    }
-
-    public bool IsDirectory
-    {
-      get
-      {
-        int length = this.name.Length;
-        return length > 0 && (this.name[length - 1] == '/' || this.name[length - 1] == '\\') || this.HasDosAttributes(16);
-      }
-    }
-
-    public bool IsFile => !this.IsDirectory && !this.HasDosAttributes(8);
-
-    public bool IsCompressionMethodSupported()
-    {
-      return ZipEntry.IsCompressionMethodSupported(this.CompressionMethod);
-    }
-
-    public object Clone()
-    {
-      ZipEntry zipEntry = (ZipEntry) this.MemberwiseClone();
-      if (this.extra != null)
-      {
-        zipEntry.extra = new byte[this.extra.Length];
-        Array.Copy((Array) this.extra, 0, (Array) zipEntry.extra, 0, this.extra.Length);
-      }
-      return (object) zipEntry;
-    }
-
-    public override string ToString() => this.name;
-
-    public static bool IsCompressionMethodSupported(CompressionMethod method)
-    {
-      return method == CompressionMethod.Deflated || method == CompressionMethod.Stored;
-    }
-
-    public static string CleanName(string name)
-    {
-      if (name == null)
-        return string.Empty;
-      if (Path.IsPathRooted(name))
-        name = name.Substring(Path.GetPathRoot(name).Length);
-      name = name.Replace("\\", "/");
-      while (name.Length > 0 && name[0] == '/')
-        name = name.Remove(0, 1);
-      return name;
-    }
-
-    [System.Flags]
-    private enum Known : byte
-    {
-      None = 0,
-      Size = 1,
-      CompressedSize = 2,
-      Crc = 4,
-      Time = 8,
-      ExternalAttributes = 16, // 0x10
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipEntryFactory.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipEntryFactory.cs
deleted file mode 100644
index d48460b..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipEntryFactory.cs
+++ /dev/null
@@ -1,148 +0,0 @@
-using ICSharpCode.SharpZipLib.Core;
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  internal class ZipEntryFactory : IEntryFactory
-  {
-    private INameTransform nameTransform_;
-    private DateTime fixedDateTime_ = DateTime.Now;
-    private ZipEntryFactory.TimeSetting timeSetting_;
-    private int getAttributes_ = -1;
-    private int setAttributes_;
-
-    public ZipEntryFactory() => this.nameTransform_ = (INameTransform) new ZipNameTransform();
-
-    public ZipEntryFactory(ZipEntryFactory.TimeSetting timeSetting)
-    {
-      this.timeSetting_ = timeSetting;
-      this.nameTransform_ = (INameTransform) new ZipNameTransform();
-    }
-
-    public ZipEntryFactory(DateTime time)
-    {
-      this.timeSetting_ = ZipEntryFactory.TimeSetting.Fixed;
-      this.FixedDateTime = time;
-      this.nameTransform_ = (INameTransform) new ZipNameTransform();
-    }
-
-    public INameTransform NameTransform
-    {
-      get => this.nameTransform_;
-      set
-      {
-        if (value == null)
-          this.nameTransform_ = (INameTransform) new ZipNameTransform();
-        else
-          this.nameTransform_ = value;
-      }
-    }
-
-    public ZipEntryFactory.TimeSetting Setting
-    {
-      get => this.timeSetting_;
-      set => this.timeSetting_ = value;
-    }
-
-    public DateTime FixedDateTime
-    {
-      get => this.fixedDateTime_;
-      set
-      {
-        this.fixedDateTime_ = value.Year >= 1970 ? value : throw new ArgumentException("Value is too old to be valid", nameof (value));
-      }
-    }
-
-    public int GetAttributes
-    {
-      get => this.getAttributes_;
-      set => this.getAttributes_ = value;
-    }
-
-    public int SetAttributes
-    {
-      get => this.setAttributes_;
-      set => this.setAttributes_ = value;
-    }
-
-    public ZipEntry MakeFileEntry(string fileName)
-    {
-      FileInfo fileInfo = new FileInfo(fileName);
-      ZipEntry zipEntry = new ZipEntry(this.nameTransform_.TransformFile(fileName));
-      zipEntry.Size = fileInfo.Length;
-      int num = (int) (fileInfo.Attributes & (FileAttributes) this.getAttributes_ | (FileAttributes) this.setAttributes_);
-      zipEntry.ExternalFileAttributes = num;
-      switch (this.timeSetting_)
-      {
-        case ZipEntryFactory.TimeSetting.LastWriteTime:
-          zipEntry.DateTime = fileInfo.LastWriteTime;
-          break;
-        case ZipEntryFactory.TimeSetting.LastWriteTimeUtc:
-          zipEntry.DateTime = fileInfo.LastWriteTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.CreateTime:
-          zipEntry.DateTime = fileInfo.CreationTime;
-          break;
-        case ZipEntryFactory.TimeSetting.CreateTimeUtc:
-          zipEntry.DateTime = fileInfo.CreationTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.LastAccessTime:
-          zipEntry.DateTime = fileInfo.LastAccessTime;
-          break;
-        case ZipEntryFactory.TimeSetting.LastAccessTimeUtc:
-          zipEntry.DateTime = fileInfo.LastAccessTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.Fixed:
-          zipEntry.DateTime = this.fixedDateTime_;
-          break;
-      }
-      zipEntry.DateTime = fileInfo.LastWriteTime;
-      return zipEntry;
-    }
-
-    public ZipEntry MakeDirectoryEntry(string directoryName)
-    {
-      DirectoryInfo directoryInfo = new DirectoryInfo(directoryName);
-      ZipEntry zipEntry = new ZipEntry(this.nameTransform_.TransformDirectory(directoryName));
-      zipEntry.ExternalFileAttributes = (int) (directoryInfo.Attributes & (FileAttributes) this.getAttributes_ | (FileAttributes) this.setAttributes_);
-      switch (this.timeSetting_)
-      {
-        case ZipEntryFactory.TimeSetting.LastWriteTime:
-          zipEntry.DateTime = directoryInfo.LastWriteTime;
-          break;
-        case ZipEntryFactory.TimeSetting.LastWriteTimeUtc:
-          zipEntry.DateTime = directoryInfo.LastWriteTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.CreateTime:
-          zipEntry.DateTime = directoryInfo.CreationTime;
-          break;
-        case ZipEntryFactory.TimeSetting.CreateTimeUtc:
-          zipEntry.DateTime = directoryInfo.CreationTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.LastAccessTime:
-          zipEntry.DateTime = directoryInfo.LastAccessTime;
-          break;
-        case ZipEntryFactory.TimeSetting.LastAccessTimeUtc:
-          zipEntry.DateTime = directoryInfo.LastAccessTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.Fixed:
-          zipEntry.DateTime = this.fixedDateTime_;
-          break;
-      }
-      return zipEntry;
-    }
-
-    public enum TimeSetting
-    {
-      LastWriteTime,
-      LastWriteTimeUtc,
-      CreateTime,
-      CreateTimeUtc,
-      LastAccessTime,
-      LastAccessTimeUtc,
-      Fixed,
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipException.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipException.cs
deleted file mode 100644
index 64bdc41..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  [Serializable]
-  public class ZipException : SharpZipBaseException
-  {
-    protected ZipException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public ZipException()
-    {
-    }
-
-    public ZipException(string message)
-      : base(message)
-    {
-    }
-
-    public ZipException(string message, Exception exception)
-      : base(message, exception)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipExtraData.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipExtraData.cs
deleted file mode 100644
index af8c65a..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipExtraData.cs
+++ /dev/null
@@ -1,230 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public sealed class ZipExtraData : IDisposable
-  {
-    private int index_;
-    private int readValueStart_;
-    private int readValueLength_;
-    private MemoryStream newEntry_;
-    private byte[] data_;
-
-    public ZipExtraData() => this.Clear();
-
-    public ZipExtraData(byte[] data)
-    {
-      if (data == null)
-        this.data_ = new byte[0];
-      else
-        this.data_ = data;
-    }
-
-    public byte[] GetEntryData()
-    {
-      if (this.Length > (int) ushort.MaxValue)
-        throw new ZipException("Data exceeds maximum length");
-      return (byte[]) this.data_.Clone();
-    }
-
-    public void Clear()
-    {
-      if (this.data_ != null && this.data_.Length == 0)
-        return;
-      this.data_ = new byte[0];
-    }
-
-    public int Length => this.data_.Length;
-
-    public Stream GetStreamForTag(int tag)
-    {
-      Stream streamForTag = (Stream) null;
-      if (this.Find(tag))
-        streamForTag = (Stream) new MemoryStream(this.data_, this.index_, this.readValueLength_, false);
-      return streamForTag;
-    }
-
-    public int ValueLength => this.readValueLength_;
-
-    public int CurrentReadIndex => this.index_;
-
-    public int UnreadCount
-    {
-      get
-      {
-        if (this.readValueStart_ > this.data_.Length || this.readValueStart_ < 4)
-          throw new ZipException("Find must be called before calling a Read method");
-        return this.readValueStart_ + this.readValueLength_ - this.index_;
-      }
-    }
-
-    public bool Find(int headerID)
-    {
-      this.readValueStart_ = this.data_.Length;
-      this.readValueLength_ = 0;
-      this.index_ = 0;
-      int num1 = this.readValueStart_;
-      int num2 = headerID - 1;
-      while (num2 != headerID && this.index_ < this.data_.Length - 3)
-      {
-        num2 = this.ReadShortInternal();
-        num1 = this.ReadShortInternal();
-        if (num2 != headerID)
-          this.index_ += num1;
-      }
-      bool flag = num2 == headerID && this.index_ + num1 <= this.data_.Length;
-      if (flag)
-      {
-        this.readValueStart_ = this.index_;
-        this.readValueLength_ = num1;
-      }
-      return flag;
-    }
-
-    public void AddEntry(int headerID, byte[] fieldData)
-    {
-      if (headerID > (int) ushort.MaxValue || headerID < 0)
-        throw new ArgumentOutOfRangeException(nameof (headerID));
-      int length1 = fieldData == null ? 0 : fieldData.Length;
-      if (length1 > (int) ushort.MaxValue)
-        throw new ArgumentOutOfRangeException(nameof (fieldData), "exceeds maximum length");
-      int length2 = this.data_.Length + length1 + 4;
-      if (this.Find(headerID))
-        length2 -= this.ValueLength + 4;
-      if (length2 > (int) ushort.MaxValue)
-        throw new ZipException("Data exceeds maximum length");
-      this.Delete(headerID);
-      byte[] numArray = new byte[length2];
-      this.data_.CopyTo((Array) numArray, 0);
-      int length3 = this.data_.Length;
-      this.data_ = numArray;
-      this.SetShort(ref length3, headerID);
-      this.SetShort(ref length3, length1);
-      fieldData?.CopyTo((Array) numArray, length3);
-    }
-
-    private void SetShort(ref int index, int source)
-    {
-      this.data_[index] = (byte) source;
-      this.data_[index + 1] = (byte) (source >> 8);
-      index += 2;
-    }
-
-    public void StartNewEntry() => this.newEntry_ = new MemoryStream();
-
-    public void AddNewEntry(int headerID)
-    {
-      byte[] array = this.newEntry_.ToArray();
-      this.newEntry_ = (MemoryStream) null;
-      this.AddEntry(headerID, array);
-    }
-
-    public void AddData(byte data) => this.newEntry_.WriteByte(data);
-
-    public void AddData(byte[] data)
-    {
-      if (data == null)
-        throw new ArgumentNullException(nameof (data));
-      this.newEntry_.Write(data, 0, data.Length);
-    }
-
-    public void AddLeShort(int toAdd)
-    {
-      this.newEntry_.WriteByte((byte) toAdd);
-      this.newEntry_.WriteByte((byte) (toAdd >> 8));
-    }
-
-    public void AddLeInt(int toAdd)
-    {
-      this.AddLeShort((int) (short) toAdd);
-      this.AddLeShort((int) (short) (toAdd >> 16));
-    }
-
-    public void AddLeLong(long toAdd)
-    {
-      this.AddLeInt((int) (toAdd & (long) uint.MaxValue));
-      this.AddLeInt((int) (toAdd >> 32));
-    }
-
-    public bool Delete(int headerID)
-    {
-      bool flag = false;
-      if (this.Find(headerID))
-      {
-        flag = true;
-        int num = this.readValueStart_ - 4;
-        byte[] destinationArray = new byte[this.data_.Length - (this.ValueLength + 4)];
-        Array.Copy((Array) this.data_, 0, (Array) destinationArray, 0, num);
-        int sourceIndex = num + this.ValueLength + 4;
-        Array.Copy((Array) this.data_, sourceIndex, (Array) destinationArray, num, this.data_.Length - sourceIndex);
-        this.data_ = destinationArray;
-      }
-      return flag;
-    }
-
-    public long ReadLong()
-    {
-      this.ReadCheck(8);
-      return (long) this.ReadInt() & (long) uint.MaxValue | (long) this.ReadInt() << 32;
-    }
-
-    public int ReadInt()
-    {
-      this.ReadCheck(4);
-      int num = (int) this.data_[this.index_] + ((int) this.data_[this.index_ + 1] << 8) + ((int) this.data_[this.index_ + 2] << 16) + ((int) this.data_[this.index_ + 3] << 24);
-      this.index_ += 4;
-      return num;
-    }
-
-    public int ReadShort()
-    {
-      this.ReadCheck(2);
-      int num = (int) this.data_[this.index_] + ((int) this.data_[this.index_ + 1] << 8);
-      this.index_ += 2;
-      return num;
-    }
-
-    public int ReadByte()
-    {
-      int num = -1;
-      if (this.index_ < this.data_.Length && this.readValueStart_ + this.readValueLength_ > this.index_)
-      {
-        num = (int) this.data_[this.index_];
-        ++this.index_;
-      }
-      return num;
-    }
-
-    public void Skip(int amount)
-    {
-      this.ReadCheck(amount);
-      this.index_ += amount;
-    }
-
-    private void ReadCheck(int length)
-    {
-      if (this.readValueStart_ > this.data_.Length || this.readValueStart_ < 4)
-        throw new ZipException("Find must be called before calling a Read method");
-      if (this.index_ > this.readValueStart_ + this.readValueLength_ - length)
-        throw new ZipException("End of extra data");
-    }
-
-    private int ReadShortInternal()
-    {
-      if (this.index_ > this.data_.Length - 2)
-        throw new ZipException("End of extra data");
-      int num = (int) this.data_[this.index_] + ((int) this.data_[this.index_ + 1] << 8);
-      this.index_ += 2;
-      return num;
-    }
-
-    public void Dispose()
-    {
-      if (this.newEntry_ == null)
-        return;
-      this.newEntry_.Close();
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipFile.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipFile.cs
deleted file mode 100644
index 05e2d0f..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipFile.cs
+++ /dev/null
@@ -1,1851 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Core;
-using ICSharpCode.SharpZipLib.Encryption;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Runtime.CompilerServices;
-using System.Security.Cryptography;
-using System.Text;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipFile : IEnumerable, IDisposable
-  {
-    private const int DefaultBufferSize = 4096;
-    public ZipFile.KeysRequiredEventHandler KeysRequired;
-    private bool isDisposed_;
-    private string name_;
-    private string comment_;
-    private Stream baseStream_;
-    private bool isStreamOwner;
-    private long offsetOfFirstEntry;
-    private ZipEntry[] entries_;
-    private byte[] key;
-    private bool isNewArchive_;
-    private UseZip64 useZip64_;
-    private ArrayList updates_;
-    private IArchiveStorage archiveStorage_;
-    private IDynamicDataSource updateDataSource_;
-    private bool contentsEdited_;
-    private int bufferSize_ = 4096;
-    private byte[] copyBuffer_;
-    private ZipFile.ZipString newComment_;
-    private bool commentEdited_;
-    private INameTransform updateNameTransform_ = (INameTransform) new ZipNameTransform();
-    private string tempDirectory_ = string.Empty;
-
-    private void OnKeysRequired(string fileName)
-    {
-      if (this.KeysRequired == null)
-        return;
-      KeysRequiredEventArgs e = new KeysRequiredEventArgs(fileName, this.key);
-      this.KeysRequired((object) this, e);
-      this.key = e.Key;
-    }
-
-    private byte[] Key
-    {
-      get => this.key;
-      set => this.key = value;
-    }
-
-    public string Password
-    {
-      set
-      {
-        if (value == null || value.Length == 0)
-          this.key = (byte[]) null;
-        else
-          this.key = PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(value));
-      }
-    }
-
-    private bool HaveKeys => this.key != null;
-
-    public ZipFile(string name)
-    {
-      this.name_ = name;
-      this.baseStream_ = (Stream) File.OpenRead(name);
-      this.isStreamOwner = true;
-      try
-      {
-        this.ReadEntries();
-      }
-      catch
-      {
-        this.DisposeInternal(true);
-        throw;
-      }
-    }
-
-    public ZipFile(FileStream file)
-    {
-      if (file == null)
-        throw new ArgumentNullException(nameof (file));
-      this.baseStream_ = file.CanSeek ? (Stream) file : throw new ArgumentException("Stream is not seekable", nameof (file));
-      this.name_ = file.Name;
-      this.isStreamOwner = true;
-      try
-      {
-        this.ReadEntries();
-      }
-      catch
-      {
-        this.DisposeInternal(true);
-        throw;
-      }
-    }
-
-    public ZipFile(Stream stream)
-    {
-      if (stream == null)
-        throw new ArgumentNullException(nameof (stream));
-      this.baseStream_ = stream.CanSeek ? stream : throw new ArgumentException("Stream is not seekable", nameof (stream));
-      this.isStreamOwner = true;
-      if (this.baseStream_.Length > 0L)
-      {
-        try
-        {
-          this.ReadEntries();
-        }
-        catch
-        {
-          this.DisposeInternal(true);
-          throw;
-        }
-      }
-      else
-      {
-        this.entries_ = new ZipEntry[0];
-        this.isNewArchive_ = true;
-      }
-    }
-
-    internal ZipFile()
-    {
-      this.entries_ = new ZipEntry[0];
-      this.isNewArchive_ = true;
-    }
-
-    ~ZipFile() => this.Dispose(false);
-
-    public void Close()
-    {
-      this.DisposeInternal(true);
-      GC.SuppressFinalize((object) this);
-    }
-
-    public static ZipFile Create(string fileName)
-    {
-      FileStream fileStream = fileName != null ? File.Create(fileName) : throw new ArgumentNullException(nameof (fileName));
-      return new ZipFile()
-      {
-        name_ = fileName,
-        baseStream_ = (Stream) fileStream,
-        isStreamOwner = true
-      };
-    }
-
-    public static ZipFile Create(Stream outStream)
-    {
-      if (outStream == null)
-        throw new ArgumentNullException(nameof (outStream));
-      if (!outStream.CanWrite)
-        throw new ArgumentException("Stream is not writeable", nameof (outStream));
-      return outStream.CanSeek ? new ZipFile()
-      {
-        baseStream_ = outStream
-      } : throw new ArgumentException("Stream is not seekable", nameof (outStream));
-    }
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public bool IsEmbeddedArchive => this.offsetOfFirstEntry > 0L;
-
-    public bool IsNewArchive => this.isNewArchive_;
-
-    public string ZipFileComment => this.comment_;
-
-    public string Name => this.name_;
-
-    [Obsolete("Use the Count property instead")]
-    public int Size
-    {
-      get
-      {
-        return this.entries_ != null ? this.entries_.Length : throw new InvalidOperationException("ZipFile is closed");
-      }
-    }
-
-    public long Count
-    {
-      get
-      {
-        return this.entries_ != null ? (long) this.entries_.Length : throw new InvalidOperationException("ZipFile is closed");
-      }
-    }
-
-    [IndexerName("EntryByIndex")]
-    public ZipEntry this[int index] => (ZipEntry) this.entries_[index].Clone();
-
-    public IEnumerator GetEnumerator()
-    {
-      return this.entries_ != null ? (IEnumerator) new ZipFile.ZipEntryEnumerator(this.entries_) : throw new InvalidOperationException("ZipFile has closed");
-    }
-
-    public int FindEntry(string name, bool ignoreCase)
-    {
-      if (this.entries_ == null)
-        throw new InvalidOperationException("ZipFile has been closed");
-      for (int entry = 0; entry < this.entries_.Length; ++entry)
-      {
-        if (string.Compare(name, this.entries_[entry].Name, ignoreCase, CultureInfo.InvariantCulture) == 0)
-          return entry;
-      }
-      return -1;
-    }
-
-    public ZipEntry GetEntry(string name)
-    {
-      if (this.entries_ == null)
-        throw new InvalidOperationException("ZipFile has been closed");
-      int entry = this.FindEntry(name, true);
-      return entry < 0 ? (ZipEntry) null : (ZipEntry) this.entries_[entry].Clone();
-    }
-
-    public Stream GetInputStream(ZipEntry entry)
-    {
-      if (entry == null)
-        throw new ArgumentNullException(nameof (entry));
-      if (this.entries_ == null)
-        throw new InvalidOperationException("ZipFile has closed");
-      long entryIndex = entry.ZipFileIndex;
-      if (entryIndex < 0L || entryIndex >= (long) this.entries_.Length || this.entries_[entryIndex].Name != entry.Name)
-      {
-        entryIndex = (long) this.FindEntry(entry.Name, true);
-        if (entryIndex < 0L)
-          throw new ZipException("Entry cannot be found");
-      }
-      return this.GetInputStream(entryIndex);
-    }
-
-    public Stream GetInputStream(long entryIndex)
-    {
-      long start = this.entries_ != null ? this.LocateEntry(this.entries_[entryIndex]) : throw new InvalidOperationException("ZipFile is not open");
-      CompressionMethod compressionMethod = this.entries_[entryIndex].CompressionMethod;
-      Stream inputStream = (Stream) new ZipFile.PartialInputStream(this.baseStream_, start, this.entries_[entryIndex].CompressedSize);
-      if (this.entries_[entryIndex].IsCrypted)
-      {
-        inputStream = this.CreateAndInitDecryptionStream(inputStream, this.entries_[entryIndex]);
-        if (inputStream == null)
-          throw new ZipException("Unable to decrypt this entry");
-      }
-      switch (compressionMethod)
-      {
-        case CompressionMethod.Stored:
-          return inputStream;
-        case CompressionMethod.Deflated:
-          inputStream = (Stream) new InflaterInputStream(inputStream, new Inflater(true));
-          goto case CompressionMethod.Stored;
-        default:
-          throw new ZipException("Unsupported compression method " + (object) compressionMethod);
-      }
-    }
-
-    public bool TestArchive(bool testData)
-    {
-      return this.TestArchive(testData, TestStrategy.FindFirstError, (ZipTestResultHandler) null);
-    }
-
-    public bool TestArchive(
-      bool testData,
-      TestStrategy strategy,
-      ZipTestResultHandler resultHandler)
-    {
-      TestStatus status = new TestStatus(this);
-      if (resultHandler != null)
-        resultHandler(status, (string) null);
-      ZipFile.HeaderTest tests = testData ? ZipFile.HeaderTest.Extract | ZipFile.HeaderTest.Header : ZipFile.HeaderTest.Header;
-      bool flag = true;
-      try
-      {
-        for (int index = 0; flag && (long) index < this.Count; ++index)
-        {
-          if (resultHandler != null)
-          {
-            status.SetEntry(this[index]);
-            status.SetOperation(TestOperation.EntryHeader);
-            resultHandler(status, (string) null);
-          }
-          try
-          {
-            this.TestLocalHeader(this[index], tests);
-          }
-          catch (ZipException ex)
-          {
-            status.AddError();
-            if (resultHandler != null)
-              resultHandler(status, string.Format("Exception during test - '{0}'", (object) ex.Message));
-            if (strategy == TestStrategy.FindFirstError)
-              flag = false;
-          }
-          if (flag && testData && this[index].IsFile)
-          {
-            if (resultHandler != null)
-            {
-              status.SetOperation(TestOperation.EntryData);
-              resultHandler(status, (string) null);
-            }
-            Stream inputStream = this.GetInputStream(this[index]);
-            Crc32 crc32 = new Crc32();
-            byte[] buffer = new byte[4096];
-            long num = 0;
-            int count;
-            while ((count = inputStream.Read(buffer, 0, buffer.Length)) > 0)
-            {
-              crc32.Update(buffer, 0, count);
-              if (resultHandler != null)
-              {
-                num += (long) count;
-                status.SetBytesTested(num);
-                resultHandler(status, (string) null);
-              }
-            }
-            if (this[index].Crc != crc32.Value)
-            {
-              status.AddError();
-              if (resultHandler != null)
-                resultHandler(status, "CRC mismatch");
-              if (strategy == TestStrategy.FindFirstError)
-                flag = false;
-            }
-          }
-          if (resultHandler != null)
-          {
-            status.SetOperation(TestOperation.EntryComplete);
-            resultHandler(status, (string) null);
-          }
-        }
-        if (resultHandler != null)
-        {
-          status.SetOperation(TestOperation.MiscellaneousTests);
-          resultHandler(status, (string) null);
-        }
-      }
-      catch (Exception ex)
-      {
-        status.AddError();
-        if (resultHandler != null)
-          resultHandler(status, string.Format("Exception during test - '{0}'", (object) ex.Message));
-      }
-      if (resultHandler != null)
-      {
-        status.SetOperation(TestOperation.Complete);
-        status.SetEntry((ZipEntry) null);
-        resultHandler(status, (string) null);
-      }
-      return status.ErrorCount == 0;
-    }
-
-    private long TestLocalHeader(ZipEntry entry, ZipFile.HeaderTest tests)
-    {
-      lock (this.baseStream_)
-      {
-        bool flag1 = (tests & ZipFile.HeaderTest.Header) != (ZipFile.HeaderTest) 0;
-        bool flag2 = (tests & ZipFile.HeaderTest.Extract) != (ZipFile.HeaderTest) 0;
-        this.baseStream_.Seek(this.offsetOfFirstEntry + entry.Offset, SeekOrigin.Begin);
-        if (this.ReadLEUint() != 67324752U)
-          throw new ZipException(string.Format("Wrong local header signature @{0:X}", (object) (this.offsetOfFirstEntry + entry.Offset)));
-        short num1 = (short) this.ReadLEUshort();
-        short flags = (short) this.ReadLEUshort();
-        short num2 = (short) this.ReadLEUshort();
-        short num3 = (short) this.ReadLEUshort();
-        short num4 = (short) this.ReadLEUshort();
-        uint num5 = this.ReadLEUint();
-        long num6 = (long) this.ReadLEUint();
-        long num7 = (long) this.ReadLEUint();
-        int length1 = (int) this.ReadLEUshort();
-        int length2 = (int) this.ReadLEUshort();
-        byte[] numArray1 = new byte[length1];
-        StreamUtils.ReadFully(this.baseStream_, numArray1);
-        byte[] numArray2 = new byte[length2];
-        StreamUtils.ReadFully(this.baseStream_, numArray2);
-        ZipExtraData zipExtraData = new ZipExtraData(numArray2);
-        if (zipExtraData.Find(1))
-        {
-          if (num1 < (short) 45)
-            throw new ZipException(string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough", (object) ((int) num1 / 10), (object) ((int) num1 % 10)));
-          num7 = (uint) num7 == uint.MaxValue || (uint) num6 == uint.MaxValue ? zipExtraData.ReadLong() : throw new ZipException("Entry sizes not correct for Zip64");
-          num6 = zipExtraData.ReadLong();
-        }
-        else if (num1 >= (short) 45 && ((uint) num7 == uint.MaxValue || (uint) num6 == uint.MaxValue))
-          throw new ZipException("Required Zip64 extended information missing");
-        if (flag2 && entry.IsFile)
-        {
-          if (!entry.IsCompressionMethodSupported())
-            throw new ZipException("Compression method not supported");
-          if (num1 > (short) 45 || num1 > (short) 20 && num1 < (short) 45)
-            throw new ZipException(string.Format("Version required to extract this entry not supported ({0})", (object) num1));
-          if (((int) flags & 12384) != 0)
-            throw new ZipException("The library does not support the zip version required to extract this entry");
-        }
-        if (flag1)
-        {
-          if (num1 <= (short) 63 && num1 != (short) 10 && num1 != (short) 11 && num1 != (short) 20 && num1 != (short) 21 && num1 != (short) 25 && num1 != (short) 27 && num1 != (short) 45 && num1 != (short) 46 && num1 != (short) 50 && num1 != (short) 51 && num1 != (short) 52 && num1 != (short) 61 && num1 != (short) 62 && num1 != (short) 63)
-            throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})", (object) num1));
-          if (((int) flags & 49168) != 0)
-            throw new ZipException("Reserved bit flags cannot be set.");
-          if (((int) flags & 1) != 0 && num1 < (short) 20)
-            throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})", (object) num1));
-          if (((int) flags & 64) != 0)
-          {
-            if (((int) flags & 1) == 0)
-              throw new ZipException("Strong encryption flag set but encryption flag is not set");
-            if (num1 < (short) 50)
-              throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})", (object) num1));
-          }
-          if (((int) flags & 32) != 0 && num1 < (short) 27)
-            throw new ZipException(string.Format("Patched data requires higher version than ({0})", (object) num1));
-          if ((int) flags != entry.Flags)
-            throw new ZipException("Central header/local header flags mismatch");
-          if (entry.CompressionMethod != (CompressionMethod) num2)
-            throw new ZipException("Central header/local header compression method mismatch");
-          if (((int) flags & 64) != 0 && num1 < (short) 62)
-            throw new ZipException("Strong encryption flag set but version not high enough");
-          if (((int) flags & 8192) != 0 && (num3 != (short) 0 || num4 != (short) 0))
-            throw new ZipException("Header masked set but date/time values non-zero");
-          if (((int) flags & 8) == 0 && (int) num5 != (int) (uint) entry.Crc)
-            throw new ZipException("Central header/local header crc mismatch");
-          if (num7 == 0L && num6 == 0L && num5 != 0U)
-            throw new ZipException("Invalid CRC for empty entry");
-          if (entry.Name.Length > length1)
-            throw new ZipException("File name length mismatch");
-          string stringExt = ZipConstants.ConvertToStringExt((int) flags, numArray1);
-          if (stringExt != entry.Name)
-            throw new ZipException("Central header and local header file name mismatch");
-          if (entry.IsDirectory && (num6 != 0L || num7 != 0L))
-            throw new ZipException("Directory cannot have size");
-          if (!ZipNameTransform.IsValidName(stringExt, true))
-            throw new ZipException("Name is invalid");
-        }
-        if (((int) flags & 8) == 0 || num7 != 0L || num6 != 0L)
-        {
-          if (num7 != entry.Size)
-            throw new ZipException(string.Format("Size mismatch between central header({0}) and local header({1})", (object) entry.Size, (object) num7));
-          if (num6 != entry.CompressedSize)
-            throw new ZipException(string.Format("Compressed size mismatch between central header({0}) and local header({1})", (object) entry.CompressedSize, (object) num6));
-        }
-        int num8 = length1 + length2;
-        return this.offsetOfFirstEntry + entry.Offset + 30L + (long) num8;
-      }
-    }
-
-    public INameTransform NameTransform
-    {
-      get => this.updateNameTransform_;
-      set => this.updateNameTransform_ = value;
-    }
-
-    public int BufferSize
-    {
-      get => this.bufferSize_;
-      set
-      {
-        if (value < 1024)
-          throw new ArgumentOutOfRangeException(nameof (value), "cannot be below 1024");
-        if (this.bufferSize_ == value)
-          return;
-        this.bufferSize_ = value;
-        this.copyBuffer_ = (byte[]) null;
-      }
-    }
-
-    public bool IsUpdating => this.updates_ != null;
-
-    public UseZip64 UseZip64
-    {
-      get => this.useZip64_;
-      set => this.useZip64_ = value;
-    }
-
-    public void BeginUpdate(IArchiveStorage archiveStorage, IDynamicDataSource dataSource)
-    {
-      if (this.IsEmbeddedArchive)
-        throw new ZipException("Cannot update embedded/SFX archives");
-      if (archiveStorage == null)
-        throw new ArgumentNullException(nameof (archiveStorage));
-      if (dataSource == null)
-        throw new ArgumentNullException(nameof (dataSource));
-      this.archiveStorage_ = archiveStorage;
-      this.updateDataSource_ = dataSource;
-      if (this.entries_ != null)
-      {
-        this.updates_ = new ArrayList(this.entries_.Length);
-        foreach (ZipEntry entry in this.entries_)
-          this.updates_.Add((object) new ZipFile.ZipUpdate(entry));
-      }
-      else
-        this.updates_ = new ArrayList();
-      this.contentsEdited_ = false;
-      this.commentEdited_ = false;
-      this.newComment_ = (ZipFile.ZipString) null;
-    }
-
-    public void BeginUpdate(IArchiveStorage archiveStorage)
-    {
-      this.BeginUpdate(archiveStorage, (IDynamicDataSource) new DynamicDiskDataSource());
-    }
-
-    public void BeginUpdate()
-    {
-      if (this.Name == null)
-        this.BeginUpdate((IArchiveStorage) new MemoryArchiveStorage(), (IDynamicDataSource) new DynamicDiskDataSource());
-      else
-        this.BeginUpdate((IArchiveStorage) new DiskArchiveStorage(this), (IDynamicDataSource) new DynamicDiskDataSource());
-    }
-
-    public void CommitUpdate()
-    {
-      this.CheckUpdating();
-      if (this.contentsEdited_)
-        this.RunUpdates();
-      else if (this.commentEdited_)
-        this.UpdateCommentOnly();
-      else if (this.entries_ != null && this.entries_.Length == 0)
-      {
-        byte[] comment = this.newComment_ != null ? this.newComment_.RawComment : ZipConstants.ConvertToArray(this.comment_);
-        using (ZipHelperStream zipHelperStream = new ZipHelperStream(this.baseStream_))
-          zipHelperStream.WriteEndOfCentralDirectory(0L, 0L, 0L, comment);
-      }
-      this.PostUpdateCleanup();
-    }
-
-    public void AbortUpdate()
-    {
-      this.updates_ = (ArrayList) null;
-      this.PostUpdateCleanup();
-    }
-
-    public void SetComment(string comment)
-    {
-      this.CheckUpdating();
-      this.newComment_ = new ZipFile.ZipString(comment);
-      if (this.newComment_.RawLength > (int) ushort.MaxValue)
-      {
-        this.newComment_ = (ZipFile.ZipString) null;
-        throw new ZipException("Comment length exceeds maximum - 65535");
-      }
-      this.commentEdited_ = true;
-    }
-
-    public void Add(string fileName, CompressionMethod compressionMethod, bool useUnicodeText)
-    {
-      if (fileName == null)
-        throw new ArgumentNullException(nameof (fileName));
-      if (!ZipEntry.IsCompressionMethodSupported(compressionMethod))
-        throw new ZipException("Compression method not supported");
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      string transformedFileName = this.GetTransformedFileName(fileName);
-      int existingUpdate = this.FindExistingUpdate(transformedFileName);
-      if (existingUpdate >= 0)
-        this.updates_.RemoveAt(existingUpdate);
-      this.updates_.Add((object) new ZipFile.ZipUpdate(fileName, transformedFileName, compressionMethod)
-      {
-        Entry = {
-          IsUnicodeText = useUnicodeText
-        }
-      });
-    }
-
-    public void Add(string fileName, CompressionMethod compressionMethod)
-    {
-      if (fileName == null)
-        throw new ArgumentNullException(nameof (fileName));
-      if (!ZipEntry.IsCompressionMethodSupported(compressionMethod))
-        throw new ZipException("Compression method not supported");
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      string transformedFileName = this.GetTransformedFileName(fileName);
-      int existingUpdate = this.FindExistingUpdate(transformedFileName);
-      if (existingUpdate >= 0)
-        this.updates_.RemoveAt(existingUpdate);
-      this.updates_.Add((object) new ZipFile.ZipUpdate(fileName, transformedFileName, compressionMethod));
-    }
-
-    public void Add(string fileName)
-    {
-      if (fileName == null)
-        throw new ArgumentNullException(nameof (fileName));
-      this.CheckUpdating();
-      this.Add(fileName, CompressionMethod.Deflated);
-    }
-
-    public void Add(IStaticDataSource dataSource, string entryName)
-    {
-      if (dataSource == null)
-        throw new ArgumentNullException(nameof (dataSource));
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      this.updates_.Add((object) new ZipFile.ZipUpdate(dataSource, this.GetTransformedFileName(entryName), CompressionMethod.Deflated));
-    }
-
-    public void Add(
-      IStaticDataSource dataSource,
-      string entryName,
-      CompressionMethod compressionMethod)
-    {
-      if (dataSource == null)
-        throw new ArgumentNullException(nameof (dataSource));
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      this.updates_.Add((object) new ZipFile.ZipUpdate(dataSource, this.GetTransformedFileName(entryName), compressionMethod));
-    }
-
-    public void Add(
-      IStaticDataSource dataSource,
-      string entryName,
-      CompressionMethod compressionMethod,
-      bool useUnicodeText)
-    {
-      if (dataSource == null)
-        throw new ArgumentNullException(nameof (dataSource));
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      this.updates_.Add((object) new ZipFile.ZipUpdate(dataSource, this.GetTransformedFileName(entryName), compressionMethod)
-      {
-        Entry = {
-          IsUnicodeText = useUnicodeText
-        }
-      });
-    }
-
-    public void Add(ZipEntry entry)
-    {
-      if (entry == null)
-        throw new ArgumentNullException(nameof (entry));
-      this.CheckUpdating();
-      if (entry.Size != 0L || entry.CompressedSize != 0L)
-        throw new ZipException("Entry cannot have any data");
-      this.contentsEdited_ = true;
-      this.updates_.Add((object) new ZipFile.ZipUpdate(ZipFile.UpdateCommand.Add, entry));
-    }
-
-    public void AddDirectory(string directoryName)
-    {
-      if (directoryName == null)
-        throw new ArgumentNullException(nameof (directoryName));
-      this.CheckUpdating();
-      this.updates_.Add((object) new ZipFile.ZipUpdate(ZipFile.UpdateCommand.Add, new ZipEntry(this.GetTransformedDirectoryName(directoryName))
-      {
-        ExternalFileAttributes = 16
-      }));
-    }
-
-    public bool Delete(string fileName)
-    {
-      this.CheckUpdating();
-      int existingUpdate = this.FindExistingUpdate(fileName);
-      if (existingUpdate < 0)
-        throw new ZipException("Cannot find entry to delete");
-      bool flag = true;
-      this.contentsEdited_ = true;
-      this.updates_.RemoveAt(existingUpdate);
-      return flag;
-    }
-
-    public void Delete(ZipEntry entry)
-    {
-      this.CheckUpdating();
-      int existingUpdate = this.FindExistingUpdate(entry);
-      if (existingUpdate < 0)
-        throw new ZipException("Cannot find entry to delete");
-      this.contentsEdited_ = true;
-      this.updates_.RemoveAt(existingUpdate);
-    }
-
-    private void WriteLEShort(int value)
-    {
-      this.baseStream_.WriteByte((byte) (value & (int) byte.MaxValue));
-      this.baseStream_.WriteByte((byte) (value >> 8 & (int) byte.MaxValue));
-    }
-
-    private void WriteLEUshort(ushort value)
-    {
-      this.baseStream_.WriteByte((byte) ((uint) value & (uint) byte.MaxValue));
-      this.baseStream_.WriteByte((byte) ((uint) value >> 8));
-    }
-
-    private void WriteLEInt(int value)
-    {
-      this.WriteLEShort(value);
-      this.WriteLEShort(value >> 16);
-    }
-
-    private void WriteLEUint(uint value)
-    {
-      this.WriteLEUshort((ushort) (value & (uint) ushort.MaxValue));
-      this.WriteLEUshort((ushort) (value >> 16));
-    }
-
-    private void WriteLeLong(long value)
-    {
-      this.WriteLEInt((int) (value & (long) uint.MaxValue));
-      this.WriteLEInt((int) (value >> 32));
-    }
-
-    private void WriteLEUlong(ulong value)
-    {
-      this.WriteLEUint((uint) (value & (ulong) uint.MaxValue));
-      this.WriteLEUint((uint) (value >> 32));
-    }
-
-    private void WriteLocalEntryHeader(ZipFile.ZipUpdate update)
-    {
-      ZipEntry outEntry = update.OutEntry;
-      outEntry.Offset = this.baseStream_.Position;
-      if (update.Command != ZipFile.UpdateCommand.Copy)
-      {
-        if (outEntry.CompressionMethod == CompressionMethod.Deflated)
-        {
-          if (outEntry.Size == 0L)
-          {
-            outEntry.CompressedSize = outEntry.Size;
-            outEntry.Crc = 0L;
-            outEntry.CompressionMethod = CompressionMethod.Stored;
-          }
-        }
-        else if (outEntry.CompressionMethod == CompressionMethod.Stored)
-          outEntry.Flags &= -9;
-        if (this.HaveKeys)
-        {
-          outEntry.IsCrypted = true;
-          if (outEntry.Crc < 0L)
-            outEntry.Flags |= 8;
-        }
-        else
-          outEntry.IsCrypted = false;
-        switch (this.useZip64_)
-        {
-          case UseZip64.On:
-            outEntry.ForceZip64();
-            break;
-          case UseZip64.Dynamic:
-            if (outEntry.Size < 0L)
-            {
-              outEntry.ForceZip64();
-              break;
-            }
-            break;
-        }
-      }
-      this.WriteLEInt(67324752);
-      this.WriteLEShort(outEntry.Version);
-      this.WriteLEShort(outEntry.Flags);
-      this.WriteLEShort((int) (byte) outEntry.CompressionMethod);
-      this.WriteLEInt((int) outEntry.DosTime);
-      if (!outEntry.HasCrc)
-      {
-        update.CrcPatchOffset = this.baseStream_.Position;
-        this.WriteLEInt(0);
-      }
-      else
-        this.WriteLEInt((int) outEntry.Crc);
-      if (outEntry.LocalHeaderRequiresZip64)
-      {
-        this.WriteLEInt(-1);
-        this.WriteLEInt(-1);
-      }
-      else
-      {
-        if (outEntry.CompressedSize < 0L || outEntry.Size < 0L)
-          update.SizePatchOffset = this.baseStream_.Position;
-        this.WriteLEInt((int) outEntry.CompressedSize);
-        this.WriteLEInt((int) outEntry.Size);
-      }
-      byte[] array = ZipConstants.ConvertToArray(outEntry.Flags, outEntry.Name);
-      if (array.Length > (int) ushort.MaxValue)
-        throw new ZipException("Entry name too long.");
-      ZipExtraData zipExtraData = new ZipExtraData(outEntry.ExtraData);
-      if (outEntry.LocalHeaderRequiresZip64)
-      {
-        zipExtraData.StartNewEntry();
-        zipExtraData.AddLeLong(outEntry.Size);
-        zipExtraData.AddLeLong(outEntry.CompressedSize);
-        zipExtraData.AddNewEntry(1);
-      }
-      else
-        zipExtraData.Delete(1);
-      outEntry.ExtraData = zipExtraData.GetEntryData();
-      this.WriteLEShort(array.Length);
-      this.WriteLEShort(outEntry.ExtraData.Length);
-      if (array.Length > 0)
-        this.baseStream_.Write(array, 0, array.Length);
-      if (outEntry.LocalHeaderRequiresZip64)
-      {
-        if (!zipExtraData.Find(1))
-          throw new ZipException("Internal error cannot find extra data");
-        update.SizePatchOffset = this.baseStream_.Position + (long) zipExtraData.CurrentReadIndex;
-      }
-      if (outEntry.ExtraData.Length <= 0)
-        return;
-      this.baseStream_.Write(outEntry.ExtraData, 0, outEntry.ExtraData.Length);
-    }
-
-    private int WriteCentralDirectoryHeader(ZipEntry entry)
-    {
-      if (entry.CompressedSize < 0L)
-        throw new ZipException("Attempt to write central directory entry with unknown csize");
-      if (entry.Size < 0L)
-        throw new ZipException("Attempt to write central directory entry with unknown size");
-      if (entry.Crc < 0L)
-        throw new ZipException("Attempt to write central directory entry with unknown crc");
-      this.WriteLEInt(33639248);
-      this.WriteLEShort(45);
-      this.WriteLEShort(entry.Version);
-      this.WriteLEShort(entry.Flags);
-      this.WriteLEShort((int) (byte) entry.CompressionMethod);
-      this.WriteLEInt((int) entry.DosTime);
-      this.WriteLEInt((int) entry.Crc);
-      if (entry.IsZip64Forced() || entry.CompressedSize >= (long) uint.MaxValue)
-        this.WriteLEInt(-1);
-      else
-        this.WriteLEInt((int) (entry.CompressedSize & (long) uint.MaxValue));
-      if (entry.IsZip64Forced() || entry.Size >= (long) uint.MaxValue)
-        this.WriteLEInt(-1);
-      else
-        this.WriteLEInt((int) entry.Size);
-      byte[] array = ZipConstants.ConvertToArray(entry.Flags, entry.Name);
-      if (array.Length > (int) ushort.MaxValue)
-        throw new ZipException("Entry name is too long.");
-      this.WriteLEShort(array.Length);
-      ZipExtraData zipExtraData = new ZipExtraData(entry.ExtraData);
-      if (entry.CentralHeaderRequiresZip64)
-      {
-        zipExtraData.StartNewEntry();
-        if (entry.Size >= (long) uint.MaxValue || this.useZip64_ == UseZip64.On)
-          zipExtraData.AddLeLong(entry.Size);
-        if (entry.CompressedSize >= (long) uint.MaxValue || this.useZip64_ == UseZip64.On)
-          zipExtraData.AddLeLong(entry.CompressedSize);
-        if (entry.Offset >= (long) uint.MaxValue)
-          zipExtraData.AddLeLong(entry.Offset);
-        zipExtraData.AddNewEntry(1);
-      }
-      else
-        zipExtraData.Delete(1);
-      byte[] entryData = zipExtraData.GetEntryData();
-      this.WriteLEShort(entryData.Length);
-      this.WriteLEShort(entry.Comment != null ? entry.Comment.Length : 0);
-      this.WriteLEShort(0);
-      this.WriteLEShort(0);
-      if (entry.ExternalFileAttributes != -1)
-        this.WriteLEInt(entry.ExternalFileAttributes);
-      else if (entry.IsDirectory)
-        this.WriteLEUint(16U);
-      else
-        this.WriteLEUint(0U);
-      if (entry.Offset >= (long) uint.MaxValue)
-        this.WriteLEUint(uint.MaxValue);
-      else
-        this.WriteLEUint((uint) (int) entry.Offset);
-      if (array.Length > 0)
-        this.baseStream_.Write(array, 0, array.Length);
-      if (entryData.Length > 0)
-        this.baseStream_.Write(entryData, 0, entryData.Length);
-      byte[] buffer = entry.Comment != null ? Encoding.ASCII.GetBytes(entry.Comment) : new byte[0];
-      if (buffer.Length > 0)
-        this.baseStream_.Write(buffer, 0, buffer.Length);
-      return 46 + array.Length + entryData.Length + buffer.Length;
-    }
-
-    private void PostUpdateCleanup()
-    {
-      if (this.archiveStorage_ != null)
-      {
-        this.archiveStorage_.Dispose();
-        this.archiveStorage_ = (IArchiveStorage) null;
-      }
-      this.updateDataSource_ = (IDynamicDataSource) null;
-    }
-
-    private string GetTransformedFileName(string name)
-    {
-      return this.updateNameTransform_ == null ? name : this.updateNameTransform_.TransformFile(name);
-    }
-
-    private string GetTransformedDirectoryName(string name)
-    {
-      return this.updateNameTransform_ == null ? name : this.updateNameTransform_.TransformDirectory(name);
-    }
-
-    private byte[] GetBuffer()
-    {
-      if (this.copyBuffer_ == null)
-        this.copyBuffer_ = new byte[this.bufferSize_];
-      return this.copyBuffer_;
-    }
-
-    private void CopyDescriptorBytes(ZipFile.ZipUpdate update, Stream dest, Stream source)
-    {
-      int descriptorSize = this.GetDescriptorSize(update);
-      if (descriptorSize <= 0)
-        return;
-      byte[] buffer = this.GetBuffer();
-      int count1;
-      for (; descriptorSize > 0; descriptorSize -= count1)
-      {
-        int count2 = Math.Min(buffer.Length, descriptorSize);
-        count1 = source.Read(buffer, 0, count2);
-        if (count1 <= 0)
-          throw new ZipException("Unxpected end of stream");
-        dest.Write(buffer, 0, count1);
-      }
-    }
-
-    private void CopyBytes(
-      ZipFile.ZipUpdate update,
-      Stream destination,
-      Stream source,
-      long bytesToCopy,
-      bool updateCrc)
-    {
-      if (destination == source)
-        throw new InvalidOperationException("Destination and source are the same");
-      Crc32 crc32 = new Crc32();
-      byte[] buffer = this.GetBuffer();
-      long num1 = bytesToCopy;
-      long num2 = 0;
-      int count1;
-      do
-      {
-        int count2 = buffer.Length;
-        if (bytesToCopy < (long) count2)
-          count2 = (int) bytesToCopy;
-        count1 = source.Read(buffer, 0, count2);
-        if (count1 > 0)
-        {
-          if (updateCrc)
-            crc32.Update(buffer, 0, count1);
-          destination.Write(buffer, 0, count1);
-          bytesToCopy -= (long) count1;
-          num2 += (long) count1;
-        }
-      }
-      while (count1 > 0 && bytesToCopy > 0L);
-      if (num2 != num1)
-        throw new ZipException(string.Format("Failed to copy bytes expected {0} read {1}", (object) num1, (object) num2));
-      if (!updateCrc)
-        return;
-      update.OutEntry.Crc = crc32.Value;
-    }
-
-    private int GetDescriptorSize(ZipFile.ZipUpdate update)
-    {
-      int descriptorSize = 0;
-      if ((update.Entry.Flags & 8) != 0)
-      {
-        descriptorSize = 12;
-        if (update.Entry.LocalHeaderRequiresZip64)
-          descriptorSize = 20;
-      }
-      return descriptorSize;
-    }
-
-    private void CopyDescriptorBytesDirect(
-      ZipFile.ZipUpdate update,
-      Stream stream,
-      ref long destinationPosition,
-      long sourcePosition)
-    {
-      int descriptorSize = this.GetDescriptorSize(update);
-      while (descriptorSize > 0)
-      {
-        int count1 = descriptorSize;
-        byte[] buffer = this.GetBuffer();
-        stream.Position = sourcePosition;
-        int count2 = stream.Read(buffer, 0, count1);
-        if (count2 <= 0)
-          throw new ZipException("Unxpected end of stream");
-        stream.Position = destinationPosition;
-        stream.Write(buffer, 0, count2);
-        descriptorSize -= count2;
-        destinationPosition += (long) count2;
-        sourcePosition += (long) count2;
-      }
-    }
-
-    private void CopyEntryDataDirect(
-      ZipFile.ZipUpdate update,
-      Stream stream,
-      bool updateCrc,
-      ref long destinationPosition,
-      ref long sourcePosition)
-    {
-      long compressedSize = update.Entry.CompressedSize;
-      Crc32 crc32 = new Crc32();
-      byte[] buffer = this.GetBuffer();
-      long num1 = compressedSize;
-      long num2 = 0;
-      int count1;
-      do
-      {
-        int count2 = buffer.Length;
-        if (compressedSize < (long) count2)
-          count2 = (int) compressedSize;
-        stream.Position = sourcePosition;
-        count1 = stream.Read(buffer, 0, count2);
-        if (count1 > 0)
-        {
-          if (updateCrc)
-            crc32.Update(buffer, 0, count1);
-          stream.Position = destinationPosition;
-          stream.Write(buffer, 0, count1);
-          destinationPosition += (long) count1;
-          sourcePosition += (long) count1;
-          compressedSize -= (long) count1;
-          num2 += (long) count1;
-        }
-      }
-      while (count1 > 0 && compressedSize > 0L);
-      if (num2 != num1)
-        throw new ZipException(string.Format("Failed to copy bytes expected {0} read {1}", (object) num1, (object) num2));
-      if (!updateCrc)
-        return;
-      update.OutEntry.Crc = crc32.Value;
-    }
-
-    private int FindExistingUpdate(ZipEntry entry)
-    {
-      int existingUpdate = -1;
-      string transformedFileName = this.GetTransformedFileName(entry.Name);
-      for (int index = 0; index < this.updates_.Count; ++index)
-      {
-        ZipFile.ZipUpdate update = (ZipFile.ZipUpdate) this.updates_[index];
-        if (update.Entry.ZipFileIndex == entry.ZipFileIndex && string.Compare(transformedFileName, update.Entry.Name, true, CultureInfo.InvariantCulture) == 0)
-        {
-          existingUpdate = index;
-          break;
-        }
-      }
-      return existingUpdate;
-    }
-
-    private int FindExistingUpdate(string fileName)
-    {
-      int existingUpdate = -1;
-      string transformedFileName = this.GetTransformedFileName(fileName);
-      for (int index = 0; index < this.updates_.Count; ++index)
-      {
-        if (string.Compare(transformedFileName, ((ZipFile.ZipUpdate) this.updates_[index]).Entry.Name, true, CultureInfo.InvariantCulture) == 0)
-        {
-          existingUpdate = index;
-          break;
-        }
-      }
-      return existingUpdate;
-    }
-
-    private Stream GetOutputStream(ZipEntry entry)
-    {
-      Stream stream = this.baseStream_;
-      if (entry.IsCrypted)
-        stream = this.CreateAndInitEncryptionStream(stream, entry);
-      switch (entry.CompressionMethod)
-      {
-        case CompressionMethod.Stored:
-          return (Stream) new ZipFile.UncompressedStream(stream);
-        case CompressionMethod.Deflated:
-          return (Stream) new DeflaterOutputStream(stream, new Deflater(9, true))
-          {
-            IsStreamOwner = false
-          };
-        default:
-          throw new ZipException("Unknown compression method " + (object) entry.CompressionMethod);
-      }
-    }
-
-    private void AddEntry(ZipFile workFile, ZipFile.ZipUpdate update)
-    {
-      long num = 0;
-      Stream source = (Stream) null;
-      if (update.Entry.IsFile)
-        source = update.GetSource() ?? this.updateDataSource_.GetSource(update.Entry, update.Filename);
-      if (source != null)
-      {
-        using (source)
-        {
-          long length = source.Length;
-          if (update.OutEntry.Size < 0L)
-            update.OutEntry.Size = length;
-          else if (update.OutEntry.Size != length)
-            throw new ZipException("Entry size/stream size mismatch");
-          workFile.WriteLocalEntryHeader(update);
-          num = workFile.baseStream_.Position;
-          using (Stream outputStream = workFile.GetOutputStream(update.OutEntry))
-            this.CopyBytes(update, outputStream, source, length, true);
-        }
-      }
-      else
-      {
-        workFile.WriteLocalEntryHeader(update);
-        num = workFile.baseStream_.Position;
-      }
-      long position = workFile.baseStream_.Position;
-      update.OutEntry.CompressedSize = position - num;
-    }
-
-    private void ModifyEntry(ZipFile workFile, ZipFile.ZipUpdate update)
-    {
-      workFile.WriteLocalEntryHeader(update);
-      long position1 = workFile.baseStream_.Position;
-      if (update.Entry.IsFile && update.Filename != null)
-      {
-        using (Stream outputStream = workFile.GetOutputStream(update.OutEntry))
-        {
-          using (Stream inputStream = this.GetInputStream(update.Entry))
-            this.CopyBytes(update, outputStream, inputStream, inputStream.Length, true);
-        }
-      }
-      long position2 = workFile.baseStream_.Position;
-      update.Entry.CompressedSize = position2 - position1;
-    }
-
-    private void CopyEntryDirect(
-      ZipFile workFile,
-      ZipFile.ZipUpdate update,
-      ref long destinationPosition)
-    {
-      bool flag = false;
-      if (update.Entry.Offset == destinationPosition)
-        flag = true;
-      if (!flag)
-      {
-        this.baseStream_.Position = destinationPosition;
-        workFile.WriteLocalEntryHeader(update);
-        destinationPosition = this.baseStream_.Position;
-      }
-      long offset = update.Entry.Offset + 26L;
-      this.baseStream_.Seek(offset, SeekOrigin.Begin);
-      long sourcePosition = this.baseStream_.Position + (long) this.ReadLEUshort() + (long) this.ReadLEUshort();
-      if (flag)
-      {
-        destinationPosition += sourcePosition - offset + 26L + update.Entry.CompressedSize + (long) this.GetDescriptorSize(update);
-      }
-      else
-      {
-        if (update.Entry.CompressedSize > 0L)
-          this.CopyEntryDataDirect(update, this.baseStream_, false, ref destinationPosition, ref sourcePosition);
-        this.CopyDescriptorBytesDirect(update, this.baseStream_, ref destinationPosition, sourcePosition);
-      }
-    }
-
-    private void CopyEntry(ZipFile workFile, ZipFile.ZipUpdate update)
-    {
-      workFile.WriteLocalEntryHeader(update);
-      if (update.Entry.CompressedSize > 0L)
-      {
-        this.baseStream_.Seek(update.Entry.Offset + 26L, SeekOrigin.Begin);
-        this.baseStream_.Seek((long) ((uint) this.ReadLEUshort() + (uint) this.ReadLEUshort()), SeekOrigin.Current);
-        this.CopyBytes(update, workFile.baseStream_, this.baseStream_, update.Entry.CompressedSize, false);
-      }
-      this.CopyDescriptorBytes(update, workFile.baseStream_, this.baseStream_);
-    }
-
-    private void Reopen(Stream source)
-    {
-      if (source == null)
-        throw new ZipException("Failed to reopen archive - no source");
-      this.isNewArchive_ = false;
-      this.baseStream_ = source;
-      this.ReadEntries();
-    }
-
-    private void Reopen()
-    {
-      if (this.Name == null)
-        throw new InvalidOperationException("Name is not known cannot Reopen");
-      this.Reopen((Stream) File.OpenRead(this.Name));
-    }
-
-    private void UpdateCommentOnly()
-    {
-      long length = this.baseStream_.Length;
-      ZipHelperStream zipHelperStream;
-      if (this.archiveStorage_.UpdateMode == FileUpdateMode.Safe)
-      {
-        zipHelperStream = new ZipHelperStream(this.archiveStorage_.MakeTemporaryCopy(this.baseStream_));
-        zipHelperStream.IsStreamOwner = true;
-        this.baseStream_.Close();
-        this.baseStream_ = (Stream) null;
-      }
-      else if (this.archiveStorage_.UpdateMode == FileUpdateMode.Direct)
-      {
-        this.baseStream_ = this.archiveStorage_.OpenForDirectUpdate(this.baseStream_);
-        zipHelperStream = new ZipHelperStream(this.baseStream_);
-      }
-      else
-      {
-        this.baseStream_.Close();
-        this.baseStream_ = (Stream) null;
-        zipHelperStream = new ZipHelperStream(this.Name);
-      }
-      using (zipHelperStream)
-      {
-        if (zipHelperStream.LocateBlockWithSignature(101010256, length, 22, (int) ushort.MaxValue) < 0L)
-          throw new ZipException("Cannot find central directory");
-        zipHelperStream.Position += 16L;
-        byte[] rawComment = this.newComment_.RawComment;
-        zipHelperStream.WriteLEShort(rawComment.Length);
-        zipHelperStream.Write(rawComment, 0, rawComment.Length);
-        zipHelperStream.SetLength(zipHelperStream.Position);
-      }
-      if (this.archiveStorage_.UpdateMode == FileUpdateMode.Safe)
-        this.Reopen(this.archiveStorage_.ConvertTemporaryToFinal());
-      else
-        this.ReadEntries();
-    }
-
-    private void RunUpdates()
-    {
-      long sizeEntries = 0;
-      long num = 0;
-      bool flag1 = true;
-      bool flag2 = false;
-      long destinationPosition = 0;
-      ZipFile workFile;
-      if (this.IsNewArchive)
-      {
-        workFile = this;
-        workFile.baseStream_.Position = 0L;
-        flag2 = true;
-      }
-      else if (this.archiveStorage_.UpdateMode == FileUpdateMode.Direct)
-      {
-        workFile = this;
-        workFile.baseStream_.Position = 0L;
-        flag2 = true;
-        this.updates_.Sort((IComparer) new ZipFile.UpdateComparer());
-      }
-      else
-      {
-        workFile = ZipFile.Create(this.archiveStorage_.GetTemporaryOutput());
-        workFile.UseZip64 = this.UseZip64;
-        if (this.key != null)
-          workFile.key = (byte[]) this.key.Clone();
-      }
-      try
-      {
-        foreach (ZipFile.ZipUpdate update in this.updates_)
-        {
-          switch (update.Command)
-          {
-            case ZipFile.UpdateCommand.Copy:
-              if (flag2)
-              {
-                this.CopyEntryDirect(workFile, update, ref destinationPosition);
-                continue;
-              }
-              this.CopyEntry(workFile, update);
-              continue;
-            case ZipFile.UpdateCommand.Modify:
-              this.ModifyEntry(workFile, update);
-              continue;
-            case ZipFile.UpdateCommand.Add:
-              if (!this.IsNewArchive && flag2)
-                workFile.baseStream_.Position = destinationPosition;
-              this.AddEntry(workFile, update);
-              if (flag2)
-              {
-                destinationPosition = workFile.baseStream_.Position;
-                continue;
-              }
-              continue;
-            default:
-              continue;
-          }
-        }
-        if (!this.IsNewArchive && flag2)
-          workFile.baseStream_.Position = destinationPosition;
-        long position = workFile.baseStream_.Position;
-        foreach (ZipFile.ZipUpdate update in this.updates_)
-          sizeEntries += (long) workFile.WriteCentralDirectoryHeader(update.OutEntry);
-        byte[] comment = this.newComment_ != null ? this.newComment_.RawComment : ZipConstants.ConvertToArray(this.comment_);
-        using (ZipHelperStream zipHelperStream = new ZipHelperStream(workFile.baseStream_))
-          zipHelperStream.WriteEndOfCentralDirectory((long) this.updates_.Count, sizeEntries, position, comment);
-        num = workFile.baseStream_.Position;
-        foreach (ZipFile.ZipUpdate update in this.updates_)
-        {
-          if (update.CrcPatchOffset > 0L && update.OutEntry.CompressedSize > 0L)
-          {
-            workFile.baseStream_.Position = update.CrcPatchOffset;
-            workFile.WriteLEInt((int) update.OutEntry.Crc);
-          }
-          if (update.SizePatchOffset > 0L)
-          {
-            workFile.baseStream_.Position = update.SizePatchOffset;
-            if (update.OutEntry.LocalHeaderRequiresZip64)
-            {
-              workFile.WriteLeLong(update.OutEntry.Size);
-              workFile.WriteLeLong(update.OutEntry.CompressedSize);
-            }
-            else
-            {
-              workFile.WriteLEInt((int) update.OutEntry.CompressedSize);
-              workFile.WriteLEInt((int) update.OutEntry.Size);
-            }
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        flag1 = false;
-      }
-      finally
-      {
-        if (flag2)
-        {
-          if (flag1)
-          {
-            workFile.baseStream_.Flush();
-            workFile.baseStream_.SetLength(num);
-          }
-        }
-        else
-          workFile.Close();
-      }
-      if (flag1)
-      {
-        if (flag2)
-        {
-          this.isNewArchive_ = false;
-          workFile.baseStream_.Flush();
-          this.ReadEntries();
-        }
-        else
-        {
-          this.baseStream_.Close();
-          this.Reopen(this.archiveStorage_.ConvertTemporaryToFinal());
-        }
-      }
-      else
-      {
-        workFile.Close();
-        if (flag2 || workFile.Name == null)
-          return;
-        File.Delete(workFile.Name);
-      }
-    }
-
-    private void CheckUpdating()
-    {
-      if (this.updates_ == null)
-        throw new ZipException("Cannot update until BeginUpdate has been called");
-    }
-
-    void IDisposable.Dispose() => this.Close();
-
-    private void DisposeInternal(bool disposing)
-    {
-      if (this.isDisposed_)
-        return;
-      this.isDisposed_ = true;
-      this.entries_ = (ZipEntry[]) null;
-      if (!this.IsStreamOwner || this.baseStream_ == null)
-        return;
-      lock (this.baseStream_)
-        this.baseStream_.Close();
-    }
-
-    protected virtual void Dispose(bool disposing) => this.DisposeInternal(disposing);
-
-    private ushort ReadLEUshort()
-    {
-      int num1 = this.baseStream_.ReadByte();
-      if (num1 < 0)
-        throw new EndOfStreamException("End of stream");
-      int num2 = this.baseStream_.ReadByte();
-      if (num2 < 0)
-        throw new EndOfStreamException("End of stream");
-      return (ushort) ((uint) (ushort) num1 | (uint) (ushort) (num2 << 8));
-    }
-
-    private uint ReadLEUint() => (uint) this.ReadLEUshort() | (uint) this.ReadLEUshort() << 16;
-
-    private ulong ReadLEUlong() => (ulong) this.ReadLEUint() | (ulong) this.ReadLEUint() << 32;
-
-    private long LocateBlockWithSignature(
-      int signature,
-      long endLocation,
-      int minimumBlockSize,
-      int maximumVariableData)
-    {
-      using (ZipHelperStream zipHelperStream = new ZipHelperStream(this.baseStream_))
-        return zipHelperStream.LocateBlockWithSignature(signature, endLocation, minimumBlockSize, maximumVariableData);
-    }
-
-    private void ReadEntries()
-    {
-      long endLocation = this.baseStream_.CanSeek ? this.LocateBlockWithSignature(101010256, this.baseStream_.Length, 22, (int) ushort.MaxValue) : throw new ZipException("ZipFile stream must be seekable");
-      if (endLocation < 0L)
-        throw new ZipException("Cannot find central directory");
-      ushort num1 = this.ReadLEUshort();
-      ushort num2 = this.ReadLEUshort();
-      ulong length1 = (ulong) this.ReadLEUshort();
-      ulong num3 = (ulong) this.ReadLEUshort();
-      ulong num4 = (ulong) this.ReadLEUint();
-      long num5 = (long) this.ReadLEUint();
-      uint length2 = (uint) this.ReadLEUshort();
-      if (length2 > 0U)
-      {
-        byte[] numArray = new byte[(IntPtr) length2];
-        StreamUtils.ReadFully(this.baseStream_, numArray);
-        this.comment_ = ZipConstants.ConvertToString(numArray);
-      }
-      else
-        this.comment_ = string.Empty;
-      bool flag = false;
-      if (num1 == ushort.MaxValue || num2 == ushort.MaxValue || length1 == (ulong) ushort.MaxValue || num3 == (ulong) ushort.MaxValue || num4 == (ulong) uint.MaxValue || num5 == (long) uint.MaxValue)
-      {
-        flag = true;
-        if (this.LocateBlockWithSignature(117853008, endLocation, 0, 4096) < 0L)
-          throw new ZipException("Cannot find Zip64 locator");
-        int num6 = (int) this.ReadLEUint();
-        ulong num7 = this.ReadLEUlong();
-        int num8 = (int) this.ReadLEUint();
-        this.baseStream_.Position = (long) num7;
-        if (this.ReadLEUint() != 101075792U)
-          throw new ZipException(string.Format("Invalid Zip64 Central directory signature at {0:X}", (object) num7));
-        long num9 = (long) this.ReadLEUlong();
-        int num10 = (int) this.ReadLEUshort();
-        int num11 = (int) this.ReadLEUshort();
-        int num12 = (int) this.ReadLEUint();
-        int num13 = (int) this.ReadLEUint();
-        length1 = this.ReadLEUlong();
-        this.ReadLEUlong();
-        num4 = this.ReadLEUlong();
-        num5 = (long) this.ReadLEUlong();
-      }
-      this.entries_ = new ZipEntry[length1];
-      if (!flag && num5 < endLocation - (4L + (long) num4))
-      {
-        this.offsetOfFirstEntry = endLocation - (4L + (long) num4 + num5);
-        if (this.offsetOfFirstEntry <= 0L)
-          throw new ZipException("Invalid embedded zip archive");
-      }
-      this.baseStream_.Seek(this.offsetOfFirstEntry + num5, SeekOrigin.Begin);
-      for (ulong index = 0; index < length1; ++index)
-      {
-        if (this.ReadLEUint() != 33639248U)
-          throw new ZipException("Wrong Central Directory signature");
-        int madeByInfo = (int) this.ReadLEUshort();
-        int versionRequiredToExtract = (int) this.ReadLEUshort();
-        int flags = (int) this.ReadLEUshort();
-        int method = (int) this.ReadLEUshort();
-        uint num14 = this.ReadLEUint();
-        uint num15 = this.ReadLEUint();
-        long num16 = (long) this.ReadLEUint();
-        long num17 = (long) this.ReadLEUint();
-        int num18 = (int) this.ReadLEUshort();
-        int length3 = (int) this.ReadLEUshort();
-        int num19 = (int) this.ReadLEUshort();
-        int num20 = (int) this.ReadLEUshort();
-        int num21 = (int) this.ReadLEUshort();
-        uint num22 = this.ReadLEUint();
-        long num23 = (long) this.ReadLEUint();
-        byte[] numArray = new byte[Math.Max(num18, num19)];
-        StreamUtils.ReadFully(this.baseStream_, numArray, 0, num18);
-        ZipEntry zipEntry = new ZipEntry(ZipConstants.ConvertToStringExt(flags, numArray, num18), versionRequiredToExtract, madeByInfo, (CompressionMethod) method);
-        zipEntry.Crc = (long) num15 & (long) uint.MaxValue;
-        zipEntry.Size = num17 & (long) uint.MaxValue;
-        zipEntry.CompressedSize = num16 & (long) uint.MaxValue;
-        zipEntry.Flags = flags;
-        zipEntry.DosTime = (long) num14;
-        zipEntry.ZipFileIndex = (long) index;
-        zipEntry.Offset = num23;
-        zipEntry.ExternalFileAttributes = (int) num22;
-        zipEntry.CryptoCheckValue = (flags & 8) != 0 ? (byte) (num14 >> 8 & (uint) byte.MaxValue) : (byte) (num15 >> 24);
-        if (length3 > 0)
-        {
-          byte[] buffer = new byte[length3];
-          StreamUtils.ReadFully(this.baseStream_, buffer);
-          zipEntry.ExtraData = buffer;
-        }
-        zipEntry.ProcessExtraData(false);
-        if (num19 > 0)
-        {
-          StreamUtils.ReadFully(this.baseStream_, numArray, 0, num19);
-          zipEntry.Comment = ZipConstants.ConvertToStringExt(flags, numArray, num19);
-        }
-        this.entries_[index] = zipEntry;
-      }
-    }
-
-    private long LocateEntry(ZipEntry entry)
-    {
-      return this.TestLocalHeader(entry, ZipFile.HeaderTest.Extract);
-    }
-
-    private Stream CreateAndInitDecryptionStream(Stream baseStream, ZipEntry entry)
-    {
-      if (entry.Version >= 50 && (entry.Flags & 64) != 0)
-        throw new ZipException("Decryption method not supported");
-      PkzipClassicManaged pkzipClassicManaged = new PkzipClassicManaged();
-      this.OnKeysRequired(entry.Name);
-      if (!this.HaveKeys)
-        throw new ZipException("No password available for encrypted stream");
-      CryptoStream classicCryptoStream = new CryptoStream(baseStream, pkzipClassicManaged.CreateDecryptor(this.key, (byte[]) null), CryptoStreamMode.Read);
-      ZipFile.CheckClassicPassword(classicCryptoStream, entry);
-      return (Stream) classicCryptoStream;
-    }
-
-    private Stream CreateAndInitEncryptionStream(Stream baseStream, ZipEntry entry)
-    {
-      CryptoStream encryptionStream = (CryptoStream) null;
-      if (entry.Version < 50 || (entry.Flags & 64) == 0)
-      {
-        PkzipClassicManaged pkzipClassicManaged = new PkzipClassicManaged();
-        this.OnKeysRequired(entry.Name);
-        if (!this.HaveKeys)
-          throw new ZipException("No password available for encrypted stream");
-        encryptionStream = new CryptoStream((Stream) new ZipFile.UncompressedStream(baseStream), pkzipClassicManaged.CreateEncryptor(this.key, (byte[]) null), CryptoStreamMode.Write);
-        if (entry.Crc < 0L || (entry.Flags & 8) != 0)
-          ZipFile.WriteEncryptionHeader((Stream) encryptionStream, entry.DosTime << 16);
-        else
-          ZipFile.WriteEncryptionHeader((Stream) encryptionStream, entry.Crc);
-      }
-      return (Stream) encryptionStream;
-    }
-
-    private static void CheckClassicPassword(CryptoStream classicCryptoStream, ZipEntry entry)
-    {
-      byte[] buffer = new byte[12];
-      StreamUtils.ReadFully((Stream) classicCryptoStream, buffer);
-      if ((int) buffer[11] != (int) entry.CryptoCheckValue)
-        throw new ZipException("Invalid password");
-    }
-
-    private static void WriteEncryptionHeader(Stream stream, long crcValue)
-    {
-      byte[] buffer = new byte[12];
-      new Random().NextBytes(buffer);
-      buffer[11] = (byte) (crcValue >> 24);
-      stream.Write(buffer, 0, buffer.Length);
-    }
-
-    public delegate void KeysRequiredEventHandler(object sender, KeysRequiredEventArgs e);
-
-    [Flags]
-    private enum HeaderTest
-    {
-      Extract = 1,
-      Header = 2,
-    }
-
-    private enum UpdateCommand
-    {
-      Copy,
-      Modify,
-      Add,
-    }
-
-    private class UpdateComparer : IComparer
-    {
-      public int Compare(object x, object y)
-      {
-        ZipFile.ZipUpdate zipUpdate1 = x as ZipFile.ZipUpdate;
-        ZipFile.ZipUpdate zipUpdate2 = y as ZipFile.ZipUpdate;
-        int num1 = (zipUpdate1.Command == ZipFile.UpdateCommand.Copy || zipUpdate1.Command == ZipFile.UpdateCommand.Modify ? 0 : 1) - (zipUpdate2.Command == ZipFile.UpdateCommand.Copy || zipUpdate2.Command == ZipFile.UpdateCommand.Modify ? 0 : 1);
-        if (num1 == 0)
-        {
-          long num2 = zipUpdate1.Entry.Offset - zipUpdate2.Entry.Offset;
-          num1 = num2 >= 0L ? (num2 != 0L ? 1 : 0) : -1;
-        }
-        return num1;
-      }
-    }
-
-    private class ZipUpdate
-    {
-      private ZipEntry entry_;
-      private ZipEntry outEntry_;
-      private ZipFile.UpdateCommand command_;
-      private IStaticDataSource dataSource_;
-      private string filename_;
-      private long sizePatchOffset_ = -1;
-      private long crcPatchOffset_ = -1;
-
-      public ZipUpdate(string fileName, string entryName, CompressionMethod compressionMethod)
-      {
-        this.command_ = ZipFile.UpdateCommand.Add;
-        this.entry_ = new ZipEntry(entryName);
-        this.entry_.CompressionMethod = compressionMethod;
-        this.filename_ = fileName;
-      }
-
-      public ZipUpdate(string fileName, string entryName)
-      {
-        this.command_ = ZipFile.UpdateCommand.Add;
-        this.entry_ = new ZipEntry(entryName);
-        this.filename_ = fileName;
-      }
-
-      public ZipUpdate(
-        IStaticDataSource dataSource,
-        string entryName,
-        CompressionMethod compressionMethod)
-      {
-        this.command_ = ZipFile.UpdateCommand.Add;
-        this.entry_ = new ZipEntry(entryName);
-        this.entry_.CompressionMethod = compressionMethod;
-        this.dataSource_ = dataSource;
-      }
-
-      public ZipUpdate(ZipEntry original, ZipEntry updated)
-      {
-        throw new ZipException("Modify not currently supported");
-      }
-
-      public ZipUpdate(ZipFile.UpdateCommand command, ZipEntry entry)
-      {
-        this.command_ = command;
-        this.entry_ = (ZipEntry) entry.Clone();
-      }
-
-      public ZipUpdate(ZipEntry entry)
-        : this(ZipFile.UpdateCommand.Copy, entry)
-      {
-      }
-
-      public ZipEntry Entry => this.entry_;
-
-      public ZipEntry OutEntry
-      {
-        get
-        {
-          if (this.outEntry_ == null)
-            this.outEntry_ = (ZipEntry) this.entry_.Clone();
-          return this.outEntry_;
-        }
-      }
-
-      public ZipFile.UpdateCommand Command => this.command_;
-
-      public string Filename => this.filename_;
-
-      public long SizePatchOffset
-      {
-        get => this.sizePatchOffset_;
-        set => this.sizePatchOffset_ = value;
-      }
-
-      public long CrcPatchOffset
-      {
-        get => this.crcPatchOffset_;
-        set => this.crcPatchOffset_ = value;
-      }
-
-      public Stream GetSource()
-      {
-        Stream source = (Stream) null;
-        if (this.dataSource_ != null)
-          source = this.dataSource_.GetSource();
-        return source;
-      }
-    }
-
-    private class ZipString
-    {
-      private string comment_;
-      private byte[] rawComment_;
-      private bool isSourceString_;
-
-      public ZipString(string comment)
-      {
-        this.comment_ = comment;
-        this.isSourceString_ = true;
-      }
-
-      public ZipString(byte[] rawString) => this.rawComment_ = rawString;
-
-      public bool IsSourceString => this.isSourceString_;
-
-      public int RawLength
-      {
-        get
-        {
-          this.MakeBytesAvailable();
-          return this.rawComment_.Length;
-        }
-      }
-
-      public byte[] RawComment
-      {
-        get
-        {
-          this.MakeBytesAvailable();
-          return (byte[]) this.rawComment_.Clone();
-        }
-      }
-
-      public void Reset()
-      {
-        if (this.isSourceString_)
-          this.rawComment_ = (byte[]) null;
-        else
-          this.comment_ = (string) null;
-      }
-
-      private void MakeTextAvailable()
-      {
-        if (this.comment_ != null)
-          return;
-        this.comment_ = ZipConstants.ConvertToString(this.rawComment_);
-      }
-
-      private void MakeBytesAvailable()
-      {
-        if (this.rawComment_ != null)
-          return;
-        this.rawComment_ = ZipConstants.ConvertToArray(this.comment_);
-      }
-
-      public static implicit operator string(ZipFile.ZipString zipString)
-      {
-        zipString.MakeTextAvailable();
-        return zipString.comment_;
-      }
-    }
-
-    private class ZipEntryEnumerator : IEnumerator
-    {
-      private ZipEntry[] array;
-      private int index = -1;
-
-      public ZipEntryEnumerator(ZipEntry[] entries) => this.array = entries;
-
-      public object Current => (object) this.array[this.index];
-
-      public void Reset() => this.index = -1;
-
-      public bool MoveNext() => ++this.index < this.array.Length;
-    }
-
-    private class UncompressedStream : Stream
-    {
-      private Stream baseStream_;
-
-      public UncompressedStream(Stream baseStream) => this.baseStream_ = baseStream;
-
-      public override void Close()
-      {
-      }
-
-      public override bool CanRead => false;
-
-      public override void Flush() => this.baseStream_.Flush();
-
-      public override bool CanWrite => this.baseStream_.CanWrite;
-
-      public override bool CanSeek => false;
-
-      public override long Length => 0;
-
-      public override long Position
-      {
-        get => this.baseStream_.Position;
-        set
-        {
-        }
-      }
-
-      public override int Read(byte[] buffer, int offset, int count) => 0;
-
-      public override long Seek(long offset, SeekOrigin origin) => 0;
-
-      public override void SetLength(long value)
-      {
-      }
-
-      public override void Write(byte[] buffer, int offset, int count)
-      {
-        this.baseStream_.Write(buffer, offset, count);
-      }
-    }
-
-    private class PartialInputStream : InflaterInputStream
-    {
-      private Stream baseStream_;
-      private long filepos_;
-      private long end_;
-
-      public PartialInputStream(Stream baseStream, long start, long length)
-        : base(baseStream)
-      {
-        this.baseStream_ = baseStream;
-        this.filepos_ = start;
-        this.end_ = start + length;
-      }
-
-      public long SkipBytes(long count)
-      {
-        if (count < 0L)
-          throw new ArgumentOutOfRangeException(nameof (count), "is less than zero");
-        if (count > this.end_ - this.filepos_)
-          count = this.end_ - this.filepos_;
-        this.filepos_ += count;
-        return count;
-      }
-
-      public override int Available
-      {
-        get
-        {
-          long num = this.end_ - this.filepos_;
-          return num > (long) int.MaxValue ? int.MaxValue : (int) num;
-        }
-      }
-
-      public override int ReadByte()
-      {
-        if (this.filepos_ == this.end_)
-          return -1;
-        lock (this.baseStream_)
-        {
-          this.baseStream_.Seek(this.filepos_++, SeekOrigin.Begin);
-          return this.baseStream_.ReadByte();
-        }
-      }
-
-      public override void Close()
-      {
-      }
-
-      public override int Read(byte[] buffer, int offset, int count)
-      {
-        if ((long) count > this.end_ - this.filepos_)
-        {
-          count = (int) (this.end_ - this.filepos_);
-          if (count == 0)
-            return 0;
-        }
-        lock (this.baseStream_)
-        {
-          this.baseStream_.Seek(this.filepos_, SeekOrigin.Begin);
-          int num = this.baseStream_.Read(buffer, offset, count);
-          if (num > 0)
-            this.filepos_ += (long) num;
-          return num;
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipHelperStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipHelperStream.cs
deleted file mode 100644
index 05bd2a4..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipHelperStream.cs
+++ /dev/null
@@ -1,189 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  internal class ZipHelperStream : Stream
-  {
-    private bool isOwner_;
-    private Stream stream_;
-
-    public ZipHelperStream(string name)
-    {
-      this.stream_ = (Stream) new FileStream(name, FileMode.Open, FileAccess.ReadWrite);
-      this.isOwner_ = true;
-    }
-
-    public ZipHelperStream(Stream stream) => this.stream_ = stream;
-
-    public bool IsStreamOwner
-    {
-      get => this.isOwner_;
-      set => this.isOwner_ = value;
-    }
-
-    public override bool CanRead => this.stream_.CanRead;
-
-    public override bool CanSeek => this.stream_.CanSeek;
-
-    public override bool CanTimeout => this.stream_.CanTimeout;
-
-    public override long Length => this.stream_.Length;
-
-    public override long Position
-    {
-      get => this.stream_.Position;
-      set => this.stream_.Position = value;
-    }
-
-    public override bool CanWrite => this.stream_.CanWrite;
-
-    public override void Flush() => this.stream_.Flush();
-
-    public override long Seek(long offset, SeekOrigin origin) => this.stream_.Seek(offset, origin);
-
-    public override void SetLength(long value) => this.stream_.SetLength(value);
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      return this.stream_.Read(buffer, offset, count);
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      this.stream_.Write(buffer, offset, count);
-    }
-
-    public long LocateBlockWithSignature(
-      int signature,
-      long endLocation,
-      int minimumBlockSize,
-      int maximumVariableData)
-    {
-      long num1 = endLocation - (long) minimumBlockSize;
-      if (num1 < 0L)
-        return -1;
-      long num2 = Math.Max(num1 - (long) maximumVariableData, 0L);
-      while (num1 >= num2)
-      {
-        this.Seek(num1--, SeekOrigin.Begin);
-        if (this.ReadLEInt() == signature)
-          return this.Position;
-      }
-      return -1;
-    }
-
-    public void WriteZip64EndOfCentralDirectory(
-      long noOfEntries,
-      long sizeEntries,
-      long centralDirOffset)
-    {
-      long position = this.stream_.Position;
-      this.WriteLEInt(101075792);
-      this.WriteLELong(44L);
-      this.WriteLEShort(45);
-      this.WriteLEShort(45);
-      this.WriteLEInt(0);
-      this.WriteLEInt(0);
-      this.WriteLELong(noOfEntries);
-      this.WriteLELong(noOfEntries);
-      this.WriteLELong(sizeEntries);
-      this.WriteLELong(centralDirOffset);
-      this.WriteLEInt(117853008);
-      this.WriteLEInt(0);
-      this.WriteLELong(position);
-      this.WriteLEInt(1);
-    }
-
-    public void WriteEndOfCentralDirectory(
-      long noOfEntries,
-      long sizeEntries,
-      long startOfCentralDirectory,
-      byte[] comment)
-    {
-      if (noOfEntries >= (long) ushort.MaxValue || startOfCentralDirectory >= (long) uint.MaxValue || sizeEntries >= (long) uint.MaxValue)
-        this.WriteZip64EndOfCentralDirectory(noOfEntries, sizeEntries, startOfCentralDirectory);
-      this.WriteLEInt(101010256);
-      this.WriteLEShort(0);
-      this.WriteLEShort(0);
-      if (noOfEntries >= (long) ushort.MaxValue)
-      {
-        this.WriteLEUshort(ushort.MaxValue);
-        this.WriteLEUshort(ushort.MaxValue);
-      }
-      else
-      {
-        this.WriteLEShort((int) (short) noOfEntries);
-        this.WriteLEShort((int) (short) noOfEntries);
-      }
-      if (sizeEntries >= (long) uint.MaxValue)
-        this.WriteLEUint(uint.MaxValue);
-      else
-        this.WriteLEInt((int) sizeEntries);
-      if (startOfCentralDirectory >= (long) uint.MaxValue)
-        this.WriteLEUint(uint.MaxValue);
-      else
-        this.WriteLEInt((int) startOfCentralDirectory);
-      int length = comment != null ? comment.Length : 0;
-      if (length > (int) ushort.MaxValue)
-        throw new ZipException(string.Format("Comment length({0}) is too long", (object) length));
-      this.WriteLEShort(length);
-      if (length <= 0)
-        return;
-      this.Write(comment, 0, comment.Length);
-    }
-
-    public int ReadLEShort() => this.stream_.ReadByte() | this.stream_.ReadByte() << 8;
-
-    public int ReadLEInt() => this.ReadLEShort() | this.ReadLEShort() << 16;
-
-    public long ReadLELong() => (long) (uint) this.ReadLEInt() | (long) this.ReadLEInt() << 32;
-
-    public void WriteLEShort(int value)
-    {
-      this.stream_.WriteByte((byte) (value & (int) byte.MaxValue));
-      this.stream_.WriteByte((byte) (value >> 8 & (int) byte.MaxValue));
-    }
-
-    public void WriteLEUshort(ushort value)
-    {
-      this.stream_.WriteByte((byte) ((uint) value & (uint) byte.MaxValue));
-      this.stream_.WriteByte((byte) ((uint) value >> 8));
-    }
-
-    public void WriteLEInt(int value)
-    {
-      this.WriteLEShort(value);
-      this.WriteLEShort(value >> 16);
-    }
-
-    public void WriteLEUint(uint value)
-    {
-      this.WriteLEUshort((ushort) (value & (uint) ushort.MaxValue));
-      this.WriteLEUshort((ushort) (value >> 16));
-    }
-
-    public void WriteLELong(long value)
-    {
-      this.WriteLEInt((int) value);
-      this.WriteLEInt((int) (value >> 32));
-    }
-
-    public void WriteLEUlong(ulong value)
-    {
-      this.WriteLEUint((uint) (value & (ulong) uint.MaxValue));
-      this.WriteLEUint((uint) (value >> 32));
-    }
-
-    public override void Close()
-    {
-      Stream stream = this.stream_;
-      this.stream_ = (Stream) null;
-      if (!this.isOwner_ || stream == null)
-        return;
-      this.isOwner_ = false;
-      stream.Close();
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipInputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipInputStream.cs
deleted file mode 100644
index 70a3d8b..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipInputStream.cs
+++ /dev/null
@@ -1,299 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Encryption;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.IO;
-using System.Security.Cryptography;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipInputStream : InflaterInputStream
-  {
-    private ZipInputStream.ReaderDelegate internalReader;
-    private Crc32 crc = new Crc32();
-    private ZipEntry entry;
-    private long size;
-    private int method;
-    private int flags;
-    private string password;
-
-    public ZipInputStream(Stream baseInputStream)
-      : base(baseInputStream, new Inflater(true))
-    {
-      this.internalReader = new ZipInputStream.ReaderDelegate(this.ReadingNotAvailable);
-    }
-
-    public string Password
-    {
-      get => this.password;
-      set => this.password = value;
-    }
-
-    public bool CanDecompressEntry => this.entry != null && this.entry.CanDecompress;
-
-    public ZipEntry GetNextEntry()
-    {
-      if (this.crc == null)
-        throw new InvalidOperationException("Closed.");
-      if (this.entry != null)
-        this.CloseEntry();
-      int num1 = this.inputBuffer.ReadLeInt();
-      if (num1 == 33639248 || num1 == 101010256 || num1 == 84233040 || num1 == 117853008 || num1 == 101075792)
-      {
-        this.Close();
-        return (ZipEntry) null;
-      }
-      if (num1 == 808471376 || num1 == 134695760)
-        num1 = this.inputBuffer.ReadLeInt();
-      if (num1 != 67324752)
-        throw new ZipException("Wrong Local header signature: 0x" + string.Format("{0:X}", (object) num1));
-      short versionRequiredToExtract = (short) this.inputBuffer.ReadLeShort();
-      this.flags = this.inputBuffer.ReadLeShort();
-      this.method = this.inputBuffer.ReadLeShort();
-      uint num2 = (uint) this.inputBuffer.ReadLeInt();
-      int num3 = this.inputBuffer.ReadLeInt();
-      this.csize = (long) this.inputBuffer.ReadLeInt();
-      this.size = (long) this.inputBuffer.ReadLeInt();
-      int length1 = this.inputBuffer.ReadLeShort();
-      int length2 = this.inputBuffer.ReadLeShort();
-      bool flag = (this.flags & 1) == 1;
-      byte[] numArray = new byte[length1];
-      this.inputBuffer.ReadRawBuffer(numArray);
-      this.entry = new ZipEntry(ZipConstants.ConvertToStringExt(this.flags, numArray), (int) versionRequiredToExtract);
-      this.entry.Flags = this.flags;
-      this.entry.CompressionMethod = (CompressionMethod) this.method;
-      if ((this.flags & 8) == 0)
-      {
-        this.entry.Crc = (long) num3 & (long) uint.MaxValue;
-        this.entry.Size = this.size & (long) uint.MaxValue;
-        this.entry.CompressedSize = this.csize & (long) uint.MaxValue;
-        this.entry.CryptoCheckValue = (byte) (num3 >> 24 & (int) byte.MaxValue);
-      }
-      else
-      {
-        if (num3 != 0)
-          this.entry.Crc = (long) num3 & (long) uint.MaxValue;
-        if (this.size != 0L)
-          this.entry.Size = this.size & (long) uint.MaxValue;
-        if (this.csize != 0L)
-          this.entry.CompressedSize = this.csize & (long) uint.MaxValue;
-        this.entry.CryptoCheckValue = (byte) (num2 >> 8 & (uint) byte.MaxValue);
-      }
-      this.entry.DosTime = (long) num2;
-      if (length2 > 0)
-      {
-        byte[] buffer = new byte[length2];
-        this.inputBuffer.ReadRawBuffer(buffer);
-        this.entry.ExtraData = buffer;
-      }
-      this.entry.ProcessExtraData(true);
-      if (this.entry.CompressedSize >= 0L)
-        this.csize = this.entry.CompressedSize;
-      if (this.entry.Size >= 0L)
-        this.size = this.entry.Size;
-      if (this.method == 0 && (!flag && this.csize != this.size || flag && this.csize - 12L != this.size))
-        throw new ZipException("Stored, but compressed != uncompressed");
-      this.internalReader = !this.entry.IsCompressionMethodSupported() ? new ZipInputStream.ReaderDelegate(this.ReadingNotSupported) : new ZipInputStream.ReaderDelegate(this.InitialRead);
-      return this.entry;
-    }
-
-    private void ReadDataDescriptor()
-    {
-      if (this.inputBuffer.ReadLeInt() != 134695760)
-        throw new ZipException("Data descriptor signature not found");
-      this.entry.Crc = (long) this.inputBuffer.ReadLeInt() & (long) uint.MaxValue;
-      if (this.entry.LocalHeaderRequiresZip64)
-      {
-        this.csize = this.inputBuffer.ReadLeLong();
-        this.size = this.inputBuffer.ReadLeLong();
-      }
-      else
-      {
-        this.csize = (long) this.inputBuffer.ReadLeInt();
-        this.size = (long) this.inputBuffer.ReadLeInt();
-      }
-      this.entry.CompressedSize = this.csize;
-      this.entry.Size = this.size;
-    }
-
-    private void CompleteCloseEntry(bool testCrc)
-    {
-      this.StopDecrypting();
-      if ((this.flags & 8) != 0)
-        this.ReadDataDescriptor();
-      this.size = 0L;
-      if (testCrc && (this.crc.Value & (long) uint.MaxValue) != this.entry.Crc && this.entry.Crc != -1L)
-        throw new ZipException("CRC mismatch");
-      this.crc.Reset();
-      if (this.method == 8)
-        this.inf.Reset();
-      this.entry = (ZipEntry) null;
-    }
-
-    public void CloseEntry()
-    {
-      if (this.crc == null)
-        throw new InvalidOperationException("Closed");
-      if (this.entry == null)
-        return;
-      if (this.method == 8)
-      {
-        if ((this.flags & 8) != 0)
-        {
-          byte[] buffer = new byte[2048];
-          do
-            ;
-          while (this.Read(buffer, 0, buffer.Length) > 0);
-          return;
-        }
-        this.csize -= this.inf.TotalIn;
-        this.inputBuffer.Available += this.inf.RemainingInput;
-      }
-      if ((long) this.inputBuffer.Available > this.csize && this.csize >= 0L)
-      {
-        this.inputBuffer.Available = (int) ((long) this.inputBuffer.Available - this.csize);
-      }
-      else
-      {
-        this.csize -= (long) this.inputBuffer.Available;
-        this.inputBuffer.Available = 0;
-        int num;
-        ZipInputStream zipInputStream;
-        for (; this.csize != 0L; zipInputStream.csize -= (long) num)
-        {
-          num = (int) this.Skip(this.csize & (long) uint.MaxValue);
-          if (num <= 0)
-            throw new ZipException("Zip archive ends early.");
-          zipInputStream = this;
-        }
-      }
-      this.CompleteCloseEntry(false);
-    }
-
-    public override int Available => this.entry == null ? 0 : 1;
-
-    public override long Length
-    {
-      get
-      {
-        if (this.entry == null)
-          throw new InvalidOperationException("No current entry");
-        return this.entry.Size >= 0L ? this.entry.Size : throw new ZipException("Length not available for the current entry");
-      }
-    }
-
-    public override int ReadByte()
-    {
-      byte[] buffer = new byte[1];
-      return this.Read(buffer, 0, 1) <= 0 ? -1 : (int) buffer[0] & (int) byte.MaxValue;
-    }
-
-    private int ReadingNotAvailable(byte[] destination, int offset, int count)
-    {
-      throw new InvalidOperationException("Unable to read from this stream");
-    }
-
-    private int ReadingNotSupported(byte[] destination, int offset, int count)
-    {
-      throw new ZipException("The compression method for this entry is not supported");
-    }
-
-    private int InitialRead(byte[] destination, int offset, int count)
-    {
-      if (!this.CanDecompressEntry)
-        throw new ZipException("Library cannot extract this entry. Version required is (" + this.entry.Version.ToString() + ")");
-      if (this.entry.IsCrypted)
-      {
-        this.inputBuffer.CryptoTransform = this.password != null ? new PkzipClassicManaged().CreateDecryptor(PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(this.password)), (byte[]) null) : throw new ZipException("No password set.");
-        byte[] outBuffer = new byte[12];
-        this.inputBuffer.ReadClearTextBuffer(outBuffer, 0, 12);
-        if ((int) outBuffer[11] != (int) this.entry.CryptoCheckValue)
-          throw new ZipException("Invalid password");
-        if (this.csize >= 12L)
-          this.csize -= 12L;
-      }
-      else
-        this.inputBuffer.CryptoTransform = (ICryptoTransform) null;
-      if (this.method == 8 && this.inputBuffer.Available > 0)
-        this.inputBuffer.SetInflaterInput(this.inf);
-      this.internalReader = new ZipInputStream.ReaderDelegate(this.BodyRead);
-      return this.BodyRead(destination, offset, count);
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be negative");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be negative");
-      if (buffer.Length - offset < count)
-        throw new ArgumentException("Invalid offset/count combination");
-      return this.internalReader(buffer, offset, count);
-    }
-
-    private int BodyRead(byte[] buffer, int offset, int count)
-    {
-      if (this.crc == null)
-        throw new InvalidOperationException("Closed");
-      if (this.entry == null || count <= 0)
-        return 0;
-      if (offset + count > buffer.Length)
-        throw new ArgumentException("Offset + count exceeds buffer size");
-      bool flag = false;
-      switch (this.method)
-      {
-        case 0:
-          if ((long) count > this.csize && this.csize >= 0L)
-            count = (int) this.csize;
-          if (count > 0)
-          {
-            count = this.inputBuffer.ReadClearTextBuffer(buffer, offset, count);
-            if (count > 0)
-            {
-              this.csize -= (long) count;
-              this.size -= (long) count;
-            }
-          }
-          if (this.csize == 0L)
-          {
-            flag = true;
-            break;
-          }
-          if (count < 0)
-            throw new ZipException("EOF in stored block");
-          break;
-        case 8:
-          count = base.Read(buffer, offset, count);
-          if (count <= 0)
-          {
-            this.inputBuffer.Available = this.inf.IsFinished ? this.inf.RemainingInput : throw new ZipException("Inflater not finished!");
-            if ((this.flags & 8) == 0 && (this.inf.TotalIn != this.csize || this.inf.TotalOut != this.size))
-              throw new ZipException("Size mismatch: " + (object) this.csize + ";" + (object) this.size + " <-> " + (object) this.inf.TotalIn + ";" + (object) this.inf.TotalOut);
-            this.inf.Reset();
-            flag = true;
-            break;
-          }
-          break;
-      }
-      if (count > 0)
-        this.crc.Update(buffer, offset, count);
-      if (flag)
-        this.CompleteCloseEntry(true);
-      return count;
-    }
-
-    public override void Close()
-    {
-      this.internalReader = new ZipInputStream.ReaderDelegate(this.ReadingNotAvailable);
-      this.crc = (Crc32) null;
-      this.entry = (ZipEntry) null;
-      base.Close();
-    }
-
-    private delegate int ReaderDelegate(byte[] b, int offset, int length);
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipNameTransform.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipNameTransform.cs
deleted file mode 100644
index afcd5f7..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipNameTransform.cs
+++ /dev/null
@@ -1,90 +0,0 @@
-using ICSharpCode.SharpZipLib.Core;
-using System;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipNameTransform : INameTransform
-  {
-    private string trimPrefix_;
-    private static readonly char[] InvalidEntryChars;
-    private static readonly char[] InvalidEntryCharsRelaxed;
-
-    public ZipNameTransform()
-    {
-    }
-
-    public ZipNameTransform(string trimPrefix) => this.TrimPrefix = trimPrefix;
-
-    static ZipNameTransform()
-    {
-      char[] invalidPathChars = Path.GetInvalidPathChars();
-      int length1 = invalidPathChars.Length + 2;
-      ZipNameTransform.InvalidEntryCharsRelaxed = new char[length1];
-      Array.Copy((Array) invalidPathChars, 0, (Array) ZipNameTransform.InvalidEntryCharsRelaxed, 0, invalidPathChars.Length);
-      ZipNameTransform.InvalidEntryCharsRelaxed[length1 - 1] = '*';
-      ZipNameTransform.InvalidEntryCharsRelaxed[length1 - 2] = '?';
-      int length2 = invalidPathChars.Length + 4;
-      ZipNameTransform.InvalidEntryChars = new char[length2];
-      Array.Copy((Array) invalidPathChars, 0, (Array) ZipNameTransform.InvalidEntryChars, 0, invalidPathChars.Length);
-      ZipNameTransform.InvalidEntryChars[length2 - 1] = ':';
-      ZipNameTransform.InvalidEntryChars[length2 - 2] = '\\';
-      ZipNameTransform.InvalidEntryChars[length2 - 3] = '*';
-      ZipNameTransform.InvalidEntryChars[length2 - 4] = '?';
-    }
-
-    public string TransformDirectory(string name)
-    {
-      name = this.TransformFile(name);
-      if (name.Length <= 0)
-        throw new ZipException("Cannot have an empty directory name");
-      if (!name.EndsWith("/"))
-        name += "/";
-      return name;
-    }
-
-    public string TransformFile(string name)
-    {
-      if (name != null)
-      {
-        string lower = name.ToLower();
-        if (this.trimPrefix_ != null && lower.IndexOf(this.trimPrefix_) == 0)
-          name = name.Substring(this.trimPrefix_.Length);
-        if (Path.IsPathRooted(name))
-          name = name.Substring(Path.GetPathRoot(name).Length);
-        name = name.Replace("\\", "/");
-        while (name.Length > 0 && name[0] == '/')
-          name = name.Remove(0, 1);
-      }
-      else
-        name = string.Empty;
-      return name;
-    }
-
-    public string TrimPrefix
-    {
-      get => this.trimPrefix_;
-      set
-      {
-        this.trimPrefix_ = value;
-        if (this.trimPrefix_ == null)
-          return;
-        this.trimPrefix_ = this.trimPrefix_.ToLower();
-      }
-    }
-
-    public static bool IsValidName(string name, bool relaxed)
-    {
-      bool flag = name != null;
-      if (flag)
-        flag = !relaxed ? name.IndexOfAny(ZipNameTransform.InvalidEntryChars) < 0 && name.IndexOf('/') != 0 : name.IndexOfAny(ZipNameTransform.InvalidEntryCharsRelaxed) < 0;
-      return flag;
-    }
-
-    public static bool IsValidName(string name)
-    {
-      return name != null && name.IndexOfAny(ZipNameTransform.InvalidEntryChars) < 0 && name.IndexOf('/') != 0;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipOutputStream.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipOutputStream.cs
deleted file mode 100644
index 59f2a0e..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipOutputStream.cs
+++ /dev/null
@@ -1,406 +0,0 @@
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.Collections;
-using System.IO;
-
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipOutputStream(Stream baseOutputStream) : DeflaterOutputStream(baseOutputStream, new Deflater(-1, true))
-  {
-    private ArrayList entries = new ArrayList();
-    private Crc32 crc = new Crc32();
-    private ZipEntry curEntry;
-    private int defaultCompressionLevel = -1;
-    private CompressionMethod curMethod = CompressionMethod.Deflated;
-    private long size;
-    private long offset;
-    private byte[] zipComment = new byte[0];
-    private bool patchEntryHeader;
-    private long crcPatchPos = -1;
-    private long sizePatchPos = -1;
-    private UseZip64 useZip64_ = UseZip64.Dynamic;
-
-    public bool IsFinished => this.entries == null;
-
-    public void SetComment(string comment)
-    {
-      byte[] array = ZipConstants.ConvertToArray(comment);
-      this.zipComment = array.Length <= (int) ushort.MaxValue ? array : throw new ArgumentOutOfRangeException(nameof (comment));
-    }
-
-    public void SetLevel(int level)
-    {
-      this.defaultCompressionLevel = level;
-      this.def.SetLevel(level);
-    }
-
-    public int GetLevel() => this.def.GetLevel();
-
-    public UseZip64 UseZip64
-    {
-      get => this.useZip64_;
-      set => this.useZip64_ = value;
-    }
-
-    private void WriteLeShort(int value)
-    {
-      this.baseOutputStream.WriteByte((byte) (value & (int) byte.MaxValue));
-      this.baseOutputStream.WriteByte((byte) (value >> 8 & (int) byte.MaxValue));
-    }
-
-    private void WriteLeInt(int value)
-    {
-      this.WriteLeShort(value);
-      this.WriteLeShort(value >> 16);
-    }
-
-    private void WriteLeLong(long value)
-    {
-      this.WriteLeInt((int) value);
-      this.WriteLeInt((int) (value >> 32));
-    }
-
-    public void PutNextEntry(ZipEntry entry)
-    {
-      if (entry == null)
-        throw new ArgumentNullException(nameof (entry));
-      if (this.entries == null)
-        throw new InvalidOperationException("ZipOutputStream was finished");
-      if (this.curEntry != null)
-        this.CloseEntry();
-      if (this.entries.Count == int.MaxValue)
-        throw new ZipException("Too many entries for Zip file");
-      CompressionMethod compressionMethod = entry.CompressionMethod;
-      int level = this.defaultCompressionLevel;
-      entry.Flags &= 2048;
-      this.patchEntryHeader = false;
-      bool flag = true;
-      if (compressionMethod == CompressionMethod.Stored)
-      {
-        entry.Flags &= -9;
-        if (entry.CompressedSize >= 0L)
-        {
-          if (entry.Size < 0L)
-            entry.Size = entry.CompressedSize;
-          else if (entry.Size != entry.CompressedSize)
-            throw new ZipException("Method STORED, but compressed size != size");
-        }
-        else if (entry.Size >= 0L)
-          entry.CompressedSize = entry.Size;
-        if (entry.Size < 0L || entry.Crc < 0L)
-        {
-          if (this.CanPatchEntries)
-          {
-            flag = false;
-          }
-          else
-          {
-            compressionMethod = CompressionMethod.Deflated;
-            level = 0;
-          }
-        }
-      }
-      if (compressionMethod == CompressionMethod.Deflated)
-      {
-        if (entry.Size == 0L)
-        {
-          entry.CompressedSize = entry.Size;
-          entry.Crc = 0L;
-          compressionMethod = CompressionMethod.Stored;
-        }
-        else if (entry.CompressedSize < 0L || entry.Size < 0L || entry.Crc < 0L)
-          flag = false;
-      }
-      if (!flag)
-      {
-        if (!this.CanPatchEntries)
-          entry.Flags |= 8;
-        else
-          this.patchEntryHeader = true;
-      }
-      if (this.Password != null)
-      {
-        entry.IsCrypted = true;
-        if (entry.Crc < 0L)
-          entry.Flags |= 8;
-      }
-      entry.Offset = this.offset;
-      entry.CompressionMethod = compressionMethod;
-      this.curMethod = compressionMethod;
-      this.sizePatchPos = -1L;
-      if (this.useZip64_ == UseZip64.On || entry.Size < 0L && this.useZip64_ == UseZip64.Dynamic)
-        entry.ForceZip64();
-      this.WriteLeInt(67324752);
-      this.WriteLeShort(entry.Version);
-      this.WriteLeShort(entry.Flags);
-      this.WriteLeShort((int) (byte) compressionMethod);
-      this.WriteLeInt((int) entry.DosTime);
-      if (flag)
-      {
-        this.WriteLeInt((int) entry.Crc);
-        if (entry.LocalHeaderRequiresZip64)
-        {
-          this.WriteLeInt(-1);
-          this.WriteLeInt(-1);
-        }
-        else
-        {
-          this.WriteLeInt(entry.IsCrypted ? (int) entry.CompressedSize + 12 : (int) entry.CompressedSize);
-          this.WriteLeInt((int) entry.Size);
-        }
-      }
-      else
-      {
-        if (this.patchEntryHeader)
-          this.crcPatchPos = this.baseOutputStream.Position;
-        this.WriteLeInt(0);
-        if (this.patchEntryHeader)
-          this.sizePatchPos = this.baseOutputStream.Position;
-        if (entry.LocalHeaderRequiresZip64 && this.patchEntryHeader)
-        {
-          this.WriteLeInt(-1);
-          this.WriteLeInt(-1);
-        }
-        else
-        {
-          this.WriteLeInt(0);
-          this.WriteLeInt(0);
-        }
-      }
-      byte[] array = ZipConstants.ConvertToArray(entry.Flags, entry.Name);
-      if (array.Length > (int) ushort.MaxValue)
-        throw new ZipException("Entry name too long.");
-      ZipExtraData zipExtraData = new ZipExtraData(entry.ExtraData);
-      if (entry.LocalHeaderRequiresZip64 && (flag || this.patchEntryHeader))
-      {
-        zipExtraData.StartNewEntry();
-        if (flag)
-        {
-          zipExtraData.AddLeLong(entry.Size);
-          zipExtraData.AddLeLong(entry.CompressedSize);
-        }
-        else
-        {
-          zipExtraData.AddLeLong(-1L);
-          zipExtraData.AddLeLong(-1L);
-        }
-        zipExtraData.AddNewEntry(1);
-        if (!zipExtraData.Find(1))
-          throw new ZipException("Internal error cant find extra data");
-        if (this.patchEntryHeader)
-          this.sizePatchPos = (long) zipExtraData.CurrentReadIndex;
-      }
-      else
-        zipExtraData.Delete(1);
-      byte[] entryData = zipExtraData.GetEntryData();
-      this.WriteLeShort(array.Length);
-      this.WriteLeShort(entryData.Length);
-      if (array.Length > 0)
-        this.baseOutputStream.Write(array, 0, array.Length);
-      if (entry.LocalHeaderRequiresZip64 && this.patchEntryHeader)
-        this.sizePatchPos += this.baseOutputStream.Position;
-      if (entryData.Length > 0)
-        this.baseOutputStream.Write(entryData, 0, entryData.Length);
-      this.offset += (long) (30 + array.Length + entryData.Length);
-      this.curEntry = entry;
-      this.crc.Reset();
-      if (compressionMethod == CompressionMethod.Deflated)
-      {
-        this.def.Reset();
-        this.def.SetLevel(level);
-      }
-      this.size = 0L;
-      if (!entry.IsCrypted)
-        return;
-      if (entry.Crc < 0L)
-        this.WriteEncryptionHeader(entry.DosTime << 16);
-      else
-        this.WriteEncryptionHeader(entry.Crc);
-    }
-
-    public void CloseEntry()
-    {
-      if (this.curEntry == null)
-        throw new InvalidOperationException("No open entry");
-      if (this.curMethod == CompressionMethod.Deflated)
-        base.Finish();
-      long num = this.curMethod == CompressionMethod.Deflated ? this.def.TotalOut : this.size;
-      if (this.curEntry.Size < 0L)
-        this.curEntry.Size = this.size;
-      else if (this.curEntry.Size != this.size)
-        throw new ZipException("size was " + (object) this.size + ", but I expected " + (object) this.curEntry.Size);
-      if (this.curEntry.CompressedSize < 0L)
-        this.curEntry.CompressedSize = num;
-      else if (this.curEntry.CompressedSize != num)
-        throw new ZipException("compressed size was " + (object) num + ", but I expected " + (object) this.curEntry.CompressedSize);
-      if (this.curEntry.Crc < 0L)
-        this.curEntry.Crc = this.crc.Value;
-      else if (this.curEntry.Crc != this.crc.Value)
-        throw new ZipException("crc was " + (object) this.crc.Value + ", but I expected " + (object) this.curEntry.Crc);
-      this.offset += num;
-      if (this.curEntry.IsCrypted)
-        this.curEntry.CompressedSize += 12L;
-      if (this.patchEntryHeader)
-      {
-        this.patchEntryHeader = false;
-        long position = this.baseOutputStream.Position;
-        this.baseOutputStream.Seek(this.crcPatchPos, SeekOrigin.Begin);
-        this.WriteLeInt((int) this.curEntry.Crc);
-        if (this.curEntry.LocalHeaderRequiresZip64)
-        {
-          if (this.sizePatchPos == -1L)
-            throw new ZipException("Entry requires zip64 but this has been turned off");
-          this.baseOutputStream.Seek(this.sizePatchPos, SeekOrigin.Begin);
-          this.WriteLeLong(this.curEntry.Size);
-          this.WriteLeLong(this.curEntry.CompressedSize);
-        }
-        else
-        {
-          this.WriteLeInt((int) this.curEntry.CompressedSize);
-          this.WriteLeInt((int) this.curEntry.Size);
-        }
-        this.baseOutputStream.Seek(position, SeekOrigin.Begin);
-      }
-      if ((this.curEntry.Flags & 8) != 0)
-      {
-        this.WriteLeInt(134695760);
-        this.WriteLeInt((int) this.curEntry.Crc);
-        if (this.curEntry.LocalHeaderRequiresZip64)
-        {
-          this.WriteLeLong(this.curEntry.CompressedSize);
-          this.WriteLeLong(this.curEntry.Size);
-          this.offset += 24L;
-        }
-        else
-        {
-          this.WriteLeInt((int) this.curEntry.CompressedSize);
-          this.WriteLeInt((int) this.curEntry.Size);
-          this.offset += 16L;
-        }
-      }
-      this.entries.Add((object) this.curEntry);
-      this.curEntry = (ZipEntry) null;
-    }
-
-    private void WriteEncryptionHeader(long crcValue)
-    {
-      this.offset += 12L;
-      this.InitializePassword(this.Password);
-      byte[] buffer = new byte[12];
-      new Random().NextBytes(buffer);
-      buffer[11] = (byte) (crcValue >> 24);
-      this.EncryptBlock(buffer, 0, buffer.Length);
-      this.baseOutputStream.Write(buffer, 0, buffer.Length);
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      if (this.curEntry == null)
-        throw new InvalidOperationException("No open entry.");
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be negative");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be negative");
-      if (buffer.Length - offset < count)
-        throw new ArgumentException("Invalid offset/count combination");
-      this.crc.Update(buffer, offset, count);
-      this.size += (long) count;
-      switch (this.curMethod)
-      {
-        case CompressionMethod.Stored:
-          if (this.Password != null)
-          {
-            byte[] numArray = new byte[count];
-            Array.Copy((Array) buffer, offset, (Array) numArray, 0, count);
-            this.EncryptBlock(numArray, 0, count);
-            this.baseOutputStream.Write(numArray, offset, count);
-            break;
-          }
-          this.baseOutputStream.Write(buffer, offset, count);
-          break;
-        case CompressionMethod.Deflated:
-          base.Write(buffer, offset, count);
-          break;
-      }
-    }
-
-    public override void Finish()
-    {
-      if (this.entries == null)
-        return;
-      if (this.curEntry != null)
-        this.CloseEntry();
-      long count = (long) this.entries.Count;
-      long sizeEntries = 0;
-      foreach (ZipEntry entry in this.entries)
-      {
-        this.WriteLeInt(33639248);
-        this.WriteLeShort(45);
-        this.WriteLeShort(entry.Version);
-        this.WriteLeShort(entry.Flags);
-        this.WriteLeShort((int) (short) entry.CompressionMethod);
-        this.WriteLeInt((int) entry.DosTime);
-        this.WriteLeInt((int) entry.Crc);
-        if (entry.IsZip64Forced() || entry.CompressedSize >= (long) uint.MaxValue)
-          this.WriteLeInt(-1);
-        else
-          this.WriteLeInt((int) entry.CompressedSize);
-        if (entry.IsZip64Forced() || entry.Size >= (long) uint.MaxValue)
-          this.WriteLeInt(-1);
-        else
-          this.WriteLeInt((int) entry.Size);
-        byte[] array = ZipConstants.ConvertToArray(entry.Flags, entry.Name);
-        if (array.Length > (int) ushort.MaxValue)
-          throw new ZipException("Name too long.");
-        ZipExtraData zipExtraData = new ZipExtraData(entry.ExtraData);
-        if (entry.CentralHeaderRequiresZip64)
-        {
-          zipExtraData.StartNewEntry();
-          if (entry.IsZip64Forced() || entry.Size >= (long) uint.MaxValue)
-            zipExtraData.AddLeLong(entry.Size);
-          if (entry.IsZip64Forced() || entry.CompressedSize >= (long) uint.MaxValue)
-            zipExtraData.AddLeLong(entry.CompressedSize);
-          if (entry.Offset >= (long) uint.MaxValue)
-            zipExtraData.AddLeLong(entry.Offset);
-          zipExtraData.AddNewEntry(1);
-        }
-        else
-          zipExtraData.Delete(1);
-        byte[] entryData = zipExtraData.GetEntryData();
-        byte[] buffer = entry.Comment != null ? ZipConstants.ConvertToArray(entry.Flags, entry.Comment) : new byte[0];
-        if (buffer.Length > (int) ushort.MaxValue)
-          throw new ZipException("Comment too long.");
-        this.WriteLeShort(array.Length);
-        this.WriteLeShort(entryData.Length);
-        this.WriteLeShort(buffer.Length);
-        this.WriteLeShort(0);
-        this.WriteLeShort(0);
-        if (entry.ExternalFileAttributes != -1)
-          this.WriteLeInt(entry.ExternalFileAttributes);
-        else if (entry.IsDirectory)
-          this.WriteLeInt(16);
-        else
-          this.WriteLeInt(0);
-        if (entry.Offset >= (long) uint.MaxValue)
-          this.WriteLeInt(-1);
-        else
-          this.WriteLeInt((int) entry.Offset);
-        if (array.Length > 0)
-          this.baseOutputStream.Write(array, 0, array.Length);
-        if (entryData.Length > 0)
-          this.baseOutputStream.Write(entryData, 0, entryData.Length);
-        if (buffer.Length > 0)
-          this.baseOutputStream.Write(buffer, 0, buffer.Length);
-        sizeEntries += (long) (46 + array.Length + entryData.Length + buffer.Length);
-      }
-      using (ZipHelperStream zipHelperStream = new ZipHelperStream(this.baseOutputStream))
-        zipHelperStream.WriteEndOfCentralDirectory(count, sizeEntries, this.offset, this.zipComment);
-      this.entries = (ArrayList) null;
-    }
-  }
-}
diff --git a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipTestResultHandler.cs b/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipTestResultHandler.cs
deleted file mode 100644
index 206416e..0000000
--- a/MSHALTester/ICSharpCode/SharpZipLib/Zip/ZipTestResultHandler.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public delegate void ZipTestResultHandler(TestStatus status, string message);
-}
diff --git a/MSHALTester/LzmaAlone/Properties/Settings.cs b/MSHALTester/LzmaAlone/Properties/Settings.cs
deleted file mode 100644
index 0327291..0000000
--- a/MSHALTester/LzmaAlone/Properties/Settings.cs
+++ /dev/null
@@ -1,37 +0,0 @@
-using System.Configuration;
-using System.Runtime.InteropServices;
-using System.Threading;
-
-#nullable disable
-namespace LzmaAlone.Properties
-{
-  [ComVisible(true)]
-  public class Settings : ApplicationSettingsBase
-  {
-    private static Settings m_Value;
-    private static object m_SyncObject = new object();
-
-    public static Settings Value
-    {
-      get
-      {
-        if (Settings.m_Value == null)
-        {
-          Monitor.Enter(Settings.m_SyncObject);
-          if (Settings.m_Value == null)
-          {
-            try
-            {
-              Settings.m_Value = new Settings();
-            }
-            finally
-            {
-              Monitor.Exit(Settings.m_SyncObject);
-            }
-          }
-        }
-        return Settings.m_Value;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/MSHALTester.csproj b/MSHALTester/MSHALTester.csproj
index 13cc278..8ce0bee 100644
--- a/MSHALTester/MSHALTester.csproj
+++ b/MSHALTester/MSHALTester.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="Current" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <!--Project was exported from assembly: U:\2024_11_07_kiosk2_fresh\Program Files\Redbox\MS HAL Tester\bin\MSHALTester.exe-->
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
@@ -10,6 +10,12 @@
     <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <ApplicationVersion>1.13.0.27</ApplicationVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <UpgradeBackupLocation>
+    </UpgradeBackupLocation>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <LangVersion>12.0</LangVersion>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <PlatformTarget>AnyCPU</PlatformTarget>
@@ -19,7 +25,7 @@
     <OutputPath>bin\Debug\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
+    <WarningLevel>0</WarningLevel>
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
@@ -33,7 +39,20 @@
     <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
   </PropertyGroup>
   <ItemGroup>
+    <Reference Include="ICSharpCode.SharpZipLib, Version=0.86.0.518, Culture=neutral, PublicKeyToken=1b03e6acf1164f73, processorArchitecture=MSIL">
+      <HintPath>packages\SharpZipLib.0.86.0\lib\20\ICSharpCode.SharpZipLib.dll</HintPath>
+    </Reference>
+    <Reference Include="log4net, Version=2.0.17.0, Culture=neutral, PublicKeyToken=669e0ddf0bb1aa2a, processorArchitecture=MSIL">
+      <HintPath>packages\log4net.2.0.17\lib\net35\log4net.dll</HintPath>
+    </Reference>
+    <Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
+      <HintPath>packages\Newtonsoft.Json.13.0.3\lib\net35\Newtonsoft.Json.dll</HintPath>
+    </Reference>
+    <Reference Include="SevenZip, Version=19.0.0.0, Culture=neutral, processorArchitecture=MSIL">
+      <HintPath>packages\SevenZip.19.0.0\lib\net20\SevenZip.dll</HintPath>
+    </Reference>
     <Reference Include="System" />
+    <Reference Include="System.Configuration" />
     <Reference Include="System.Core" />
     <Reference Include="System.Data" />
     <Reference Include="System.Drawing" />
@@ -45,42 +64,76 @@
     <Reference Include="System.Xml.Linq" />
   </ItemGroup>
   <ItemGroup>
-    <Compile Include="Redbox\HAL\Common\GUI\Functions\QuadrantForm.cs" />
+    <Compile Include="Redbox\HAL\Common\GUI\Functions\QuadrantForm.cs">
+      <SubType>Form</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\Common\GUI\Functions\ButtonAspectsManager.cs" />
     <Compile Include="Redbox\HAL\Common\GUI\Functions\ButtonAspects.cs" />
     <Compile Include="Redbox\HAL\Common\GUI\Functions\ConfigItem.cs" />
     <Compile Include="Redbox\HAL\Common\GUI\Functions\ISessionUser.cs" />
     <Compile Include="Redbox\HAL\Common\GUI\Functions\ISessionUserService.cs" />
-    <Compile Include="Redbox\HAL\Common\GUI\Functions\LocationNumberPad.cs" />
-    <Compile Include="Redbox\HAL\Common\GUI\Functions\NumberPad.cs" />
-    <Compile Include="Redbox\HAL\Common\GUI\Functions\NumberPadForm.cs" />
+    <Compile Include="Redbox\HAL\Common\GUI\Functions\LocationNumberPad.cs">
+      <SubType>Form</SubType>
+    </Compile>
+    <Compile Include="Redbox\HAL\Common\GUI\Functions\NumberPad.cs">
+      <SubType>UserControl</SubType>
+    </Compile>
+    <Compile Include="Redbox\HAL\Common\GUI\Functions\NumberPadForm.cs">
+      <SubType>Form</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\Common\GUI\Functions\OutputBox.cs" />
     <Compile Include="Redbox\HAL\Common\GUI\Functions\TextBoxExtensions.cs" />
     <Compile Include="Redbox\HAL\Common\GUI\Functions\Properties\Resources.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\AdvancedMode.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\CameraPreviewForm.cs" />
+    <Compile Include="Redbox\HAL\MSHALTester\AdvancedMode.cs">
+      <SubType>Form</SubType>
+    </Compile>
+    <Compile Include="Redbox\HAL\MSHALTester\CameraPreviewForm.cs">
+      <SubType>Form</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\MSHALTester\DecodeExecutor.cs" />
     <Compile Include="Redbox\HAL\MSHALTester\CommonFunctions.cs" />
     <Compile Include="Redbox\HAL\MSHALTester\CompositeFunctions.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\ComputeQuadrantsForm.cs" />
+    <Compile Include="Redbox\HAL\MSHALTester\ComputeQuadrantsForm.cs">
+      <SubType>Form</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\MSHALTester\Configuration.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\ConfigPropertyList.cs" />
+    <Compile Include="Redbox\HAL\MSHALTester\ConfigPropertyList.cs">
+      <SubType>UserControl</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\MSHALTester\DecksConfigurationManager.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\ConfiguredDevicesForm.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\ConfirmationDialog.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\DeckConfigurationDetailForm.cs" />
+    <Compile Include="Redbox\HAL\MSHALTester\ConfiguredDevicesForm.cs">
+      <SubType>Form</SubType>
+    </Compile>
+    <Compile Include="Redbox\HAL\MSHALTester\ConfirmationDialog.cs">
+      <SubType>Form</SubType>
+    </Compile>
+    <Compile Include="Redbox\HAL\MSHALTester\DeckConfigurationDetailForm.cs">
+      <SubType>Form</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\MSHALTester\DeckConfigurationDetailColumns.cs" />
     <Compile Include="Redbox\HAL\MSHALTester\DeckConfigurationColumns.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\DeckConfigurationForm.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\EditSlotData.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\Form1.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\GearAndMotorProperties.cs" />
+    <Compile Include="Redbox\HAL\MSHALTester\DeckConfigurationForm.cs">
+      <SubType>Form</SubType>
+    </Compile>
+    <Compile Include="Redbox\HAL\MSHALTester\EditSlotData.cs">
+      <SubType>Form</SubType>
+    </Compile>
+    <Compile Include="Redbox\HAL\MSHALTester\Form1.cs">
+      <SubType>Form</SubType>
+    </Compile>
+    <Compile Include="Redbox\HAL\MSHALTester\GearAndMotorProperties.cs">
+      <SubType>Form</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\MSHALTester\HardwareJobAdapter.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\ImageViewer.cs" />
+    <Compile Include="Redbox\HAL\MSHALTester\ImageViewer.cs">
+      <SubType>Form</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\MSHALTester\TestState.cs" />
     <Compile Include="Redbox\HAL\MSHALTester\KioskFunctionTest.cs" />
     <Compile Include="Redbox\HAL\MSHALTester\PickAtOffsetExecutor.cs" />
-    <Compile Include="Redbox\HAL\MSHALTester\PickerSensorsBar.cs" />
+    <Compile Include="Redbox\HAL\MSHALTester\PickerSensorsBar.cs">
+      <SubType>UserControl</SubType>
+    </Compile>
     <Compile Include="Redbox\HAL\MSHALTester\Program.cs" />
     <Compile Include="Redbox\HAL\MSHALTester\ReadDiskJob.cs" />
     <Compile Include="Redbox\HAL\MSHALTester\ScanResult.cs" />
@@ -555,7 +608,9 @@
     <Compile Include="Redbox\DirectShow\NewFrameEventArgs.cs" />
     <Compile Include="Redbox\DirectShow\VideoSourceErrorEventArgs.cs" />
     <Compile Include="Redbox\DirectShow\VideoInput.cs" />
-    <Compile Include="Redbox\DirectShow\VideoSourcePlayer.cs" />
+    <Compile Include="Redbox\DirectShow\VideoSourcePlayer.cs">
+      <SubType>Component</SubType>
+    </Compile>
     <Compile Include="Redbox\DirectShow\Interop\IAMCameraControl.cs" />
     <Compile Include="Redbox\DirectShow\Interop\IAMCrossbar.cs" />
     <Compile Include="Redbox\DirectShow\Interop\IAMStreamConfig.cs" />
@@ -602,579 +657,7 @@
     <Compile Include="Redbox\DirectShow\Interop\PinCategory.cs" />
     <Compile Include="Redbox\DirectShow\Interop\FindDirection.cs" />
     <Compile Include="Redbox\DirectShow\Interop\Win32.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\SharpZipBaseException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2Constants.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2Exception.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Checksums\IChecksum.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Checksums\Adler32.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Checksums\Crc32.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Checksums\StrangeCRC.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ScanEventArgs.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\DirectoryEventArgs.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ScanFailureEventArgs.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ProcessDirectoryDelegate.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ProcessFileDelegate.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\DirectoryFailureDelegate.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\FileFailureDelegate.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\FileSystemScanner.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\INameTransform.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\IScanFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\NameFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\PathFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ExtendedPathFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\NameAndSizeFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\StreamUtils.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassicCryptoBase.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassicEncryptCryptoTransform.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassicDecryptCryptoTransform.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassicManaged.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\GZip\GZipConstants.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\GZip\GZipException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\GZip\GZipInputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\GZip\GZipOutputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\FastZipEvents.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\FastZip.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\IEntryFactory.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\UseZip64.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\CompressionMethod.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\EncryptionAlgorithm.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\GeneralBitFlags.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipConstants.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\HostSystemID.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipEntry.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipEntryFactory.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\KeysRequiredEventArgs.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\TestStrategy.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\TestOperation.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\TestStatus.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipTestResultHandler.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\FileUpdateMode.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipFile.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\IStaticDataSource.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\IDynamicDataSource.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\StaticDiskDataSource.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\DynamicDiskDataSource.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\IArchiveStorage.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\BaseArchiveStorage.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\DiskArchiveStorage.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\MemoryArchiveStorage.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipNameTransform.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflaterConstants.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflateStrategy.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflaterPending.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputBuffer.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\OutputWindow.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\InvalidHeaderException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\ProgressMessageHandler.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarArchive.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarBuffer.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarEntry.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarHeader.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarInputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarOutputStream.cs" />
-    <Compile Include="SevenZip\ICoder.cs" />
-    <Compile Include="SevenZip\ISetCoderProperties.cs" />
-    <Compile Include="SevenZip\IWriteCoderProperties.cs" />
-    <Compile Include="SevenZip\CRC.cs" />
-    <Compile Include="SevenZip\ISetDecoderProperties.cs" />
-    <Compile Include="SevenZip\DataErrorException.cs" />
-    <Compile Include="SevenZip\InvalidParamException.cs" />
-    <Compile Include="SevenZip\ICodeProgress.cs" />
-    <Compile Include="SevenZip\CoderPropID.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\BitEncoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\BitDecoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\Encoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\Decoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\BitTreeEncoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\BitTreeDecoder.cs" />
     <Compile Include="SevenZip\Compression\LZMA\SevenZipHelper.cs" />
-    <Compile Include="SevenZip\Compression\LZMA\Encoder.cs" />
-    <Compile Include="SevenZip\Compression\LZMA\Base.cs" />
-    <Compile Include="SevenZip\Compression\LZMA\Decoder.cs" />
-    <Compile Include="SevenZip\Compression\LZ\InWindow.cs" />
-    <Compile Include="SevenZip\Compression\LZ\OutWindow.cs" />
-    <Compile Include="SevenZip\Compression\LZ\IInWindowStream.cs" />
-    <Compile Include="SevenZip\Compression\LZ\IMatchFinder.cs" />
-    <Compile Include="SevenZip\Compression\LZ\BinTree.cs" />
-    <Compile Include="LzmaAlone\Properties\Settings.cs" />
-    <Compile Include="Newtonsoft\Json\ConstructorHandling.cs" />
-    <Compile Include="Newtonsoft\Json\DateFormatHandling.cs" />
-    <Compile Include="Newtonsoft\Json\DateParseHandling.cs" />
-    <Compile Include="Newtonsoft\Json\DateTimeZoneHandling.cs" />
-    <Compile Include="Newtonsoft\Json\DefaultValueHandling.cs" />
-    <Compile Include="Newtonsoft\Json\FloatFormatHandling.cs" />
-    <Compile Include="Newtonsoft\Json\FloatParseHandling.cs" />
-    <Compile Include="Newtonsoft\Json\Formatting.cs" />
-    <Compile Include="Newtonsoft\Json\IArrayPool`1.cs" />
-    <Compile Include="Newtonsoft\Json\IJsonLineInfo.cs" />
-    <Compile Include="Newtonsoft\Json\JsonArrayAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonConstructorAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonContainerAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonConvert.cs" />
-    <Compile Include="Newtonsoft\Json\JsonConverter.cs" />
-    <Compile Include="Newtonsoft\Json\JsonConverter`1.cs" />
-    <Compile Include="Newtonsoft\Json\JsonConverterAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonConverterCollection.cs" />
-    <Compile Include="Newtonsoft\Json\JsonDictionaryAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonException.cs" />
-    <Compile Include="Newtonsoft\Json\JsonExtensionDataAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonIgnoreAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonObjectAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonContainerType.cs" />
-    <Compile Include="Newtonsoft\Json\JsonPosition.cs" />
-    <Compile Include="Newtonsoft\Json\JsonPropertyAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonReader.cs" />
-    <Compile Include="Newtonsoft\Json\JsonReaderException.cs" />
-    <Compile Include="Newtonsoft\Json\JsonRequiredAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\JsonSerializationException.cs" />
-    <Compile Include="Newtonsoft\Json\JsonSerializer.cs" />
-    <Compile Include="Newtonsoft\Json\JsonSerializerSettings.cs" />
-    <Compile Include="Newtonsoft\Json\ReadType.cs" />
-    <Compile Include="Newtonsoft\Json\JsonTextReader.cs" />
-    <Compile Include="Newtonsoft\Json\JsonTextWriter.cs" />
-    <Compile Include="Newtonsoft\Json\JsonToken.cs" />
-    <Compile Include="Newtonsoft\Json\JsonValidatingReader.cs" />
-    <Compile Include="Newtonsoft\Json\JsonWriter.cs" />
-    <Compile Include="Newtonsoft\Json\JsonWriterException.cs" />
-    <Compile Include="Newtonsoft\Json\MemberSerialization.cs" />
-    <Compile Include="Newtonsoft\Json\MetadataPropertyHandling.cs" />
-    <Compile Include="Newtonsoft\Json\MissingMemberHandling.cs" />
-    <Compile Include="Newtonsoft\Json\NullValueHandling.cs" />
-    <Compile Include="Newtonsoft\Json\ObjectCreationHandling.cs" />
-    <Compile Include="Newtonsoft\Json\PreserveReferencesHandling.cs" />
-    <Compile Include="Newtonsoft\Json\ReferenceLoopHandling.cs" />
-    <Compile Include="Newtonsoft\Json\Required.cs" />
-    <Compile Include="Newtonsoft\Json\StringEscapeHandling.cs" />
-    <Compile Include="Newtonsoft\Json\TypeNameAssemblyFormatHandling.cs" />
-    <Compile Include="Newtonsoft\Json\TypeNameHandling.cs" />
-    <Compile Include="Newtonsoft\Json\WriteState.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\Base64Encoder.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\BidirectionalDictionary`2.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\CollectionUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\IWrappedCollection.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\CollectionWrapper`1.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\PrimitiveTypeCode.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\TypeInformation.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ParseResult.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ConvertUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ParserTimeZone.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\DateTimeParser.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\DateTimeUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\IWrappedDictionary.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\DictionaryWrapper`2.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\DynamicReflectionDelegateFactory.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\EnumInfo.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\EnumUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ILGeneratorExtensions.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ImmutableCollectionsUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\BufferUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\JavaScriptUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\JsonTokenUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\LateBoundReflectionDelegateFactory.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\MathUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\MethodCall`2.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\Creator`1.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\MiscellaneousUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\PropertyNameTable.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ReflectionDelegateFactory.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ReflectionMember.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ReflectionObject.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ReflectionUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\TypeNameKey.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\StringBuffer.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\StringReference.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\StringReferenceExtensions.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\StringUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ThreadSafeStore`2.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\TypeExtensions.cs" />
-    <Compile Include="Newtonsoft\Json\Utilities\ValidationUtils.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\CachedAttributeGetter`1.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\CamelCaseNamingStrategy.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ResolverContractKey.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\CamelCasePropertyNamesContractResolver.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\DefaultContractResolver.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\DefaultNamingStrategy.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\DefaultReferenceResolver.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\DefaultSerializationBinder.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\DiagnosticsTraceWriter.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\DynamicValueProvider.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ErrorContext.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ErrorEventArgs.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\IAttributeProvider.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\IContractResolver.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\IReferenceResolver.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ISerializationBinder.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ITraceWriter.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\IValueProvider.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonArrayContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonContainerContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonContractType.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\SerializationCallback.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\SerializationErrorCallback.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ExtensionDataSetter.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ExtensionDataGetter.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonDictionaryContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonFormatterConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonISerializableContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonLinqContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonObjectContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonPrimitiveContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonProperty.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonPropertyCollection.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonSerializerInternalBase.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonSerializerInternalReader.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonSerializerInternalWriter.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonSerializerProxy.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonStringContract.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\JsonTypeReflector.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\MemoryTraceWriter.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\NamingStrategy.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ObjectConstructor`1.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\OnErrorAttribute.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ReflectionAttributeProvider.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\ReflectionValueProvider.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\SerializationBinderAdapter.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\SnakeCaseNamingStrategy.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\TraceJsonReader.cs" />
-    <Compile Include="Newtonsoft\Json\Serialization\TraceJsonWriter.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\Extensions.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchema.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaBuilder.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaConstants.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaException.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaGenerator.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaModel.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaModelBuilder.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaNode.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaNodeCollection.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaResolver.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaType.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\JsonSchemaWriter.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\UndefinedSchemaIdHandling.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\ValidationEventArgs.cs" />
-    <Compile Include="Newtonsoft\Json\Schema\ValidationEventHandler.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\CommentHandling.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\Extensions.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\IJEnumerable`1.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JArray.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JConstructor.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JContainer.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JEnumerable`1.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JObject.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JProperty.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JPropertyDescriptor.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JPropertyKeyedCollection.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JRaw.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonLoadSettings.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonMergeSettings.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JToken.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JTokenEqualityComparer.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JTokenReader.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JTokenType.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JTokenWriter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JValue.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\LineInfoHandling.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\MergeArrayHandling.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\MergeNullValueHandling.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\ArrayIndexFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\ArrayMultipleIndexFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\ArraySliceFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\FieldFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\FieldMultipleFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\JPath.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\PathFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\QueryOperator.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\QueryExpression.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\CompositeExpression.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\BooleanQueryExpression.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\QueryFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\QueryScanFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\RootFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\ScanFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Linq\JsonPath\ScanMultipleFilter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\BinaryConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\BsonObjectIdConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\CustomCreationConverter`1.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\DataSetConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\DataTableConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\DateTimeConverterBase.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\EntityKeyMemberConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\IsoDateTimeConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\JavaScriptDateTimeConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\KeyValuePairConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\RegexConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\StringEnumConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\UnixDateTimeConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\VersionConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XmlDocumentWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XmlElementWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XmlDeclarationWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XmlDocumentTypeWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XmlNodeWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\IXmlDocument.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\IXmlDeclaration.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\IXmlDocumentType.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\IXmlElement.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\IXmlNode.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XDeclarationWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XDocumentTypeWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XDocumentWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XTextWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XCommentWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XProcessingInstructionWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XContainerWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XObjectWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XAttributeWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XElementWrapper.cs" />
-    <Compile Include="Newtonsoft\Json\Converters\XmlNodeConverter.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonBinaryType.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonBinaryWriter.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonObjectId.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonReader.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonToken.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonObject.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonArray.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonEmpty.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonValue.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonBoolean.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonString.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonBinary.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonRegex.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonProperty.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonType.cs" />
-    <Compile Include="Newtonsoft\Json\Bson\BsonWriter.cs" />
-    <Compile Include="log4net\ILog.cs" />
-    <Compile Include="log4net\GlobalContext.cs" />
-    <Compile Include="log4net\LogicalThreadContext.cs" />
-    <Compile Include="log4net\LogManager.cs" />
-    <Compile Include="log4net\MDC.cs" />
-    <Compile Include="log4net\NDC.cs" />
-    <Compile Include="log4net\ThreadContext.cs" />
-    <Compile Include="log4net\Appender\IAppender.cs" />
-    <Compile Include="log4net\Appender\AppenderSkeleton.cs" />
-    <Compile Include="log4net\Appender\BufferingAppenderSkeleton.cs" />
-    <Compile Include="log4net\Appender\AdoNetAppender.cs" />
-    <Compile Include="log4net\Appender\AdoNetAppenderParameter.cs" />
-    <Compile Include="log4net\Appender\AnsiColorTerminalAppender.cs" />
-    <Compile Include="log4net\Appender\AppenderCollection.cs" />
-    <Compile Include="log4net\Appender\AspNetTraceAppender.cs" />
-    <Compile Include="log4net\Appender\BufferingForwardingAppender.cs" />
-    <Compile Include="log4net\Appender\ColoredConsoleAppender.cs" />
-    <Compile Include="log4net\Appender\ConsoleAppender.cs" />
-    <Compile Include="log4net\Appender\DebugAppender.cs" />
-    <Compile Include="log4net\Appender\EventLogAppender.cs" />
-    <Compile Include="log4net\Appender\TextWriterAppender.cs" />
-    <Compile Include="log4net\Appender\FileAppender.cs" />
-    <Compile Include="log4net\Appender\ForwardingAppender.cs" />
-    <Compile Include="log4net\Appender\LocalSyslogAppender.cs" />
-    <Compile Include="log4net\Appender\MemoryAppender.cs" />
-    <Compile Include="log4net\Appender\NetSendAppender.cs" />
-    <Compile Include="log4net\Appender\OutputDebugStringAppender.cs" />
-    <Compile Include="log4net\Appender\UdpAppender.cs" />
-    <Compile Include="log4net\Appender\RemoteSyslogAppender.cs" />
-    <Compile Include="log4net\Appender\RemotingAppender.cs" />
-    <Compile Include="log4net\Appender\RollingFileAppender.cs" />
-    <Compile Include="log4net\Appender\SmtpAppender.cs" />
-    <Compile Include="log4net\Appender\SmtpPickupDirAppender.cs" />
-    <Compile Include="log4net\Appender\TelnetAppender.cs" />
-    <Compile Include="log4net\Appender\TraceAppender.cs" />
-    <Compile Include="log4net\Core\IOptionHandler.cs" />
-    <Compile Include="log4net\Core\IAppenderAttachable.cs" />
-    <Compile Include="log4net\Core\LogException.cs" />
-    <Compile Include="log4net\Core\IRepositorySelector.cs" />
-    <Compile Include="log4net\Core\CompactRepositorySelector.cs" />
-    <Compile Include="log4net\Core\DefaultRepositorySelector.cs" />
-    <Compile Include="log4net\Core\ErrorCode.cs" />
-    <Compile Include="log4net\Core\IErrorHandler.cs" />
-    <Compile Include="log4net\Core\IFixingRequired.cs" />
-    <Compile Include="log4net\Core\ILogger.cs" />
-    <Compile Include="log4net\Core\ILoggerWrapper.cs" />
-    <Compile Include="log4net\Core\LoggerRepositoryCreationEventHandler.cs" />
-    <Compile Include="log4net\Core\LoggerRepositoryCreationEventArgs.cs" />
-    <Compile Include="log4net\Core\ITriggeringEventEvaluator.cs" />
-    <Compile Include="log4net\Core\Level.cs" />
-    <Compile Include="log4net\Core\LevelCollection.cs" />
-    <Compile Include="log4net\Core\LevelEvaluator.cs" />
-    <Compile Include="log4net\Core\LevelMap.cs" />
-    <Compile Include="log4net\Core\LocationInfo.cs" />
-    <Compile Include="log4net\Core\LoggerManager.cs" />
-    <Compile Include="log4net\Core\LoggerWrapperImpl.cs" />
-    <Compile Include="log4net\Core\LoggingEventData.cs" />
-    <Compile Include="log4net\Core\FixFlags.cs" />
-    <Compile Include="log4net\Core\LoggingEvent.cs" />
-    <Compile Include="log4net\Core\LogImpl.cs" />
-    <Compile Include="log4net\Core\SecurityContext.cs" />
-    <Compile Include="log4net\Core\SecurityContextProvider.cs" />
-    <Compile Include="log4net\Core\WrapperCreationHandler.cs" />
-    <Compile Include="log4net\Core\WrapperMap.cs" />
-    <Compile Include="log4net\Util\LevelMappingEntry.cs" />
-    <Compile Include="log4net\Util\PatternConverter.cs" />
-    <Compile Include="log4net\Util\AppenderAttachedImpl.cs" />
-    <Compile Include="log4net\Util\CompositeProperties.cs" />
-    <Compile Include="log4net\Util\ContextPropertiesBase.cs" />
-    <Compile Include="log4net\Util\TextWriterAdapter.cs" />
-    <Compile Include="log4net\Util\QuietTextWriter.cs" />
-    <Compile Include="log4net\Util\CountingQuietTextWriter.cs" />
-    <Compile Include="log4net\Util\CyclicBuffer.cs" />
-    <Compile Include="log4net\Util\EmptyCollection.cs" />
-    <Compile Include="log4net\Util\EmptyDictionary.cs" />
-    <Compile Include="log4net\Util\FormattingInfo.cs" />
-    <Compile Include="log4net\Util\GlobalContextProperties.cs" />
-    <Compile Include="log4net\Util\LevelMapping.cs" />
-    <Compile Include="log4net\Util\LogicalThreadContextProperties.cs" />
-    <Compile Include="log4net\Util\LogLog.cs" />
-    <Compile Include="log4net\Util\NativeError.cs" />
-    <Compile Include="log4net\Util\NullDictionaryEnumerator.cs" />
-    <Compile Include="log4net\Util\NullEnumerator.cs" />
-    <Compile Include="log4net\Util\NullSecurityContext.cs" />
-    <Compile Include="log4net\Util\OnlyOnceErrorHandler.cs" />
-    <Compile Include="log4net\Util\OptionConverter.cs" />
-    <Compile Include="log4net\Util\PatternParser.cs" />
-    <Compile Include="log4net\Util\PatternString.cs" />
-    <Compile Include="log4net\Util\ReadOnlyPropertiesDictionary.cs" />
-    <Compile Include="log4net\Util\PropertiesDictionary.cs" />
-    <Compile Include="log4net\Util\ProtectCloseTextWriter.cs" />
-    <Compile Include="log4net\Util\ReaderWriterLock.cs" />
-    <Compile Include="log4net\Util\ReusableStringWriter.cs" />
-    <Compile Include="log4net\Util\SystemInfo.cs" />
-    <Compile Include="log4net\Util\ThreadContextProperties.cs" />
-    <Compile Include="log4net\Util\ThreadContextStack.cs" />
-    <Compile Include="log4net\Util\ThreadContextStacks.cs" />
-    <Compile Include="log4net\Util\Transform.cs" />
-    <Compile Include="log4net\Util\WindowsSecurityContext.cs" />
-    <Compile Include="log4net\Util\TypeConverters\IConvertFrom.cs" />
-    <Compile Include="log4net\Util\TypeConverters\BooleanConverter.cs" />
-    <Compile Include="log4net\Util\TypeConverters\ConversionNotSupportedException.cs" />
-    <Compile Include="log4net\Util\TypeConverters\ConverterRegistry.cs" />
-    <Compile Include="log4net\Util\TypeConverters\EncodingConverter.cs" />
-    <Compile Include="log4net\Util\TypeConverters\IConvertTo.cs" />
-    <Compile Include="log4net\Util\TypeConverters\IPAddressConverter.cs" />
-    <Compile Include="log4net\Util\TypeConverters\PatternLayoutConverter.cs" />
-    <Compile Include="log4net\Util\TypeConverters\PatternStringConverter.cs" />
-    <Compile Include="log4net\Util\TypeConverters\TypeConverter.cs" />
-    <Compile Include="log4net\Util\TypeConverters\TypeConverterAttribute.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\AppDomainPatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\DatePatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\EnvironmentPatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\IdentityPatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\LiteralPatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\NewLinePatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\ProcessIdPatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\PropertyPatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\RandomStringPatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\UserNamePatternConverter.cs" />
-    <Compile Include="log4net\Util\PatternStringConverters\UtcDatePatternConverter.cs" />
-    <Compile Include="log4net\Config\AliasRepositoryAttribute.cs" />
-    <Compile Include="log4net\Config\AliasDomainAttribute.cs" />
-    <Compile Include="log4net\Config\BasicConfigurator.cs" />
-    <Compile Include="log4net\Config\ConfiguratorAttribute.cs" />
-    <Compile Include="log4net\Config\RepositoryAttribute.cs" />
-    <Compile Include="log4net\Config\DomainAttribute.cs" />
-    <Compile Include="log4net\Config\DOMConfigurator.cs" />
-    <Compile Include="log4net\Config\XmlConfiguratorAttribute.cs" />
-    <Compile Include="log4net\Config\DOMConfiguratorAttribute.cs" />
-    <Compile Include="log4net\Config\Log4NetConfigurationSectionHandler.cs" />
-    <Compile Include="log4net\Config\PluginAttribute.cs" />
-    <Compile Include="log4net\Config\SecurityContextProviderAttribute.cs" />
-    <Compile Include="log4net\Config\XmlConfigurator.cs" />
-    <Compile Include="log4net\Plugin\IPluginFactory.cs" />
-    <Compile Include="log4net\Plugin\IPlugin.cs" />
-    <Compile Include="log4net\Plugin\PluginCollection.cs" />
-    <Compile Include="log4net\Plugin\PluginMap.cs" />
-    <Compile Include="log4net\Plugin\PluginSkeleton.cs" />
-    <Compile Include="log4net\Plugin\RemoteLoggingServerPlugin.cs" />
-    <Compile Include="log4net\DateFormatter\IDateFormatter.cs" />
-    <Compile Include="log4net\DateFormatter\AbsoluteTimeDateFormatter.cs" />
-    <Compile Include="log4net\DateFormatter\DateTimeDateFormatter.cs" />
-    <Compile Include="log4net\DateFormatter\Iso8601DateFormatter.cs" />
-    <Compile Include="log4net\DateFormatter\SimpleDateFormatter.cs" />
-    <Compile Include="log4net\Filter\IFilter.cs" />
-    <Compile Include="log4net\Filter\FilterSkeleton.cs" />
-    <Compile Include="log4net\Filter\DenyAllFilter.cs" />
-    <Compile Include="log4net\Filter\FilterDecision.cs" />
-    <Compile Include="log4net\Filter\LevelMatchFilter.cs" />
-    <Compile Include="log4net\Filter\LevelRangeFilter.cs" />
-    <Compile Include="log4net\Filter\LoggerMatchFilter.cs" />
-    <Compile Include="log4net\Filter\StringMatchFilter.cs" />
-    <Compile Include="log4net\Filter\PropertyFilter.cs" />
-    <Compile Include="log4net\Filter\MdcFilter.cs" />
-    <Compile Include="log4net\Filter\NdcFilter.cs" />
-    <Compile Include="log4net\Layout\ILayout.cs" />
-    <Compile Include="log4net\Layout\LayoutSkeleton.cs" />
-    <Compile Include="log4net\Layout\ExceptionLayout.cs" />
-    <Compile Include="log4net\Layout\IRawLayout.cs" />
-    <Compile Include="log4net\Layout\Layout2RawLayoutAdapter.cs" />
-    <Compile Include="log4net\Layout\PatternLayout.cs" />
-    <Compile Include="log4net\Layout\RawLayoutConverter.cs" />
-    <Compile Include="log4net\Layout\RawPropertyLayout.cs" />
-    <Compile Include="log4net\Layout\RawTimeStampLayout.cs" />
-    <Compile Include="log4net\Layout\RawUtcTimeStampLayout.cs" />
-    <Compile Include="log4net\Layout\SimpleLayout.cs" />
-    <Compile Include="log4net\Layout\XmlLayoutBase.cs" />
-    <Compile Include="log4net\Layout\XmlLayout.cs" />
-    <Compile Include="log4net\Layout\XmlLayoutSchemaLog4j.cs" />
-    <Compile Include="log4net\Layout\Pattern\PatternLayoutConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\AppDomainPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\DatePatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\ExceptionPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\FileLocationPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\FullLocationPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\IdentityPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\LevelPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\LineLocationPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\NamedPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\LoggerPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\MessagePatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\MethodLocationPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\NdcPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\PropertyPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\RelativeTimePatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\ThreadPatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\TypeNamePatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\UserNamePatternConverter.cs" />
-    <Compile Include="log4net\Layout\Pattern\UtcDatePatternConverter.cs" />
-    <Compile Include="log4net\ObjectRenderer\IObjectRenderer.cs" />
-    <Compile Include="log4net\ObjectRenderer\DefaultRenderer.cs" />
-    <Compile Include="log4net\ObjectRenderer\RendererMap.cs" />
-    <Compile Include="log4net\Repository\ILoggerRepository.cs" />
-    <Compile Include="log4net\Repository\LoggerRepositorySkeleton.cs" />
-    <Compile Include="log4net\Repository\IBasicRepositoryConfigurator.cs" />
-    <Compile Include="log4net\Repository\IXmlRepositoryConfigurator.cs" />
-    <Compile Include="log4net\Repository\LoggerRepositoryShutdownEventHandler.cs" />
-    <Compile Include="log4net\Repository\LoggerRepositoryConfigurationResetEventHandler.cs" />
-    <Compile Include="log4net\Repository\LoggerRepositoryConfigurationChangedEventHandler.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\ILoggerFactory.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\DefaultLoggerFactory.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\Logger.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\LoggerCreationEventHandler.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\LoggerCreationEventArgs.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\Hierarchy.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\LoggerKey.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\ProvisionNode.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\RootLogger.cs" />
-    <Compile Include="log4net\Repository\Hierarchy\XmlHierarchyConfigurator.cs" />
-    <Compile Include="log4net630819\_003CPrivateImplementationDetails_003E.cs" />
     <Compile Include="AssemblyInfo.cs" />
   </ItemGroup>
   <ItemGroup>
@@ -1198,5 +681,8 @@
     <EmbeddedResource Include="Redbox\HAL\MSHALTester\PickerSensorsBar.resx" />
     <EmbeddedResource Include="Redbox\HAL\MSHALTester\Properties\Resources.resx" />
   </ItemGroup>
+  <ItemGroup>
+    <None Include="packages.config" />
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
 </Project>
\ No newline at end of file
diff --git a/MSHALTester/MSHALTester.sln b/MSHALTester/MSHALTester.sln
index 58edff5..81d4928 100644
--- a/MSHALTester/MSHALTester.sln
+++ b/MSHALTester/MSHALTester.sln
@@ -1,6 +1,7 @@
-
-Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual Studio 2008
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 17
+VisualStudioVersion = 17.10.35122.118
+MinimumVisualStudioVersion = 10.0.40219.1
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MSHALTester", "MSHALTester.csproj", "{4D1167F2-9245-4F36-99C8-87D27113925C}"
 EndProject
 Global
@@ -17,4 +18,7 @@ Global
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
 	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {A11DFC84-20F9-4AFB-B4BA-0D284CB22E8F}
+	EndGlobalSection
 EndGlobal
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonArray.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonArray.cs
deleted file mode 100644
index 2073078..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonArray.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using System.Collections;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonArray : BsonToken, IEnumerable<BsonToken>, IEnumerable
-  {
-    private readonly List<BsonToken> _children = new List<BsonToken>();
-
-    public void Add(BsonToken token)
-    {
-      this._children.Add(token);
-      token.Parent = (BsonToken) this;
-    }
-
-    public override BsonType Type => BsonType.Array;
-
-    public IEnumerator<BsonToken> GetEnumerator()
-    {
-      return (IEnumerator<BsonToken>) this._children.GetEnumerator();
-    }
-
-    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonBinary.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonBinary.cs
deleted file mode 100644
index 7d48802..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonBinary.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonBinary : BsonValue
-  {
-    public BsonBinaryType BinaryType { get; set; }
-
-    public BsonBinary(byte[] value, BsonBinaryType binaryType)
-      : base((object) value, BsonType.Binary)
-    {
-      this.BinaryType = binaryType;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonBinaryType.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonBinaryType.cs
deleted file mode 100644
index 50c760f..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonBinaryType.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal enum BsonBinaryType : byte
-  {
-    Binary = 0,
-    Function = 1,
-    [Obsolete("This type has been deprecated in the BSON specification. Use Binary instead.")] BinaryOld = 2,
-    [Obsolete("This type has been deprecated in the BSON specification. Use Uuid instead.")] UuidOld = 3,
-    Uuid = 4,
-    Md5 = 5,
-    UserDefined = 128, // 0x80
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonBinaryWriter.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonBinaryWriter.cs
deleted file mode 100644
index c228dd9..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonBinaryWriter.cs
+++ /dev/null
@@ -1,215 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonBinaryWriter
-  {
-    private static readonly Encoding Encoding = (Encoding) new UTF8Encoding(false);
-    private readonly BinaryWriter _writer;
-    private byte[] _largeByteBuffer;
-
-    public DateTimeKind DateTimeKindHandling { get; set; }
-
-    public BsonBinaryWriter(BinaryWriter writer)
-    {
-      this.DateTimeKindHandling = DateTimeKind.Utc;
-      this._writer = writer;
-    }
-
-    public void Flush() => this._writer.Flush();
-
-    public void Close() => this._writer.Close();
-
-    public void WriteToken(BsonToken t)
-    {
-      this.CalculateSize(t);
-      this.WriteTokenInternal(t);
-    }
-
-    private void WriteTokenInternal(BsonToken t)
-    {
-      switch (t.Type)
-      {
-        case BsonType.Number:
-          this._writer.Write(Convert.ToDouble(((BsonValue) t).Value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case BsonType.String:
-          BsonString bsonString = (BsonString) t;
-          this.WriteString((string) bsonString.Value, bsonString.ByteCount, new int?(bsonString.CalculatedSize - 4));
-          break;
-        case BsonType.Object:
-          BsonObject bsonObject = (BsonObject) t;
-          this._writer.Write(bsonObject.CalculatedSize);
-          foreach (BsonProperty bsonProperty in bsonObject)
-          {
-            this._writer.Write((sbyte) bsonProperty.Value.Type);
-            this.WriteString((string) bsonProperty.Name.Value, bsonProperty.Name.ByteCount, new int?());
-            this.WriteTokenInternal(bsonProperty.Value);
-          }
-          this._writer.Write((byte) 0);
-          break;
-        case BsonType.Array:
-          BsonArray bsonArray = (BsonArray) t;
-          this._writer.Write(bsonArray.CalculatedSize);
-          ulong i = 0;
-          foreach (BsonToken t1 in bsonArray)
-          {
-            this._writer.Write((sbyte) t1.Type);
-            this.WriteString(i.ToString((IFormatProvider) CultureInfo.InvariantCulture), MathUtils.IntLength(i), new int?());
-            this.WriteTokenInternal(t1);
-            ++i;
-          }
-          this._writer.Write((byte) 0);
-          break;
-        case BsonType.Binary:
-          BsonBinary bsonBinary = (BsonBinary) t;
-          byte[] buffer = (byte[]) bsonBinary.Value;
-          this._writer.Write(buffer.Length);
-          this._writer.Write((byte) bsonBinary.BinaryType);
-          this._writer.Write(buffer);
-          break;
-        case BsonType.Undefined:
-          break;
-        case BsonType.Oid:
-          this._writer.Write((byte[]) ((BsonValue) t).Value);
-          break;
-        case BsonType.Boolean:
-          this._writer.Write(t == BsonBoolean.True);
-          break;
-        case BsonType.Date:
-          BsonValue bsonValue = (BsonValue) t;
-          long javaScriptTicks;
-          if (bsonValue.Value is DateTime)
-          {
-            DateTime dateTime = (DateTime) bsonValue.Value;
-            if (this.DateTimeKindHandling == DateTimeKind.Utc)
-              dateTime = dateTime.ToUniversalTime();
-            else if (this.DateTimeKindHandling == DateTimeKind.Local)
-              dateTime = dateTime.ToLocalTime();
-            javaScriptTicks = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime, false);
-          }
-          else
-          {
-            DateTimeOffset dateTimeOffset = (DateTimeOffset) bsonValue.Value;
-            javaScriptTicks = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.UtcDateTime, dateTimeOffset.Offset);
-          }
-          this._writer.Write(javaScriptTicks);
-          break;
-        case BsonType.Null:
-          break;
-        case BsonType.Regex:
-          BsonRegex bsonRegex = (BsonRegex) t;
-          this.WriteString((string) bsonRegex.Pattern.Value, bsonRegex.Pattern.ByteCount, new int?());
-          this.WriteString((string) bsonRegex.Options.Value, bsonRegex.Options.ByteCount, new int?());
-          break;
-        case BsonType.Integer:
-          this._writer.Write(Convert.ToInt32(((BsonValue) t).Value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case BsonType.Long:
-          this._writer.Write(Convert.ToInt64(((BsonValue) t).Value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        default:
-          throw new ArgumentOutOfRangeException(nameof (t), "Unexpected token when writing BSON: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) t.Type));
-      }
-    }
-
-    private void WriteString(string s, int byteCount, int? calculatedlengthPrefix)
-    {
-      if (calculatedlengthPrefix.HasValue)
-        this._writer.Write(calculatedlengthPrefix.GetValueOrDefault());
-      this.WriteUtf8Bytes(s, byteCount);
-      this._writer.Write((byte) 0);
-    }
-
-    public void WriteUtf8Bytes(string s, int byteCount)
-    {
-      if (s == null)
-        return;
-      if (byteCount <= 256)
-      {
-        if (this._largeByteBuffer == null)
-          this._largeByteBuffer = new byte[256];
-        BsonBinaryWriter.Encoding.GetBytes(s, 0, s.Length, this._largeByteBuffer, 0);
-        this._writer.Write(this._largeByteBuffer, 0, byteCount);
-      }
-      else
-        this._writer.Write(BsonBinaryWriter.Encoding.GetBytes(s));
-    }
-
-    private int CalculateSize(int stringByteCount) => stringByteCount + 1;
-
-    private int CalculateSizeWithLength(int stringByteCount, bool includeSize)
-    {
-      return (includeSize ? 5 : 1) + stringByteCount;
-    }
-
-    private int CalculateSize(BsonToken t)
-    {
-      switch (t.Type)
-      {
-        case BsonType.Number:
-          return 8;
-        case BsonType.String:
-          BsonString bsonString = (BsonString) t;
-          string s = (string) bsonString.Value;
-          bsonString.ByteCount = s != null ? BsonBinaryWriter.Encoding.GetByteCount(s) : 0;
-          bsonString.CalculatedSize = this.CalculateSizeWithLength(bsonString.ByteCount, bsonString.IncludeLength);
-          return bsonString.CalculatedSize;
-        case BsonType.Object:
-          BsonObject bsonObject = (BsonObject) t;
-          int num1 = 4;
-          foreach (BsonProperty bsonProperty in bsonObject)
-          {
-            int num2 = 1 + this.CalculateSize((BsonToken) bsonProperty.Name) + this.CalculateSize(bsonProperty.Value);
-            num1 += num2;
-          }
-          int size = num1 + 1;
-          bsonObject.CalculatedSize = size;
-          return size;
-        case BsonType.Array:
-          BsonArray bsonArray = (BsonArray) t;
-          int num3 = 4;
-          ulong i = 0;
-          foreach (BsonToken t1 in bsonArray)
-          {
-            ++num3;
-            num3 += this.CalculateSize(MathUtils.IntLength(i));
-            num3 += this.CalculateSize(t1);
-            ++i;
-          }
-          int num4 = num3 + 1;
-          bsonArray.CalculatedSize = num4;
-          return bsonArray.CalculatedSize;
-        case BsonType.Binary:
-          BsonBinary bsonBinary = (BsonBinary) t;
-          bsonBinary.CalculatedSize = 5 + ((byte[]) bsonBinary.Value).Length;
-          return bsonBinary.CalculatedSize;
-        case BsonType.Undefined:
-        case BsonType.Null:
-          return 0;
-        case BsonType.Oid:
-          return 12;
-        case BsonType.Boolean:
-          return 1;
-        case BsonType.Date:
-          return 8;
-        case BsonType.Regex:
-          BsonRegex bsonRegex = (BsonRegex) t;
-          int num5 = 0 + this.CalculateSize((BsonToken) bsonRegex.Pattern) + this.CalculateSize((BsonToken) bsonRegex.Options);
-          bsonRegex.CalculatedSize = num5;
-          return bsonRegex.CalculatedSize;
-        case BsonType.Integer:
-          return 4;
-        case BsonType.Long:
-          return 8;
-        default:
-          throw new ArgumentOutOfRangeException(nameof (t), "Unexpected token when writing BSON: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) t.Type));
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonBoolean.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonBoolean.cs
deleted file mode 100644
index 596c827..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonBoolean.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonBoolean : BsonValue
-  {
-    public static readonly BsonBoolean False = new BsonBoolean(false);
-    public static readonly BsonBoolean True = new BsonBoolean(true);
-
-    private BsonBoolean(bool value)
-      : base((object) value, BsonType.Boolean)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonEmpty.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonEmpty.cs
deleted file mode 100644
index 0941897..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonEmpty.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonEmpty : BsonToken
-  {
-    public static readonly BsonToken Null = (BsonToken) new BsonEmpty(BsonType.Null);
-    public static readonly BsonToken Undefined = (BsonToken) new BsonEmpty(BsonType.Undefined);
-
-    private BsonEmpty(BsonType type) => this.Type = type;
-
-    public override BsonType Type { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonObject.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonObject.cs
deleted file mode 100644
index 6e15030..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonObject.cs
+++ /dev/null
@@ -1,30 +0,0 @@
-using System.Collections;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonObject : BsonToken, IEnumerable<BsonProperty>, IEnumerable
-  {
-    private readonly List<BsonProperty> _children = new List<BsonProperty>();
-
-    public void Add(string name, BsonToken token)
-    {
-      this._children.Add(new BsonProperty()
-      {
-        Name = new BsonString((object) name, false),
-        Value = token
-      });
-      token.Parent = (BsonToken) this;
-    }
-
-    public override BsonType Type => BsonType.Object;
-
-    public IEnumerator<BsonProperty> GetEnumerator()
-    {
-      return (IEnumerator<BsonProperty>) this._children.GetEnumerator();
-    }
-
-    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonObjectId.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonObjectId.cs
deleted file mode 100644
index 6cb818f..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonObjectId.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  [Obsolete("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
-  public class BsonObjectId
-  {
-    public byte[] Value { get; }
-
-    public BsonObjectId(byte[] value)
-    {
-      ValidationUtils.ArgumentNotNull((object) value, nameof (value));
-      this.Value = value.Length == 12 ? value : throw new ArgumentException("An ObjectId must be 12 bytes", nameof (value));
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonProperty.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonProperty.cs
deleted file mode 100644
index 64d84ee..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonProperty.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonProperty
-  {
-    public BsonString Name { get; set; }
-
-    public BsonToken Value { get; set; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonReader.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonReader.cs
deleted file mode 100644
index 76969a6..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonReader.cs
+++ /dev/null
@@ -1,581 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  [Obsolete("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
-  public class BsonReader : JsonReader
-  {
-    private const int MaxCharBytesSize = 128;
-    private static readonly byte[] SeqRange1 = new byte[2]
-    {
-      (byte) 0,
-      (byte) 127
-    };
-    private static readonly byte[] SeqRange2 = new byte[2]
-    {
-      (byte) 194,
-      (byte) 223
-    };
-    private static readonly byte[] SeqRange3 = new byte[2]
-    {
-      (byte) 224,
-      (byte) 239
-    };
-    private static readonly byte[] SeqRange4 = new byte[2]
-    {
-      (byte) 240,
-      (byte) 244
-    };
-    private readonly BinaryReader _reader;
-    private readonly List<BsonReader.ContainerContext> _stack;
-    private byte[] _byteBuffer;
-    private char[] _charBuffer;
-    private BsonType _currentElementType;
-    private BsonReader.BsonReaderState _bsonReaderState;
-    private BsonReader.ContainerContext _currentContext;
-    private bool _readRootValueAsArray;
-    private bool _jsonNet35BinaryCompatibility;
-    private DateTimeKind _dateTimeKindHandling;
-
-    [Obsolete("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
-    public bool JsonNet35BinaryCompatibility
-    {
-      get => this._jsonNet35BinaryCompatibility;
-      set => this._jsonNet35BinaryCompatibility = value;
-    }
-
-    public bool ReadRootValueAsArray
-    {
-      get => this._readRootValueAsArray;
-      set => this._readRootValueAsArray = value;
-    }
-
-    public DateTimeKind DateTimeKindHandling
-    {
-      get => this._dateTimeKindHandling;
-      set => this._dateTimeKindHandling = value;
-    }
-
-    public BsonReader(Stream stream)
-      : this(stream, false, DateTimeKind.Local)
-    {
-    }
-
-    public BsonReader(BinaryReader reader)
-      : this(reader, false, DateTimeKind.Local)
-    {
-    }
-
-    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
-    {
-      ValidationUtils.ArgumentNotNull((object) stream, nameof (stream));
-      this._reader = new BinaryReader(stream);
-      this._stack = new List<BsonReader.ContainerContext>();
-      this._readRootValueAsArray = readRootValueAsArray;
-      this._dateTimeKindHandling = dateTimeKindHandling;
-    }
-
-    public BsonReader(
-      BinaryReader reader,
-      bool readRootValueAsArray,
-      DateTimeKind dateTimeKindHandling)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      this._reader = reader;
-      this._stack = new List<BsonReader.ContainerContext>();
-      this._readRootValueAsArray = readRootValueAsArray;
-      this._dateTimeKindHandling = dateTimeKindHandling;
-    }
-
-    private string ReadElement()
-    {
-      this._currentElementType = this.ReadType();
-      return this.ReadString();
-    }
-
-    public override bool Read()
-    {
-      try
-      {
-        bool flag;
-        switch (this._bsonReaderState)
-        {
-          case BsonReader.BsonReaderState.Normal:
-            flag = this.ReadNormal();
-            break;
-          case BsonReader.BsonReaderState.ReferenceStart:
-          case BsonReader.BsonReaderState.ReferenceRef:
-          case BsonReader.BsonReaderState.ReferenceId:
-            flag = this.ReadReference();
-            break;
-          case BsonReader.BsonReaderState.CodeWScopeStart:
-          case BsonReader.BsonReaderState.CodeWScopeCode:
-          case BsonReader.BsonReaderState.CodeWScopeScope:
-          case BsonReader.BsonReaderState.CodeWScopeScopeObject:
-          case BsonReader.BsonReaderState.CodeWScopeScopeEnd:
-            flag = this.ReadCodeWScope();
-            break;
-          default:
-            throw JsonReaderException.Create((JsonReader) this, "Unexpected state: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._bsonReaderState));
-        }
-        if (flag)
-          return true;
-        this.SetToken(JsonToken.None);
-        return false;
-      }
-      catch (EndOfStreamException ex)
-      {
-        this.SetToken(JsonToken.None);
-        return false;
-      }
-    }
-
-    public override void Close()
-    {
-      base.Close();
-      if (!this.CloseInput)
-        return;
-      this._reader?.Close();
-    }
-
-    private bool ReadCodeWScope()
-    {
-      switch (this._bsonReaderState)
-      {
-        case BsonReader.BsonReaderState.CodeWScopeStart:
-          this.SetToken(JsonToken.PropertyName, (object) "$code");
-          this._bsonReaderState = BsonReader.BsonReaderState.CodeWScopeCode;
-          return true;
-        case BsonReader.BsonReaderState.CodeWScopeCode:
-          this.ReadInt32();
-          this.SetToken(JsonToken.String, (object) this.ReadLengthString());
-          this._bsonReaderState = BsonReader.BsonReaderState.CodeWScopeScope;
-          return true;
-        case BsonReader.BsonReaderState.CodeWScopeScope:
-          if (this.CurrentState == JsonReader.State.PostValue)
-          {
-            this.SetToken(JsonToken.PropertyName, (object) "$scope");
-            return true;
-          }
-          this.SetToken(JsonToken.StartObject);
-          this._bsonReaderState = BsonReader.BsonReaderState.CodeWScopeScopeObject;
-          BsonReader.ContainerContext newContext = new BsonReader.ContainerContext(BsonType.Object);
-          this.PushContext(newContext);
-          newContext.Length = this.ReadInt32();
-          return true;
-        case BsonReader.BsonReaderState.CodeWScopeScopeObject:
-          int num = this.ReadNormal() ? 1 : 0;
-          if (num == 0)
-            return num != 0;
-          if (this.TokenType != JsonToken.EndObject)
-            return num != 0;
-          this._bsonReaderState = BsonReader.BsonReaderState.CodeWScopeScopeEnd;
-          return num != 0;
-        case BsonReader.BsonReaderState.CodeWScopeScopeEnd:
-          this.SetToken(JsonToken.EndObject);
-          this._bsonReaderState = BsonReader.BsonReaderState.Normal;
-          return true;
-        default:
-          throw new ArgumentOutOfRangeException();
-      }
-    }
-
-    private bool ReadReference()
-    {
-      switch (this.CurrentState)
-      {
-        case JsonReader.State.Property:
-          if (this._bsonReaderState == BsonReader.BsonReaderState.ReferenceRef)
-          {
-            this.SetToken(JsonToken.String, (object) this.ReadLengthString());
-            return true;
-          }
-          if (this._bsonReaderState != BsonReader.BsonReaderState.ReferenceId)
-            throw JsonReaderException.Create((JsonReader) this, "Unexpected state when reading BSON reference: " + (object) this._bsonReaderState);
-          this.SetToken(JsonToken.Bytes, (object) this.ReadBytes(12));
-          return true;
-        case JsonReader.State.ObjectStart:
-          this.SetToken(JsonToken.PropertyName, (object) "$ref");
-          this._bsonReaderState = BsonReader.BsonReaderState.ReferenceRef;
-          return true;
-        case JsonReader.State.PostValue:
-          if (this._bsonReaderState == BsonReader.BsonReaderState.ReferenceRef)
-          {
-            this.SetToken(JsonToken.PropertyName, (object) "$id");
-            this._bsonReaderState = BsonReader.BsonReaderState.ReferenceId;
-            return true;
-          }
-          if (this._bsonReaderState != BsonReader.BsonReaderState.ReferenceId)
-            throw JsonReaderException.Create((JsonReader) this, "Unexpected state when reading BSON reference: " + (object) this._bsonReaderState);
-          this.SetToken(JsonToken.EndObject);
-          this._bsonReaderState = BsonReader.BsonReaderState.Normal;
-          return true;
-        default:
-          throw JsonReaderException.Create((JsonReader) this, "Unexpected state when reading BSON reference: " + (object) this.CurrentState);
-      }
-    }
-
-    private bool ReadNormal()
-    {
-      switch (this.CurrentState)
-      {
-        case JsonReader.State.Start:
-          JsonToken newToken = !this._readRootValueAsArray ? JsonToken.StartObject : JsonToken.StartArray;
-          int type = !this._readRootValueAsArray ? 3 : 4;
-          this.SetToken(newToken);
-          BsonReader.ContainerContext newContext = new BsonReader.ContainerContext((BsonType) type);
-          this.PushContext(newContext);
-          newContext.Length = this.ReadInt32();
-          return true;
-        case JsonReader.State.Complete:
-        case JsonReader.State.Closed:
-          return false;
-        case JsonReader.State.Property:
-          this.ReadType(this._currentElementType);
-          return true;
-        case JsonReader.State.ObjectStart:
-        case JsonReader.State.ArrayStart:
-        case JsonReader.State.PostValue:
-          BsonReader.ContainerContext currentContext = this._currentContext;
-          if (currentContext == null)
-            return false;
-          int num = currentContext.Length - 1;
-          if (currentContext.Position < num)
-          {
-            if (currentContext.Type == BsonType.Array)
-            {
-              this.ReadElement();
-              this.ReadType(this._currentElementType);
-              return true;
-            }
-            this.SetToken(JsonToken.PropertyName, (object) this.ReadElement());
-            return true;
-          }
-          if (currentContext.Position != num)
-            throw JsonReaderException.Create((JsonReader) this, "Read past end of current container context.");
-          if (this.ReadByte() != (byte) 0)
-            throw JsonReaderException.Create((JsonReader) this, "Unexpected end of object byte value.");
-          this.PopContext();
-          if (this._currentContext != null)
-            this.MovePosition(currentContext.Length);
-          this.SetToken(currentContext.Type == BsonType.Object ? JsonToken.EndObject : JsonToken.EndArray);
-          return true;
-        case JsonReader.State.ConstructorStart:
-        case JsonReader.State.Constructor:
-        case JsonReader.State.Error:
-        case JsonReader.State.Finished:
-          return false;
-        default:
-          throw new ArgumentOutOfRangeException();
-      }
-    }
-
-    private void PopContext()
-    {
-      this._stack.RemoveAt(this._stack.Count - 1);
-      if (this._stack.Count == 0)
-        this._currentContext = (BsonReader.ContainerContext) null;
-      else
-        this._currentContext = this._stack[this._stack.Count - 1];
-    }
-
-    private void PushContext(BsonReader.ContainerContext newContext)
-    {
-      this._stack.Add(newContext);
-      this._currentContext = newContext;
-    }
-
-    private byte ReadByte()
-    {
-      this.MovePosition(1);
-      return this._reader.ReadByte();
-    }
-
-    private void ReadType(BsonType type)
-    {
-      switch (type)
-      {
-        case BsonType.Number:
-          double num = this.ReadDouble();
-          if (this._floatParseHandling == FloatParseHandling.Decimal)
-          {
-            this.SetToken(JsonToken.Float, (object) Convert.ToDecimal((object) num, (IFormatProvider) CultureInfo.InvariantCulture));
-            break;
-          }
-          this.SetToken(JsonToken.Float, (object) num);
-          break;
-        case BsonType.String:
-        case BsonType.Symbol:
-          this.SetToken(JsonToken.String, (object) this.ReadLengthString());
-          break;
-        case BsonType.Object:
-          this.SetToken(JsonToken.StartObject);
-          BsonReader.ContainerContext newContext1 = new BsonReader.ContainerContext(BsonType.Object);
-          this.PushContext(newContext1);
-          newContext1.Length = this.ReadInt32();
-          break;
-        case BsonType.Array:
-          this.SetToken(JsonToken.StartArray);
-          BsonReader.ContainerContext newContext2 = new BsonReader.ContainerContext(BsonType.Array);
-          this.PushContext(newContext2);
-          newContext2.Length = this.ReadInt32();
-          break;
-        case BsonType.Binary:
-          BsonBinaryType binaryType;
-          byte[] b = this.ReadBinary(out binaryType);
-          this.SetToken(JsonToken.Bytes, binaryType != BsonBinaryType.Uuid ? (object) b : (object) new Guid(b));
-          break;
-        case BsonType.Undefined:
-          this.SetToken(JsonToken.Undefined);
-          break;
-        case BsonType.Oid:
-          this.SetToken(JsonToken.Bytes, (object) this.ReadBytes(12));
-          break;
-        case BsonType.Boolean:
-          this.SetToken(JsonToken.Boolean, (object) Convert.ToBoolean(this.ReadByte()));
-          break;
-        case BsonType.Date:
-          DateTime dateTime1 = DateTimeUtils.ConvertJavaScriptTicksToDateTime(this.ReadInt64());
-          DateTime dateTime2;
-          switch (this.DateTimeKindHandling)
-          {
-            case DateTimeKind.Unspecified:
-              dateTime2 = DateTime.SpecifyKind(dateTime1, DateTimeKind.Unspecified);
-              break;
-            case DateTimeKind.Local:
-              dateTime2 = dateTime1.ToLocalTime();
-              break;
-            default:
-              dateTime2 = dateTime1;
-              break;
-          }
-          this.SetToken(JsonToken.Date, (object) dateTime2);
-          break;
-        case BsonType.Null:
-          this.SetToken(JsonToken.Null);
-          break;
-        case BsonType.Regex:
-          this.SetToken(JsonToken.String, (object) ("/" + this.ReadString() + "/" + this.ReadString()));
-          break;
-        case BsonType.Reference:
-          this.SetToken(JsonToken.StartObject);
-          this._bsonReaderState = BsonReader.BsonReaderState.ReferenceStart;
-          break;
-        case BsonType.Code:
-          this.SetToken(JsonToken.String, (object) this.ReadLengthString());
-          break;
-        case BsonType.CodeWScope:
-          this.SetToken(JsonToken.StartObject);
-          this._bsonReaderState = BsonReader.BsonReaderState.CodeWScopeStart;
-          break;
-        case BsonType.Integer:
-          this.SetToken(JsonToken.Integer, (object) (long) this.ReadInt32());
-          break;
-        case BsonType.TimeStamp:
-        case BsonType.Long:
-          this.SetToken(JsonToken.Integer, (object) this.ReadInt64());
-          break;
-        default:
-          throw new ArgumentOutOfRangeException(nameof (type), "Unexpected BsonType value: " + (object) type);
-      }
-    }
-
-    private byte[] ReadBinary(out BsonBinaryType binaryType)
-    {
-      int count = this.ReadInt32();
-      binaryType = (BsonBinaryType) this.ReadByte();
-      if (binaryType == BsonBinaryType.BinaryOld && !this._jsonNet35BinaryCompatibility)
-        count = this.ReadInt32();
-      return this.ReadBytes(count);
-    }
-
-    private string ReadString()
-    {
-      this.EnsureBuffers();
-      StringBuilder stringBuilder = (StringBuilder) null;
-      int num1 = 0;
-      int length = 0;
-      int byteCount;
-      while (true)
-      {
-        int num2 = length;
-        byte num3;
-        while (num2 < 128 && (num3 = this._reader.ReadByte()) > (byte) 0)
-          this._byteBuffer[num2++] = num3;
-        byteCount = num2 - length;
-        num1 += byteCount;
-        if (num2 >= 128 || stringBuilder != null)
-        {
-          int lastFullCharStop = this.GetLastFullCharStop(num2 - 1);
-          int chars = Encoding.UTF8.GetChars(this._byteBuffer, 0, lastFullCharStop + 1, this._charBuffer, 0);
-          if (stringBuilder == null)
-            stringBuilder = new StringBuilder(256);
-          stringBuilder.Append(this._charBuffer, 0, chars);
-          if (lastFullCharStop < byteCount - 1)
-          {
-            length = byteCount - lastFullCharStop - 1;
-            Array.Copy((Array) this._byteBuffer, lastFullCharStop + 1, (Array) this._byteBuffer, 0, length);
-          }
-          else if (num2 >= 128)
-            length = 0;
-          else
-            goto label_11;
-        }
-        else
-          break;
-      }
-      int chars1 = Encoding.UTF8.GetChars(this._byteBuffer, 0, byteCount, this._charBuffer, 0);
-      this.MovePosition(num1 + 1);
-      return new string(this._charBuffer, 0, chars1);
-label_11:
-      this.MovePosition(num1 + 1);
-      return stringBuilder.ToString();
-    }
-
-    private string ReadLengthString()
-    {
-      int count = this.ReadInt32();
-      this.MovePosition(count);
-      string str = this.GetString(count - 1);
-      int num = (int) this._reader.ReadByte();
-      return str;
-    }
-
-    private string GetString(int length)
-    {
-      if (length == 0)
-        return string.Empty;
-      this.EnsureBuffers();
-      StringBuilder stringBuilder = (StringBuilder) null;
-      int num1 = 0;
-      int num2 = 0;
-      do
-      {
-        int count = length - num1 > 128 - num2 ? 128 - num2 : length - num1;
-        int num3 = this._reader.Read(this._byteBuffer, num2, count);
-        if (num3 == 0)
-          throw new EndOfStreamException("Unable to read beyond the end of the stream.");
-        num1 += num3;
-        int byteCount = num3 + num2;
-        if (byteCount == length)
-          return new string(this._charBuffer, 0, Encoding.UTF8.GetChars(this._byteBuffer, 0, byteCount, this._charBuffer, 0));
-        int lastFullCharStop = this.GetLastFullCharStop(byteCount - 1);
-        if (stringBuilder == null)
-          stringBuilder = new StringBuilder(length);
-        int chars = Encoding.UTF8.GetChars(this._byteBuffer, 0, lastFullCharStop + 1, this._charBuffer, 0);
-        stringBuilder.Append(this._charBuffer, 0, chars);
-        if (lastFullCharStop < byteCount - 1)
-        {
-          num2 = byteCount - lastFullCharStop - 1;
-          Array.Copy((Array) this._byteBuffer, lastFullCharStop + 1, (Array) this._byteBuffer, 0, num2);
-        }
-        else
-          num2 = 0;
-      }
-      while (num1 < length);
-      return stringBuilder.ToString();
-    }
-
-    private int GetLastFullCharStop(int start)
-    {
-      int index = start;
-      int num = 0;
-      for (; index >= 0; --index)
-      {
-        num = this.BytesInSequence(this._byteBuffer[index]);
-        switch (num)
-        {
-          case 0:
-            continue;
-          case 1:
-            goto label_5;
-          default:
-            --index;
-            goto label_5;
-        }
-      }
-label_5:
-      return num == start - index ? start : index;
-    }
-
-    private int BytesInSequence(byte b)
-    {
-      if ((int) b <= (int) BsonReader.SeqRange1[1])
-        return 1;
-      if ((int) b >= (int) BsonReader.SeqRange2[0] && (int) b <= (int) BsonReader.SeqRange2[1])
-        return 2;
-      if ((int) b >= (int) BsonReader.SeqRange3[0] && (int) b <= (int) BsonReader.SeqRange3[1])
-        return 3;
-      return (int) b >= (int) BsonReader.SeqRange4[0] && (int) b <= (int) BsonReader.SeqRange4[1] ? 4 : 0;
-    }
-
-    private void EnsureBuffers()
-    {
-      if (this._byteBuffer == null)
-        this._byteBuffer = new byte[128];
-      if (this._charBuffer != null)
-        return;
-      this._charBuffer = new char[Encoding.UTF8.GetMaxCharCount(128)];
-    }
-
-    private double ReadDouble()
-    {
-      this.MovePosition(8);
-      return this._reader.ReadDouble();
-    }
-
-    private int ReadInt32()
-    {
-      this.MovePosition(4);
-      return this._reader.ReadInt32();
-    }
-
-    private long ReadInt64()
-    {
-      this.MovePosition(8);
-      return this._reader.ReadInt64();
-    }
-
-    private BsonType ReadType()
-    {
-      this.MovePosition(1);
-      return (BsonType) this._reader.ReadSByte();
-    }
-
-    private void MovePosition(int count) => this._currentContext.Position += count;
-
-    private byte[] ReadBytes(int count)
-    {
-      this.MovePosition(count);
-      return this._reader.ReadBytes(count);
-    }
-
-    private enum BsonReaderState
-    {
-      Normal,
-      ReferenceStart,
-      ReferenceRef,
-      ReferenceId,
-      CodeWScopeStart,
-      CodeWScopeCode,
-      CodeWScopeScope,
-      CodeWScopeScopeObject,
-      CodeWScopeScopeEnd,
-    }
-
-    private class ContainerContext
-    {
-      public readonly BsonType Type;
-      public int Length;
-      public int Position;
-
-      public ContainerContext(BsonType type) => this.Type = type;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonRegex.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonRegex.cs
deleted file mode 100644
index 86765c0..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonRegex.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonRegex : BsonToken
-  {
-    public BsonString Pattern { get; set; }
-
-    public BsonString Options { get; set; }
-
-    public BsonRegex(string pattern, string options)
-    {
-      this.Pattern = new BsonString((object) pattern, false);
-      this.Options = new BsonString((object) options, false);
-    }
-
-    public override BsonType Type => BsonType.Regex;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonString.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonString.cs
deleted file mode 100644
index 8263a09..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonString.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonString : BsonValue
-  {
-    public int ByteCount { get; set; }
-
-    public bool IncludeLength { get; }
-
-    public BsonString(object value, bool includeLength)
-      : base(value, BsonType.String)
-    {
-      this.IncludeLength = includeLength;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonToken.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonToken.cs
deleted file mode 100644
index 76e874a..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonToken.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal abstract class BsonToken
-  {
-    public abstract BsonType Type { get; }
-
-    public BsonToken Parent { get; set; }
-
-    public int CalculatedSize { get; set; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonType.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonType.cs
deleted file mode 100644
index 7e69a3e..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonType.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal enum BsonType : sbyte
-  {
-    MinKey = -1, // 0xFF
-    Number = 1,
-    String = 2,
-    Object = 3,
-    Array = 4,
-    Binary = 5,
-    Undefined = 6,
-    Oid = 7,
-    Boolean = 8,
-    Date = 9,
-    Null = 10, // 0x0A
-    Regex = 11, // 0x0B
-    Reference = 12, // 0x0C
-    Code = 13, // 0x0D
-    Symbol = 14, // 0x0E
-    CodeWScope = 15, // 0x0F
-    Integer = 16, // 0x10
-    TimeStamp = 17, // 0x11
-    Long = 18, // 0x12
-    MaxKey = 127, // 0x7F
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonValue.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonValue.cs
deleted file mode 100644
index d662887..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonValue.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  internal class BsonValue : BsonToken
-  {
-    private readonly object _value;
-    private readonly BsonType _type;
-
-    public BsonValue(object value, BsonType type)
-    {
-      this._value = value;
-      this._type = type;
-    }
-
-    public object Value => this._value;
-
-    public override BsonType Type => this._type;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Bson/BsonWriter.cs b/MSHALTester/Newtonsoft/Json/Bson/BsonWriter.cs
deleted file mode 100644
index f127064..0000000
--- a/MSHALTester/Newtonsoft/Json/Bson/BsonWriter.cs
+++ /dev/null
@@ -1,297 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json.Bson
-{
-  [Obsolete("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
-  public class BsonWriter : JsonWriter
-  {
-    private readonly BsonBinaryWriter _writer;
-    private BsonToken _root;
-    private BsonToken _parent;
-    private string _propertyName;
-
-    public DateTimeKind DateTimeKindHandling
-    {
-      get => this._writer.DateTimeKindHandling;
-      set => this._writer.DateTimeKindHandling = value;
-    }
-
-    public BsonWriter(Stream stream)
-    {
-      ValidationUtils.ArgumentNotNull((object) stream, nameof (stream));
-      this._writer = new BsonBinaryWriter(new BinaryWriter(stream));
-    }
-
-    public BsonWriter(BinaryWriter writer)
-    {
-      ValidationUtils.ArgumentNotNull((object) writer, nameof (writer));
-      this._writer = new BsonBinaryWriter(writer);
-    }
-
-    public override void Flush() => this._writer.Flush();
-
-    protected override void WriteEnd(JsonToken token)
-    {
-      base.WriteEnd(token);
-      this.RemoveParent();
-      if (this.Top != 0)
-        return;
-      this._writer.WriteToken(this._root);
-    }
-
-    public override void WriteComment(string text)
-    {
-      throw JsonWriterException.Create((JsonWriter) this, "Cannot write JSON comment as BSON.", (Exception) null);
-    }
-
-    public override void WriteStartConstructor(string name)
-    {
-      throw JsonWriterException.Create((JsonWriter) this, "Cannot write JSON constructor as BSON.", (Exception) null);
-    }
-
-    public override void WriteRaw(string json)
-    {
-      throw JsonWriterException.Create((JsonWriter) this, "Cannot write raw JSON as BSON.", (Exception) null);
-    }
-
-    public override void WriteRawValue(string json)
-    {
-      throw JsonWriterException.Create((JsonWriter) this, "Cannot write raw JSON as BSON.", (Exception) null);
-    }
-
-    public override void WriteStartArray()
-    {
-      base.WriteStartArray();
-      this.AddParent((BsonToken) new BsonArray());
-    }
-
-    public override void WriteStartObject()
-    {
-      base.WriteStartObject();
-      this.AddParent((BsonToken) new BsonObject());
-    }
-
-    public override void WritePropertyName(string name)
-    {
-      base.WritePropertyName(name);
-      this._propertyName = name;
-    }
-
-    public override void Close()
-    {
-      base.Close();
-      if (!this.CloseOutput)
-        return;
-      this._writer?.Close();
-    }
-
-    private void AddParent(BsonToken container)
-    {
-      this.AddToken(container);
-      this._parent = container;
-    }
-
-    private void RemoveParent() => this._parent = this._parent.Parent;
-
-    private void AddValue(object value, BsonType type)
-    {
-      this.AddToken((BsonToken) new BsonValue(value, type));
-    }
-
-    internal void AddToken(BsonToken token)
-    {
-      if (this._parent != null)
-      {
-        if (this._parent is BsonObject parent)
-        {
-          parent.Add(this._propertyName, token);
-          this._propertyName = (string) null;
-        }
-        else
-          ((BsonArray) this._parent).Add(token);
-      }
-      else
-      {
-        this._parent = token.Type == BsonType.Object || token.Type == BsonType.Array ? token : throw JsonWriterException.Create((JsonWriter) this, "Error writing {0} value. BSON must start with an Object or Array.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token.Type), (Exception) null);
-        this._root = token;
-      }
-    }
-
-    public override void WriteValue(object value) => base.WriteValue(value);
-
-    public override void WriteNull()
-    {
-      base.WriteNull();
-      this.AddToken(BsonEmpty.Null);
-    }
-
-    public override void WriteUndefined()
-    {
-      base.WriteUndefined();
-      this.AddToken(BsonEmpty.Undefined);
-    }
-
-    public override void WriteValue(string value)
-    {
-      base.WriteValue(value);
-      this.AddToken(value == null ? BsonEmpty.Null : (BsonToken) new BsonString((object) value, true));
-    }
-
-    public override void WriteValue(int value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Integer);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(uint value)
-    {
-      if (value > (uint) int.MaxValue)
-        throw JsonWriterException.Create((JsonWriter) this, "Value is too large to fit in a signed 32 bit integer. BSON does not support unsigned values.", (Exception) null);
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Integer);
-    }
-
-    public override void WriteValue(long value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Long);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(ulong value)
-    {
-      if (value > (ulong) long.MaxValue)
-        throw JsonWriterException.Create((JsonWriter) this, "Value is too large to fit in a signed 64 bit integer. BSON does not support unsigned values.", (Exception) null);
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Long);
-    }
-
-    public override void WriteValue(float value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Number);
-    }
-
-    public override void WriteValue(double value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Number);
-    }
-
-    public override void WriteValue(bool value)
-    {
-      base.WriteValue(value);
-      this.AddToken(value ? (BsonToken) BsonBoolean.True : (BsonToken) BsonBoolean.False);
-    }
-
-    public override void WriteValue(short value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Integer);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(ushort value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Integer);
-    }
-
-    public override void WriteValue(char value)
-    {
-      base.WriteValue(value);
-      this.AddToken((BsonToken) new BsonString((object) value.ToString((IFormatProvider) CultureInfo.InvariantCulture), true));
-    }
-
-    public override void WriteValue(byte value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Integer);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(sbyte value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Integer);
-    }
-
-    public override void WriteValue(Decimal value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Number);
-    }
-
-    public override void WriteValue(DateTime value)
-    {
-      base.WriteValue(value);
-      value = DateTimeUtils.EnsureDateTime(value, this.DateTimeZoneHandling);
-      this.AddValue((object) value, BsonType.Date);
-    }
-
-    public override void WriteValue(DateTimeOffset value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, BsonType.Date);
-    }
-
-    public override void WriteValue(byte[] value)
-    {
-      if (value == null)
-      {
-        this.WriteNull();
-      }
-      else
-      {
-        base.WriteValue(value);
-        this.AddToken((BsonToken) new BsonBinary(value, BsonBinaryType.Binary));
-      }
-    }
-
-    public override void WriteValue(Guid value)
-    {
-      base.WriteValue(value);
-      this.AddToken((BsonToken) new BsonBinary(value.ToByteArray(), BsonBinaryType.Uuid));
-    }
-
-    public override void WriteValue(TimeSpan value)
-    {
-      base.WriteValue(value);
-      this.AddToken((BsonToken) new BsonString((object) value.ToString(), true));
-    }
-
-    public override void WriteValue(Uri value)
-    {
-      if (value == (Uri) null)
-      {
-        this.WriteNull();
-      }
-      else
-      {
-        base.WriteValue(value);
-        this.AddToken((BsonToken) new BsonString((object) value.ToString(), true));
-      }
-    }
-
-    public void WriteObjectId(byte[] value)
-    {
-      ValidationUtils.ArgumentNotNull((object) value, nameof (value));
-      if (value.Length != 12)
-        throw JsonWriterException.Create((JsonWriter) this, "An object id must be 12 bytes", (Exception) null);
-      this.SetWriteState(JsonToken.Undefined, (object) null);
-      this.AddValue((object) value, BsonType.Oid);
-    }
-
-    public void WriteRegex(string pattern, string options)
-    {
-      ValidationUtils.ArgumentNotNull((object) pattern, nameof (pattern));
-      this.SetWriteState(JsonToken.Undefined, (object) null);
-      this.AddToken((BsonToken) new BsonRegex(pattern, options));
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/ConstructorHandling.cs b/MSHALTester/Newtonsoft/Json/ConstructorHandling.cs
deleted file mode 100644
index a474be1..0000000
--- a/MSHALTester/Newtonsoft/Json/ConstructorHandling.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum ConstructorHandling
-  {
-    Default,
-    AllowNonPublicDefaultConstructor,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/BinaryConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/BinaryConverter.cs
deleted file mode 100644
index 5c99922..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/BinaryConverter.cs
+++ /dev/null
@@ -1,104 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Data.SqlTypes;
-using System.Globalization;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class BinaryConverter : JsonConverter
-  {
-    private const string BinaryTypeName = "System.Data.Linq.Binary";
-    private const string BinaryToArrayName = "ToArray";
-    private static ReflectionObject _reflectionObject;
-
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      if (value == null)
-      {
-        writer.WriteNull();
-      }
-      else
-      {
-        byte[] byteArray = this.GetByteArray(value);
-        writer.WriteValue(byteArray);
-      }
-    }
-
-    private byte[] GetByteArray(object value)
-    {
-      if (value.GetType().FullName == "System.Data.Linq.Binary")
-      {
-        BinaryConverter.EnsureReflectionObject(value.GetType());
-        return (byte[]) BinaryConverter._reflectionObject.GetValue(value, "ToArray");
-      }
-      return value is SqlBinary sqlBinary ? sqlBinary.Value : throw new JsonSerializationException("Unexpected value type when writing binary: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType()));
-    }
-
-    private static void EnsureReflectionObject(Type t)
-    {
-      if (BinaryConverter._reflectionObject != null)
-        return;
-      BinaryConverter._reflectionObject = ReflectionObject.Create(t, (MethodBase) t.GetConstructor(new Type[1]
-      {
-        typeof (byte[])
-      }), "ToArray");
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      if (reader.TokenType == JsonToken.Null)
-      {
-        if (!ReflectionUtils.IsNullable(objectType))
-          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-        return (object) null;
-      }
-      byte[] numArray;
-      if (reader.TokenType == JsonToken.StartArray)
-        numArray = this.ReadByteArray(reader);
-      else
-        numArray = reader.TokenType == JsonToken.String ? Convert.FromBase64String(reader.Value.ToString()) : throw JsonSerializationException.Create(reader, "Unexpected token parsing binary. Expected String or StartArray, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      Type t = ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType;
-      if (t.FullName == "System.Data.Linq.Binary")
-      {
-        BinaryConverter.EnsureReflectionObject(t);
-        return BinaryConverter._reflectionObject.Creator((object) numArray);
-      }
-      if (t == typeof (SqlBinary))
-        return (object) new SqlBinary(numArray);
-      throw JsonSerializationException.Create(reader, "Unexpected object type when writing binary: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-    }
-
-    private byte[] ReadByteArray(JsonReader reader)
-    {
-      List<byte> byteList = new List<byte>();
-      while (reader.Read())
-      {
-        switch (reader.TokenType)
-        {
-          case JsonToken.Comment:
-            continue;
-          case JsonToken.Integer:
-            byteList.Add(Convert.ToByte(reader.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-            continue;
-          case JsonToken.EndArray:
-            return byteList.ToArray();
-          default:
-            throw JsonSerializationException.Create(reader, "Unexpected token when reading bytes: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-        }
-      }
-      throw JsonSerializationException.Create(reader, "Unexpected end when reading bytes.");
-    }
-
-    public override bool CanConvert(Type objectType)
-    {
-      return objectType.FullName == "System.Data.Linq.Binary" || objectType == typeof (SqlBinary) || objectType == typeof (SqlBinary?);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/BsonObjectIdConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/BsonObjectIdConverter.cs
deleted file mode 100644
index 7945988..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/BsonObjectIdConverter.cs
+++ /dev/null
@@ -1,32 +0,0 @@
-using Newtonsoft.Json.Bson;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  [Obsolete("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
-  public class BsonObjectIdConverter : JsonConverter
-  {
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      BsonObjectId bsonObjectId = (BsonObjectId) value;
-      if (writer is BsonWriter bsonWriter)
-        bsonWriter.WriteObjectId(bsonObjectId.Value);
-      else
-        writer.WriteValue(bsonObjectId.Value);
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      return reader.TokenType == JsonToken.Bytes ? (object) new BsonObjectId((byte[]) reader.Value) : throw new JsonSerializationException("Expected Bytes but got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-    }
-
-    public override bool CanConvert(Type objectType) => objectType == typeof (BsonObjectId);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/CustomCreationConverter`1.cs b/MSHALTester/Newtonsoft/Json/Converters/CustomCreationConverter`1.cs
deleted file mode 100644
index cdaa59a..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/CustomCreationConverter`1.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public abstract class CustomCreationConverter<T> : JsonConverter
-  {
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      throw new NotSupportedException("CustomCreationConverter should only be used while deserializing.");
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      if (reader.TokenType == JsonToken.Null)
-        return (object) null;
-      T target = this.Create(objectType);
-      if ((object) target == null)
-        throw new JsonSerializationException("No object created.");
-      serializer.Populate(reader, (object) target);
-      return (object) target;
-    }
-
-    public abstract T Create(Type objectType);
-
-    public override bool CanConvert(Type objectType) => typeof (T).IsAssignableFrom(objectType);
-
-    public override bool CanWrite => false;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/DataSetConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/DataSetConverter.cs
deleted file mode 100644
index 8356aca..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/DataSetConverter.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Data;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class DataSetConverter : JsonConverter
-  {
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      if (value == null)
-      {
-        writer.WriteNull();
-      }
-      else
-      {
-        DataSet dataSet = (DataSet) value;
-        DefaultContractResolver contractResolver = serializer.ContractResolver as DefaultContractResolver;
-        DataTableConverter dataTableConverter = new DataTableConverter();
-        writer.WriteStartObject();
-        foreach (DataTable table in (InternalDataCollectionBase) dataSet.Tables)
-        {
-          writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName(table.TableName) : table.TableName);
-          dataTableConverter.WriteJson(writer, (object) table, serializer);
-        }
-        writer.WriteEndObject();
-      }
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      if (reader.TokenType == JsonToken.Null)
-        return (object) null;
-      DataSet dataSet = objectType == typeof (DataSet) ? new DataSet() : (DataSet) Activator.CreateInstance(objectType);
-      DataTableConverter dataTableConverter = new DataTableConverter();
-      reader.ReadAndAssert();
-      while (reader.TokenType == JsonToken.PropertyName)
-      {
-        DataTable table1 = dataSet.Tables[(string) reader.Value];
-        int num = table1 != null ? 1 : 0;
-        DataTable table2 = (DataTable) dataTableConverter.ReadJson(reader, typeof (DataTable), (object) table1, serializer);
-        if (num == 0)
-          dataSet.Tables.Add(table2);
-        reader.ReadAndAssert();
-      }
-      return (object) dataSet;
-    }
-
-    public override bool CanConvert(Type valueType) => typeof (DataSet).IsAssignableFrom(valueType);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/DataTableConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/DataTableConverter.cs
deleted file mode 100644
index 92ae367..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/DataTableConverter.cs
+++ /dev/null
@@ -1,151 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Data;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class DataTableConverter : JsonConverter
-  {
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      if (value == null)
-      {
-        writer.WriteNull();
-      }
-      else
-      {
-        DataTable dataTable = (DataTable) value;
-        DefaultContractResolver contractResolver = serializer.ContractResolver as DefaultContractResolver;
-        writer.WriteStartArray();
-        foreach (DataRow row in (InternalDataCollectionBase) dataTable.Rows)
-        {
-          writer.WriteStartObject();
-          foreach (DataColumn column in (InternalDataCollectionBase) row.Table.Columns)
-          {
-            object obj = row[column];
-            if (serializer.NullValueHandling != NullValueHandling.Ignore || obj != null && obj != DBNull.Value)
-            {
-              writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName(column.ColumnName) : column.ColumnName);
-              serializer.Serialize(writer, obj);
-            }
-          }
-          writer.WriteEndObject();
-        }
-        writer.WriteEndArray();
-      }
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      if (reader.TokenType == JsonToken.Null)
-        return (object) null;
-      if (!(existingValue is DataTable dt))
-        dt = objectType == typeof (DataTable) ? new DataTable() : (DataTable) Activator.CreateInstance(objectType);
-      if (reader.TokenType == JsonToken.PropertyName)
-      {
-        dt.TableName = (string) reader.Value;
-        reader.ReadAndAssert();
-        if (reader.TokenType == JsonToken.Null)
-          return (object) dt;
-      }
-      if (reader.TokenType != JsonToken.StartArray)
-        throw JsonSerializationException.Create(reader, "Unexpected JSON token when reading DataTable. Expected StartArray, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      reader.ReadAndAssert();
-      while (reader.TokenType != JsonToken.EndArray)
-      {
-        DataTableConverter.CreateRow(reader, dt, serializer);
-        reader.ReadAndAssert();
-      }
-      return (object) dt;
-    }
-
-    private static void CreateRow(JsonReader reader, DataTable dt, JsonSerializer serializer)
-    {
-      DataRow row = dt.NewRow();
-      reader.ReadAndAssert();
-      while (reader.TokenType == JsonToken.PropertyName)
-      {
-        string str = (string) reader.Value;
-        reader.ReadAndAssert();
-        DataColumn column = dt.Columns[str];
-        if (column == null)
-        {
-          Type columnDataType = DataTableConverter.GetColumnDataType(reader);
-          column = new DataColumn(str, columnDataType);
-          dt.Columns.Add(column);
-        }
-        if (column.DataType == typeof (DataTable))
-        {
-          if (reader.TokenType == JsonToken.StartArray)
-            reader.ReadAndAssert();
-          DataTable dt1 = new DataTable();
-          while (reader.TokenType != JsonToken.EndArray)
-          {
-            DataTableConverter.CreateRow(reader, dt1, serializer);
-            reader.ReadAndAssert();
-          }
-          row[str] = (object) dt1;
-        }
-        else if (column.DataType.IsArray && column.DataType != typeof (byte[]))
-        {
-          if (reader.TokenType == JsonToken.StartArray)
-            reader.ReadAndAssert();
-          List<object> objectList = new List<object>();
-          while (reader.TokenType != JsonToken.EndArray)
-          {
-            objectList.Add(reader.Value);
-            reader.ReadAndAssert();
-          }
-          Array instance = Array.CreateInstance(column.DataType.GetElementType(), objectList.Count);
-          ((ICollection) objectList).CopyTo(instance, 0);
-          row[str] = (object) instance;
-        }
-        else
-        {
-          object obj = reader.Value != null ? serializer.Deserialize(reader, column.DataType) ?? (object) DBNull.Value : (object) DBNull.Value;
-          row[str] = obj;
-        }
-        reader.ReadAndAssert();
-      }
-      row.EndEdit();
-      dt.Rows.Add(row);
-    }
-
-    private static Type GetColumnDataType(JsonReader reader)
-    {
-      JsonToken tokenType = reader.TokenType;
-      switch (tokenType)
-      {
-        case JsonToken.StartArray:
-          reader.ReadAndAssert();
-          return reader.TokenType == JsonToken.StartObject ? typeof (DataTable) : DataTableConverter.GetColumnDataType(reader).MakeArrayType();
-        case JsonToken.Integer:
-        case JsonToken.Float:
-        case JsonToken.String:
-        case JsonToken.Boolean:
-        case JsonToken.Date:
-        case JsonToken.Bytes:
-          return reader.ValueType;
-        case JsonToken.Null:
-        case JsonToken.Undefined:
-          return typeof (string);
-        default:
-          throw JsonSerializationException.Create(reader, "Unexpected JSON token when reading DataTable: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) tokenType));
-      }
-    }
-
-    public override bool CanConvert(Type valueType)
-    {
-      return typeof (DataTable).IsAssignableFrom(valueType);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/DateTimeConverterBase.cs b/MSHALTester/Newtonsoft/Json/Converters/DateTimeConverterBase.cs
deleted file mode 100644
index 7344366..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/DateTimeConverterBase.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public abstract class DateTimeConverterBase : JsonConverter
-  {
-    public override bool CanConvert(Type objectType)
-    {
-      return objectType == typeof (DateTime) || objectType == typeof (DateTime?) || objectType == typeof (DateTimeOffset) || objectType == typeof (DateTimeOffset?);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/EntityKeyMemberConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/EntityKeyMemberConverter.cs
deleted file mode 100644
index cd1a4d1..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/EntityKeyMemberConverter.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class EntityKeyMemberConverter : JsonConverter
-  {
-    private const string EntityKeyMemberFullTypeName = "System.Data.EntityKeyMember";
-    private const string KeyPropertyName = "Key";
-    private const string TypePropertyName = "Type";
-    private const string ValuePropertyName = "Value";
-    private static ReflectionObject _reflectionObject;
-
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      EntityKeyMemberConverter.EnsureReflectionObject(value.GetType());
-      DefaultContractResolver contractResolver = serializer.ContractResolver as DefaultContractResolver;
-      string str = (string) EntityKeyMemberConverter._reflectionObject.GetValue(value, "Key");
-      object obj = EntityKeyMemberConverter._reflectionObject.GetValue(value, "Value");
-      Type type = obj?.GetType();
-      writer.WriteStartObject();
-      writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName("Key") : "Key");
-      writer.WriteValue(str);
-      writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName("Type") : "Type");
-      writer.WriteValue(type?.FullName);
-      writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName("Value") : "Value");
-      if (type != null)
-      {
-        string s;
-        if (JsonSerializerInternalWriter.TryConvertToString(obj, type, out s))
-          writer.WriteValue(s);
-        else
-          writer.WriteValue(obj);
-      }
-      else
-        writer.WriteNull();
-      writer.WriteEndObject();
-    }
-
-    private static void ReadAndAssertProperty(JsonReader reader, string propertyName)
-    {
-      reader.ReadAndAssert();
-      if (reader.TokenType != JsonToken.PropertyName || !string.Equals(reader.Value.ToString(), propertyName, StringComparison.OrdinalIgnoreCase))
-        throw new JsonSerializationException("Expected JSON property '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) propertyName));
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      EntityKeyMemberConverter.EnsureReflectionObject(objectType);
-      object target = EntityKeyMemberConverter._reflectionObject.Creator();
-      EntityKeyMemberConverter.ReadAndAssertProperty(reader, "Key");
-      reader.ReadAndAssert();
-      EntityKeyMemberConverter._reflectionObject.SetValue(target, "Key", (object) reader.Value.ToString());
-      EntityKeyMemberConverter.ReadAndAssertProperty(reader, "Type");
-      reader.ReadAndAssert();
-      Type type = Type.GetType(reader.Value.ToString());
-      EntityKeyMemberConverter.ReadAndAssertProperty(reader, "Value");
-      reader.ReadAndAssert();
-      EntityKeyMemberConverter._reflectionObject.SetValue(target, "Value", serializer.Deserialize(reader, type));
-      reader.ReadAndAssert();
-      return target;
-    }
-
-    private static void EnsureReflectionObject(Type objectType)
-    {
-      if (EntityKeyMemberConverter._reflectionObject != null)
-        return;
-      EntityKeyMemberConverter._reflectionObject = ReflectionObject.Create(objectType, "Key", "Value");
-    }
-
-    public override bool CanConvert(Type objectType)
-    {
-      return objectType.AssignableToTypeName("System.Data.EntityKeyMember", false);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/IXmlDeclaration.cs b/MSHALTester/Newtonsoft/Json/Converters/IXmlDeclaration.cs
deleted file mode 100644
index eb748a6..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/IXmlDeclaration.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal interface IXmlDeclaration : IXmlNode
-  {
-    string Version { get; }
-
-    string Encoding { get; set; }
-
-    string Standalone { get; set; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/IXmlDocument.cs b/MSHALTester/Newtonsoft/Json/Converters/IXmlDocument.cs
deleted file mode 100644
index d4479f1..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/IXmlDocument.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal interface IXmlDocument : IXmlNode
-  {
-    IXmlNode CreateComment(string text);
-
-    IXmlNode CreateTextNode(string text);
-
-    IXmlNode CreateCDataSection(string data);
-
-    IXmlNode CreateWhitespace(string text);
-
-    IXmlNode CreateSignificantWhitespace(string text);
-
-    IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
-
-    IXmlNode CreateXmlDocumentType(
-      string name,
-      string publicId,
-      string systemId,
-      string internalSubset);
-
-    IXmlNode CreateProcessingInstruction(string target, string data);
-
-    IXmlElement CreateElement(string elementName);
-
-    IXmlElement CreateElement(string qualifiedName, string namespaceUri);
-
-    IXmlNode CreateAttribute(string name, string value);
-
-    IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
-
-    IXmlElement DocumentElement { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/IXmlDocumentType.cs b/MSHALTester/Newtonsoft/Json/Converters/IXmlDocumentType.cs
deleted file mode 100644
index 99b1b08..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/IXmlDocumentType.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal interface IXmlDocumentType : IXmlNode
-  {
-    string Name { get; }
-
-    string System { get; }
-
-    string Public { get; }
-
-    string InternalSubset { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/IXmlElement.cs b/MSHALTester/Newtonsoft/Json/Converters/IXmlElement.cs
deleted file mode 100644
index 93ca8f8..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/IXmlElement.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal interface IXmlElement : IXmlNode
-  {
-    void SetAttributeNode(IXmlNode attribute);
-
-    string GetPrefixOfNamespace(string namespaceUri);
-
-    bool IsEmpty { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/IXmlNode.cs b/MSHALTester/Newtonsoft/Json/Converters/IXmlNode.cs
deleted file mode 100644
index e03713f..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/IXmlNode.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-using System.Collections.Generic;
-using System.Xml;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal interface IXmlNode
-  {
-    XmlNodeType NodeType { get; }
-
-    string LocalName { get; }
-
-    List<IXmlNode> ChildNodes { get; }
-
-    List<IXmlNode> Attributes { get; }
-
-    IXmlNode ParentNode { get; }
-
-    string Value { get; set; }
-
-    IXmlNode AppendChild(IXmlNode newChild);
-
-    string NamespaceUri { get; }
-
-    object WrappedNode { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/IsoDateTimeConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/IsoDateTimeConverter.cs
deleted file mode 100644
index 06e8730..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/IsoDateTimeConverter.cs
+++ /dev/null
@@ -1,76 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class IsoDateTimeConverter : DateTimeConverterBase
-  {
-    private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
-    private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;
-    private string _dateTimeFormat;
-    private CultureInfo _culture;
-
-    public DateTimeStyles DateTimeStyles
-    {
-      get => this._dateTimeStyles;
-      set => this._dateTimeStyles = value;
-    }
-
-    public string DateTimeFormat
-    {
-      get => this._dateTimeFormat ?? string.Empty;
-      set => this._dateTimeFormat = string.IsNullOrEmpty(value) ? (string) null : value;
-    }
-
-    public CultureInfo Culture
-    {
-      get => this._culture ?? CultureInfo.CurrentCulture;
-      set => this._culture = value;
-    }
-
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      string str;
-      switch (value)
-      {
-        case DateTime universalTime1:
-          if ((this._dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (this._dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
-            universalTime1 = universalTime1.ToUniversalTime();
-          str = universalTime1.ToString(this._dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", (IFormatProvider) this.Culture);
-          break;
-        case DateTimeOffset universalTime2:
-          if ((this._dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (this._dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
-            universalTime2 = universalTime2.ToUniversalTime();
-          str = universalTime2.ToString(this._dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", (IFormatProvider) this.Culture);
-          break;
-        default:
-          throw new JsonSerializationException("Unexpected value when converting date. Expected DateTime or DateTimeOffset, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) ReflectionUtils.GetObjectType(value)));
-      }
-      writer.WriteValue(str);
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      bool flag = ReflectionUtils.IsNullableType(objectType);
-      if (reader.TokenType == JsonToken.Null)
-      {
-        if (!flag)
-          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-        return (object) null;
-      }
-      Type type = flag ? Nullable.GetUnderlyingType(objectType) : objectType;
-      if (reader.TokenType == JsonToken.Date)
-        return type == typeof (DateTimeOffset) ? (!(reader.Value is DateTimeOffset) ? (object) new DateTimeOffset((DateTime) reader.Value) : reader.Value) : (reader.Value is DateTimeOffset dateTimeOffset ? (object) dateTimeOffset.DateTime : reader.Value);
-      string str = reader.TokenType == JsonToken.String ? reader.Value.ToString() : throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected String, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      if (string.IsNullOrEmpty(str) & flag)
-        return (object) null;
-      return type == typeof (DateTimeOffset) ? (!string.IsNullOrEmpty(this._dateTimeFormat) ? (object) DateTimeOffset.ParseExact(str, this._dateTimeFormat, (IFormatProvider) this.Culture, this._dateTimeStyles) : (object) DateTimeOffset.Parse(str, (IFormatProvider) this.Culture, this._dateTimeStyles)) : (!string.IsNullOrEmpty(this._dateTimeFormat) ? (object) DateTime.ParseExact(str, this._dateTimeFormat, (IFormatProvider) this.Culture, this._dateTimeStyles) : (object) DateTime.Parse(str, (IFormatProvider) this.Culture, this._dateTimeStyles));
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/JavaScriptDateTimeConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/JavaScriptDateTimeConverter.cs
deleted file mode 100644
index faa5327..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/JavaScriptDateTimeConverter.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class JavaScriptDateTimeConverter : DateTimeConverterBase
-  {
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      long javaScriptTicks;
-      switch (value)
-      {
-        case DateTime dateTime:
-          javaScriptTicks = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime.ToUniversalTime());
-          break;
-        case DateTimeOffset dateTimeOffset:
-          javaScriptTicks = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.ToUniversalTime().UtcDateTime);
-          break;
-        default:
-          throw new JsonSerializationException("Expected date object value.");
-      }
-      writer.WriteStartConstructor("Date");
-      writer.WriteValue(javaScriptTicks);
-      writer.WriteEndConstructor();
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      if (reader.TokenType == JsonToken.Null)
-      {
-        if (!ReflectionUtils.IsNullable(objectType))
-          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-        return (object) null;
-      }
-      if (reader.TokenType != JsonToken.StartConstructor || !string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
-        throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing date. Token: {0}, Value: {1}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType, reader.Value));
-      reader.Read();
-      DateTime dateTime = reader.TokenType == JsonToken.Integer ? DateTimeUtils.ConvertJavaScriptTicksToDateTime((long) reader.Value) : throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected Integer, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      reader.Read();
-      if (reader.TokenType != JsonToken.EndConstructor)
-        throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected EndConstructor, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      return (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType) == typeof (DateTimeOffset) ? (object) new DateTimeOffset(dateTime) : (object) dateTime;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/KeyValuePairConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/KeyValuePairConverter.cs
deleted file mode 100644
index 626cf45..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/KeyValuePairConverter.cs
+++ /dev/null
@@ -1,85 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class KeyValuePairConverter : JsonConverter
-  {
-    private const string KeyName = "Key";
-    private const string ValueName = "Value";
-    private static readonly ThreadSafeStore<Type, ReflectionObject> ReflectionObjectPerType = new ThreadSafeStore<Type, ReflectionObject>(new Func<Type, ReflectionObject>(KeyValuePairConverter.InitializeReflectionObject));
-
-    private static ReflectionObject InitializeReflectionObject(Type t)
-    {
-      Type[] genericArguments = t.GetGenericArguments();
-      Type type1 = ((IList<Type>) genericArguments)[0];
-      Type type2 = ((IList<Type>) genericArguments)[1];
-      return ReflectionObject.Create(t, (MethodBase) t.GetConstructor(new Type[2]
-      {
-        type1,
-        type2
-      }), "Key", "Value");
-    }
-
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      ReflectionObject reflectionObject = KeyValuePairConverter.ReflectionObjectPerType.Get(value.GetType());
-      DefaultContractResolver contractResolver = serializer.ContractResolver as DefaultContractResolver;
-      writer.WriteStartObject();
-      writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName("Key") : "Key");
-      serializer.Serialize(writer, reflectionObject.GetValue(value, "Key"), reflectionObject.GetType("Key"));
-      writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName("Value") : "Value");
-      serializer.Serialize(writer, reflectionObject.GetValue(value, "Value"), reflectionObject.GetType("Value"));
-      writer.WriteEndObject();
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      if (reader.TokenType == JsonToken.Null)
-      {
-        if (!ReflectionUtils.IsNullableType(objectType))
-          throw JsonSerializationException.Create(reader, "Cannot convert null value to KeyValuePair.");
-        return (object) null;
-      }
-      object obj1 = (object) null;
-      object obj2 = (object) null;
-      reader.ReadAndAssert();
-      Type key = ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType;
-      ReflectionObject reflectionObject = KeyValuePairConverter.ReflectionObjectPerType.Get(key);
-      JsonContract contract1 = serializer.ContractResolver.ResolveContract(reflectionObject.GetType("Key"));
-      JsonContract contract2 = serializer.ContractResolver.ResolveContract(reflectionObject.GetType("Value"));
-      while (reader.TokenType == JsonToken.PropertyName)
-      {
-        string a = reader.Value.ToString();
-        if (string.Equals(a, "Key", StringComparison.OrdinalIgnoreCase))
-        {
-          reader.ReadForTypeAndAssert(contract1, false);
-          obj1 = serializer.Deserialize(reader, contract1.UnderlyingType);
-        }
-        else if (string.Equals(a, "Value", StringComparison.OrdinalIgnoreCase))
-        {
-          reader.ReadForTypeAndAssert(contract2, false);
-          obj2 = serializer.Deserialize(reader, contract2.UnderlyingType);
-        }
-        else
-          reader.Skip();
-        reader.ReadAndAssert();
-      }
-      return reflectionObject.Creator(obj1, obj2);
-    }
-
-    public override bool CanConvert(Type objectType)
-    {
-      Type type = ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType;
-      return type.IsValueType() && type.IsGenericType() && type.GetGenericTypeDefinition() == typeof (KeyValuePair<,>);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/RegexConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/RegexConverter.cs
deleted file mode 100644
index abaa8e3..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/RegexConverter.cs
+++ /dev/null
@@ -1,128 +0,0 @@
-using Newtonsoft.Json.Bson;
-using Newtonsoft.Json.Serialization;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Runtime.CompilerServices;
-using System.Text.RegularExpressions;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class RegexConverter : JsonConverter
-  {
-    private const string PatternName = "Pattern";
-    private const string OptionsName = "Options";
-
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      if (value == null)
-      {
-        writer.WriteNull();
-      }
-      else
-      {
-        Regex regex = (Regex) value;
-        if (writer is BsonWriter writer1)
-          this.WriteBson(writer1, regex);
-        else
-          this.WriteJson(writer, regex, serializer);
-      }
-    }
-
-    private bool HasFlag(RegexOptions options, RegexOptions flag) => (options & flag) == flag;
-
-    private void WriteBson(BsonWriter writer, Regex regex)
-    {
-      string str = (string) null;
-      if (this.HasFlag(regex.Options, RegexOptions.IgnoreCase))
-        str += "i";
-      if (this.HasFlag(regex.Options, RegexOptions.Multiline))
-        str += "m";
-      if (this.HasFlag(regex.Options, RegexOptions.Singleline))
-        str += "s";
-      string options = str + "u";
-      if (this.HasFlag(regex.Options, RegexOptions.ExplicitCapture))
-        options += "x";
-      writer.WriteRegex(regex.ToString(), options);
-    }
-
-    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer)
-    {
-      DefaultContractResolver contractResolver = serializer.ContractResolver as DefaultContractResolver;
-      writer.WriteStartObject();
-      writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName("Pattern") : "Pattern");
-      writer.WriteValue(regex.ToString());
-      writer.WritePropertyName(contractResolver != null ? contractResolver.GetResolvedPropertyName("Options") : "Options");
-      serializer.Serialize(writer, (object) regex.Options);
-      writer.WriteEndObject();
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      switch (reader.TokenType)
-      {
-        case JsonToken.StartObject:
-          return (object) this.ReadRegexObject(reader, serializer);
-        case JsonToken.String:
-          return this.ReadRegexString(reader);
-        case JsonToken.Null:
-          return (object) null;
-        default:
-          throw JsonSerializationException.Create(reader, "Unexpected token when reading Regex.");
-      }
-    }
-
-    private object ReadRegexString(JsonReader reader)
-    {
-      string str = (string) reader.Value;
-      int num = str.Length > 0 && str[0] == '/' ? str.LastIndexOf('/') : throw JsonSerializationException.Create(reader, "Regex pattern must be enclosed by slashes.");
-      if (num > 0)
-        return (object) new Regex(str.Substring(1, num - 1), MiscellaneousUtils.GetRegexOptions(str.Substring(num + 1)));
-    }
-
-    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer)
-    {
-      string pattern = (string) null;
-      RegexOptions? nullable = new RegexOptions?();
-      while (reader.Read())
-      {
-        switch (reader.TokenType)
-        {
-          case JsonToken.PropertyName:
-            string a = reader.Value.ToString();
-            if (!reader.Read())
-              throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
-            if (string.Equals(a, "Pattern", StringComparison.OrdinalIgnoreCase))
-            {
-              pattern = (string) reader.Value;
-              continue;
-            }
-            if (string.Equals(a, "Options", StringComparison.OrdinalIgnoreCase))
-            {
-              nullable = new RegexOptions?(serializer.Deserialize<RegexOptions>(reader));
-              continue;
-            }
-            reader.Skip();
-            continue;
-          case JsonToken.EndObject:
-            return pattern != null ? new Regex(pattern, (RegexOptions) ((int) nullable ?? 0)) : throw JsonSerializationException.Create(reader, "Error deserializing Regex. No pattern found.");
-          default:
-            continue;
-        }
-      }
-      throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
-    }
-
-    public override bool CanConvert(Type objectType)
-    {
-      return objectType.Name == "Regex" && this.IsRegex(objectType);
-    }
-
-    [MethodImpl(MethodImplOptions.NoInlining)]
-    private bool IsRegex(Type objectType) => objectType == typeof (Regex);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/StringEnumConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/StringEnumConverter.cs
deleted file mode 100644
index 6a3611a..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/StringEnumConverter.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class StringEnumConverter : JsonConverter
-  {
-    public bool CamelCaseText { get; set; }
-
-    public bool AllowIntegerValues { get; set; }
-
-    public StringEnumConverter() => this.AllowIntegerValues = true;
-
-    public StringEnumConverter(bool camelCaseText)
-      : this()
-    {
-      this.CamelCaseText = camelCaseText;
-    }
-
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      if (value == null)
-      {
-        writer.WriteNull();
-      }
-      else
-      {
-        Enum @enum = (Enum) value;
-        string name;
-        if (!EnumUtils.TryToString(@enum.GetType(), value, this.CamelCaseText, out name))
-        {
-          if (!this.AllowIntegerValues)
-            throw JsonSerializationException.Create((IJsonLineInfo) null, writer.ContainerPath, "Integer value {0} is not allowed.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) @enum.ToString("D")), (Exception) null);
-          writer.WriteValue(value);
-        }
-        else
-          writer.WriteValue(name);
-      }
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      if (reader.TokenType == JsonToken.Null)
-      {
-        if (!ReflectionUtils.IsNullableType(objectType))
-          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-        return (object) null;
-      }
-      bool flag = ReflectionUtils.IsNullableType(objectType);
-      Type type = flag ? Nullable.GetUnderlyingType(objectType) : objectType;
-      try
-      {
-        if (reader.TokenType == JsonToken.String)
-        {
-          string str = reader.Value.ToString();
-          return str == string.Empty & flag ? (object) null : EnumUtils.ParseEnum(type, str, !this.AllowIntegerValues);
-        }
-        if (reader.TokenType == JsonToken.Integer)
-        {
-          if (!this.AllowIntegerValues)
-            throw JsonSerializationException.Create(reader, "Integer value {0} is not allowed.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, reader.Value));
-          return ConvertUtils.ConvertOrCast(reader.Value, CultureInfo.InvariantCulture, type);
-        }
-      }
-      catch (Exception ex)
-      {
-        throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) MiscellaneousUtils.FormatValueForPrint(reader.Value), (object) objectType), ex);
-      }
-      throw JsonSerializationException.Create(reader, "Unexpected token {0} when parsing enum.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-    }
-
-    public override bool CanConvert(Type objectType)
-    {
-      return (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType).IsEnum();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/UnixDateTimeConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/UnixDateTimeConverter.cs
deleted file mode 100644
index c17a807..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/UnixDateTimeConverter.cs
+++ /dev/null
@@ -1,60 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class UnixDateTimeConverter : DateTimeConverterBase
-  {
-    internal static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
-
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      long totalSeconds;
-      switch (value)
-      {
-        case DateTime dateTime:
-          totalSeconds = (long) (dateTime.ToUniversalTime() - UnixDateTimeConverter.UnixEpoch).TotalSeconds;
-          break;
-        case DateTimeOffset dateTimeOffset:
-          totalSeconds = (long) (dateTimeOffset.ToUniversalTime() - (DateTimeOffset) UnixDateTimeConverter.UnixEpoch).TotalSeconds;
-          break;
-        default:
-          throw new JsonSerializationException("Expected date object value.");
-      }
-      if (totalSeconds < 0L)
-        throw new JsonSerializationException("Cannot convert date value that is before Unix epoch of 00:00:00 UTC on 1 January 1970.");
-      writer.WriteValue(totalSeconds);
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      bool flag = ReflectionUtils.IsNullable(objectType);
-      if (reader.TokenType == JsonToken.Null)
-      {
-        if (!flag)
-          throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-        return (object) null;
-      }
-      long result;
-      if (reader.TokenType == JsonToken.Integer)
-      {
-        result = (long) reader.Value;
-      }
-      else
-      {
-        if (reader.TokenType != JsonToken.String)
-          throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected Integer or String, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-        if (!long.TryParse((string) reader.Value, out result))
-          throw JsonSerializationException.Create(reader, "Cannot convert invalid value to {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-      }
-      DateTime dateTime = result >= 0L ? UnixDateTimeConverter.UnixEpoch.AddSeconds((double) result) : throw JsonSerializationException.Create(reader, "Cannot convert value that is before Unix epoch of 00:00:00 UTC on 1 January 1970 to {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-      return (flag ? Nullable.GetUnderlyingType(objectType) : objectType) == typeof (DateTimeOffset) ? (object) new DateTimeOffset(dateTime, TimeSpan.Zero) : (object) dateTime;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/VersionConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/VersionConverter.cs
deleted file mode 100644
index 35a1e5c..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/VersionConverter.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class VersionConverter : JsonConverter
-  {
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      if (value == null)
-      {
-        writer.WriteNull();
-      }
-      else
-      {
-        if ((object) (value as Version) == null)
-          throw new JsonSerializationException("Expected Version object value");
-        writer.WriteValue(value.ToString());
-      }
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      if (reader.TokenType == JsonToken.Null)
-        return (object) null;
-      if (reader.TokenType != JsonToken.String)
-        throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing version. Token: {0}, Value: {1}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType, reader.Value));
-      try
-      {
-        return (object) new Version((string) reader.Value);
-      }
-      catch (Exception ex)
-      {
-        throw JsonSerializationException.Create(reader, "Error parsing version string: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, reader.Value), ex);
-      }
-    }
-
-    public override bool CanConvert(Type objectType) => objectType == typeof (Version);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XAttributeWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XAttributeWrapper.cs
deleted file mode 100644
index 3357125..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XAttributeWrapper.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XAttributeWrapper(XAttribute attribute) : XObjectWrapper((XObject) attribute)
-  {
-    private XAttribute Attribute => (XAttribute) this.WrappedNode;
-
-    public override string Value
-    {
-      get => this.Attribute.Value;
-      set => this.Attribute.Value = value;
-    }
-
-    public override string LocalName => this.Attribute.Name.LocalName;
-
-    public override string NamespaceUri => this.Attribute.Name.NamespaceName;
-
-    public override IXmlNode ParentNode
-    {
-      get
-      {
-        return this.Attribute.Parent == null ? (IXmlNode) null : XContainerWrapper.WrapNode((XObject) this.Attribute.Parent);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XCommentWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XCommentWrapper.cs
deleted file mode 100644
index 643aaab..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XCommentWrapper.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XCommentWrapper(XComment text) : XObjectWrapper((XObject) text)
-  {
-    private XComment Text => (XComment) this.WrappedNode;
-
-    public override string Value
-    {
-      get => this.Text.Value;
-      set => this.Text.Value = value;
-    }
-
-    public override IXmlNode ParentNode
-    {
-      get
-      {
-        return this.Text.Parent == null ? (IXmlNode) null : XContainerWrapper.WrapNode((XObject) this.Text.Parent);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XContainerWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XContainerWrapper.cs
deleted file mode 100644
index 347f8e1..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XContainerWrapper.cs
+++ /dev/null
@@ -1,76 +0,0 @@
-using System.Collections.Generic;
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XContainerWrapper(XContainer container) : XObjectWrapper((XObject) container)
-  {
-    private List<IXmlNode> _childNodes;
-
-    private XContainer Container => (XContainer) this.WrappedNode;
-
-    public override List<IXmlNode> ChildNodes
-    {
-      get
-      {
-        if (this._childNodes == null)
-        {
-          if (!this.HasChildNodes)
-          {
-            this._childNodes = XmlNodeConverter.EmptyChildNodes;
-          }
-          else
-          {
-            this._childNodes = new List<IXmlNode>();
-            foreach (XObject node in this.Container.Nodes())
-              this._childNodes.Add(XContainerWrapper.WrapNode(node));
-          }
-        }
-        return this._childNodes;
-      }
-    }
-
-    protected virtual bool HasChildNodes => this.Container.LastNode != null;
-
-    public override IXmlNode ParentNode
-    {
-      get
-      {
-        return this.Container.Parent == null ? (IXmlNode) null : XContainerWrapper.WrapNode((XObject) this.Container.Parent);
-      }
-    }
-
-    internal static IXmlNode WrapNode(XObject node)
-    {
-      switch (node)
-      {
-        case XDocument document:
-          return (IXmlNode) new XDocumentWrapper(document);
-        case XElement element:
-          return (IXmlNode) new XElementWrapper(element);
-        case XContainer container:
-          return (IXmlNode) new XContainerWrapper(container);
-        case XProcessingInstruction processingInstruction:
-          return (IXmlNode) new XProcessingInstructionWrapper(processingInstruction);
-        case XText text1:
-          return (IXmlNode) new XTextWrapper(text1);
-        case XComment text2:
-          return (IXmlNode) new XCommentWrapper(text2);
-        case XAttribute attribute:
-          return (IXmlNode) new XAttributeWrapper(attribute);
-        case XDocumentType documentType:
-          return (IXmlNode) new XDocumentTypeWrapper(documentType);
-        default:
-          return (IXmlNode) new XObjectWrapper(node);
-      }
-    }
-
-    public override IXmlNode AppendChild(IXmlNode newChild)
-    {
-      this.Container.Add(newChild.WrappedNode);
-      this._childNodes = (List<IXmlNode>) null;
-      return newChild;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XDeclarationWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XDeclarationWrapper.cs
deleted file mode 100644
index 463da48..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XDeclarationWrapper.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-using System.Xml;
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XDeclarationWrapper : XObjectWrapper, IXmlDeclaration, IXmlNode
-  {
-    internal XDeclaration Declaration { get; }
-
-    public XDeclarationWrapper(XDeclaration declaration)
-      : base((XObject) null)
-    {
-      this.Declaration = declaration;
-    }
-
-    public override XmlNodeType NodeType => XmlNodeType.XmlDeclaration;
-
-    public string Version => this.Declaration.Version;
-
-    public string Encoding
-    {
-      get => this.Declaration.Encoding;
-      set => this.Declaration.Encoding = value;
-    }
-
-    public string Standalone
-    {
-      get => this.Declaration.Standalone;
-      set => this.Declaration.Standalone = value;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XDocumentTypeWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XDocumentTypeWrapper.cs
deleted file mode 100644
index 14ce5e8..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XDocumentTypeWrapper.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XDocumentTypeWrapper : XObjectWrapper, IXmlDocumentType, IXmlNode
-  {
-    private readonly XDocumentType _documentType;
-
-    public XDocumentTypeWrapper(XDocumentType documentType)
-      : base((XObject) documentType)
-    {
-      this._documentType = documentType;
-    }
-
-    public string Name => this._documentType.Name;
-
-    public string System => this._documentType.SystemId;
-
-    public string Public => this._documentType.PublicId;
-
-    public string InternalSubset => this._documentType.InternalSubset;
-
-    public override string LocalName => "DOCTYPE";
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XDocumentWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XDocumentWrapper.cs
deleted file mode 100644
index b0dd3db..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XDocumentWrapper.cs
+++ /dev/null
@@ -1,109 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System.Collections.Generic;
-using System.Xml;
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XDocumentWrapper(XDocument document) : XContainerWrapper((XContainer) document), IXmlDocument, IXmlNode
-  {
-    private XDocument Document => (XDocument) this.WrappedNode;
-
-    public override List<IXmlNode> ChildNodes
-    {
-      get
-      {
-        List<IXmlNode> childNodes = base.ChildNodes;
-        if (this.Document.Declaration != null && (childNodes.Count == 0 || childNodes[0].NodeType != XmlNodeType.XmlDeclaration))
-          childNodes.Insert(0, (IXmlNode) new XDeclarationWrapper(this.Document.Declaration));
-        return childNodes;
-      }
-    }
-
-    protected override bool HasChildNodes
-    {
-      get => base.HasChildNodes || this.Document.Declaration != null;
-    }
-
-    public IXmlNode CreateComment(string text)
-    {
-      return (IXmlNode) new XObjectWrapper((XObject) new XComment(text));
-    }
-
-    public IXmlNode CreateTextNode(string text)
-    {
-      return (IXmlNode) new XObjectWrapper((XObject) new XText(text));
-    }
-
-    public IXmlNode CreateCDataSection(string data)
-    {
-      return (IXmlNode) new XObjectWrapper((XObject) new XCData(data));
-    }
-
-    public IXmlNode CreateWhitespace(string text)
-    {
-      return (IXmlNode) new XObjectWrapper((XObject) new XText(text));
-    }
-
-    public IXmlNode CreateSignificantWhitespace(string text)
-    {
-      return (IXmlNode) new XObjectWrapper((XObject) new XText(text));
-    }
-
-    public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
-    {
-      return (IXmlNode) new XDeclarationWrapper(new XDeclaration(version, encoding, standalone));
-    }
-
-    public IXmlNode CreateXmlDocumentType(
-      string name,
-      string publicId,
-      string systemId,
-      string internalSubset)
-    {
-      return (IXmlNode) new XDocumentTypeWrapper(new XDocumentType(name, publicId, systemId, internalSubset));
-    }
-
-    public IXmlNode CreateProcessingInstruction(string target, string data)
-    {
-      return (IXmlNode) new XProcessingInstructionWrapper(new XProcessingInstruction(target, data));
-    }
-
-    public IXmlElement CreateElement(string elementName)
-    {
-      return (IXmlElement) new XElementWrapper(new XElement((XName) elementName));
-    }
-
-    public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
-    {
-      return (IXmlElement) new XElementWrapper(new XElement(XName.Get(MiscellaneousUtils.GetLocalName(qualifiedName), namespaceUri)));
-    }
-
-    public IXmlNode CreateAttribute(string name, string value)
-    {
-      return (IXmlNode) new XAttributeWrapper(new XAttribute((XName) name, (object) value));
-    }
-
-    public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
-    {
-      return (IXmlNode) new XAttributeWrapper(new XAttribute(XName.Get(MiscellaneousUtils.GetLocalName(qualifiedName), namespaceUri), (object) value));
-    }
-
-    public IXmlElement DocumentElement
-    {
-      get
-      {
-        return this.Document.Root == null ? (IXmlElement) null : (IXmlElement) new XElementWrapper(this.Document.Root);
-      }
-    }
-
-    public override IXmlNode AppendChild(IXmlNode newChild)
-    {
-      if (!(newChild is XDeclarationWrapper xdeclarationWrapper))
-        return base.AppendChild(newChild);
-      this.Document.Declaration = xdeclarationWrapper.Declaration;
-      return (IXmlNode) xdeclarationWrapper;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XElementWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XElementWrapper.cs
deleted file mode 100644
index c7e719c..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XElementWrapper.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-using System.Collections.Generic;
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XElementWrapper(XElement element) : XContainerWrapper((XContainer) element), IXmlElement, IXmlNode
-  {
-    private List<IXmlNode> _attributes;
-
-    private XElement Element => (XElement) this.WrappedNode;
-
-    public void SetAttributeNode(IXmlNode attribute)
-    {
-      this.Element.Add(((XObjectWrapper) attribute).WrappedNode);
-      this._attributes = (List<IXmlNode>) null;
-    }
-
-    public override List<IXmlNode> Attributes
-    {
-      get
-      {
-        if (this._attributes == null)
-        {
-          if (!this.Element.HasAttributes && !this.HasImplicitNamespaceAttribute(this.NamespaceUri))
-          {
-            this._attributes = XmlNodeConverter.EmptyChildNodes;
-          }
-          else
-          {
-            this._attributes = new List<IXmlNode>();
-            foreach (XAttribute attribute in this.Element.Attributes())
-              this._attributes.Add((IXmlNode) new XAttributeWrapper(attribute));
-            string namespaceUri = this.NamespaceUri;
-            if (this.HasImplicitNamespaceAttribute(namespaceUri))
-              this._attributes.Insert(0, (IXmlNode) new XAttributeWrapper(new XAttribute((XName) "xmlns", (object) namespaceUri)));
-          }
-        }
-        return this._attributes;
-      }
-    }
-
-    private bool HasImplicitNamespaceAttribute(string namespaceUri)
-    {
-      if (!string.IsNullOrEmpty(namespaceUri) && namespaceUri != this.ParentNode?.NamespaceUri && string.IsNullOrEmpty(this.GetPrefixOfNamespace(namespaceUri)))
-      {
-        bool flag = false;
-        if (this.Element.HasAttributes)
-        {
-          foreach (XAttribute attribute in this.Element.Attributes())
-          {
-            if (attribute.Name.LocalName == "xmlns" && string.IsNullOrEmpty(attribute.Name.NamespaceName) && attribute.Value == namespaceUri)
-              flag = true;
-          }
-        }
-        if (!flag)
-          return true;
-      }
-      return false;
-    }
-
-    public override IXmlNode AppendChild(IXmlNode newChild)
-    {
-      IXmlNode xmlNode = base.AppendChild(newChild);
-      this._attributes = (List<IXmlNode>) null;
-      return xmlNode;
-    }
-
-    public override string Value
-    {
-      get => this.Element.Value;
-      set => this.Element.Value = value;
-    }
-
-    public override string LocalName => this.Element.Name.LocalName;
-
-    public override string NamespaceUri => this.Element.Name.NamespaceName;
-
-    public string GetPrefixOfNamespace(string namespaceUri)
-    {
-      return this.Element.GetPrefixOfNamespace((XNamespace) namespaceUri);
-    }
-
-    public bool IsEmpty => this.Element.IsEmpty;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XObjectWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XObjectWrapper.cs
deleted file mode 100644
index 3b40108..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XObjectWrapper.cs
+++ /dev/null
@@ -1,37 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Xml;
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XObjectWrapper : IXmlNode
-  {
-    private readonly XObject _xmlObject;
-
-    public XObjectWrapper(XObject xmlObject) => this._xmlObject = xmlObject;
-
-    public object WrappedNode => (object) this._xmlObject;
-
-    public virtual XmlNodeType NodeType => this._xmlObject.NodeType;
-
-    public virtual string LocalName => (string) null;
-
-    public virtual List<IXmlNode> ChildNodes => XmlNodeConverter.EmptyChildNodes;
-
-    public virtual List<IXmlNode> Attributes => XmlNodeConverter.EmptyChildNodes;
-
-    public virtual IXmlNode ParentNode => (IXmlNode) null;
-
-    public virtual string Value
-    {
-      get => (string) null;
-      set => throw new InvalidOperationException();
-    }
-
-    public virtual IXmlNode AppendChild(IXmlNode newChild) => throw new InvalidOperationException();
-
-    public virtual string NamespaceUri => (string) null;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XProcessingInstructionWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XProcessingInstructionWrapper.cs
deleted file mode 100644
index b1e0216..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XProcessingInstructionWrapper.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XProcessingInstructionWrapper(XProcessingInstruction processingInstruction) : 
-    XObjectWrapper((XObject) processingInstruction)
-  {
-    private XProcessingInstruction ProcessingInstruction
-    {
-      get => (XProcessingInstruction) this.WrappedNode;
-    }
-
-    public override string LocalName => this.ProcessingInstruction.Target;
-
-    public override string Value
-    {
-      get => this.ProcessingInstruction.Data;
-      set => this.ProcessingInstruction.Data = value;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XTextWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XTextWrapper.cs
deleted file mode 100644
index 55b6dd7..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XTextWrapper.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XTextWrapper(XText text) : XObjectWrapper((XObject) text)
-  {
-    private XText Text => (XText) this.WrappedNode;
-
-    public override string Value
-    {
-      get => this.Text.Value;
-      set => this.Text.Value = value;
-    }
-
-    public override IXmlNode ParentNode
-    {
-      get
-      {
-        return this.Text.Parent == null ? (IXmlNode) null : XContainerWrapper.WrapNode((XObject) this.Text.Parent);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XmlDeclarationWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XmlDeclarationWrapper.cs
deleted file mode 100644
index bbee3e8..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XmlDeclarationWrapper.cs
+++ /dev/null
@@ -1,30 +0,0 @@
-using System.Xml;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XmlDeclarationWrapper : XmlNodeWrapper, IXmlDeclaration, IXmlNode
-  {
-    private readonly XmlDeclaration _declaration;
-
-    public XmlDeclarationWrapper(XmlDeclaration declaration)
-      : base((XmlNode) declaration)
-    {
-      this._declaration = declaration;
-    }
-
-    public string Version => this._declaration.Version;
-
-    public string Encoding
-    {
-      get => this._declaration.Encoding;
-      set => this._declaration.Encoding = value;
-    }
-
-    public string Standalone
-    {
-      get => this._declaration.Standalone;
-      set => this._declaration.Standalone = value;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XmlDocumentTypeWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XmlDocumentTypeWrapper.cs
deleted file mode 100644
index 35e3463..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XmlDocumentTypeWrapper.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using System.Xml;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XmlDocumentTypeWrapper : XmlNodeWrapper, IXmlDocumentType, IXmlNode
-  {
-    private readonly XmlDocumentType _documentType;
-
-    public XmlDocumentTypeWrapper(XmlDocumentType documentType)
-      : base((XmlNode) documentType)
-    {
-      this._documentType = documentType;
-    }
-
-    public string Name => this._documentType.Name;
-
-    public string System => this._documentType.SystemId;
-
-    public string Public => this._documentType.PublicId;
-
-    public string InternalSubset => this._documentType.InternalSubset;
-
-    public override string LocalName => "DOCTYPE";
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XmlDocumentWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XmlDocumentWrapper.cs
deleted file mode 100644
index 0c82e22..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XmlDocumentWrapper.cs
+++ /dev/null
@@ -1,94 +0,0 @@
-using System.Xml;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XmlDocumentWrapper : XmlNodeWrapper, IXmlDocument, IXmlNode
-  {
-    private readonly XmlDocument _document;
-
-    public XmlDocumentWrapper(XmlDocument document)
-      : base((XmlNode) document)
-    {
-      this._document = document;
-    }
-
-    public IXmlNode CreateComment(string data)
-    {
-      return (IXmlNode) new XmlNodeWrapper((XmlNode) this._document.CreateComment(data));
-    }
-
-    public IXmlNode CreateTextNode(string text)
-    {
-      return (IXmlNode) new XmlNodeWrapper((XmlNode) this._document.CreateTextNode(text));
-    }
-
-    public IXmlNode CreateCDataSection(string data)
-    {
-      return (IXmlNode) new XmlNodeWrapper((XmlNode) this._document.CreateCDataSection(data));
-    }
-
-    public IXmlNode CreateWhitespace(string text)
-    {
-      return (IXmlNode) new XmlNodeWrapper((XmlNode) this._document.CreateWhitespace(text));
-    }
-
-    public IXmlNode CreateSignificantWhitespace(string text)
-    {
-      return (IXmlNode) new XmlNodeWrapper((XmlNode) this._document.CreateSignificantWhitespace(text));
-    }
-
-    public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
-    {
-      return (IXmlNode) new XmlDeclarationWrapper(this._document.CreateXmlDeclaration(version, encoding, standalone));
-    }
-
-    public IXmlNode CreateXmlDocumentType(
-      string name,
-      string publicId,
-      string systemId,
-      string internalSubset)
-    {
-      return (IXmlNode) new XmlDocumentTypeWrapper(this._document.CreateDocumentType(name, publicId, systemId, (string) null));
-    }
-
-    public IXmlNode CreateProcessingInstruction(string target, string data)
-    {
-      return (IXmlNode) new XmlNodeWrapper((XmlNode) this._document.CreateProcessingInstruction(target, data));
-    }
-
-    public IXmlElement CreateElement(string elementName)
-    {
-      return (IXmlElement) new XmlElementWrapper(this._document.CreateElement(elementName));
-    }
-
-    public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
-    {
-      return (IXmlElement) new XmlElementWrapper(this._document.CreateElement(qualifiedName, namespaceUri));
-    }
-
-    public IXmlNode CreateAttribute(string name, string value)
-    {
-      return (IXmlNode) new XmlNodeWrapper((XmlNode) this._document.CreateAttribute(name))
-      {
-        Value = value
-      };
-    }
-
-    public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
-    {
-      return (IXmlNode) new XmlNodeWrapper((XmlNode) this._document.CreateAttribute(qualifiedName, namespaceUri))
-      {
-        Value = value
-      };
-    }
-
-    public IXmlElement DocumentElement
-    {
-      get
-      {
-        return this._document.DocumentElement == null ? (IXmlElement) null : (IXmlElement) new XmlElementWrapper(this._document.DocumentElement);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XmlElementWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XmlElementWrapper.cs
deleted file mode 100644
index d6b4c79..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XmlElementWrapper.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using System.Xml;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XmlElementWrapper : XmlNodeWrapper, IXmlElement, IXmlNode
-  {
-    private readonly XmlElement _element;
-
-    public XmlElementWrapper(XmlElement element)
-      : base((XmlNode) element)
-    {
-      this._element = element;
-    }
-
-    public void SetAttributeNode(IXmlNode attribute)
-    {
-      this._element.SetAttributeNode((XmlAttribute) ((XmlNodeWrapper) attribute).WrappedNode);
-    }
-
-    public string GetPrefixOfNamespace(string namespaceUri)
-    {
-      return this._element.GetPrefixOfNamespace(namespaceUri);
-    }
-
-    public bool IsEmpty => this._element.IsEmpty;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XmlNodeConverter.cs b/MSHALTester/Newtonsoft/Json/Converters/XmlNodeConverter.cs
deleted file mode 100644
index 8e45a01..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XmlNodeConverter.cs
+++ /dev/null
@@ -1,944 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Runtime.CompilerServices;
-using System.Xml;
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  public class XmlNodeConverter : JsonConverter
-  {
-    internal static readonly List<IXmlNode> EmptyChildNodes = new List<IXmlNode>();
-    private const string TextName = "#text";
-    private const string CommentName = "#comment";
-    private const string CDataName = "#cdata-section";
-    private const string WhitespaceName = "#whitespace";
-    private const string SignificantWhitespaceName = "#significant-whitespace";
-    private const string DeclarationName = "?xml";
-    private const string JsonNamespaceUri = "http://james.newtonking.com/projects/json";
-
-    public string DeserializeRootElementName { get; set; }
-
-    public bool WriteArrayAttribute { get; set; }
-
-    public bool OmitRootObject { get; set; }
-
-    public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
-    {
-      if (value == null)
-      {
-        writer.WriteNull();
-      }
-      else
-      {
-        IXmlNode node = this.WrapXml(value);
-        XmlNamespaceManager manager = new XmlNamespaceManager((XmlNameTable) new NameTable());
-        this.PushParentNamespaces(node, manager);
-        if (!this.OmitRootObject)
-          writer.WriteStartObject();
-        this.SerializeNode(writer, node, manager, !this.OmitRootObject);
-        if (this.OmitRootObject)
-          return;
-        writer.WriteEndObject();
-      }
-    }
-
-    private IXmlNode WrapXml(object value)
-    {
-      switch (value)
-      {
-        case XObject node1:
-          return XContainerWrapper.WrapNode(node1);
-        case XmlNode node2:
-          return XmlNodeWrapper.WrapNode(node2);
-        default:
-          throw new ArgumentException("Value must be an XML object.", nameof (value));
-      }
-    }
-
-    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager)
-    {
-      List<IXmlNode> xmlNodeList = (List<IXmlNode>) null;
-      IXmlNode xmlNode1 = node;
-      while ((xmlNode1 = xmlNode1.ParentNode) != null)
-      {
-        if (xmlNode1.NodeType == XmlNodeType.Element)
-        {
-          if (xmlNodeList == null)
-            xmlNodeList = new List<IXmlNode>();
-          xmlNodeList.Add(xmlNode1);
-        }
-      }
-      if (xmlNodeList == null)
-        return;
-      xmlNodeList.Reverse();
-      foreach (IXmlNode xmlNode2 in xmlNodeList)
-      {
-        manager.PushScope();
-        foreach (IXmlNode attribute in xmlNode2.Attributes)
-        {
-          if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/" && attribute.LocalName != "xmlns")
-            manager.AddNamespace(attribute.LocalName, attribute.Value);
-        }
-      }
-    }
-
-    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager)
-    {
-      string str = node.NamespaceUri == null || node.LocalName == "xmlns" && node.NamespaceUri == "http://www.w3.org/2000/xmlns/" ? (string) null : manager.LookupPrefix(node.NamespaceUri);
-      return !string.IsNullOrEmpty(str) ? str + ":" + XmlConvert.DecodeName(node.LocalName) : XmlConvert.DecodeName(node.LocalName);
-    }
-
-    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager)
-    {
-      switch (node.NodeType)
-      {
-        case XmlNodeType.Element:
-          return node.NamespaceUri == "http://james.newtonking.com/projects/json" ? "$" + node.LocalName : this.ResolveFullName(node, manager);
-        case XmlNodeType.Attribute:
-          return node.NamespaceUri == "http://james.newtonking.com/projects/json" ? "$" + node.LocalName : "@" + this.ResolveFullName(node, manager);
-        case XmlNodeType.Text:
-          return "#text";
-        case XmlNodeType.CDATA:
-          return "#cdata-section";
-        case XmlNodeType.ProcessingInstruction:
-          return "?" + this.ResolveFullName(node, manager);
-        case XmlNodeType.Comment:
-          return "#comment";
-        case XmlNodeType.DocumentType:
-          return "!" + this.ResolveFullName(node, manager);
-        case XmlNodeType.Whitespace:
-          return "#whitespace";
-        case XmlNodeType.SignificantWhitespace:
-          return "#significant-whitespace";
-        case XmlNodeType.XmlDeclaration:
-          return "?xml";
-        default:
-          throw new JsonSerializationException("Unexpected XmlNodeType when getting node name: " + (object) node.NodeType);
-      }
-    }
-
-    private bool IsArray(IXmlNode node)
-    {
-      foreach (IXmlNode attribute in node.Attributes)
-      {
-        if (attribute.LocalName == "Array" && attribute.NamespaceUri == "http://james.newtonking.com/projects/json")
-          return XmlConvert.ToBoolean(attribute.Value);
-      }
-      return false;
-    }
-
-    private void SerializeGroupedNodes(
-      JsonWriter writer,
-      IXmlNode node,
-      XmlNamespaceManager manager,
-      bool writePropertyName)
-    {
-      switch (node.ChildNodes.Count)
-      {
-        case 0:
-          break;
-        case 1:
-          string propertyName1 = this.GetPropertyName(node.ChildNodes[0], manager);
-          this.WriteGroupedNodes(writer, manager, writePropertyName, node.ChildNodes, propertyName1);
-          break;
-        default:
-          Dictionary<string, object> dictionary = (Dictionary<string, object>) null;
-          string str = (string) null;
-          for (int index1 = 0; index1 < node.ChildNodes.Count; ++index1)
-          {
-            IXmlNode childNode = node.ChildNodes[index1];
-            string propertyName2 = this.GetPropertyName(childNode, manager);
-            if (dictionary == null)
-            {
-              if (str == null)
-                str = propertyName2;
-              else if (!(propertyName2 == str))
-              {
-                dictionary = new Dictionary<string, object>();
-                if (index1 > 1)
-                {
-                  List<IXmlNode> xmlNodeList = new List<IXmlNode>(index1);
-                  for (int index2 = 0; index2 < index1; ++index2)
-                    xmlNodeList.Add(node.ChildNodes[index2]);
-                  dictionary.Add(str, (object) xmlNodeList);
-                }
-                else
-                  dictionary.Add(str, (object) node.ChildNodes[0]);
-                dictionary.Add(propertyName2, (object) childNode);
-              }
-            }
-            else
-            {
-              object obj;
-              if (!dictionary.TryGetValue(propertyName2, out obj))
-              {
-                dictionary.Add(propertyName2, (object) childNode);
-              }
-              else
-              {
-                if (!(obj is List<IXmlNode> xmlNodeList))
-                {
-                  xmlNodeList = new List<IXmlNode>()
-                  {
-                    (IXmlNode) obj
-                  };
-                  dictionary[propertyName2] = (object) xmlNodeList;
-                }
-                xmlNodeList.Add(childNode);
-              }
-            }
-          }
-          if (dictionary == null)
-          {
-            this.WriteGroupedNodes(writer, manager, writePropertyName, node.ChildNodes, str);
-            break;
-          }
-          using (Dictionary<string, object>.Enumerator enumerator = dictionary.GetEnumerator())
-          {
-            while (enumerator.MoveNext())
-            {
-              KeyValuePair<string, object> current = enumerator.Current;
-              if (current.Value is List<IXmlNode> groupedNodes)
-                this.WriteGroupedNodes(writer, manager, writePropertyName, groupedNodes, current.Key);
-              else
-                this.WriteGroupedNodes(writer, manager, writePropertyName, (IXmlNode) current.Value, current.Key);
-            }
-            break;
-          }
-      }
-    }
-
-    private void WriteGroupedNodes(
-      JsonWriter writer,
-      XmlNamespaceManager manager,
-      bool writePropertyName,
-      List<IXmlNode> groupedNodes,
-      string elementNames)
-    {
-      if ((groupedNodes.Count != 1 ? 1 : (this.IsArray(groupedNodes[0]) ? 1 : 0)) == 0)
-      {
-        this.SerializeNode(writer, groupedNodes[0], manager, writePropertyName);
-      }
-      else
-      {
-        if (writePropertyName)
-          writer.WritePropertyName(elementNames);
-        writer.WriteStartArray();
-        for (int index = 0; index < groupedNodes.Count; ++index)
-          this.SerializeNode(writer, groupedNodes[index], manager, false);
-        writer.WriteEndArray();
-      }
-    }
-
-    private void WriteGroupedNodes(
-      JsonWriter writer,
-      XmlNamespaceManager manager,
-      bool writePropertyName,
-      IXmlNode node,
-      string elementNames)
-    {
-      if (!this.IsArray(node))
-      {
-        this.SerializeNode(writer, node, manager, writePropertyName);
-      }
-      else
-      {
-        if (writePropertyName)
-          writer.WritePropertyName(elementNames);
-        writer.WriteStartArray();
-        this.SerializeNode(writer, node, manager, false);
-        writer.WriteEndArray();
-      }
-    }
-
-    private void SerializeNode(
-      JsonWriter writer,
-      IXmlNode node,
-      XmlNamespaceManager manager,
-      bool writePropertyName)
-    {
-      switch (node.NodeType)
-      {
-        case XmlNodeType.Element:
-          if (this.IsArray(node) && XmlNodeConverter.AllSameName(node) && node.ChildNodes.Count > 0)
-          {
-            this.SerializeGroupedNodes(writer, node, manager, false);
-            break;
-          }
-          manager.PushScope();
-          foreach (IXmlNode attribute in node.Attributes)
-          {
-            if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/")
-            {
-              string prefix = attribute.LocalName != "xmlns" ? XmlConvert.DecodeName(attribute.LocalName) : string.Empty;
-              string uri = attribute.Value;
-              manager.AddNamespace(prefix, uri);
-            }
-          }
-          if (writePropertyName)
-            writer.WritePropertyName(this.GetPropertyName(node, manager));
-          if (!this.ValueAttributes(node.Attributes) && node.ChildNodes.Count == 1 && node.ChildNodes[0].NodeType == XmlNodeType.Text)
-            writer.WriteValue(node.ChildNodes[0].Value);
-          else if (node.ChildNodes.Count == 0 && node.Attributes.Count == 0)
-          {
-            if (((IXmlElement) node).IsEmpty)
-              writer.WriteNull();
-            else
-              writer.WriteValue(string.Empty);
-          }
-          else
-          {
-            writer.WriteStartObject();
-            for (int index = 0; index < node.Attributes.Count; ++index)
-              this.SerializeNode(writer, node.Attributes[index], manager, true);
-            this.SerializeGroupedNodes(writer, node, manager, true);
-            writer.WriteEndObject();
-          }
-          manager.PopScope();
-          break;
-        case XmlNodeType.Attribute:
-        case XmlNodeType.Text:
-        case XmlNodeType.CDATA:
-        case XmlNodeType.ProcessingInstruction:
-        case XmlNodeType.Whitespace:
-        case XmlNodeType.SignificantWhitespace:
-          if (node.NamespaceUri == "http://www.w3.org/2000/xmlns/" && node.Value == "http://james.newtonking.com/projects/json" || node.NamespaceUri == "http://james.newtonking.com/projects/json" && node.LocalName == "Array")
-            break;
-          if (writePropertyName)
-            writer.WritePropertyName(this.GetPropertyName(node, manager));
-          writer.WriteValue(node.Value);
-          break;
-        case XmlNodeType.Comment:
-          if (!writePropertyName)
-            break;
-          writer.WriteComment(node.Value);
-          break;
-        case XmlNodeType.Document:
-        case XmlNodeType.DocumentFragment:
-          this.SerializeGroupedNodes(writer, node, manager, writePropertyName);
-          break;
-        case XmlNodeType.DocumentType:
-          IXmlDocumentType xmlDocumentType = (IXmlDocumentType) node;
-          writer.WritePropertyName(this.GetPropertyName(node, manager));
-          writer.WriteStartObject();
-          if (!string.IsNullOrEmpty(xmlDocumentType.Name))
-          {
-            writer.WritePropertyName("@name");
-            writer.WriteValue(xmlDocumentType.Name);
-          }
-          if (!string.IsNullOrEmpty(xmlDocumentType.Public))
-          {
-            writer.WritePropertyName("@public");
-            writer.WriteValue(xmlDocumentType.Public);
-          }
-          if (!string.IsNullOrEmpty(xmlDocumentType.System))
-          {
-            writer.WritePropertyName("@system");
-            writer.WriteValue(xmlDocumentType.System);
-          }
-          if (!string.IsNullOrEmpty(xmlDocumentType.InternalSubset))
-          {
-            writer.WritePropertyName("@internalSubset");
-            writer.WriteValue(xmlDocumentType.InternalSubset);
-          }
-          writer.WriteEndObject();
-          break;
-        case XmlNodeType.XmlDeclaration:
-          IXmlDeclaration xmlDeclaration = (IXmlDeclaration) node;
-          writer.WritePropertyName(this.GetPropertyName(node, manager));
-          writer.WriteStartObject();
-          if (!string.IsNullOrEmpty(xmlDeclaration.Version))
-          {
-            writer.WritePropertyName("@version");
-            writer.WriteValue(xmlDeclaration.Version);
-          }
-          if (!string.IsNullOrEmpty(xmlDeclaration.Encoding))
-          {
-            writer.WritePropertyName("@encoding");
-            writer.WriteValue(xmlDeclaration.Encoding);
-          }
-          if (!string.IsNullOrEmpty(xmlDeclaration.Standalone))
-          {
-            writer.WritePropertyName("@standalone");
-            writer.WriteValue(xmlDeclaration.Standalone);
-          }
-          writer.WriteEndObject();
-          break;
-        default:
-          throw new JsonSerializationException("Unexpected XmlNodeType when serializing nodes: " + (object) node.NodeType);
-      }
-    }
-
-    private static bool AllSameName(IXmlNode node)
-    {
-      foreach (IXmlNode childNode in node.ChildNodes)
-      {
-        if (childNode.LocalName != node.LocalName)
-          return false;
-      }
-      return true;
-    }
-
-    public override object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      switch (reader.TokenType)
-      {
-        case JsonToken.StartObject:
-          XmlNamespaceManager manager = new XmlNamespaceManager((XmlNameTable) new NameTable());
-          IXmlDocument document = (IXmlDocument) null;
-          IXmlNode currentNode = (IXmlNode) null;
-          if (typeof (XObject).IsAssignableFrom(objectType))
-          {
-            if (objectType != typeof (XContainer) && objectType != typeof (XDocument) && objectType != typeof (XElement) && objectType != typeof (XNode) && objectType != typeof (XObject))
-              throw JsonSerializationException.Create(reader, "XmlNodeConverter only supports deserializing XDocument, XElement, XContainer, XNode or XObject.");
-            document = (IXmlDocument) new XDocumentWrapper(new XDocument());
-            currentNode = (IXmlNode) document;
-          }
-          if (typeof (XmlNode).IsAssignableFrom(objectType))
-          {
-            if (objectType != typeof (XmlDocument) && objectType != typeof (XmlElement) && objectType != typeof (XmlNode))
-              throw JsonSerializationException.Create(reader, "XmlNodeConverter only supports deserializing XmlDocument, XmlElement or XmlNode.");
-            document = (IXmlDocument) new XmlDocumentWrapper(new XmlDocument()
-            {
-              XmlResolver = (XmlResolver) null
-            });
-            currentNode = (IXmlNode) document;
-          }
-          if (document == null || currentNode == null)
-            throw JsonSerializationException.Create(reader, "Unexpected type when converting XML: " + (object) objectType);
-          if (!string.IsNullOrEmpty(this.DeserializeRootElementName))
-          {
-            this.ReadElement(reader, document, currentNode, this.DeserializeRootElementName, manager);
-          }
-          else
-          {
-            reader.ReadAndAssert();
-            this.DeserializeNode(reader, document, manager, currentNode);
-          }
-          if (objectType == typeof (XElement))
-          {
-            XElement wrappedNode = (XElement) document.DocumentElement.WrappedNode;
-            wrappedNode.Remove();
-            return (object) wrappedNode;
-          }
-          return objectType == typeof (XmlElement) ? document.DocumentElement.WrappedNode : document.WrappedNode;
-        case JsonToken.Null:
-          return (object) null;
-        default:
-          throw JsonSerializationException.Create(reader, "XmlNodeConverter can only convert JSON that begins with an object.");
-      }
-    }
-
-    private void DeserializeValue(
-      JsonReader reader,
-      IXmlDocument document,
-      XmlNamespaceManager manager,
-      string propertyName,
-      IXmlNode currentNode)
-    {
-      switch (propertyName)
-      {
-        case "#text":
-          currentNode.AppendChild(document.CreateTextNode(XmlNodeConverter.ConvertTokenToXmlValue(reader)));
-          break;
-        case "#cdata-section":
-          currentNode.AppendChild(document.CreateCDataSection(XmlNodeConverter.ConvertTokenToXmlValue(reader)));
-          break;
-        case "#whitespace":
-          currentNode.AppendChild(document.CreateWhitespace(XmlNodeConverter.ConvertTokenToXmlValue(reader)));
-          break;
-        case "#significant-whitespace":
-          currentNode.AppendChild(document.CreateSignificantWhitespace(XmlNodeConverter.ConvertTokenToXmlValue(reader)));
-          break;
-        default:
-          if (!string.IsNullOrEmpty(propertyName) && propertyName[0] == '?')
-          {
-            this.CreateInstruction(reader, document, currentNode, propertyName);
-            break;
-          }
-          if (string.Equals(propertyName, "!DOCTYPE", StringComparison.OrdinalIgnoreCase))
-          {
-            this.CreateDocumentType(reader, document, currentNode);
-            break;
-          }
-          if (reader.TokenType == JsonToken.StartArray)
-          {
-            this.ReadArrayElements(reader, document, propertyName, currentNode, manager);
-            break;
-          }
-          this.ReadElement(reader, document, currentNode, propertyName, manager);
-          break;
-      }
-    }
-
-    private void ReadElement(
-      JsonReader reader,
-      IXmlDocument document,
-      IXmlNode currentNode,
-      string propertyName,
-      XmlNamespaceManager manager)
-    {
-      if (string.IsNullOrEmpty(propertyName))
-        throw JsonSerializationException.Create(reader, "XmlNodeConverter cannot convert JSON with an empty property name to XML.");
-      Dictionary<string, string> attributeNameValues = this.ReadAttributeElements(reader, manager);
-      string prefix1 = MiscellaneousUtils.GetPrefix(propertyName);
-      if (propertyName.StartsWith('@'))
-      {
-        string str = propertyName.Substring(1);
-        string prefix2 = MiscellaneousUtils.GetPrefix(str);
-        XmlNodeConverter.AddAttribute(reader, document, currentNode, propertyName, str, manager, prefix2);
-      }
-      else
-      {
-        if (propertyName.StartsWith('$'))
-        {
-          switch (propertyName)
-          {
-            case "$values":
-              propertyName = propertyName.Substring(1);
-              string elementPrefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
-              this.CreateElement(reader, document, currentNode, propertyName, manager, elementPrefix, attributeNameValues);
-              return;
-            case "$id":
-            case "$ref":
-            case "$type":
-            case "$value":
-              string attributeName = propertyName.Substring(1);
-              string attributePrefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
-              XmlNodeConverter.AddAttribute(reader, document, currentNode, propertyName, attributeName, manager, attributePrefix);
-              return;
-          }
-        }
-        this.CreateElement(reader, document, currentNode, propertyName, manager, prefix1, attributeNameValues);
-      }
-    }
-
-    private void CreateElement(
-      JsonReader reader,
-      IXmlDocument document,
-      IXmlNode currentNode,
-      string elementName,
-      XmlNamespaceManager manager,
-      string elementPrefix,
-      Dictionary<string, string> attributeNameValues)
-    {
-      IXmlElement element = this.CreateElement(elementName, document, elementPrefix, manager);
-      currentNode.AppendChild((IXmlNode) element);
-      if (attributeNameValues != null)
-      {
-        foreach (KeyValuePair<string, string> attributeNameValue in attributeNameValues)
-        {
-          string str = XmlConvert.EncodeName(attributeNameValue.Key);
-          string prefix = MiscellaneousUtils.GetPrefix(attributeNameValue.Key);
-          IXmlNode attribute = !string.IsNullOrEmpty(prefix) ? document.CreateAttribute(str, manager.LookupNamespace(prefix) ?? string.Empty, attributeNameValue.Value) : document.CreateAttribute(str, attributeNameValue.Value);
-          element.SetAttributeNode(attribute);
-        }
-      }
-      switch (reader.TokenType)
-      {
-        case JsonToken.Integer:
-        case JsonToken.Float:
-        case JsonToken.String:
-        case JsonToken.Boolean:
-        case JsonToken.Date:
-        case JsonToken.Bytes:
-          string xmlValue = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-          if (xmlValue == null)
-            break;
-          element.AppendChild(document.CreateTextNode(xmlValue));
-          break;
-        case JsonToken.Null:
-          break;
-        case JsonToken.EndObject:
-          manager.RemoveNamespace(string.Empty, manager.DefaultNamespace);
-          break;
-        default:
-          manager.PushScope();
-          this.DeserializeNode(reader, document, manager, (IXmlNode) element);
-          manager.PopScope();
-          manager.RemoveNamespace(string.Empty, manager.DefaultNamespace);
-          break;
-      }
-    }
-
-    private static void AddAttribute(
-      JsonReader reader,
-      IXmlDocument document,
-      IXmlNode currentNode,
-      string propertyName,
-      string attributeName,
-      XmlNamespaceManager manager,
-      string attributePrefix)
-    {
-      if (currentNode.NodeType == XmlNodeType.Document)
-        throw JsonSerializationException.Create(reader, "JSON root object has property '{0}' that will be converted to an attribute. A root object cannot have any attribute properties. Consider specifying a DeserializeRootElementName.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) propertyName));
-      string str = XmlConvert.EncodeName(attributeName);
-      string xmlValue = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-      IXmlNode attribute = !string.IsNullOrEmpty(attributePrefix) ? document.CreateAttribute(str, manager.LookupNamespace(attributePrefix), xmlValue) : document.CreateAttribute(str, xmlValue);
-      ((IXmlElement) currentNode).SetAttributeNode(attribute);
-    }
-
-    private static string ConvertTokenToXmlValue(JsonReader reader)
-    {
-      switch (reader.TokenType)
-      {
-        case JsonToken.Integer:
-          return XmlConvert.ToString(Convert.ToInt64(reader.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-        case JsonToken.Float:
-          if (reader.Value is Decimal num)
-            return XmlConvert.ToString(num);
-          object obj;
-          return (obj = reader.Value) is float ? XmlConvert.ToString((float) obj) : XmlConvert.ToString(Convert.ToDouble(reader.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-        case JsonToken.String:
-          return reader.Value?.ToString();
-        case JsonToken.Boolean:
-          return XmlConvert.ToString(Convert.ToBoolean(reader.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-        case JsonToken.Null:
-          return (string) null;
-        case JsonToken.Date:
-          if (reader.Value is DateTimeOffset dateTimeOffset)
-            return XmlConvert.ToString(dateTimeOffset);
-          DateTime dateTime = Convert.ToDateTime(reader.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-          return XmlConvert.ToString(dateTime, DateTimeUtils.ToSerializationMode(dateTime.Kind));
-        case JsonToken.Bytes:
-          return Convert.ToBase64String((byte[]) reader.Value);
-        default:
-          throw JsonSerializationException.Create(reader, "Cannot get an XML string value from token type '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      }
-    }
-
-    private void ReadArrayElements(
-      JsonReader reader,
-      IXmlDocument document,
-      string propertyName,
-      IXmlNode currentNode,
-      XmlNamespaceManager manager)
-    {
-      string prefix = MiscellaneousUtils.GetPrefix(propertyName);
-      IXmlElement element1 = this.CreateElement(propertyName, document, prefix, manager);
-      currentNode.AppendChild((IXmlNode) element1);
-      int num = 0;
-      while (reader.Read() && reader.TokenType != JsonToken.EndArray)
-      {
-        this.DeserializeValue(reader, document, manager, propertyName, (IXmlNode) element1);
-        ++num;
-      }
-      if (this.WriteArrayAttribute)
-        this.AddJsonArrayAttribute(element1, document);
-      if (num != 1 || !this.WriteArrayAttribute)
-        return;
-      foreach (IXmlNode childNode in element1.ChildNodes)
-      {
-        if (childNode is IXmlElement element2 && element2.LocalName == propertyName)
-        {
-          this.AddJsonArrayAttribute(element2, document);
-          break;
-        }
-      }
-    }
-
-    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document)
-    {
-      element.SetAttributeNode(document.CreateAttribute("json:Array", "http://james.newtonking.com/projects/json", "true"));
-      if (!(element is XElementWrapper) || element.GetPrefixOfNamespace("http://james.newtonking.com/projects/json") != null)
-        return;
-      element.SetAttributeNode(document.CreateAttribute("xmlns:json", "http://www.w3.org/2000/xmlns/", "http://james.newtonking.com/projects/json"));
-    }
-
-    private Dictionary<string, string> ReadAttributeElements(
-      JsonReader reader,
-      XmlNamespaceManager manager)
-    {
-      switch (reader.TokenType)
-      {
-        case JsonToken.StartConstructor:
-        case JsonToken.Integer:
-        case JsonToken.Float:
-        case JsonToken.String:
-        case JsonToken.Boolean:
-        case JsonToken.Null:
-        case JsonToken.Date:
-        case JsonToken.Bytes:
-          return (Dictionary<string, string>) null;
-        default:
-          Dictionary<string, string> dictionary = (Dictionary<string, string>) null;
-          bool flag = false;
-          while (!flag && reader.Read())
-          {
-            switch (reader.TokenType)
-            {
-              case JsonToken.PropertyName:
-                string str1 = reader.Value.ToString();
-                if (!string.IsNullOrEmpty(str1))
-                {
-                  switch (str1[0])
-                  {
-                    case '$':
-                      if (str1 == "$values" || str1 == "$id" || str1 == "$ref" || str1 == "$type" || str1 == "$value")
-                      {
-                        string prefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
-                        if (prefix == null)
-                        {
-                          if (dictionary == null)
-                            dictionary = new Dictionary<string, string>();
-                          int? nullable = new int?();
-                          while (manager.LookupNamespace("json" + (object) nullable) != null)
-                            nullable = new int?(nullable.GetValueOrDefault() + 1);
-                          prefix = "json" + (object) nullable;
-                          dictionary.Add("xmlns:" + prefix, "http://james.newtonking.com/projects/json");
-                          manager.AddNamespace(prefix, "http://james.newtonking.com/projects/json");
-                        }
-                        if (str1 == "$values")
-                        {
-                          flag = true;
-                          continue;
-                        }
-                        string str2 = str1.Substring(1);
-                        reader.ReadAndAssert();
-                        if (!JsonTokenUtils.IsPrimitiveToken(reader.TokenType))
-                          throw JsonSerializationException.Create(reader, "Unexpected JsonToken: " + (object) reader.TokenType);
-                        if (dictionary == null)
-                          dictionary = new Dictionary<string, string>();
-                        string str3 = reader.Value?.ToString();
-                        dictionary.Add(prefix + ":" + str2, str3);
-                        continue;
-                      }
-                      flag = true;
-                      continue;
-                    case '@':
-                      if (dictionary == null)
-                        dictionary = new Dictionary<string, string>();
-                      string str4 = str1.Substring(1);
-                      reader.ReadAndAssert();
-                      string xmlValue = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-                      dictionary.Add(str4, xmlValue);
-                      string prefix1;
-                      if (this.IsNamespaceAttribute(str4, out prefix1))
-                      {
-                        manager.AddNamespace(prefix1, xmlValue);
-                        continue;
-                      }
-                      continue;
-                    default:
-                      flag = true;
-                      continue;
-                  }
-                }
-                else
-                {
-                  flag = true;
-                  continue;
-                }
-              case JsonToken.Comment:
-              case JsonToken.EndObject:
-                flag = true;
-                continue;
-              default:
-                throw JsonSerializationException.Create(reader, "Unexpected JsonToken: " + (object) reader.TokenType);
-            }
-          }
-          return dictionary;
-      }
-    }
-
-    private void CreateInstruction(
-      JsonReader reader,
-      IXmlDocument document,
-      IXmlNode currentNode,
-      string propertyName)
-    {
-      if (propertyName == "?xml")
-      {
-        string version = (string) null;
-        string encoding = (string) null;
-        string standalone = (string) null;
-        while (reader.Read() && reader.TokenType != JsonToken.EndObject)
-        {
-          switch (reader.Value.ToString())
-          {
-            case "@version":
-              reader.ReadAndAssert();
-              version = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-              continue;
-            case "@encoding":
-              reader.ReadAndAssert();
-              encoding = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-              continue;
-            case "@standalone":
-              reader.ReadAndAssert();
-              standalone = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-              continue;
-            default:
-              throw JsonSerializationException.Create(reader, "Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
-          }
-        }
-        IXmlNode xmlDeclaration = document.CreateXmlDeclaration(version, encoding, standalone);
-        currentNode.AppendChild(xmlDeclaration);
-      }
-      else
-      {
-        IXmlNode processingInstruction = document.CreateProcessingInstruction(propertyName.Substring(1), XmlNodeConverter.ConvertTokenToXmlValue(reader));
-        currentNode.AppendChild(processingInstruction);
-      }
-    }
-
-    private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode)
-    {
-      string name = (string) null;
-      string publicId = (string) null;
-      string systemId = (string) null;
-      string internalSubset = (string) null;
-      while (reader.Read() && reader.TokenType != JsonToken.EndObject)
-      {
-        switch (reader.Value.ToString())
-        {
-          case "@name":
-            reader.ReadAndAssert();
-            name = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-            continue;
-          case "@public":
-            reader.ReadAndAssert();
-            publicId = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-            continue;
-          case "@system":
-            reader.ReadAndAssert();
-            systemId = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-            continue;
-          case "@internalSubset":
-            reader.ReadAndAssert();
-            internalSubset = XmlNodeConverter.ConvertTokenToXmlValue(reader);
-            continue;
-          default:
-            throw JsonSerializationException.Create(reader, "Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
-        }
-      }
-      IXmlNode xmlDocumentType = document.CreateXmlDocumentType(name, publicId, systemId, internalSubset);
-      currentNode.AppendChild(xmlDocumentType);
-    }
-
-    private IXmlElement CreateElement(
-      string elementName,
-      IXmlDocument document,
-      string elementPrefix,
-      XmlNamespaceManager manager)
-    {
-      string str = XmlConvert.EncodeName(elementName);
-      string namespaceUri = string.IsNullOrEmpty(elementPrefix) ? manager.DefaultNamespace : manager.LookupNamespace(elementPrefix);
-      return string.IsNullOrEmpty(namespaceUri) ? document.CreateElement(str) : document.CreateElement(str, namespaceUri);
-    }
-
-    private void DeserializeNode(
-      JsonReader reader,
-      IXmlDocument document,
-      XmlNamespaceManager manager,
-      IXmlNode currentNode)
-    {
-      do
-      {
-        switch (reader.TokenType)
-        {
-          case JsonToken.StartConstructor:
-            string propertyName1 = reader.Value.ToString();
-            while (reader.Read() && reader.TokenType != JsonToken.EndConstructor)
-              this.DeserializeValue(reader, document, manager, propertyName1, currentNode);
-            break;
-          case JsonToken.PropertyName:
-            if (currentNode.NodeType == XmlNodeType.Document && document.DocumentElement != null)
-              throw JsonSerializationException.Create(reader, "JSON root object has multiple properties. The root object must have a single property in order to create a valid XML document. Consider specifying a DeserializeRootElementName.");
-            string propertyName2 = reader.Value.ToString();
-            reader.ReadAndAssert();
-            if (reader.TokenType == JsonToken.StartArray)
-            {
-              int num = 0;
-              while (reader.Read() && reader.TokenType != JsonToken.EndArray)
-              {
-                this.DeserializeValue(reader, document, manager, propertyName2, currentNode);
-                ++num;
-              }
-              if (num == 1 && this.WriteArrayAttribute)
-              {
-                using (List<IXmlNode>.Enumerator enumerator = currentNode.ChildNodes.GetEnumerator())
-                {
-                  while (enumerator.MoveNext())
-                  {
-                    if (enumerator.Current is IXmlElement current && current.LocalName == propertyName2)
-                    {
-                      this.AddJsonArrayAttribute(current, document);
-                      break;
-                    }
-                  }
-                  break;
-                }
-              }
-              else
-                break;
-            }
-            else
-            {
-              this.DeserializeValue(reader, document, manager, propertyName2, currentNode);
-              break;
-            }
-          case JsonToken.Comment:
-            currentNode.AppendChild(document.CreateComment((string) reader.Value));
-            break;
-          case JsonToken.EndObject:
-          case JsonToken.EndArray:
-            return;
-          default:
-            throw JsonSerializationException.Create(reader, "Unexpected JsonToken when deserializing node: " + (object) reader.TokenType);
-        }
-      }
-      while (reader.Read());
-    }
-
-    private bool IsNamespaceAttribute(string attributeName, out string prefix)
-    {
-      if (attributeName.StartsWith("xmlns", StringComparison.Ordinal))
-      {
-        if (attributeName.Length == 5)
-        {
-          prefix = string.Empty;
-          return true;
-        }
-        if (attributeName[5] == ':')
-        {
-          prefix = attributeName.Substring(6, attributeName.Length - 6);
-          return true;
-        }
-      }
-      prefix = (string) null;
-      return false;
-    }
-
-    private bool ValueAttributes(List<IXmlNode> c)
-    {
-      foreach (IXmlNode xmlNode in c)
-      {
-        if (!(xmlNode.NamespaceUri == "http://james.newtonking.com/projects/json") && (!(xmlNode.NamespaceUri == "http://www.w3.org/2000/xmlns/") || !(xmlNode.Value == "http://james.newtonking.com/projects/json")))
-          return true;
-      }
-      return false;
-    }
-
-    public override bool CanConvert(Type valueType)
-    {
-      if (valueType.AssignableToTypeName("System.Xml.Linq.XObject", false))
-        return this.IsXObject(valueType);
-      return valueType.AssignableToTypeName("System.Xml.XmlNode", false) && this.IsXmlNode(valueType);
-    }
-
-    [MethodImpl(MethodImplOptions.NoInlining)]
-    private bool IsXObject(Type valueType) => typeof (XObject).IsAssignableFrom(valueType);
-
-    [MethodImpl(MethodImplOptions.NoInlining)]
-    private bool IsXmlNode(Type valueType) => typeof (XmlNode).IsAssignableFrom(valueType);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Converters/XmlNodeWrapper.cs b/MSHALTester/Newtonsoft/Json/Converters/XmlNodeWrapper.cs
deleted file mode 100644
index 3b91156..0000000
--- a/MSHALTester/Newtonsoft/Json/Converters/XmlNodeWrapper.cs
+++ /dev/null
@@ -1,116 +0,0 @@
-using System.Collections.Generic;
-using System.Xml;
-
-#nullable disable
-namespace Newtonsoft.Json.Converters
-{
-  internal class XmlNodeWrapper : IXmlNode
-  {
-    private readonly XmlNode _node;
-    private List<IXmlNode> _childNodes;
-    private List<IXmlNode> _attributes;
-
-    public XmlNodeWrapper(XmlNode node) => this._node = node;
-
-    public object WrappedNode => (object) this._node;
-
-    public XmlNodeType NodeType => this._node.NodeType;
-
-    public virtual string LocalName => this._node.LocalName;
-
-    public List<IXmlNode> ChildNodes
-    {
-      get
-      {
-        if (this._childNodes == null)
-        {
-          if (!this._node.HasChildNodes)
-          {
-            this._childNodes = XmlNodeConverter.EmptyChildNodes;
-          }
-          else
-          {
-            this._childNodes = new List<IXmlNode>(this._node.ChildNodes.Count);
-            foreach (XmlNode childNode in this._node.ChildNodes)
-              this._childNodes.Add(XmlNodeWrapper.WrapNode(childNode));
-          }
-        }
-        return this._childNodes;
-      }
-    }
-
-    protected virtual bool HasChildNodes => this._node.HasChildNodes;
-
-    internal static IXmlNode WrapNode(XmlNode node)
-    {
-      switch (node.NodeType)
-      {
-        case XmlNodeType.Element:
-          return (IXmlNode) new XmlElementWrapper((XmlElement) node);
-        case XmlNodeType.DocumentType:
-          return (IXmlNode) new XmlDocumentTypeWrapper((XmlDocumentType) node);
-        case XmlNodeType.XmlDeclaration:
-          return (IXmlNode) new XmlDeclarationWrapper((XmlDeclaration) node);
-        default:
-          return (IXmlNode) new XmlNodeWrapper(node);
-      }
-    }
-
-    public List<IXmlNode> Attributes
-    {
-      get
-      {
-        if (this._attributes == null)
-        {
-          if (!this.HasAttributes)
-          {
-            this._attributes = XmlNodeConverter.EmptyChildNodes;
-          }
-          else
-          {
-            this._attributes = new List<IXmlNode>(this._node.Attributes.Count);
-            foreach (XmlNode attribute in (XmlNamedNodeMap) this._node.Attributes)
-              this._attributes.Add(XmlNodeWrapper.WrapNode(attribute));
-          }
-        }
-        return this._attributes;
-      }
-    }
-
-    private bool HasAttributes
-    {
-      get
-      {
-        if (this._node is XmlElement node)
-          return node.HasAttributes;
-        XmlAttributeCollection attributes = this._node.Attributes;
-        return attributes != null && attributes.Count > 0;
-      }
-    }
-
-    public IXmlNode ParentNode
-    {
-      get
-      {
-        XmlNode node1 = this._node is XmlAttribute node2 ? (XmlNode) node2.OwnerElement : this._node.ParentNode;
-        return node1 == null ? (IXmlNode) null : XmlNodeWrapper.WrapNode(node1);
-      }
-    }
-
-    public string Value
-    {
-      get => this._node.Value;
-      set => this._node.Value = value;
-    }
-
-    public IXmlNode AppendChild(IXmlNode newChild)
-    {
-      this._node.AppendChild(((XmlNodeWrapper) newChild)._node);
-      this._childNodes = (List<IXmlNode>) null;
-      this._attributes = (List<IXmlNode>) null;
-      return newChild;
-    }
-
-    public string NamespaceUri => this._node.NamespaceURI;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/DateFormatHandling.cs b/MSHALTester/Newtonsoft/Json/DateFormatHandling.cs
deleted file mode 100644
index 911cf07..0000000
--- a/MSHALTester/Newtonsoft/Json/DateFormatHandling.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum DateFormatHandling
-  {
-    IsoDateFormat,
-    MicrosoftDateFormat,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/DateParseHandling.cs b/MSHALTester/Newtonsoft/Json/DateParseHandling.cs
deleted file mode 100644
index 2f7f430..0000000
--- a/MSHALTester/Newtonsoft/Json/DateParseHandling.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum DateParseHandling
-  {
-    None,
-    DateTime,
-    DateTimeOffset,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/DateTimeZoneHandling.cs b/MSHALTester/Newtonsoft/Json/DateTimeZoneHandling.cs
deleted file mode 100644
index cdbd57b..0000000
--- a/MSHALTester/Newtonsoft/Json/DateTimeZoneHandling.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum DateTimeZoneHandling
-  {
-    Local,
-    Utc,
-    Unspecified,
-    RoundtripKind,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/DefaultValueHandling.cs b/MSHALTester/Newtonsoft/Json/DefaultValueHandling.cs
deleted file mode 100644
index 82b0a69..0000000
--- a/MSHALTester/Newtonsoft/Json/DefaultValueHandling.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [Flags]
-  public enum DefaultValueHandling
-  {
-    Include = 0,
-    Ignore = 1,
-    Populate = 2,
-    IgnoreAndPopulate = Populate | Ignore, // 0x00000003
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/FloatFormatHandling.cs b/MSHALTester/Newtonsoft/Json/FloatFormatHandling.cs
deleted file mode 100644
index 95b46a5..0000000
--- a/MSHALTester/Newtonsoft/Json/FloatFormatHandling.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum FloatFormatHandling
-  {
-    String,
-    Symbol,
-    DefaultValue,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/FloatParseHandling.cs b/MSHALTester/Newtonsoft/Json/FloatParseHandling.cs
deleted file mode 100644
index 1d9288d..0000000
--- a/MSHALTester/Newtonsoft/Json/FloatParseHandling.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum FloatParseHandling
-  {
-    Double,
-    Decimal,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Formatting.cs b/MSHALTester/Newtonsoft/Json/Formatting.cs
deleted file mode 100644
index 39feac4..0000000
--- a/MSHALTester/Newtonsoft/Json/Formatting.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum Formatting
-  {
-    None,
-    Indented,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/IArrayPool`1.cs b/MSHALTester/Newtonsoft/Json/IArrayPool`1.cs
deleted file mode 100644
index 676b4d2..0000000
--- a/MSHALTester/Newtonsoft/Json/IArrayPool`1.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public interface IArrayPool<T>
-  {
-    T[] Rent(int minimumLength);
-
-    void Return(T[] array);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/IJsonLineInfo.cs b/MSHALTester/Newtonsoft/Json/IJsonLineInfo.cs
deleted file mode 100644
index 7dad3a6..0000000
--- a/MSHALTester/Newtonsoft/Json/IJsonLineInfo.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public interface IJsonLineInfo
-  {
-    bool HasLineInfo();
-
-    int LineNumber { get; }
-
-    int LinePosition { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonArrayAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonArrayAttribute.cs
deleted file mode 100644
index b386f42..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonArrayAttribute.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
-  public sealed class JsonArrayAttribute : JsonContainerAttribute
-  {
-    private bool _allowNullItems;
-
-    public bool AllowNullItems
-    {
-      get => this._allowNullItems;
-      set => this._allowNullItems = value;
-    }
-
-    public JsonArrayAttribute()
-    {
-    }
-
-    public JsonArrayAttribute(bool allowNullItems) => this._allowNullItems = allowNullItems;
-
-    public JsonArrayAttribute(string id)
-      : base(id)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonConstructorAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonConstructorAttribute.cs
deleted file mode 100644
index b6880db..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonConstructorAttribute.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
-  public sealed class JsonConstructorAttribute : Attribute
-  {
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonContainerAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonContainerAttribute.cs
deleted file mode 100644
index 987cf8e..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonContainerAttribute.cs
+++ /dev/null
@@ -1,79 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
-  public abstract class JsonContainerAttribute : Attribute
-  {
-    internal bool? _isReference;
-    internal bool? _itemIsReference;
-    internal ReferenceLoopHandling? _itemReferenceLoopHandling;
-    internal TypeNameHandling? _itemTypeNameHandling;
-    private Type _namingStrategyType;
-    private object[] _namingStrategyParameters;
-
-    public string Id { get; set; }
-
-    public string Title { get; set; }
-
-    public string Description { get; set; }
-
-    public Type ItemConverterType { get; set; }
-
-    public object[] ItemConverterParameters { get; set; }
-
-    public Type NamingStrategyType
-    {
-      get => this._namingStrategyType;
-      set
-      {
-        this._namingStrategyType = value;
-        this.NamingStrategyInstance = (NamingStrategy) null;
-      }
-    }
-
-    public object[] NamingStrategyParameters
-    {
-      get => this._namingStrategyParameters;
-      set
-      {
-        this._namingStrategyParameters = value;
-        this.NamingStrategyInstance = (NamingStrategy) null;
-      }
-    }
-
-    internal NamingStrategy NamingStrategyInstance { get; set; }
-
-    public bool IsReference
-    {
-      get => this._isReference ?? false;
-      set => this._isReference = new bool?(value);
-    }
-
-    public bool ItemIsReference
-    {
-      get => this._itemIsReference ?? false;
-      set => this._itemIsReference = new bool?(value);
-    }
-
-    public ReferenceLoopHandling ItemReferenceLoopHandling
-    {
-      get => this._itemReferenceLoopHandling ?? ReferenceLoopHandling.Error;
-      set => this._itemReferenceLoopHandling = new ReferenceLoopHandling?(value);
-    }
-
-    public TypeNameHandling ItemTypeNameHandling
-    {
-      get => this._itemTypeNameHandling ?? TypeNameHandling.None;
-      set => this._itemTypeNameHandling = new TypeNameHandling?(value);
-    }
-
-    protected JsonContainerAttribute()
-    {
-    }
-
-    protected JsonContainerAttribute(string id) => this.Id = id;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonContainerType.cs b/MSHALTester/Newtonsoft/Json/JsonContainerType.cs
deleted file mode 100644
index 042f6e2..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonContainerType.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  internal enum JsonContainerType
-  {
-    None,
-    Object,
-    Array,
-    Constructor,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonConvert.cs b/MSHALTester/Newtonsoft/Json/JsonConvert.cs
deleted file mode 100644
index b46a1d0..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonConvert.cs
+++ /dev/null
@@ -1,524 +0,0 @@
-using Newtonsoft.Json.Converters;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Text;
-using System.Xml;
-using System.Xml.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public static class JsonConvert
-  {
-    public static readonly string True = "true";
-    public static readonly string False = "false";
-    public static readonly string Null = "null";
-    public static readonly string Undefined = "undefined";
-    public static readonly string PositiveInfinity = "Infinity";
-    public static readonly string NegativeInfinity = "-Infinity";
-    public static readonly string NaN = nameof (NaN);
-
-    public static Func<JsonSerializerSettings> DefaultSettings { get; set; }
-
-    public static string ToString(DateTime value)
-    {
-      return JsonConvert.ToString(value, DateFormatHandling.IsoDateFormat, DateTimeZoneHandling.RoundtripKind);
-    }
-
-    public static string ToString(
-      DateTime value,
-      DateFormatHandling format,
-      DateTimeZoneHandling timeZoneHandling)
-    {
-      DateTime dateTime = DateTimeUtils.EnsureDateTime(value, timeZoneHandling);
-      using (StringWriter stringWriter = StringUtils.CreateStringWriter(64))
-      {
-        stringWriter.Write('"');
-        DateTimeUtils.WriteDateTimeString((TextWriter) stringWriter, dateTime, format, (string) null, CultureInfo.InvariantCulture);
-        stringWriter.Write('"');
-        return stringWriter.ToString();
-      }
-    }
-
-    public static string ToString(DateTimeOffset value)
-    {
-      return JsonConvert.ToString(value, DateFormatHandling.IsoDateFormat);
-    }
-
-    public static string ToString(DateTimeOffset value, DateFormatHandling format)
-    {
-      using (StringWriter stringWriter = StringUtils.CreateStringWriter(64))
-      {
-        stringWriter.Write('"');
-        DateTimeUtils.WriteDateTimeOffsetString((TextWriter) stringWriter, value, format, (string) null, CultureInfo.InvariantCulture);
-        stringWriter.Write('"');
-        return stringWriter.ToString();
-      }
-    }
-
-    public static string ToString(bool value) => !value ? JsonConvert.False : JsonConvert.True;
-
-    public static string ToString(char value) => JsonConvert.ToString(char.ToString(value));
-
-    public static string ToString(Enum value) => value.ToString("D");
-
-    public static string ToString(int value)
-    {
-      return value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static string ToString(short value)
-    {
-      return value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static string ToString(ushort value)
-    {
-      return value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static string ToString(uint value)
-    {
-      return value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static string ToString(long value)
-    {
-      return value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static string ToString(ulong value)
-    {
-      return value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static string ToString(float value)
-    {
-      return JsonConvert.EnsureDecimalPlace((double) value, value.ToString("R", (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    internal static string ToString(
-      float value,
-      FloatFormatHandling floatFormatHandling,
-      char quoteChar,
-      bool nullable)
-    {
-      return JsonConvert.EnsureFloatFormat((double) value, JsonConvert.EnsureDecimalPlace((double) value, value.ToString("R", (IFormatProvider) CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
-    }
-
-    private static string EnsureFloatFormat(
-      double value,
-      string text,
-      FloatFormatHandling floatFormatHandling,
-      char quoteChar,
-      bool nullable)
-    {
-      if (floatFormatHandling == FloatFormatHandling.Symbol || !double.IsInfinity(value) && !double.IsNaN(value))
-        return text;
-      if (floatFormatHandling != FloatFormatHandling.DefaultValue)
-        return quoteChar.ToString() + text + quoteChar.ToString();
-      return nullable ? JsonConvert.Null : "0.0";
-    }
-
-    public static string ToString(double value)
-    {
-      return JsonConvert.EnsureDecimalPlace(value, value.ToString("R", (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    internal static string ToString(
-      double value,
-      FloatFormatHandling floatFormatHandling,
-      char quoteChar,
-      bool nullable)
-    {
-      return JsonConvert.EnsureFloatFormat(value, JsonConvert.EnsureDecimalPlace(value, value.ToString("R", (IFormatProvider) CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
-    }
-
-    private static string EnsureDecimalPlace(double value, string text)
-    {
-      return double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1 || text.IndexOf('e') != -1 ? text : text + ".0";
-    }
-
-    private static string EnsureDecimalPlace(string text)
-    {
-      return text.IndexOf('.') != -1 ? text : text + ".0";
-    }
-
-    public static string ToString(byte value)
-    {
-      return value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static string ToString(sbyte value)
-    {
-      return value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static string ToString(Decimal value)
-    {
-      return JsonConvert.EnsureDecimalPlace(value.ToString((string) null, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static string ToString(Guid value) => JsonConvert.ToString(value, '"');
-
-    internal static string ToString(Guid value, char quoteChar)
-    {
-      string str1 = value.ToString("D", (IFormatProvider) CultureInfo.InvariantCulture);
-      string str2 = quoteChar.ToString((IFormatProvider) CultureInfo.InvariantCulture);
-      return str2 + str1 + str2;
-    }
-
-    public static string ToString(TimeSpan value) => JsonConvert.ToString(value, '"');
-
-    internal static string ToString(TimeSpan value, char quoteChar)
-    {
-      return JsonConvert.ToString(value.ToString(), quoteChar);
-    }
-
-    public static string ToString(Uri value)
-    {
-      return value == (Uri) null ? JsonConvert.Null : JsonConvert.ToString(value, '"');
-    }
-
-    internal static string ToString(Uri value, char quoteChar)
-    {
-      return JsonConvert.ToString(value.OriginalString, quoteChar);
-    }
-
-    public static string ToString(string value) => JsonConvert.ToString(value, '"');
-
-    public static string ToString(string value, char delimiter)
-    {
-      return JsonConvert.ToString(value, delimiter, StringEscapeHandling.Default);
-    }
-
-    public static string ToString(
-      string value,
-      char delimiter,
-      StringEscapeHandling stringEscapeHandling)
-    {
-      if (delimiter != '"' && delimiter != '\'')
-        throw new ArgumentException("Delimiter must be a single or double quote.", nameof (delimiter));
-      return JavaScriptUtils.ToEscapedJavaScriptString(value, delimiter, true, stringEscapeHandling);
-    }
-
-    public static string ToString(object value)
-    {
-      if (value == null)
-        return JsonConvert.Null;
-      switch (ConvertUtils.GetTypeCode(value.GetType()))
-      {
-        case PrimitiveTypeCode.Char:
-          return JsonConvert.ToString((char) value);
-        case PrimitiveTypeCode.Boolean:
-          return JsonConvert.ToString((bool) value);
-        case PrimitiveTypeCode.SByte:
-          return JsonConvert.ToString((sbyte) value);
-        case PrimitiveTypeCode.Int16:
-          return JsonConvert.ToString((short) value);
-        case PrimitiveTypeCode.UInt16:
-          return JsonConvert.ToString((ushort) value);
-        case PrimitiveTypeCode.Int32:
-          return JsonConvert.ToString((int) value);
-        case PrimitiveTypeCode.Byte:
-          return JsonConvert.ToString((byte) value);
-        case PrimitiveTypeCode.UInt32:
-          return JsonConvert.ToString((uint) value);
-        case PrimitiveTypeCode.Int64:
-          return JsonConvert.ToString((long) value);
-        case PrimitiveTypeCode.UInt64:
-          return JsonConvert.ToString((ulong) value);
-        case PrimitiveTypeCode.Single:
-          return JsonConvert.ToString((float) value);
-        case PrimitiveTypeCode.Double:
-          return JsonConvert.ToString((double) value);
-        case PrimitiveTypeCode.DateTime:
-          return JsonConvert.ToString((DateTime) value);
-        case PrimitiveTypeCode.DateTimeOffset:
-          return JsonConvert.ToString((DateTimeOffset) value);
-        case PrimitiveTypeCode.Decimal:
-          return JsonConvert.ToString((Decimal) value);
-        case PrimitiveTypeCode.Guid:
-          return JsonConvert.ToString((Guid) value);
-        case PrimitiveTypeCode.TimeSpan:
-          return JsonConvert.ToString((TimeSpan) value);
-        case PrimitiveTypeCode.Uri:
-          return JsonConvert.ToString((Uri) value);
-        case PrimitiveTypeCode.String:
-          return JsonConvert.ToString((string) value);
-        case PrimitiveTypeCode.DBNull:
-          return JsonConvert.Null;
-        default:
-          throw new ArgumentException("Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType()));
-      }
-    }
-
-    public static string SerializeObject(object value)
-    {
-      return JsonConvert.SerializeObject(value, (Type) null, (JsonSerializerSettings) null);
-    }
-
-    public static string SerializeObject(object value, Formatting formatting)
-    {
-      return JsonConvert.SerializeObject(value, formatting, (JsonSerializerSettings) null);
-    }
-
-    public static string SerializeObject(object value, params JsonConverter[] converters)
-    {
-      JsonSerializerSettings serializerSettings;
-      if (converters == null || converters.Length == 0)
-        serializerSettings = (JsonSerializerSettings) null;
-      else
-        serializerSettings = new JsonSerializerSettings()
-        {
-          Converters = (IList<JsonConverter>) converters
-        };
-      JsonSerializerSettings settings = serializerSettings;
-      return JsonConvert.SerializeObject(value, (Type) null, settings);
-    }
-
-    public static string SerializeObject(
-      object value,
-      Formatting formatting,
-      params JsonConverter[] converters)
-    {
-      JsonSerializerSettings serializerSettings;
-      if (converters == null || converters.Length == 0)
-        serializerSettings = (JsonSerializerSettings) null;
-      else
-        serializerSettings = new JsonSerializerSettings()
-        {
-          Converters = (IList<JsonConverter>) converters
-        };
-      JsonSerializerSettings settings = serializerSettings;
-      return JsonConvert.SerializeObject(value, (Type) null, formatting, settings);
-    }
-
-    public static string SerializeObject(object value, JsonSerializerSettings settings)
-    {
-      return JsonConvert.SerializeObject(value, (Type) null, settings);
-    }
-
-    public static string SerializeObject(object value, Type type, JsonSerializerSettings settings)
-    {
-      JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
-      return JsonConvert.SerializeObjectInternal(value, type, jsonSerializer);
-    }
-
-    public static string SerializeObject(
-      object value,
-      Formatting formatting,
-      JsonSerializerSettings settings)
-    {
-      return JsonConvert.SerializeObject(value, (Type) null, formatting, settings);
-    }
-
-    public static string SerializeObject(
-      object value,
-      Type type,
-      Formatting formatting,
-      JsonSerializerSettings settings)
-    {
-      JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
-      jsonSerializer.Formatting = formatting;
-      return JsonConvert.SerializeObjectInternal(value, type, jsonSerializer);
-    }
-
-    private static string SerializeObjectInternal(
-      object value,
-      Type type,
-      JsonSerializer jsonSerializer)
-    {
-      StringWriter stringWriter = new StringWriter(new StringBuilder(256), (IFormatProvider) CultureInfo.InvariantCulture);
-      using (JsonTextWriter jsonTextWriter = new JsonTextWriter((TextWriter) stringWriter))
-      {
-        jsonTextWriter.Formatting = jsonSerializer.Formatting;
-        jsonSerializer.Serialize((JsonWriter) jsonTextWriter, value, type);
-      }
-      return stringWriter.ToString();
-    }
-
-    public static object DeserializeObject(string value)
-    {
-      return JsonConvert.DeserializeObject(value, (Type) null, (JsonSerializerSettings) null);
-    }
-
-    public static object DeserializeObject(string value, JsonSerializerSettings settings)
-    {
-      return JsonConvert.DeserializeObject(value, (Type) null, settings);
-    }
-
-    public static object DeserializeObject(string value, Type type)
-    {
-      return JsonConvert.DeserializeObject(value, type, (JsonSerializerSettings) null);
-    }
-
-    public static T DeserializeObject<T>(string value)
-    {
-      return JsonConvert.DeserializeObject<T>(value, (JsonSerializerSettings) null);
-    }
-
-    public static T DeserializeAnonymousType<T>(string value, T anonymousTypeObject)
-    {
-      return JsonConvert.DeserializeObject<T>(value);
-    }
-
-    public static T DeserializeAnonymousType<T>(
-      string value,
-      T anonymousTypeObject,
-      JsonSerializerSettings settings)
-    {
-      return JsonConvert.DeserializeObject<T>(value, settings);
-    }
-
-    public static T DeserializeObject<T>(string value, params JsonConverter[] converters)
-    {
-      return (T) JsonConvert.DeserializeObject(value, typeof (T), converters);
-    }
-
-    public static T DeserializeObject<T>(string value, JsonSerializerSettings settings)
-    {
-      return (T) JsonConvert.DeserializeObject(value, typeof (T), settings);
-    }
-
-    public static object DeserializeObject(
-      string value,
-      Type type,
-      params JsonConverter[] converters)
-    {
-      JsonSerializerSettings serializerSettings;
-      if (converters == null || converters.Length == 0)
-        serializerSettings = (JsonSerializerSettings) null;
-      else
-        serializerSettings = new JsonSerializerSettings()
-        {
-          Converters = (IList<JsonConverter>) converters
-        };
-      JsonSerializerSettings settings = serializerSettings;
-      return JsonConvert.DeserializeObject(value, type, settings);
-    }
-
-    public static object DeserializeObject(
-      string value,
-      Type type,
-      JsonSerializerSettings settings)
-    {
-      ValidationUtils.ArgumentNotNull((object) value, nameof (value));
-      JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
-      if (!jsonSerializer.IsCheckAdditionalContentSet())
-        jsonSerializer.CheckAdditionalContent = true;
-      using (JsonTextReader reader = new JsonTextReader((TextReader) new StringReader(value)))
-        return jsonSerializer.Deserialize((JsonReader) reader, type);
-    }
-
-    public static void PopulateObject(string value, object target)
-    {
-      JsonConvert.PopulateObject(value, target, (JsonSerializerSettings) null);
-    }
-
-    public static void PopulateObject(string value, object target, JsonSerializerSettings settings)
-    {
-      using (JsonReader reader = (JsonReader) new JsonTextReader((TextReader) new StringReader(value)))
-      {
-        JsonSerializer.CreateDefault(settings).Populate(reader, target);
-        if (settings == null || !settings.CheckAdditionalContent)
-          return;
-        while (reader.Read())
-        {
-          if (reader.TokenType != JsonToken.Comment)
-            throw JsonSerializationException.Create(reader, "Additional text found in JSON string after finishing deserializing object.");
-        }
-      }
-    }
-
-    public static string SerializeXmlNode(XmlNode node)
-    {
-      return JsonConvert.SerializeXmlNode(node, Formatting.None);
-    }
-
-    public static string SerializeXmlNode(XmlNode node, Formatting formatting)
-    {
-      XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
-      return JsonConvert.SerializeObject((object) node, formatting, (JsonConverter) xmlNodeConverter);
-    }
-
-    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject)
-    {
-      XmlNodeConverter xmlNodeConverter = new XmlNodeConverter()
-      {
-        OmitRootObject = omitRootObject
-      };
-      return JsonConvert.SerializeObject((object) node, formatting, (JsonConverter) xmlNodeConverter);
-    }
-
-    public static XmlDocument DeserializeXmlNode(string value)
-    {
-      return JsonConvert.DeserializeXmlNode(value, (string) null);
-    }
-
-    public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName)
-    {
-      return JsonConvert.DeserializeXmlNode(value, deserializeRootElementName, false);
-    }
-
-    public static XmlDocument DeserializeXmlNode(
-      string value,
-      string deserializeRootElementName,
-      bool writeArrayAttribute)
-    {
-      return (XmlDocument) JsonConvert.DeserializeObject(value, typeof (XmlDocument), (JsonConverter) new XmlNodeConverter()
-      {
-        DeserializeRootElementName = deserializeRootElementName,
-        WriteArrayAttribute = writeArrayAttribute
-      });
-    }
-
-    public static string SerializeXNode(XObject node)
-    {
-      return JsonConvert.SerializeXNode(node, Formatting.None);
-    }
-
-    public static string SerializeXNode(XObject node, Formatting formatting)
-    {
-      return JsonConvert.SerializeXNode(node, formatting, false);
-    }
-
-    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject)
-    {
-      XmlNodeConverter xmlNodeConverter = new XmlNodeConverter()
-      {
-        OmitRootObject = omitRootObject
-      };
-      return JsonConvert.SerializeObject((object) node, formatting, (JsonConverter) xmlNodeConverter);
-    }
-
-    public static XDocument DeserializeXNode(string value)
-    {
-      return JsonConvert.DeserializeXNode(value, (string) null);
-    }
-
-    public static XDocument DeserializeXNode(string value, string deserializeRootElementName)
-    {
-      return JsonConvert.DeserializeXNode(value, deserializeRootElementName, false);
-    }
-
-    public static XDocument DeserializeXNode(
-      string value,
-      string deserializeRootElementName,
-      bool writeArrayAttribute)
-    {
-      return (XDocument) JsonConvert.DeserializeObject(value, typeof (XDocument), (JsonConverter) new XmlNodeConverter()
-      {
-        DeserializeRootElementName = deserializeRootElementName,
-        WriteArrayAttribute = writeArrayAttribute
-      });
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonConverter.cs b/MSHALTester/Newtonsoft/Json/JsonConverter.cs
deleted file mode 100644
index e81dfe4..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonConverter.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public abstract class JsonConverter
-  {
-    public abstract void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
-
-    public abstract object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer);
-
-    public abstract bool CanConvert(Type objectType);
-
-    public virtual bool CanRead => true;
-
-    public virtual bool CanWrite => true;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonConverterAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonConverterAttribute.cs
deleted file mode 100644
index 2391a29..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonConverterAttribute.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter, AllowMultiple = false)]
-  public sealed class JsonConverterAttribute : Attribute
-  {
-    private readonly Type _converterType;
-
-    public Type ConverterType => this._converterType;
-
-    public object[] ConverterParameters { get; }
-
-    public JsonConverterAttribute(Type converterType)
-    {
-      this._converterType = converterType != null ? converterType : throw new ArgumentNullException(nameof (converterType));
-    }
-
-    public JsonConverterAttribute(Type converterType, params object[] converterParameters)
-      : this(converterType)
-    {
-      this.ConverterParameters = converterParameters;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonConverterCollection.cs b/MSHALTester/Newtonsoft/Json/JsonConverterCollection.cs
deleted file mode 100644
index 469ccac..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonConverterCollection.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-using System.Collections.ObjectModel;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public class JsonConverterCollection : Collection<JsonConverter>
-  {
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonConverter`1.cs b/MSHALTester/Newtonsoft/Json/JsonConverter`1.cs
deleted file mode 100644
index c70026d..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonConverter`1.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public abstract class JsonConverter<T> : JsonConverter
-  {
-    public override sealed void WriteJson(
-      JsonWriter writer,
-      object value,
-      JsonSerializer serializer)
-    {
-      if ((value != null ? (value is T ? 1 : 0) : (ReflectionUtils.IsNullable(typeof (T)) ? 1 : 0)) == 0)
-        throw new JsonSerializationException("Converter cannot write specified value to JSON. {0} is required.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeof (T)));
-      this.WriteJson(writer, (T) value, serializer);
-    }
-
-    public abstract void WriteJson(JsonWriter writer, T value, JsonSerializer serializer);
-
-    public override sealed object ReadJson(
-      JsonReader reader,
-      Type objectType,
-      object existingValue,
-      JsonSerializer serializer)
-    {
-      bool flag = existingValue == null;
-      if (!flag && !(existingValue is T))
-        throw new JsonSerializationException("Converter cannot read JSON with the specified existing value. {0} is required.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeof (T)));
-      return (object) this.ReadJson(reader, objectType, flag ? default (T) : (T) existingValue, !flag, serializer);
-    }
-
-    public abstract T ReadJson(
-      JsonReader reader,
-      Type objectType,
-      T existingValue,
-      bool hasExistingValue,
-      JsonSerializer serializer);
-
-    public override sealed bool CanConvert(Type objectType)
-    {
-      return typeof (T).IsAssignableFrom(objectType);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonDictionaryAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonDictionaryAttribute.cs
deleted file mode 100644
index 3e68644..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonDictionaryAttribute.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
-  public sealed class JsonDictionaryAttribute : JsonContainerAttribute
-  {
-    public JsonDictionaryAttribute()
-    {
-    }
-
-    public JsonDictionaryAttribute(string id)
-      : base(id)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonException.cs b/MSHALTester/Newtonsoft/Json/JsonException.cs
deleted file mode 100644
index abd2757..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonException.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [Serializable]
-  public class JsonException : Exception
-  {
-    public JsonException()
-    {
-    }
-
-    public JsonException(string message)
-      : base(message)
-    {
-    }
-
-    public JsonException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-
-    public JsonException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message)
-    {
-      message = JsonPosition.FormatMessage(lineInfo, path, message);
-      return new JsonException(message);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonExtensionDataAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonExtensionDataAttribute.cs
deleted file mode 100644
index 39a7b28..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonExtensionDataAttribute.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
-  public class JsonExtensionDataAttribute : Attribute
-  {
-    public bool WriteData { get; set; }
-
-    public bool ReadData { get; set; }
-
-    public JsonExtensionDataAttribute()
-    {
-      this.WriteData = true;
-      this.ReadData = true;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonIgnoreAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonIgnoreAttribute.cs
deleted file mode 100644
index c23d54a..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonIgnoreAttribute.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
-  public sealed class JsonIgnoreAttribute : Attribute
-  {
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonObjectAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonObjectAttribute.cs
deleted file mode 100644
index 6b0c03b..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonObjectAttribute.cs
+++ /dev/null
@@ -1,45 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false)]
-  public sealed class JsonObjectAttribute : JsonContainerAttribute
-  {
-    private MemberSerialization _memberSerialization;
-    internal Required? _itemRequired;
-    internal NullValueHandling? _itemNullValueHandling;
-
-    public MemberSerialization MemberSerialization
-    {
-      get => this._memberSerialization;
-      set => this._memberSerialization = value;
-    }
-
-    public NullValueHandling ItemNullValueHandling
-    {
-      get => this._itemNullValueHandling ?? NullValueHandling.Include;
-      set => this._itemNullValueHandling = new NullValueHandling?(value);
-    }
-
-    public Required ItemRequired
-    {
-      get => this._itemRequired ?? Required.Default;
-      set => this._itemRequired = new Required?(value);
-    }
-
-    public JsonObjectAttribute()
-    {
-    }
-
-    public JsonObjectAttribute(MemberSerialization memberSerialization)
-    {
-      this.MemberSerialization = memberSerialization;
-    }
-
-    public JsonObjectAttribute(string id)
-      : base(id)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonPosition.cs b/MSHALTester/Newtonsoft/Json/JsonPosition.cs
deleted file mode 100644
index 910ae72..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonPosition.cs
+++ /dev/null
@@ -1,139 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  internal struct JsonPosition(JsonContainerType type)
-  {
-    private static readonly char[] SpecialCharacters = new char[18]
-    {
-      '.',
-      ' ',
-      '\'',
-      '/',
-      '"',
-      '[',
-      ']',
-      '(',
-      ')',
-      '\t',
-      '\n',
-      '\r',
-      '\f',
-      '\b',
-      '\\',
-      '\u0085',
-      '\u2028',
-      '\u2029'
-    };
-    internal JsonContainerType Type = type;
-    internal int Position = -1;
-    internal string PropertyName = (string) null;
-    internal bool HasIndex = JsonPosition.TypeHasIndex(type);
-
-    internal int CalculateLength()
-    {
-      switch (this.Type)
-      {
-        case JsonContainerType.Object:
-          return this.PropertyName.Length + 5;
-        case JsonContainerType.Array:
-        case JsonContainerType.Constructor:
-          return MathUtils.IntLength((ulong) this.Position) + 2;
-        default:
-          throw new ArgumentOutOfRangeException("Type");
-      }
-    }
-
-    internal void WriteTo(StringBuilder sb, ref StringWriter writer, ref char[] buffer)
-    {
-      switch (this.Type)
-      {
-        case JsonContainerType.Object:
-          string propertyName = this.PropertyName;
-          if (propertyName.IndexOfAny(JsonPosition.SpecialCharacters) != -1)
-          {
-            sb.Append("['");
-            if (writer == null)
-              writer = new StringWriter(sb);
-            JavaScriptUtils.WriteEscapedJavaScriptString((TextWriter) writer, propertyName, '\'', false, JavaScriptUtils.SingleQuoteCharEscapeFlags, StringEscapeHandling.Default, (IArrayPool<char>) null, ref buffer);
-            sb.Append("']");
-            break;
-          }
-          if (sb.Length > 0)
-            sb.Append('.');
-          sb.Append(propertyName);
-          break;
-        case JsonContainerType.Array:
-        case JsonContainerType.Constructor:
-          sb.Append('[');
-          sb.Append(this.Position);
-          sb.Append(']');
-          break;
-      }
-    }
-
-    internal static bool TypeHasIndex(JsonContainerType type)
-    {
-      return type == JsonContainerType.Array || type == JsonContainerType.Constructor;
-    }
-
-    internal static string BuildPath(List<JsonPosition> positions, JsonPosition? currentPosition)
-    {
-      int capacity = 0;
-      JsonPosition jsonPosition;
-      if (positions != null)
-      {
-        for (int index = 0; index < positions.Count; ++index)
-        {
-          int num = capacity;
-          jsonPosition = positions[index];
-          int length = jsonPosition.CalculateLength();
-          capacity = num + length;
-        }
-      }
-      if (currentPosition.HasValue)
-      {
-        int num = capacity;
-        jsonPosition = currentPosition.GetValueOrDefault();
-        int length = jsonPosition.CalculateLength();
-        capacity = num + length;
-      }
-      StringBuilder sb = new StringBuilder(capacity);
-      StringWriter writer = (StringWriter) null;
-      char[] buffer = (char[]) null;
-      if (positions != null)
-      {
-        foreach (JsonPosition position in positions)
-          position.WriteTo(sb, ref writer, ref buffer);
-      }
-      if (currentPosition.HasValue)
-      {
-        jsonPosition = currentPosition.GetValueOrDefault();
-        jsonPosition.WriteTo(sb, ref writer, ref buffer);
-      }
-      return sb.ToString();
-    }
-
-    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message)
-    {
-      if (!message.EndsWith(Environment.NewLine, StringComparison.Ordinal))
-      {
-        message = message.Trim();
-        if (!message.EndsWith('.'))
-          message += ".";
-        message += " ";
-      }
-      message += "Path '{0}'".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) path);
-      if (lineInfo != null && lineInfo.HasLineInfo())
-        message += ", line {0}, position {1}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) lineInfo.LineNumber, (object) lineInfo.LinePosition);
-      message += ".";
-      return message;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonPropertyAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonPropertyAttribute.cs
deleted file mode 100644
index 15c7225..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonPropertyAttribute.cs
+++ /dev/null
@@ -1,103 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
-  public sealed class JsonPropertyAttribute : Attribute
-  {
-    internal NullValueHandling? _nullValueHandling;
-    internal DefaultValueHandling? _defaultValueHandling;
-    internal ReferenceLoopHandling? _referenceLoopHandling;
-    internal ObjectCreationHandling? _objectCreationHandling;
-    internal TypeNameHandling? _typeNameHandling;
-    internal bool? _isReference;
-    internal int? _order;
-    internal Required? _required;
-    internal bool? _itemIsReference;
-    internal ReferenceLoopHandling? _itemReferenceLoopHandling;
-    internal TypeNameHandling? _itemTypeNameHandling;
-
-    public Type ItemConverterType { get; set; }
-
-    public object[] ItemConverterParameters { get; set; }
-
-    public Type NamingStrategyType { get; set; }
-
-    public object[] NamingStrategyParameters { get; set; }
-
-    public NullValueHandling NullValueHandling
-    {
-      get => this._nullValueHandling ?? NullValueHandling.Include;
-      set => this._nullValueHandling = new NullValueHandling?(value);
-    }
-
-    public DefaultValueHandling DefaultValueHandling
-    {
-      get => this._defaultValueHandling ?? DefaultValueHandling.Include;
-      set => this._defaultValueHandling = new DefaultValueHandling?(value);
-    }
-
-    public ReferenceLoopHandling ReferenceLoopHandling
-    {
-      get => this._referenceLoopHandling ?? ReferenceLoopHandling.Error;
-      set => this._referenceLoopHandling = new ReferenceLoopHandling?(value);
-    }
-
-    public ObjectCreationHandling ObjectCreationHandling
-    {
-      get => this._objectCreationHandling ?? ObjectCreationHandling.Auto;
-      set => this._objectCreationHandling = new ObjectCreationHandling?(value);
-    }
-
-    public TypeNameHandling TypeNameHandling
-    {
-      get => this._typeNameHandling ?? TypeNameHandling.None;
-      set => this._typeNameHandling = new TypeNameHandling?(value);
-    }
-
-    public bool IsReference
-    {
-      get => this._isReference ?? false;
-      set => this._isReference = new bool?(value);
-    }
-
-    public int Order
-    {
-      get => this._order ?? 0;
-      set => this._order = new int?(value);
-    }
-
-    public Required Required
-    {
-      get => this._required ?? Required.Default;
-      set => this._required = new Required?(value);
-    }
-
-    public string PropertyName { get; set; }
-
-    public ReferenceLoopHandling ItemReferenceLoopHandling
-    {
-      get => this._itemReferenceLoopHandling ?? ReferenceLoopHandling.Error;
-      set => this._itemReferenceLoopHandling = new ReferenceLoopHandling?(value);
-    }
-
-    public TypeNameHandling ItemTypeNameHandling
-    {
-      get => this._itemTypeNameHandling ?? TypeNameHandling.None;
-      set => this._itemTypeNameHandling = new TypeNameHandling?(value);
-    }
-
-    public bool ItemIsReference
-    {
-      get => this._itemIsReference ?? false;
-      set => this._itemIsReference = new bool?(value);
-    }
-
-    public JsonPropertyAttribute()
-    {
-    }
-
-    public JsonPropertyAttribute(string propertyName) => this.PropertyName = propertyName;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonReader.cs b/MSHALTester/Newtonsoft/Json/JsonReader.cs
deleted file mode 100644
index d3b2010..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonReader.cs
+++ /dev/null
@@ -1,825 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public abstract class JsonReader : IDisposable
-  {
-    private JsonToken _tokenType;
-    private object _value;
-    internal char _quoteChar;
-    internal JsonReader.State _currentState;
-    private JsonPosition _currentPosition;
-    private CultureInfo _culture;
-    private DateTimeZoneHandling _dateTimeZoneHandling;
-    private int? _maxDepth;
-    private bool _hasExceededMaxDepth;
-    internal DateParseHandling _dateParseHandling;
-    internal FloatParseHandling _floatParseHandling;
-    private string _dateFormatString;
-    private List<JsonPosition> _stack;
-
-    protected JsonReader.State CurrentState => this._currentState;
-
-    public bool CloseInput { get; set; }
-
-    public bool SupportMultipleContent { get; set; }
-
-    public virtual char QuoteChar
-    {
-      get => this._quoteChar;
-      protected internal set => this._quoteChar = value;
-    }
-
-    public DateTimeZoneHandling DateTimeZoneHandling
-    {
-      get => this._dateTimeZoneHandling;
-      set
-      {
-        this._dateTimeZoneHandling = value >= DateTimeZoneHandling.Local && value <= DateTimeZoneHandling.RoundtripKind ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public DateParseHandling DateParseHandling
-    {
-      get => this._dateParseHandling;
-      set
-      {
-        this._dateParseHandling = value >= DateParseHandling.None && value <= DateParseHandling.DateTimeOffset ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public FloatParseHandling FloatParseHandling
-    {
-      get => this._floatParseHandling;
-      set
-      {
-        this._floatParseHandling = value >= FloatParseHandling.Double && value <= FloatParseHandling.Decimal ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public string DateFormatString
-    {
-      get => this._dateFormatString;
-      set => this._dateFormatString = value;
-    }
-
-    public int? MaxDepth
-    {
-      get => this._maxDepth;
-      set
-      {
-        int? nullable = value;
-        int num = 0;
-        if ((nullable.GetValueOrDefault() <= num ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-          throw new ArgumentException("Value must be positive.", nameof (value));
-        this._maxDepth = value;
-      }
-    }
-
-    public virtual JsonToken TokenType => this._tokenType;
-
-    public virtual object Value => this._value;
-
-    public virtual Type ValueType => this._value?.GetType();
-
-    public virtual int Depth
-    {
-      get
-      {
-        List<JsonPosition> stack = this._stack;
-        int count = stack != null ? __nonvirtual (stack.Count) : 0;
-        return JsonTokenUtils.IsStartToken(this.TokenType) || this._currentPosition.Type == JsonContainerType.None ? count : count + 1;
-      }
-    }
-
-    public virtual string Path
-    {
-      get
-      {
-        return this._currentPosition.Type == JsonContainerType.None ? string.Empty : JsonPosition.BuildPath(this._stack, (this._currentState == JsonReader.State.ArrayStart || this._currentState == JsonReader.State.ConstructorStart ? 0 : (this._currentState != JsonReader.State.ObjectStart ? 1 : 0)) != 0 ? new JsonPosition?(this._currentPosition) : new JsonPosition?());
-      }
-    }
-
-    public CultureInfo Culture
-    {
-      get => this._culture ?? CultureInfo.InvariantCulture;
-      set => this._culture = value;
-    }
-
-    internal JsonPosition GetPosition(int depth)
-    {
-      return this._stack != null && depth < this._stack.Count ? this._stack[depth] : this._currentPosition;
-    }
-
-    protected JsonReader()
-    {
-      this._currentState = JsonReader.State.Start;
-      this._dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
-      this._dateParseHandling = DateParseHandling.DateTime;
-      this._floatParseHandling = FloatParseHandling.Double;
-      this.CloseInput = true;
-    }
-
-    private void Push(JsonContainerType value)
-    {
-      this.UpdateScopeWithFinishedValue();
-      if (this._currentPosition.Type == JsonContainerType.None)
-      {
-        this._currentPosition = new JsonPosition(value);
-      }
-      else
-      {
-        if (this._stack == null)
-          this._stack = new List<JsonPosition>();
-        this._stack.Add(this._currentPosition);
-        this._currentPosition = new JsonPosition(value);
-        if (!this._maxDepth.HasValue)
-          return;
-        int num = this.Depth + 1;
-        int? maxDepth = this._maxDepth;
-        int valueOrDefault = maxDepth.GetValueOrDefault();
-        if ((num > valueOrDefault ? (maxDepth.HasValue ? 1 : 0) : 0) != 0 && !this._hasExceededMaxDepth)
-        {
-          this._hasExceededMaxDepth = true;
-          throw JsonReaderException.Create(this, "The reader's MaxDepth of {0} has been exceeded.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._maxDepth));
-        }
-      }
-    }
-
-    private JsonContainerType Pop()
-    {
-      JsonPosition currentPosition;
-      if (this._stack != null && this._stack.Count > 0)
-      {
-        currentPosition = this._currentPosition;
-        this._currentPosition = this._stack[this._stack.Count - 1];
-        this._stack.RemoveAt(this._stack.Count - 1);
-      }
-      else
-      {
-        currentPosition = this._currentPosition;
-        this._currentPosition = new JsonPosition();
-      }
-      if (this._maxDepth.HasValue)
-      {
-        int depth = this.Depth;
-        int? maxDepth = this._maxDepth;
-        int valueOrDefault = maxDepth.GetValueOrDefault();
-        if ((depth <= valueOrDefault ? (maxDepth.HasValue ? 1 : 0) : 0) != 0)
-          this._hasExceededMaxDepth = false;
-      }
-      return currentPosition.Type;
-    }
-
-    private JsonContainerType Peek() => this._currentPosition.Type;
-
-    public abstract bool Read();
-
-    public virtual int? ReadAsInt32()
-    {
-      JsonToken contentToken = this.GetContentToken();
-      switch (contentToken)
-      {
-        case JsonToken.None:
-        case JsonToken.Null:
-        case JsonToken.EndArray:
-          return new int?();
-        case JsonToken.Integer:
-        case JsonToken.Float:
-          object obj = this.Value;
-          if (obj is int num)
-            return new int?(num);
-          int int32;
-          try
-          {
-            int32 = Convert.ToInt32(obj, (IFormatProvider) CultureInfo.InvariantCulture);
-          }
-          catch (Exception ex)
-          {
-            throw JsonReaderException.Create(this, "Could not convert to integer: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, obj), ex);
-          }
-          this.SetToken(JsonToken.Integer, (object) int32, false);
-          return new int?(int32);
-        case JsonToken.String:
-          return this.ReadInt32String((string) this.Value);
-        default:
-          throw JsonReaderException.Create(this, "Error reading integer. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contentToken));
-      }
-    }
-
-    internal int? ReadInt32String(string s)
-    {
-      if (string.IsNullOrEmpty(s))
-      {
-        this.SetToken(JsonToken.Null, (object) null, false);
-        return new int?();
-      }
-      int result;
-      if (int.TryParse(s, NumberStyles.Integer, (IFormatProvider) this.Culture, out result))
-      {
-        this.SetToken(JsonToken.Integer, (object) result, false);
-        return new int?(result);
-      }
-      this.SetToken(JsonToken.String, (object) s, false);
-      throw JsonReaderException.Create(this, "Could not convert string to integer: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) s));
-    }
-
-    public virtual string ReadAsString()
-    {
-      JsonToken contentToken = this.GetContentToken();
-      switch (contentToken)
-      {
-        case JsonToken.None:
-        case JsonToken.Null:
-        case JsonToken.EndArray:
-          return (string) null;
-        case JsonToken.String:
-          return (string) this.Value;
-        default:
-          if (JsonTokenUtils.IsPrimitiveToken(contentToken))
-          {
-            object obj = this.Value;
-            if (obj != null)
-            {
-              string str;
-              if (obj is IFormattable formattable)
-              {
-                str = formattable.ToString((string) null, (IFormatProvider) this.Culture);
-              }
-              else
-              {
-                Uri uri = obj as Uri;
-                str = uri != (Uri) null ? uri.OriginalString : obj.ToString();
-              }
-              this.SetToken(JsonToken.String, (object) str, false);
-              return str;
-            }
-          }
-          throw JsonReaderException.Create(this, "Error reading string. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contentToken));
-      }
-    }
-
-    public virtual byte[] ReadAsBytes()
-    {
-      JsonToken contentToken = this.GetContentToken();
-      switch (contentToken)
-      {
-        case JsonToken.None:
-        case JsonToken.Null:
-        case JsonToken.EndArray:
-          return (byte[]) null;
-        case JsonToken.StartObject:
-          this.ReadIntoWrappedTypeObject();
-          byte[] numArray1 = this.ReadAsBytes();
-          this.ReaderReadAndAssert();
-          if (this.TokenType != JsonToken.EndObject)
-            throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.TokenType));
-          this.SetToken(JsonToken.Bytes, (object) numArray1, false);
-          return numArray1;
-        case JsonToken.StartArray:
-          return this.ReadArrayIntoByteArray();
-        case JsonToken.String:
-          string s = (string) this.Value;
-          Guid g;
-          byte[] numArray2 = s.Length != 0 ? (!ConvertUtils.TryConvertGuid(s, out g) ? Convert.FromBase64String(s) : g.ToByteArray()) : CollectionUtils.ArrayEmpty<byte>();
-          this.SetToken(JsonToken.Bytes, (object) numArray2, false);
-          return numArray2;
-        case JsonToken.Bytes:
-          if (!(this.Value is Guid guid))
-            return (byte[]) this.Value;
-          byte[] byteArray = guid.ToByteArray();
-          this.SetToken(JsonToken.Bytes, (object) byteArray, false);
-          return byteArray;
-        default:
-          throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contentToken));
-      }
-    }
-
-    internal byte[] ReadArrayIntoByteArray()
-    {
-      List<byte> buffer = new List<byte>();
-      do
-      {
-        if (!this.Read())
-          this.SetToken(JsonToken.None);
-      }
-      while (!this.ReadArrayElementIntoByteArrayReportDone(buffer));
-      byte[] array = buffer.ToArray();
-      this.SetToken(JsonToken.Bytes, (object) array, false);
-      return array;
-    }
-
-    private bool ReadArrayElementIntoByteArrayReportDone(List<byte> buffer)
-    {
-      switch (this.TokenType)
-      {
-        case JsonToken.None:
-          throw JsonReaderException.Create(this, "Unexpected end when reading bytes.");
-        case JsonToken.Comment:
-          return false;
-        case JsonToken.Integer:
-          buffer.Add(Convert.ToByte(this.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-          return false;
-        case JsonToken.EndArray:
-          return true;
-        default:
-          throw JsonReaderException.Create(this, "Unexpected token when reading bytes: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.TokenType));
-      }
-    }
-
-    public virtual double? ReadAsDouble()
-    {
-      JsonToken contentToken = this.GetContentToken();
-      switch (contentToken)
-      {
-        case JsonToken.None:
-        case JsonToken.Null:
-        case JsonToken.EndArray:
-          return new double?();
-        case JsonToken.Integer:
-        case JsonToken.Float:
-          object obj = this.Value;
-          if (obj is double num1)
-            return new double?(num1);
-          double num2 = Convert.ToDouble(obj, (IFormatProvider) CultureInfo.InvariantCulture);
-          this.SetToken(JsonToken.Float, (object) num2, false);
-          return new double?(num2);
-        case JsonToken.String:
-          return this.ReadDoubleString((string) this.Value);
-        default:
-          throw JsonReaderException.Create(this, "Error reading double. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contentToken));
-      }
-    }
-
-    internal double? ReadDoubleString(string s)
-    {
-      if (string.IsNullOrEmpty(s))
-      {
-        this.SetToken(JsonToken.Null, (object) null, false);
-        return new double?();
-      }
-      double result;
-      if (double.TryParse(s, NumberStyles.Float | NumberStyles.AllowThousands, (IFormatProvider) this.Culture, out result))
-      {
-        this.SetToken(JsonToken.Float, (object) result, false);
-        return new double?(result);
-      }
-      this.SetToken(JsonToken.String, (object) s, false);
-      throw JsonReaderException.Create(this, "Could not convert string to double: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) s));
-    }
-
-    public virtual bool? ReadAsBoolean()
-    {
-      JsonToken contentToken = this.GetContentToken();
-      switch (contentToken)
-      {
-        case JsonToken.None:
-        case JsonToken.Null:
-        case JsonToken.EndArray:
-          return new bool?();
-        case JsonToken.Integer:
-        case JsonToken.Float:
-          bool boolean = Convert.ToBoolean(this.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-          this.SetToken(JsonToken.Boolean, (object) boolean, false);
-          return new bool?(boolean);
-        case JsonToken.String:
-          return this.ReadBooleanString((string) this.Value);
-        case JsonToken.Boolean:
-          return new bool?((bool) this.Value);
-        default:
-          throw JsonReaderException.Create(this, "Error reading boolean. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contentToken));
-      }
-    }
-
-    internal bool? ReadBooleanString(string s)
-    {
-      if (string.IsNullOrEmpty(s))
-      {
-        this.SetToken(JsonToken.Null, (object) null, false);
-        return new bool?();
-      }
-      bool result;
-      if (bool.TryParse(s, out result))
-      {
-        this.SetToken(JsonToken.Boolean, (object) result, false);
-        return new bool?(result);
-      }
-      this.SetToken(JsonToken.String, (object) s, false);
-      throw JsonReaderException.Create(this, "Could not convert string to boolean: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) s));
-    }
-
-    public virtual Decimal? ReadAsDecimal()
-    {
-      JsonToken contentToken = this.GetContentToken();
-      switch (contentToken)
-      {
-        case JsonToken.None:
-        case JsonToken.Null:
-        case JsonToken.EndArray:
-          return new Decimal?();
-        case JsonToken.Integer:
-        case JsonToken.Float:
-          object obj = this.Value;
-          if (obj is Decimal num1)
-            return new Decimal?(num1);
-          Decimal num2;
-          try
-          {
-            num2 = Convert.ToDecimal(obj, (IFormatProvider) CultureInfo.InvariantCulture);
-          }
-          catch (Exception ex)
-          {
-            throw JsonReaderException.Create(this, "Could not convert to decimal: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, obj), ex);
-          }
-          this.SetToken(JsonToken.Float, (object) num2, false);
-          return new Decimal?(num2);
-        case JsonToken.String:
-          return this.ReadDecimalString((string) this.Value);
-        default:
-          throw JsonReaderException.Create(this, "Error reading decimal. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contentToken));
-      }
-    }
-
-    internal Decimal? ReadDecimalString(string s)
-    {
-      if (string.IsNullOrEmpty(s))
-      {
-        this.SetToken(JsonToken.Null, (object) null, false);
-        return new Decimal?();
-      }
-      Decimal result;
-      if (Decimal.TryParse(s, NumberStyles.Number, (IFormatProvider) this.Culture, out result))
-      {
-        this.SetToken(JsonToken.Float, (object) result, false);
-        return new Decimal?(result);
-      }
-      this.SetToken(JsonToken.String, (object) s, false);
-      throw JsonReaderException.Create(this, "Could not convert string to decimal: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) s));
-    }
-
-    public virtual DateTime? ReadAsDateTime()
-    {
-      switch (this.GetContentToken())
-      {
-        case JsonToken.None:
-        case JsonToken.Null:
-        case JsonToken.EndArray:
-          return new DateTime?();
-        case JsonToken.String:
-          return this.ReadDateTimeString((string) this.Value);
-        case JsonToken.Date:
-          if (this.Value is DateTimeOffset dateTimeOffset)
-            this.SetToken(JsonToken.Date, (object) dateTimeOffset.DateTime, false);
-          return new DateTime?((DateTime) this.Value);
-        default:
-          throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.TokenType));
-      }
-    }
-
-    internal DateTime? ReadDateTimeString(string s)
-    {
-      if (string.IsNullOrEmpty(s))
-      {
-        this.SetToken(JsonToken.Null, (object) null, false);
-        return new DateTime?();
-      }
-      DateTime dateTime;
-      if (DateTimeUtils.TryParseDateTime(s, this.DateTimeZoneHandling, this._dateFormatString, this.Culture, out dateTime))
-      {
-        dateTime = DateTimeUtils.EnsureDateTime(dateTime, this.DateTimeZoneHandling);
-        this.SetToken(JsonToken.Date, (object) dateTime, false);
-        return new DateTime?(dateTime);
-      }
-      if (!DateTime.TryParse(s, (IFormatProvider) this.Culture, DateTimeStyles.RoundtripKind, out dateTime))
-        throw JsonReaderException.Create(this, "Could not convert string to DateTime: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) s));
-      dateTime = DateTimeUtils.EnsureDateTime(dateTime, this.DateTimeZoneHandling);
-      this.SetToken(JsonToken.Date, (object) dateTime, false);
-      return new DateTime?(dateTime);
-    }
-
-    public virtual DateTimeOffset? ReadAsDateTimeOffset()
-    {
-      JsonToken contentToken = this.GetContentToken();
-      switch (contentToken)
-      {
-        case JsonToken.None:
-        case JsonToken.Null:
-        case JsonToken.EndArray:
-          return new DateTimeOffset?();
-        case JsonToken.String:
-          return this.ReadDateTimeOffsetString((string) this.Value);
-        case JsonToken.Date:
-          if (this.Value is DateTime dateTime)
-            this.SetToken(JsonToken.Date, (object) new DateTimeOffset(dateTime), false);
-          return new DateTimeOffset?((DateTimeOffset) this.Value);
-        default:
-          throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contentToken));
-      }
-    }
-
-    internal DateTimeOffset? ReadDateTimeOffsetString(string s)
-    {
-      if (string.IsNullOrEmpty(s))
-      {
-        this.SetToken(JsonToken.Null, (object) null, false);
-        return new DateTimeOffset?();
-      }
-      DateTimeOffset dateTimeOffset;
-      if (DateTimeUtils.TryParseDateTimeOffset(s, this._dateFormatString, this.Culture, out dateTimeOffset))
-      {
-        this.SetToken(JsonToken.Date, (object) dateTimeOffset, false);
-        return new DateTimeOffset?(dateTimeOffset);
-      }
-      if (DateTimeOffset.TryParse(s, (IFormatProvider) this.Culture, DateTimeStyles.RoundtripKind, out dateTimeOffset))
-      {
-        this.SetToken(JsonToken.Date, (object) dateTimeOffset, false);
-        return new DateTimeOffset?(dateTimeOffset);
-      }
-      this.SetToken(JsonToken.String, (object) s, false);
-      throw JsonReaderException.Create(this, "Could not convert string to DateTimeOffset: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) s));
-    }
-
-    internal void ReaderReadAndAssert()
-    {
-      if (!this.Read())
-        throw this.CreateUnexpectedEndException();
-    }
-
-    internal JsonReaderException CreateUnexpectedEndException()
-    {
-      return JsonReaderException.Create(this, "Unexpected end when reading JSON.");
-    }
-
-    internal void ReadIntoWrappedTypeObject()
-    {
-      this.ReaderReadAndAssert();
-      if (this.Value != null && this.Value.ToString() == "$type")
-      {
-        this.ReaderReadAndAssert();
-        if (this.Value != null && this.Value.ToString().StartsWith("System.Byte[]", StringComparison.Ordinal))
-        {
-          this.ReaderReadAndAssert();
-          if (this.Value.ToString() == "$value")
-            return;
-        }
-      }
-      throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JsonToken.StartObject));
-    }
-
-    public void Skip()
-    {
-      if (this.TokenType == JsonToken.PropertyName)
-        this.Read();
-      if (!JsonTokenUtils.IsStartToken(this.TokenType))
-        return;
-      int depth = this.Depth;
-      do
-        ;
-      while (this.Read() && depth < this.Depth);
-    }
-
-    protected void SetToken(JsonToken newToken) => this.SetToken(newToken, (object) null, true);
-
-    protected void SetToken(JsonToken newToken, object value)
-    {
-      this.SetToken(newToken, value, true);
-    }
-
-    protected void SetToken(JsonToken newToken, object value, bool updateIndex)
-    {
-      this._tokenType = newToken;
-      this._value = value;
-      switch (newToken)
-      {
-        case JsonToken.StartObject:
-          this._currentState = JsonReader.State.ObjectStart;
-          this.Push(JsonContainerType.Object);
-          break;
-        case JsonToken.StartArray:
-          this._currentState = JsonReader.State.ArrayStart;
-          this.Push(JsonContainerType.Array);
-          break;
-        case JsonToken.StartConstructor:
-          this._currentState = JsonReader.State.ConstructorStart;
-          this.Push(JsonContainerType.Constructor);
-          break;
-        case JsonToken.PropertyName:
-          this._currentState = JsonReader.State.Property;
-          this._currentPosition.PropertyName = (string) value;
-          break;
-        case JsonToken.Raw:
-        case JsonToken.Integer:
-        case JsonToken.Float:
-        case JsonToken.String:
-        case JsonToken.Boolean:
-        case JsonToken.Null:
-        case JsonToken.Undefined:
-        case JsonToken.Date:
-        case JsonToken.Bytes:
-          this.SetPostValueState(updateIndex);
-          break;
-        case JsonToken.EndObject:
-          this.ValidateEnd(JsonToken.EndObject);
-          break;
-        case JsonToken.EndArray:
-          this.ValidateEnd(JsonToken.EndArray);
-          break;
-        case JsonToken.EndConstructor:
-          this.ValidateEnd(JsonToken.EndConstructor);
-          break;
-      }
-    }
-
-    internal void SetPostValueState(bool updateIndex)
-    {
-      if (this.Peek() != JsonContainerType.None || this.SupportMultipleContent)
-        this._currentState = JsonReader.State.PostValue;
-      else
-        this.SetFinished();
-      if (!updateIndex)
-        return;
-      this.UpdateScopeWithFinishedValue();
-    }
-
-    private void UpdateScopeWithFinishedValue()
-    {
-      if (!this._currentPosition.HasIndex)
-        return;
-      ++this._currentPosition.Position;
-    }
-
-    private void ValidateEnd(JsonToken endToken)
-    {
-      JsonContainerType jsonContainerType = this.Pop();
-      if (this.GetTypeForCloseToken(endToken) != jsonContainerType)
-        throw JsonReaderException.Create(this, "JsonToken {0} is not valid for closing JsonType {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) endToken, (object) jsonContainerType));
-      if (this.Peek() != JsonContainerType.None || this.SupportMultipleContent)
-        this._currentState = JsonReader.State.PostValue;
-      else
-        this.SetFinished();
-    }
-
-    protected void SetStateBasedOnCurrent()
-    {
-      JsonContainerType jsonContainerType = this.Peek();
-      switch (jsonContainerType)
-      {
-        case JsonContainerType.None:
-          this.SetFinished();
-          break;
-        case JsonContainerType.Object:
-          this._currentState = JsonReader.State.Object;
-          break;
-        case JsonContainerType.Array:
-          this._currentState = JsonReader.State.Array;
-          break;
-        case JsonContainerType.Constructor:
-          this._currentState = JsonReader.State.Constructor;
-          break;
-        default:
-          throw JsonReaderException.Create(this, "While setting the reader state back to current object an unexpected JsonType was encountered: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) jsonContainerType));
-      }
-    }
-
-    private void SetFinished()
-    {
-      this._currentState = this.SupportMultipleContent ? JsonReader.State.Start : JsonReader.State.Finished;
-    }
-
-    private JsonContainerType GetTypeForCloseToken(JsonToken token)
-    {
-      switch (token)
-      {
-        case JsonToken.EndObject:
-          return JsonContainerType.Object;
-        case JsonToken.EndArray:
-          return JsonContainerType.Array;
-        case JsonToken.EndConstructor:
-          return JsonContainerType.Constructor;
-        default:
-          throw JsonReaderException.Create(this, "Not a valid close JsonToken: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token));
-      }
-    }
-
-    void IDisposable.Dispose()
-    {
-      this.Dispose(true);
-      GC.SuppressFinalize((object) this);
-    }
-
-    protected virtual void Dispose(bool disposing)
-    {
-      if (!(this._currentState != JsonReader.State.Closed & disposing))
-        return;
-      this.Close();
-    }
-
-    public virtual void Close()
-    {
-      this._currentState = JsonReader.State.Closed;
-      this._tokenType = JsonToken.None;
-      this._value = (object) null;
-    }
-
-    internal void ReadAndAssert()
-    {
-      if (!this.Read())
-        throw JsonSerializationException.Create(this, "Unexpected end when reading JSON.");
-    }
-
-    internal void ReadForTypeAndAssert(JsonContract contract, bool hasConverter)
-    {
-      if (!this.ReadForType(contract, hasConverter))
-        throw JsonSerializationException.Create(this, "Unexpected end when reading JSON.");
-    }
-
-    internal bool ReadForType(JsonContract contract, bool hasConverter)
-    {
-      if (hasConverter)
-        return this.Read();
-      switch (contract != null ? (int) contract.InternalReadType : 0)
-      {
-        case 0:
-          return this.ReadAndMoveToContent();
-        case 1:
-          this.ReadAsInt32();
-          break;
-        case 2:
-          int num = this.ReadAndMoveToContent() ? 1 : 0;
-          if (this.TokenType != JsonToken.Undefined)
-            return num != 0;
-          throw JsonReaderException.Create(this, "An undefined token is not a valid {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) (contract?.UnderlyingType ?? typeof (long))));
-        case 3:
-          this.ReadAsBytes();
-          break;
-        case 4:
-          this.ReadAsString();
-          break;
-        case 5:
-          this.ReadAsDecimal();
-          break;
-        case 6:
-          this.ReadAsDateTime();
-          break;
-        case 7:
-          this.ReadAsDateTimeOffset();
-          break;
-        case 8:
-          this.ReadAsDouble();
-          break;
-        case 9:
-          this.ReadAsBoolean();
-          break;
-        default:
-          throw new ArgumentOutOfRangeException();
-      }
-      return this.TokenType != 0;
-    }
-
-    internal bool ReadAndMoveToContent() => this.Read() && this.MoveToContent();
-
-    internal bool MoveToContent()
-    {
-      for (JsonToken tokenType = this.TokenType; tokenType == JsonToken.None || tokenType == JsonToken.Comment; tokenType = this.TokenType)
-      {
-        if (!this.Read())
-          return false;
-      }
-      return true;
-    }
-
-    private JsonToken GetContentToken()
-    {
-      while (this.Read())
-      {
-        JsonToken tokenType = this.TokenType;
-        if (tokenType != JsonToken.Comment)
-          return tokenType;
-      }
-      this.SetToken(JsonToken.None);
-      return JsonToken.None;
-    }
-
-    protected internal enum State
-    {
-      Start,
-      Complete,
-      Property,
-      ObjectStart,
-      Object,
-      ArrayStart,
-      Array,
-      Closed,
-      PostValue,
-      ConstructorStart,
-      Constructor,
-      Error,
-      Finished,
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonReaderException.cs b/MSHALTester/Newtonsoft/Json/JsonReaderException.cs
deleted file mode 100644
index 170424f..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonReaderException.cs
+++ /dev/null
@@ -1,80 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [Serializable]
-  public class JsonReaderException : JsonException
-  {
-    public int LineNumber { get; }
-
-    public int LinePosition { get; }
-
-    public string Path { get; }
-
-    public JsonReaderException()
-    {
-    }
-
-    public JsonReaderException(string message)
-      : base(message)
-    {
-    }
-
-    public JsonReaderException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-
-    public JsonReaderException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public JsonReaderException(
-      string message,
-      string path,
-      int lineNumber,
-      int linePosition,
-      Exception innerException)
-      : base(message, innerException)
-    {
-      this.Path = path;
-      this.LineNumber = lineNumber;
-      this.LinePosition = linePosition;
-    }
-
-    internal static JsonReaderException Create(JsonReader reader, string message)
-    {
-      return JsonReaderException.Create(reader, message, (Exception) null);
-    }
-
-    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex)
-    {
-      return JsonReaderException.Create(reader as IJsonLineInfo, reader.Path, message, ex);
-    }
-
-    internal static JsonReaderException Create(
-      IJsonLineInfo lineInfo,
-      string path,
-      string message,
-      Exception ex)
-    {
-      message = JsonPosition.FormatMessage(lineInfo, path, message);
-      int lineNumber;
-      int linePosition;
-      if (lineInfo != null && lineInfo.HasLineInfo())
-      {
-        lineNumber = lineInfo.LineNumber;
-        linePosition = lineInfo.LinePosition;
-      }
-      else
-      {
-        lineNumber = 0;
-        linePosition = 0;
-      }
-      return new JsonReaderException(message, path, lineNumber, linePosition, ex);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonRequiredAttribute.cs b/MSHALTester/Newtonsoft/Json/JsonRequiredAttribute.cs
deleted file mode 100644
index 9db5edb..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonRequiredAttribute.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
-  public sealed class JsonRequiredAttribute : Attribute
-  {
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonSerializationException.cs b/MSHALTester/Newtonsoft/Json/JsonSerializationException.cs
deleted file mode 100644
index ce29557..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonSerializationException.cs
+++ /dev/null
@@ -1,52 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [Serializable]
-  public class JsonSerializationException : JsonException
-  {
-    public JsonSerializationException()
-    {
-    }
-
-    public JsonSerializationException(string message)
-      : base(message)
-    {
-    }
-
-    public JsonSerializationException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-
-    public JsonSerializationException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    internal static JsonSerializationException Create(JsonReader reader, string message)
-    {
-      return JsonSerializationException.Create(reader, message, (Exception) null);
-    }
-
-    internal static JsonSerializationException Create(
-      JsonReader reader,
-      string message,
-      Exception ex)
-    {
-      return JsonSerializationException.Create(reader as IJsonLineInfo, reader.Path, message, ex);
-    }
-
-    internal static JsonSerializationException Create(
-      IJsonLineInfo lineInfo,
-      string path,
-      string message,
-      Exception ex)
-    {
-      message = JsonPosition.FormatMessage(lineInfo, path, message);
-      return new JsonSerializationException(message, ex);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonSerializer.cs b/MSHALTester/Newtonsoft/Json/JsonSerializer.cs
deleted file mode 100644
index d547aa5..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonSerializer.cs
+++ /dev/null
@@ -1,742 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Globalization;
-using System.IO;
-using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public class JsonSerializer
-  {
-    internal TypeNameHandling _typeNameHandling;
-    internal TypeNameAssemblyFormatHandling _typeNameAssemblyFormatHandling;
-    internal PreserveReferencesHandling _preserveReferencesHandling;
-    internal ReferenceLoopHandling _referenceLoopHandling;
-    internal MissingMemberHandling _missingMemberHandling;
-    internal ObjectCreationHandling _objectCreationHandling;
-    internal NullValueHandling _nullValueHandling;
-    internal DefaultValueHandling _defaultValueHandling;
-    internal ConstructorHandling _constructorHandling;
-    internal MetadataPropertyHandling _metadataPropertyHandling;
-    internal JsonConverterCollection _converters;
-    internal IContractResolver _contractResolver;
-    internal ITraceWriter _traceWriter;
-    internal IEqualityComparer _equalityComparer;
-    internal ISerializationBinder _serializationBinder;
-    internal StreamingContext _context;
-    private IReferenceResolver _referenceResolver;
-    private Formatting? _formatting;
-    private DateFormatHandling? _dateFormatHandling;
-    private DateTimeZoneHandling? _dateTimeZoneHandling;
-    private DateParseHandling? _dateParseHandling;
-    private FloatFormatHandling? _floatFormatHandling;
-    private FloatParseHandling? _floatParseHandling;
-    private StringEscapeHandling? _stringEscapeHandling;
-    private CultureInfo _culture;
-    private int? _maxDepth;
-    private bool _maxDepthSet;
-    private bool? _checkAdditionalContent;
-    private string _dateFormatString;
-    private bool _dateFormatStringSet;
-
-    public virtual event EventHandler<Newtonsoft.Json.Serialization.ErrorEventArgs> Error;
-
-    public virtual IReferenceResolver ReferenceResolver
-    {
-      get => this.GetReferenceResolver();
-      set
-      {
-        this._referenceResolver = value != null ? value : throw new ArgumentNullException(nameof (value), "Reference resolver cannot be null.");
-      }
-    }
-
-    [Obsolete("Binder is obsolete. Use SerializationBinder instead.")]
-    public virtual System.Runtime.Serialization.SerializationBinder Binder
-    {
-      get
-      {
-        if (this._serializationBinder == null)
-          return (System.Runtime.Serialization.SerializationBinder) null;
-        if (this._serializationBinder is System.Runtime.Serialization.SerializationBinder serializationBinder1)
-          return serializationBinder1;
-        return this._serializationBinder is SerializationBinderAdapter serializationBinder2 ? serializationBinder2.SerializationBinder : throw new InvalidOperationException("Cannot get SerializationBinder because an ISerializationBinder was previously set.");
-      }
-      set
-      {
-        if (value == null)
-          throw new ArgumentNullException(nameof (value), "Serialization binder cannot be null.");
-        if (!(value is ISerializationBinder serializationBinder))
-          serializationBinder = (ISerializationBinder) new SerializationBinderAdapter(value);
-        this._serializationBinder = serializationBinder;
-      }
-    }
-
-    public virtual ISerializationBinder SerializationBinder
-    {
-      get => this._serializationBinder;
-      set
-      {
-        this._serializationBinder = value != null ? value : throw new ArgumentNullException(nameof (value), "Serialization binder cannot be null.");
-      }
-    }
-
-    public virtual ITraceWriter TraceWriter
-    {
-      get => this._traceWriter;
-      set => this._traceWriter = value;
-    }
-
-    public virtual IEqualityComparer EqualityComparer
-    {
-      get => this._equalityComparer;
-      set => this._equalityComparer = value;
-    }
-
-    public virtual TypeNameHandling TypeNameHandling
-    {
-      get => this._typeNameHandling;
-      set
-      {
-        this._typeNameHandling = value >= TypeNameHandling.None && value <= TypeNameHandling.Auto ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    [Obsolete("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
-    public virtual FormatterAssemblyStyle TypeNameAssemblyFormat
-    {
-      get => (FormatterAssemblyStyle) this._typeNameAssemblyFormatHandling;
-      set
-      {
-        this._typeNameAssemblyFormatHandling = value >= FormatterAssemblyStyle.Simple && value <= FormatterAssemblyStyle.Full ? (TypeNameAssemblyFormatHandling) value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling
-    {
-      get => this._typeNameAssemblyFormatHandling;
-      set
-      {
-        this._typeNameAssemblyFormatHandling = value >= TypeNameAssemblyFormatHandling.Simple && value <= TypeNameAssemblyFormatHandling.Full ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual PreserveReferencesHandling PreserveReferencesHandling
-    {
-      get => this._preserveReferencesHandling;
-      set
-      {
-        this._preserveReferencesHandling = value >= PreserveReferencesHandling.None && value <= PreserveReferencesHandling.All ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual ReferenceLoopHandling ReferenceLoopHandling
-    {
-      get => this._referenceLoopHandling;
-      set
-      {
-        this._referenceLoopHandling = value >= ReferenceLoopHandling.Error && value <= ReferenceLoopHandling.Serialize ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual MissingMemberHandling MissingMemberHandling
-    {
-      get => this._missingMemberHandling;
-      set
-      {
-        this._missingMemberHandling = value >= MissingMemberHandling.Ignore && value <= MissingMemberHandling.Error ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual NullValueHandling NullValueHandling
-    {
-      get => this._nullValueHandling;
-      set
-      {
-        this._nullValueHandling = value >= NullValueHandling.Include && value <= NullValueHandling.Ignore ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual DefaultValueHandling DefaultValueHandling
-    {
-      get => this._defaultValueHandling;
-      set
-      {
-        this._defaultValueHandling = value >= DefaultValueHandling.Include && value <= DefaultValueHandling.IgnoreAndPopulate ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual ObjectCreationHandling ObjectCreationHandling
-    {
-      get => this._objectCreationHandling;
-      set
-      {
-        this._objectCreationHandling = value >= ObjectCreationHandling.Auto && value <= ObjectCreationHandling.Replace ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual ConstructorHandling ConstructorHandling
-    {
-      get => this._constructorHandling;
-      set
-      {
-        this._constructorHandling = value >= ConstructorHandling.Default && value <= ConstructorHandling.AllowNonPublicDefaultConstructor ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual MetadataPropertyHandling MetadataPropertyHandling
-    {
-      get => this._metadataPropertyHandling;
-      set
-      {
-        this._metadataPropertyHandling = value >= MetadataPropertyHandling.Default && value <= MetadataPropertyHandling.Ignore ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public virtual JsonConverterCollection Converters
-    {
-      get
-      {
-        if (this._converters == null)
-          this._converters = new JsonConverterCollection();
-        return this._converters;
-      }
-    }
-
-    public virtual IContractResolver ContractResolver
-    {
-      get => this._contractResolver;
-      set => this._contractResolver = value ?? DefaultContractResolver.Instance;
-    }
-
-    public virtual StreamingContext Context
-    {
-      get => this._context;
-      set => this._context = value;
-    }
-
-    public virtual Formatting Formatting
-    {
-      get => this._formatting ?? Formatting.None;
-      set => this._formatting = new Formatting?(value);
-    }
-
-    public virtual DateFormatHandling DateFormatHandling
-    {
-      get => this._dateFormatHandling ?? DateFormatHandling.IsoDateFormat;
-      set => this._dateFormatHandling = new DateFormatHandling?(value);
-    }
-
-    public virtual DateTimeZoneHandling DateTimeZoneHandling
-    {
-      get => this._dateTimeZoneHandling ?? DateTimeZoneHandling.RoundtripKind;
-      set => this._dateTimeZoneHandling = new DateTimeZoneHandling?(value);
-    }
-
-    public virtual DateParseHandling DateParseHandling
-    {
-      get => this._dateParseHandling ?? DateParseHandling.DateTime;
-      set => this._dateParseHandling = new DateParseHandling?(value);
-    }
-
-    public virtual FloatParseHandling FloatParseHandling
-    {
-      get => this._floatParseHandling ?? FloatParseHandling.Double;
-      set => this._floatParseHandling = new FloatParseHandling?(value);
-    }
-
-    public virtual FloatFormatHandling FloatFormatHandling
-    {
-      get => this._floatFormatHandling ?? FloatFormatHandling.String;
-      set => this._floatFormatHandling = new FloatFormatHandling?(value);
-    }
-
-    public virtual StringEscapeHandling StringEscapeHandling
-    {
-      get => this._stringEscapeHandling ?? StringEscapeHandling.Default;
-      set => this._stringEscapeHandling = new StringEscapeHandling?(value);
-    }
-
-    public virtual string DateFormatString
-    {
-      get => this._dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
-      set
-      {
-        this._dateFormatString = value;
-        this._dateFormatStringSet = true;
-      }
-    }
-
-    public virtual CultureInfo Culture
-    {
-      get => this._culture ?? JsonSerializerSettings.DefaultCulture;
-      set => this._culture = value;
-    }
-
-    public virtual int? MaxDepth
-    {
-      get => this._maxDepth;
-      set
-      {
-        int? nullable = value;
-        int num = 0;
-        if ((nullable.GetValueOrDefault() <= num ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-          throw new ArgumentException("Value must be positive.", nameof (value));
-        this._maxDepth = value;
-        this._maxDepthSet = true;
-      }
-    }
-
-    public virtual bool CheckAdditionalContent
-    {
-      get => this._checkAdditionalContent ?? false;
-      set => this._checkAdditionalContent = new bool?(value);
-    }
-
-    internal bool IsCheckAdditionalContentSet() => this._checkAdditionalContent.HasValue;
-
-    public JsonSerializer()
-    {
-      this._referenceLoopHandling = ReferenceLoopHandling.Error;
-      this._missingMemberHandling = MissingMemberHandling.Ignore;
-      this._nullValueHandling = NullValueHandling.Include;
-      this._defaultValueHandling = DefaultValueHandling.Include;
-      this._objectCreationHandling = ObjectCreationHandling.Auto;
-      this._preserveReferencesHandling = PreserveReferencesHandling.None;
-      this._constructorHandling = ConstructorHandling.Default;
-      this._typeNameHandling = TypeNameHandling.None;
-      this._metadataPropertyHandling = MetadataPropertyHandling.Default;
-      this._context = JsonSerializerSettings.DefaultContext;
-      this._serializationBinder = (ISerializationBinder) DefaultSerializationBinder.Instance;
-      this._culture = JsonSerializerSettings.DefaultCulture;
-      this._contractResolver = DefaultContractResolver.Instance;
-    }
-
-    public static JsonSerializer Create() => new JsonSerializer();
-
-    public static JsonSerializer Create(JsonSerializerSettings settings)
-    {
-      JsonSerializer serializer = JsonSerializer.Create();
-      if (settings != null)
-        JsonSerializer.ApplySerializerSettings(serializer, settings);
-      return serializer;
-    }
-
-    public static JsonSerializer CreateDefault()
-    {
-      Func<JsonSerializerSettings> defaultSettings = JsonConvert.DefaultSettings;
-      return JsonSerializer.Create(defaultSettings != null ? defaultSettings() : (JsonSerializerSettings) null);
-    }
-
-    public static JsonSerializer CreateDefault(JsonSerializerSettings settings)
-    {
-      JsonSerializer serializer = JsonSerializer.CreateDefault();
-      if (settings != null)
-        JsonSerializer.ApplySerializerSettings(serializer, settings);
-      return serializer;
-    }
-
-    private static void ApplySerializerSettings(
-      JsonSerializer serializer,
-      JsonSerializerSettings settings)
-    {
-      if (!CollectionUtils.IsNullOrEmpty<JsonConverter>((ICollection<JsonConverter>) settings.Converters))
-      {
-        for (int index = 0; index < settings.Converters.Count; ++index)
-          serializer.Converters.Insert(index, settings.Converters[index]);
-      }
-      if (settings._typeNameHandling.HasValue)
-        serializer.TypeNameHandling = settings.TypeNameHandling;
-      if (settings._metadataPropertyHandling.HasValue)
-        serializer.MetadataPropertyHandling = settings.MetadataPropertyHandling;
-      if (settings._typeNameAssemblyFormatHandling.HasValue)
-        serializer.TypeNameAssemblyFormatHandling = settings.TypeNameAssemblyFormatHandling;
-      if (settings._preserveReferencesHandling.HasValue)
-        serializer.PreserveReferencesHandling = settings.PreserveReferencesHandling;
-      if (settings._referenceLoopHandling.HasValue)
-        serializer.ReferenceLoopHandling = settings.ReferenceLoopHandling;
-      if (settings._missingMemberHandling.HasValue)
-        serializer.MissingMemberHandling = settings.MissingMemberHandling;
-      if (settings._objectCreationHandling.HasValue)
-        serializer.ObjectCreationHandling = settings.ObjectCreationHandling;
-      if (settings._nullValueHandling.HasValue)
-        serializer.NullValueHandling = settings.NullValueHandling;
-      if (settings._defaultValueHandling.HasValue)
-        serializer.DefaultValueHandling = settings.DefaultValueHandling;
-      if (settings._constructorHandling.HasValue)
-        serializer.ConstructorHandling = settings.ConstructorHandling;
-      if (settings._context.HasValue)
-        serializer.Context = settings.Context;
-      if (settings._checkAdditionalContent.HasValue)
-        serializer._checkAdditionalContent = settings._checkAdditionalContent;
-      if (settings.Error != null)
-        serializer.Error += settings.Error;
-      if (settings.ContractResolver != null)
-        serializer.ContractResolver = settings.ContractResolver;
-      if (settings.ReferenceResolverProvider != null)
-        serializer.ReferenceResolver = settings.ReferenceResolverProvider();
-      if (settings.TraceWriter != null)
-        serializer.TraceWriter = settings.TraceWriter;
-      if (settings.EqualityComparer != null)
-        serializer.EqualityComparer = settings.EqualityComparer;
-      if (settings.SerializationBinder != null)
-        serializer.SerializationBinder = settings.SerializationBinder;
-      if (settings._formatting.HasValue)
-        serializer._formatting = settings._formatting;
-      if (settings._dateFormatHandling.HasValue)
-        serializer._dateFormatHandling = settings._dateFormatHandling;
-      if (settings._dateTimeZoneHandling.HasValue)
-        serializer._dateTimeZoneHandling = settings._dateTimeZoneHandling;
-      if (settings._dateParseHandling.HasValue)
-        serializer._dateParseHandling = settings._dateParseHandling;
-      if (settings._dateFormatStringSet)
-      {
-        serializer._dateFormatString = settings._dateFormatString;
-        serializer._dateFormatStringSet = settings._dateFormatStringSet;
-      }
-      if (settings._floatFormatHandling.HasValue)
-        serializer._floatFormatHandling = settings._floatFormatHandling;
-      if (settings._floatParseHandling.HasValue)
-        serializer._floatParseHandling = settings._floatParseHandling;
-      if (settings._stringEscapeHandling.HasValue)
-        serializer._stringEscapeHandling = settings._stringEscapeHandling;
-      if (settings._culture != null)
-        serializer._culture = settings._culture;
-      if (!settings._maxDepthSet)
-        return;
-      serializer._maxDepth = settings._maxDepth;
-      serializer._maxDepthSet = settings._maxDepthSet;
-    }
-
-    public void Populate(TextReader reader, object target)
-    {
-      this.Populate((JsonReader) new JsonTextReader(reader), target);
-    }
-
-    public void Populate(JsonReader reader, object target) => this.PopulateInternal(reader, target);
-
-    internal virtual void PopulateInternal(JsonReader reader, object target)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      ValidationUtils.ArgumentNotNull(target, nameof (target));
-      CultureInfo previousCulture;
-      DateTimeZoneHandling? previousDateTimeZoneHandling;
-      DateParseHandling? previousDateParseHandling;
-      FloatParseHandling? previousFloatParseHandling;
-      int? previousMaxDepth;
-      string previousDateFormatString;
-      this.SetupReader(reader, out previousCulture, out previousDateTimeZoneHandling, out previousDateParseHandling, out previousFloatParseHandling, out previousMaxDepth, out previousDateFormatString);
-      TraceJsonReader traceJsonReader = this.TraceWriter == null || this.TraceWriter.LevelFilter < TraceLevel.Verbose ? (TraceJsonReader) null : this.CreateTraceJsonReader(reader);
-      new JsonSerializerInternalReader(this).Populate((JsonReader) traceJsonReader ?? reader, target);
-      if (traceJsonReader != null)
-        this.TraceWriter.Trace(TraceLevel.Verbose, traceJsonReader.GetDeserializedJsonMessage(), (Exception) null);
-      this.ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
-    }
-
-    public object Deserialize(JsonReader reader) => this.Deserialize(reader, (Type) null);
-
-    public object Deserialize(TextReader reader, Type objectType)
-    {
-      return this.Deserialize((JsonReader) new JsonTextReader(reader), objectType);
-    }
-
-    public T Deserialize<T>(JsonReader reader) => (T) this.Deserialize(reader, typeof (T));
-
-    public object Deserialize(JsonReader reader, Type objectType)
-    {
-      return this.DeserializeInternal(reader, objectType);
-    }
-
-    internal virtual object DeserializeInternal(JsonReader reader, Type objectType)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      CultureInfo previousCulture;
-      DateTimeZoneHandling? previousDateTimeZoneHandling;
-      DateParseHandling? previousDateParseHandling;
-      FloatParseHandling? previousFloatParseHandling;
-      int? previousMaxDepth;
-      string previousDateFormatString;
-      this.SetupReader(reader, out previousCulture, out previousDateTimeZoneHandling, out previousDateParseHandling, out previousFloatParseHandling, out previousMaxDepth, out previousDateFormatString);
-      TraceJsonReader traceJsonReader = this.TraceWriter == null || this.TraceWriter.LevelFilter < TraceLevel.Verbose ? (TraceJsonReader) null : this.CreateTraceJsonReader(reader);
-      object obj = new JsonSerializerInternalReader(this).Deserialize((JsonReader) traceJsonReader ?? reader, objectType, this.CheckAdditionalContent);
-      if (traceJsonReader != null)
-        this.TraceWriter.Trace(TraceLevel.Verbose, traceJsonReader.GetDeserializedJsonMessage(), (Exception) null);
-      this.ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
-      return obj;
-    }
-
-    private void SetupReader(
-      JsonReader reader,
-      out CultureInfo previousCulture,
-      out DateTimeZoneHandling? previousDateTimeZoneHandling,
-      out DateParseHandling? previousDateParseHandling,
-      out FloatParseHandling? previousFloatParseHandling,
-      out int? previousMaxDepth,
-      out string previousDateFormatString)
-    {
-      if (this._culture != null && !this._culture.Equals((object) reader.Culture))
-      {
-        previousCulture = reader.Culture;
-        reader.Culture = this._culture;
-      }
-      else
-        previousCulture = (CultureInfo) null;
-      if (this._dateTimeZoneHandling.HasValue)
-      {
-        int timeZoneHandling1 = (int) reader.DateTimeZoneHandling;
-        DateTimeZoneHandling? timeZoneHandling2 = this._dateTimeZoneHandling;
-        int valueOrDefault = (int) timeZoneHandling2.GetValueOrDefault();
-        if ((timeZoneHandling1 == valueOrDefault ? (!timeZoneHandling2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          previousDateTimeZoneHandling = new DateTimeZoneHandling?(reader.DateTimeZoneHandling);
-          reader.DateTimeZoneHandling = this._dateTimeZoneHandling.GetValueOrDefault();
-          goto label_7;
-        }
-      }
-      previousDateTimeZoneHandling = new DateTimeZoneHandling?();
-label_7:
-      if (this._dateParseHandling.HasValue)
-      {
-        int dateParseHandling1 = (int) reader.DateParseHandling;
-        DateParseHandling? dateParseHandling2 = this._dateParseHandling;
-        int valueOrDefault = (int) dateParseHandling2.GetValueOrDefault();
-        if ((dateParseHandling1 == valueOrDefault ? (!dateParseHandling2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          previousDateParseHandling = new DateParseHandling?(reader.DateParseHandling);
-          reader.DateParseHandling = this._dateParseHandling.GetValueOrDefault();
-          goto label_11;
-        }
-      }
-      previousDateParseHandling = new DateParseHandling?();
-label_11:
-      if (this._floatParseHandling.HasValue)
-      {
-        int floatParseHandling1 = (int) reader.FloatParseHandling;
-        FloatParseHandling? floatParseHandling2 = this._floatParseHandling;
-        int valueOrDefault = (int) floatParseHandling2.GetValueOrDefault();
-        if ((floatParseHandling1 == valueOrDefault ? (!floatParseHandling2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          previousFloatParseHandling = new FloatParseHandling?(reader.FloatParseHandling);
-          reader.FloatParseHandling = this._floatParseHandling.GetValueOrDefault();
-          goto label_15;
-        }
-      }
-      previousFloatParseHandling = new FloatParseHandling?();
-label_15:
-      if (this._maxDepthSet)
-      {
-        int? maxDepth1 = reader.MaxDepth;
-        int? maxDepth2 = this._maxDepth;
-        if ((maxDepth1.GetValueOrDefault() == maxDepth2.GetValueOrDefault() ? (maxDepth1.HasValue != maxDepth2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          previousMaxDepth = reader.MaxDepth;
-          reader.MaxDepth = this._maxDepth;
-          goto label_19;
-        }
-      }
-      previousMaxDepth = new int?();
-label_19:
-      if (this._dateFormatStringSet && reader.DateFormatString != this._dateFormatString)
-      {
-        previousDateFormatString = reader.DateFormatString;
-        reader.DateFormatString = this._dateFormatString;
-      }
-      else
-        previousDateFormatString = (string) null;
-      if (!(reader is JsonTextReader jsonTextReader) || !(this._contractResolver is DefaultContractResolver contractResolver))
-        return;
-      jsonTextReader.NameTable = contractResolver.GetNameTable();
-    }
-
-    private void ResetReader(
-      JsonReader reader,
-      CultureInfo previousCulture,
-      DateTimeZoneHandling? previousDateTimeZoneHandling,
-      DateParseHandling? previousDateParseHandling,
-      FloatParseHandling? previousFloatParseHandling,
-      int? previousMaxDepth,
-      string previousDateFormatString)
-    {
-      if (previousCulture != null)
-        reader.Culture = previousCulture;
-      if (previousDateTimeZoneHandling.HasValue)
-        reader.DateTimeZoneHandling = previousDateTimeZoneHandling.GetValueOrDefault();
-      if (previousDateParseHandling.HasValue)
-        reader.DateParseHandling = previousDateParseHandling.GetValueOrDefault();
-      if (previousFloatParseHandling.HasValue)
-        reader.FloatParseHandling = previousFloatParseHandling.GetValueOrDefault();
-      if (this._maxDepthSet)
-        reader.MaxDepth = previousMaxDepth;
-      if (this._dateFormatStringSet)
-        reader.DateFormatString = previousDateFormatString;
-      if (!(reader is JsonTextReader jsonTextReader))
-        return;
-      jsonTextReader.NameTable = (PropertyNameTable) null;
-    }
-
-    public void Serialize(TextWriter textWriter, object value)
-    {
-      this.Serialize((JsonWriter) new JsonTextWriter(textWriter), value);
-    }
-
-    public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
-    {
-      this.SerializeInternal(jsonWriter, value, objectType);
-    }
-
-    public void Serialize(TextWriter textWriter, object value, Type objectType)
-    {
-      this.Serialize((JsonWriter) new JsonTextWriter(textWriter), value, objectType);
-    }
-
-    public void Serialize(JsonWriter jsonWriter, object value)
-    {
-      this.SerializeInternal(jsonWriter, value, (Type) null);
-    }
-
-    private TraceJsonReader CreateTraceJsonReader(JsonReader reader)
-    {
-      TraceJsonReader traceJsonReader = new TraceJsonReader(reader);
-      if (reader.TokenType != JsonToken.None)
-        traceJsonReader.WriteCurrentToken();
-      return traceJsonReader;
-    }
-
-    internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType)
-    {
-      ValidationUtils.ArgumentNotNull((object) jsonWriter, nameof (jsonWriter));
-      Formatting? nullable1 = new Formatting?();
-      if (this._formatting.HasValue)
-      {
-        int formatting1 = (int) jsonWriter.Formatting;
-        Formatting? formatting2 = this._formatting;
-        int valueOrDefault = (int) formatting2.GetValueOrDefault();
-        if ((formatting1 == valueOrDefault ? (!formatting2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          nullable1 = new Formatting?(jsonWriter.Formatting);
-          jsonWriter.Formatting = this._formatting.GetValueOrDefault();
-        }
-      }
-      DateFormatHandling? nullable2 = new DateFormatHandling?();
-      if (this._dateFormatHandling.HasValue)
-      {
-        int dateFormatHandling1 = (int) jsonWriter.DateFormatHandling;
-        DateFormatHandling? dateFormatHandling2 = this._dateFormatHandling;
-        int valueOrDefault = (int) dateFormatHandling2.GetValueOrDefault();
-        if ((dateFormatHandling1 == valueOrDefault ? (!dateFormatHandling2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          nullable2 = new DateFormatHandling?(jsonWriter.DateFormatHandling);
-          jsonWriter.DateFormatHandling = this._dateFormatHandling.GetValueOrDefault();
-        }
-      }
-      DateTimeZoneHandling? nullable3 = new DateTimeZoneHandling?();
-      if (this._dateTimeZoneHandling.HasValue)
-      {
-        int timeZoneHandling1 = (int) jsonWriter.DateTimeZoneHandling;
-        DateTimeZoneHandling? timeZoneHandling2 = this._dateTimeZoneHandling;
-        int valueOrDefault = (int) timeZoneHandling2.GetValueOrDefault();
-        if ((timeZoneHandling1 == valueOrDefault ? (!timeZoneHandling2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          nullable3 = new DateTimeZoneHandling?(jsonWriter.DateTimeZoneHandling);
-          jsonWriter.DateTimeZoneHandling = this._dateTimeZoneHandling.GetValueOrDefault();
-        }
-      }
-      FloatFormatHandling? nullable4 = new FloatFormatHandling?();
-      if (this._floatFormatHandling.HasValue)
-      {
-        int floatFormatHandling1 = (int) jsonWriter.FloatFormatHandling;
-        FloatFormatHandling? floatFormatHandling2 = this._floatFormatHandling;
-        int valueOrDefault = (int) floatFormatHandling2.GetValueOrDefault();
-        if ((floatFormatHandling1 == valueOrDefault ? (!floatFormatHandling2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          nullable4 = new FloatFormatHandling?(jsonWriter.FloatFormatHandling);
-          jsonWriter.FloatFormatHandling = this._floatFormatHandling.GetValueOrDefault();
-        }
-      }
-      StringEscapeHandling? nullable5 = new StringEscapeHandling?();
-      if (this._stringEscapeHandling.HasValue)
-      {
-        int stringEscapeHandling1 = (int) jsonWriter.StringEscapeHandling;
-        StringEscapeHandling? stringEscapeHandling2 = this._stringEscapeHandling;
-        int valueOrDefault = (int) stringEscapeHandling2.GetValueOrDefault();
-        if ((stringEscapeHandling1 == valueOrDefault ? (!stringEscapeHandling2.HasValue ? 1 : 0) : 1) != 0)
-        {
-          nullable5 = new StringEscapeHandling?(jsonWriter.StringEscapeHandling);
-          jsonWriter.StringEscapeHandling = this._stringEscapeHandling.GetValueOrDefault();
-        }
-      }
-      CultureInfo cultureInfo = (CultureInfo) null;
-      if (this._culture != null && !this._culture.Equals((object) jsonWriter.Culture))
-      {
-        cultureInfo = jsonWriter.Culture;
-        jsonWriter.Culture = this._culture;
-      }
-      string str = (string) null;
-      if (this._dateFormatStringSet && jsonWriter.DateFormatString != this._dateFormatString)
-      {
-        str = jsonWriter.DateFormatString;
-        jsonWriter.DateFormatString = this._dateFormatString;
-      }
-      TraceJsonWriter traceJsonWriter = this.TraceWriter == null || this.TraceWriter.LevelFilter < TraceLevel.Verbose ? (TraceJsonWriter) null : new TraceJsonWriter(jsonWriter);
-      new JsonSerializerInternalWriter(this).Serialize((JsonWriter) traceJsonWriter ?? jsonWriter, value, objectType);
-      if (traceJsonWriter != null)
-        this.TraceWriter.Trace(TraceLevel.Verbose, traceJsonWriter.GetSerializedJsonMessage(), (Exception) null);
-      if (nullable1.HasValue)
-        jsonWriter.Formatting = nullable1.GetValueOrDefault();
-      if (nullable2.HasValue)
-        jsonWriter.DateFormatHandling = nullable2.GetValueOrDefault();
-      if (nullable3.HasValue)
-        jsonWriter.DateTimeZoneHandling = nullable3.GetValueOrDefault();
-      if (nullable4.HasValue)
-        jsonWriter.FloatFormatHandling = nullable4.GetValueOrDefault();
-      if (nullable5.HasValue)
-        jsonWriter.StringEscapeHandling = nullable5.GetValueOrDefault();
-      if (this._dateFormatStringSet)
-        jsonWriter.DateFormatString = str;
-      if (cultureInfo == null)
-        return;
-      jsonWriter.Culture = cultureInfo;
-    }
-
-    internal IReferenceResolver GetReferenceResolver()
-    {
-      if (this._referenceResolver == null)
-        this._referenceResolver = (IReferenceResolver) new DefaultReferenceResolver();
-      return this._referenceResolver;
-    }
-
-    internal JsonConverter GetMatchingConverter(Type type)
-    {
-      return JsonSerializer.GetMatchingConverter((IList<JsonConverter>) this._converters, type);
-    }
-
-    internal static JsonConverter GetMatchingConverter(
-      IList<JsonConverter> converters,
-      Type objectType)
-    {
-      if (converters != null)
-      {
-        for (int index = 0; index < converters.Count; ++index)
-        {
-          JsonConverter converter = converters[index];
-          if (converter.CanConvert(objectType))
-            return converter;
-        }
-      }
-      return (JsonConverter) null;
-    }
-
-    internal void OnError(Newtonsoft.Json.Serialization.ErrorEventArgs e)
-    {
-      EventHandler<Newtonsoft.Json.Serialization.ErrorEventArgs> error = this.Error;
-      if (error == null)
-        return;
-      error((object) this, e);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonSerializerSettings.cs b/MSHALTester/Newtonsoft/Json/JsonSerializerSettings.cs
deleted file mode 100644
index a7e6abd..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonSerializerSettings.cs
+++ /dev/null
@@ -1,259 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public class JsonSerializerSettings
-  {
-    internal const ReferenceLoopHandling DefaultReferenceLoopHandling = ReferenceLoopHandling.Error;
-    internal const MissingMemberHandling DefaultMissingMemberHandling = MissingMemberHandling.Ignore;
-    internal const NullValueHandling DefaultNullValueHandling = NullValueHandling.Include;
-    internal const DefaultValueHandling DefaultDefaultValueHandling = DefaultValueHandling.Include;
-    internal const ObjectCreationHandling DefaultObjectCreationHandling = ObjectCreationHandling.Auto;
-    internal const PreserveReferencesHandling DefaultPreserveReferencesHandling = PreserveReferencesHandling.None;
-    internal const ConstructorHandling DefaultConstructorHandling = ConstructorHandling.Default;
-    internal const TypeNameHandling DefaultTypeNameHandling = TypeNameHandling.None;
-    internal const MetadataPropertyHandling DefaultMetadataPropertyHandling = MetadataPropertyHandling.Default;
-    internal static readonly StreamingContext DefaultContext = new StreamingContext();
-    internal const Formatting DefaultFormatting = Formatting.None;
-    internal const DateFormatHandling DefaultDateFormatHandling = DateFormatHandling.IsoDateFormat;
-    internal const DateTimeZoneHandling DefaultDateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
-    internal const DateParseHandling DefaultDateParseHandling = DateParseHandling.DateTime;
-    internal const FloatParseHandling DefaultFloatParseHandling = FloatParseHandling.Double;
-    internal const FloatFormatHandling DefaultFloatFormatHandling = FloatFormatHandling.String;
-    internal const StringEscapeHandling DefaultStringEscapeHandling = StringEscapeHandling.Default;
-    internal const TypeNameAssemblyFormatHandling DefaultTypeNameAssemblyFormatHandling = TypeNameAssemblyFormatHandling.Simple;
-    internal static readonly CultureInfo DefaultCulture = CultureInfo.InvariantCulture;
-    internal const bool DefaultCheckAdditionalContent = false;
-    internal const string DefaultDateFormatString = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
-    internal Formatting? _formatting;
-    internal DateFormatHandling? _dateFormatHandling;
-    internal DateTimeZoneHandling? _dateTimeZoneHandling;
-    internal DateParseHandling? _dateParseHandling;
-    internal FloatFormatHandling? _floatFormatHandling;
-    internal FloatParseHandling? _floatParseHandling;
-    internal StringEscapeHandling? _stringEscapeHandling;
-    internal CultureInfo _culture;
-    internal bool? _checkAdditionalContent;
-    internal int? _maxDepth;
-    internal bool _maxDepthSet;
-    internal string _dateFormatString;
-    internal bool _dateFormatStringSet;
-    internal TypeNameAssemblyFormatHandling? _typeNameAssemblyFormatHandling;
-    internal DefaultValueHandling? _defaultValueHandling;
-    internal PreserveReferencesHandling? _preserveReferencesHandling;
-    internal NullValueHandling? _nullValueHandling;
-    internal ObjectCreationHandling? _objectCreationHandling;
-    internal MissingMemberHandling? _missingMemberHandling;
-    internal ReferenceLoopHandling? _referenceLoopHandling;
-    internal StreamingContext? _context;
-    internal ConstructorHandling? _constructorHandling;
-    internal TypeNameHandling? _typeNameHandling;
-    internal MetadataPropertyHandling? _metadataPropertyHandling;
-
-    public ReferenceLoopHandling ReferenceLoopHandling
-    {
-      get => this._referenceLoopHandling ?? ReferenceLoopHandling.Error;
-      set => this._referenceLoopHandling = new ReferenceLoopHandling?(value);
-    }
-
-    public MissingMemberHandling MissingMemberHandling
-    {
-      get => this._missingMemberHandling ?? MissingMemberHandling.Ignore;
-      set => this._missingMemberHandling = new MissingMemberHandling?(value);
-    }
-
-    public ObjectCreationHandling ObjectCreationHandling
-    {
-      get => this._objectCreationHandling ?? ObjectCreationHandling.Auto;
-      set => this._objectCreationHandling = new ObjectCreationHandling?(value);
-    }
-
-    public NullValueHandling NullValueHandling
-    {
-      get => this._nullValueHandling ?? NullValueHandling.Include;
-      set => this._nullValueHandling = new NullValueHandling?(value);
-    }
-
-    public DefaultValueHandling DefaultValueHandling
-    {
-      get => this._defaultValueHandling ?? DefaultValueHandling.Include;
-      set => this._defaultValueHandling = new DefaultValueHandling?(value);
-    }
-
-    public IList<JsonConverter> Converters { get; set; }
-
-    public PreserveReferencesHandling PreserveReferencesHandling
-    {
-      get => this._preserveReferencesHandling ?? PreserveReferencesHandling.None;
-      set => this._preserveReferencesHandling = new PreserveReferencesHandling?(value);
-    }
-
-    public TypeNameHandling TypeNameHandling
-    {
-      get => this._typeNameHandling ?? TypeNameHandling.None;
-      set => this._typeNameHandling = new TypeNameHandling?(value);
-    }
-
-    public MetadataPropertyHandling MetadataPropertyHandling
-    {
-      get => this._metadataPropertyHandling ?? MetadataPropertyHandling.Default;
-      set => this._metadataPropertyHandling = new MetadataPropertyHandling?(value);
-    }
-
-    [Obsolete("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
-    public FormatterAssemblyStyle TypeNameAssemblyFormat
-    {
-      get => (FormatterAssemblyStyle) this.TypeNameAssemblyFormatHandling;
-      set => this.TypeNameAssemblyFormatHandling = (TypeNameAssemblyFormatHandling) value;
-    }
-
-    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling
-    {
-      get => this._typeNameAssemblyFormatHandling ?? TypeNameAssemblyFormatHandling.Simple;
-      set => this._typeNameAssemblyFormatHandling = new TypeNameAssemblyFormatHandling?(value);
-    }
-
-    public ConstructorHandling ConstructorHandling
-    {
-      get => this._constructorHandling ?? ConstructorHandling.Default;
-      set => this._constructorHandling = new ConstructorHandling?(value);
-    }
-
-    public IContractResolver ContractResolver { get; set; }
-
-    public IEqualityComparer EqualityComparer { get; set; }
-
-    [Obsolete("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
-    public IReferenceResolver ReferenceResolver
-    {
-      get
-      {
-        Func<IReferenceResolver> resolverProvider = this.ReferenceResolverProvider;
-        return resolverProvider == null ? (IReferenceResolver) null : resolverProvider();
-      }
-      set
-      {
-        this.ReferenceResolverProvider = value != null ? (Func<IReferenceResolver>) (() => value) : (Func<IReferenceResolver>) null;
-      }
-    }
-
-    public Func<IReferenceResolver> ReferenceResolverProvider { get; set; }
-
-    public ITraceWriter TraceWriter { get; set; }
-
-    [Obsolete("Binder is obsolete. Use SerializationBinder instead.")]
-    public System.Runtime.Serialization.SerializationBinder Binder
-    {
-      get
-      {
-        if (this.SerializationBinder == null)
-          return (System.Runtime.Serialization.SerializationBinder) null;
-        return this.SerializationBinder is SerializationBinderAdapter serializationBinder ? serializationBinder.SerializationBinder : throw new InvalidOperationException("Cannot get SerializationBinder because an ISerializationBinder was previously set.");
-      }
-      set
-      {
-        this.SerializationBinder = value == null ? (ISerializationBinder) null : (ISerializationBinder) new SerializationBinderAdapter(value);
-      }
-    }
-
-    public ISerializationBinder SerializationBinder { get; set; }
-
-    public EventHandler<ErrorEventArgs> Error { get; set; }
-
-    public StreamingContext Context
-    {
-      get => this._context ?? JsonSerializerSettings.DefaultContext;
-      set => this._context = new StreamingContext?(value);
-    }
-
-    public string DateFormatString
-    {
-      get => this._dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
-      set
-      {
-        this._dateFormatString = value;
-        this._dateFormatStringSet = true;
-      }
-    }
-
-    public int? MaxDepth
-    {
-      get => this._maxDepth;
-      set
-      {
-        int? nullable = value;
-        int num = 0;
-        if ((nullable.GetValueOrDefault() <= num ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-          throw new ArgumentException("Value must be positive.", nameof (value));
-        this._maxDepth = value;
-        this._maxDepthSet = true;
-      }
-    }
-
-    public Formatting Formatting
-    {
-      get => this._formatting ?? Formatting.None;
-      set => this._formatting = new Formatting?(value);
-    }
-
-    public DateFormatHandling DateFormatHandling
-    {
-      get => this._dateFormatHandling ?? DateFormatHandling.IsoDateFormat;
-      set => this._dateFormatHandling = new DateFormatHandling?(value);
-    }
-
-    public DateTimeZoneHandling DateTimeZoneHandling
-    {
-      get => this._dateTimeZoneHandling ?? DateTimeZoneHandling.RoundtripKind;
-      set => this._dateTimeZoneHandling = new DateTimeZoneHandling?(value);
-    }
-
-    public DateParseHandling DateParseHandling
-    {
-      get => this._dateParseHandling ?? DateParseHandling.DateTime;
-      set => this._dateParseHandling = new DateParseHandling?(value);
-    }
-
-    public FloatFormatHandling FloatFormatHandling
-    {
-      get => this._floatFormatHandling ?? FloatFormatHandling.String;
-      set => this._floatFormatHandling = new FloatFormatHandling?(value);
-    }
-
-    public FloatParseHandling FloatParseHandling
-    {
-      get => this._floatParseHandling ?? FloatParseHandling.Double;
-      set => this._floatParseHandling = new FloatParseHandling?(value);
-    }
-
-    public StringEscapeHandling StringEscapeHandling
-    {
-      get => this._stringEscapeHandling ?? StringEscapeHandling.Default;
-      set => this._stringEscapeHandling = new StringEscapeHandling?(value);
-    }
-
-    public CultureInfo Culture
-    {
-      get => this._culture ?? JsonSerializerSettings.DefaultCulture;
-      set => this._culture = value;
-    }
-
-    public bool CheckAdditionalContent
-    {
-      get => this._checkAdditionalContent ?? false;
-      set => this._checkAdditionalContent = new bool?(value);
-    }
-
-    public JsonSerializerSettings()
-    {
-      this.Converters = (IList<JsonConverter>) new List<JsonConverter>();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonTextReader.cs b/MSHALTester/Newtonsoft/Json/JsonTextReader.cs
deleted file mode 100644
index b496ec2..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonTextReader.cs
+++ /dev/null
@@ -1,2091 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public class JsonTextReader : JsonReader, IJsonLineInfo
-  {
-    private const char UnicodeReplacementChar = '?';
-    private const int MaximumJavascriptIntegerCharacterLength = 380;
-    private const int LargeBufferLength = 1073741823;
-    private readonly TextReader _reader;
-    private char[] _chars;
-    private int _charsUsed;
-    private int _charPos;
-    private int _lineStartPos;
-    private int _lineNumber;
-    private bool _isEndOfFile;
-    private StringBuffer _stringBuffer;
-    private StringReference _stringReference;
-    private IArrayPool<char> _arrayPool;
-    internal PropertyNameTable NameTable;
-
-    public JsonTextReader(TextReader reader)
-    {
-      this._reader = reader != null ? reader : throw new ArgumentNullException(nameof (reader));
-      this._lineNumber = 1;
-    }
-
-    public IArrayPool<char> ArrayPool
-    {
-      get => this._arrayPool;
-      set
-      {
-        this._arrayPool = value != null ? value : throw new ArgumentNullException(nameof (value));
-      }
-    }
-
-    private void EnsureBufferNotEmpty()
-    {
-      if (!this._stringBuffer.IsEmpty)
-        return;
-      this._stringBuffer = new StringBuffer(this._arrayPool, 1024);
-    }
-
-    private void SetNewLine(bool hasNextChar)
-    {
-      if (hasNextChar && this._chars[this._charPos] == '\n')
-        ++this._charPos;
-      this.OnNewLine(this._charPos);
-    }
-
-    private void OnNewLine(int pos)
-    {
-      ++this._lineNumber;
-      this._lineStartPos = pos;
-    }
-
-    private void ParseString(char quote, ReadType readType)
-    {
-      ++this._charPos;
-      this.ShiftBufferIfNeeded();
-      this.ReadStringIntoBuffer(quote);
-      this.ParseReadString(quote, readType);
-    }
-
-    private void ParseReadString(char quote, ReadType readType)
-    {
-      this.SetPostValueState(true);
-      switch (readType)
-      {
-        case ReadType.ReadAsInt32:
-          break;
-        case ReadType.ReadAsBytes:
-          Guid g;
-          this.SetToken(JsonToken.Bytes, this._stringReference.Length != 0 ? (this._stringReference.Length != 36 || !ConvertUtils.TryConvertGuid(this._stringReference.ToString(), out g) ? (object) Convert.FromBase64CharArray(this._stringReference.Chars, this._stringReference.StartIndex, this._stringReference.Length) : (object) g.ToByteArray()) : (object) CollectionUtils.ArrayEmpty<byte>(), false);
-          break;
-        case ReadType.ReadAsString:
-          this.SetToken(JsonToken.String, (object) this._stringReference.ToString(), false);
-          this._quoteChar = quote;
-          break;
-        case ReadType.ReadAsDecimal:
-          break;
-        case ReadType.ReadAsBoolean:
-          break;
-        default:
-          if (this._dateParseHandling != DateParseHandling.None)
-          {
-            DateParseHandling dateParseHandling;
-            switch (readType)
-            {
-              case ReadType.ReadAsDateTime:
-                dateParseHandling = DateParseHandling.DateTime;
-                break;
-              case ReadType.ReadAsDateTimeOffset:
-                dateParseHandling = DateParseHandling.DateTimeOffset;
-                break;
-              default:
-                dateParseHandling = this._dateParseHandling;
-                break;
-            }
-            if (dateParseHandling == DateParseHandling.DateTime)
-            {
-              DateTime dt;
-              if (DateTimeUtils.TryParseDateTime(this._stringReference, this.DateTimeZoneHandling, this.DateFormatString, this.Culture, out dt))
-              {
-                this.SetToken(JsonToken.Date, (object) dt, false);
-                break;
-              }
-            }
-            else
-            {
-              DateTimeOffset dt;
-              if (DateTimeUtils.TryParseDateTimeOffset(this._stringReference, this.DateFormatString, this.Culture, out dt))
-              {
-                this.SetToken(JsonToken.Date, (object) dt, false);
-                break;
-              }
-            }
-          }
-          this.SetToken(JsonToken.String, (object) this._stringReference.ToString(), false);
-          this._quoteChar = quote;
-          break;
-      }
-    }
-
-    private static void BlockCopyChars(
-      char[] src,
-      int srcOffset,
-      char[] dst,
-      int dstOffset,
-      int count)
-    {
-      Buffer.BlockCopy((Array) src, srcOffset * 2, (Array) dst, dstOffset * 2, count * 2);
-    }
-
-    private void ShiftBufferIfNeeded()
-    {
-      int length = this._chars.Length;
-      if ((double) (length - this._charPos) > (double) length * 0.1 && length < 1073741823)
-        return;
-      int count = this._charsUsed - this._charPos;
-      if (count > 0)
-        JsonTextReader.BlockCopyChars(this._chars, this._charPos, this._chars, 0, count);
-      this._lineStartPos -= this._charPos;
-      this._charPos = 0;
-      this._charsUsed = count;
-      this._chars[this._charsUsed] = char.MinValue;
-    }
-
-    private int ReadData(bool append) => this.ReadData(append, 0);
-
-    private void PrepareBufferForReadData(bool append, int charsRequired)
-    {
-      if (this._charsUsed + charsRequired < this._chars.Length - 1)
-        return;
-      if (append)
-      {
-        int num = this._chars.Length * 2;
-        char[] dst = BufferUtils.RentBuffer(this._arrayPool, Math.Max(num < 0 ? int.MaxValue : num, this._charsUsed + charsRequired + 1));
-        JsonTextReader.BlockCopyChars(this._chars, 0, dst, 0, this._chars.Length);
-        BufferUtils.ReturnBuffer(this._arrayPool, this._chars);
-        this._chars = dst;
-      }
-      else
-      {
-        int count = this._charsUsed - this._charPos;
-        if (count + charsRequired + 1 >= this._chars.Length)
-        {
-          char[] dst = BufferUtils.RentBuffer(this._arrayPool, count + charsRequired + 1);
-          if (count > 0)
-            JsonTextReader.BlockCopyChars(this._chars, this._charPos, dst, 0, count);
-          BufferUtils.ReturnBuffer(this._arrayPool, this._chars);
-          this._chars = dst;
-        }
-        else if (count > 0)
-          JsonTextReader.BlockCopyChars(this._chars, this._charPos, this._chars, 0, count);
-        this._lineStartPos -= this._charPos;
-        this._charPos = 0;
-        this._charsUsed = count;
-      }
-    }
-
-    private int ReadData(bool append, int charsRequired)
-    {
-      if (this._isEndOfFile)
-        return 0;
-      this.PrepareBufferForReadData(append, charsRequired);
-      int num = this._reader.Read(this._chars, this._charsUsed, this._chars.Length - this._charsUsed - 1);
-      this._charsUsed += num;
-      if (num == 0)
-        this._isEndOfFile = true;
-      this._chars[this._charsUsed] = char.MinValue;
-      return num;
-    }
-
-    private bool EnsureChars(int relativePosition, bool append)
-    {
-      return this._charPos + relativePosition < this._charsUsed || this.ReadChars(relativePosition, append);
-    }
-
-    private bool ReadChars(int relativePosition, bool append)
-    {
-      if (this._isEndOfFile)
-        return false;
-      int num1 = this._charPos + relativePosition - this._charsUsed + 1;
-      int num2 = 0;
-      do
-      {
-        int num3 = this.ReadData(append, num1 - num2);
-        if (num3 != 0)
-          num2 += num3;
-        else
-          break;
-      }
-      while (num2 < num1);
-      return num2 >= num1;
-    }
-
-    public override bool Read()
-    {
-      this.EnsureBuffer();
-      do
-      {
-        switch (this._currentState)
-        {
-          case JsonReader.State.Start:
-          case JsonReader.State.Property:
-          case JsonReader.State.ArrayStart:
-          case JsonReader.State.Array:
-          case JsonReader.State.ConstructorStart:
-          case JsonReader.State.Constructor:
-            return this.ParseValue();
-          case JsonReader.State.ObjectStart:
-          case JsonReader.State.Object:
-            return this.ParseObject();
-          case JsonReader.State.PostValue:
-            continue;
-          case JsonReader.State.Finished:
-            goto label_6;
-          default:
-            goto label_13;
-        }
-      }
-      while (!this.ParsePostValue(false));
-      return true;
-label_6:
-      if (this.EnsureChars(0, false))
-      {
-        this.EatWhitespace();
-        if (this._isEndOfFile)
-        {
-          this.SetToken(JsonToken.None);
-          return false;
-        }
-        if (this._chars[this._charPos] != '/')
-          throw JsonReaderException.Create((JsonReader) this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._chars[this._charPos]));
-        this.ParseComment(true);
-        return true;
-      }
-      this.SetToken(JsonToken.None);
-      return false;
-label_13:
-      throw JsonReaderException.Create((JsonReader) this, "Unexpected state: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.CurrentState));
-    }
-
-    public override int? ReadAsInt32() => (int?) this.ReadNumberValue(ReadType.ReadAsInt32);
-
-    public override DateTime? ReadAsDateTime()
-    {
-      return (DateTime?) this.ReadStringValue(ReadType.ReadAsDateTime);
-    }
-
-    public override string ReadAsString() => (string) this.ReadStringValue(ReadType.ReadAsString);
-
-    public override byte[] ReadAsBytes()
-    {
-      this.EnsureBuffer();
-      bool flag = false;
-      switch (this._currentState)
-      {
-        case JsonReader.State.Start:
-        case JsonReader.State.Property:
-        case JsonReader.State.ArrayStart:
-        case JsonReader.State.Array:
-        case JsonReader.State.ConstructorStart:
-        case JsonReader.State.Constructor:
-          char ch;
-          do
-          {
-            do
-            {
-              ch = this._chars[this._charPos];
-              switch (ch)
-              {
-                case char.MinValue:
-                  continue;
-                case '\t':
-                case ' ':
-                  goto label_21;
-                case '\n':
-                  goto label_20;
-                case '\r':
-                  goto label_19;
-                case '"':
-                case '\'':
-                  goto label_6;
-                case ',':
-                  goto label_15;
-                case '/':
-                  goto label_14;
-                case '[':
-                  goto label_12;
-                case ']':
-                  goto label_16;
-                case 'n':
-                  goto label_13;
-                case '{':
-                  goto label_11;
-                default:
-                  goto label_22;
-              }
-            }
-            while (!this.ReadNullChar());
-            this.SetToken(JsonToken.None, (object) null, false);
-            return (byte[]) null;
-label_6:
-            this.ParseString(ch, ReadType.ReadAsBytes);
-            byte[] numArray = (byte[]) this.Value;
-            if (flag)
-            {
-              this.ReaderReadAndAssert();
-              if (this.TokenType != JsonToken.EndObject)
-                throw JsonReaderException.Create((JsonReader) this, "Error reading bytes. Unexpected token: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.TokenType));
-              this.SetToken(JsonToken.Bytes, (object) numArray, false);
-            }
-            return numArray;
-label_11:
-            ++this._charPos;
-            this.SetToken(JsonToken.StartObject);
-            this.ReadIntoWrappedTypeObject();
-            flag = true;
-            continue;
-label_12:
-            ++this._charPos;
-            this.SetToken(JsonToken.StartArray);
-            return this.ReadArrayIntoByteArray();
-label_13:
-            this.HandleNull();
-            return (byte[]) null;
-label_14:
-            this.ParseComment(false);
-            continue;
-label_15:
-            this.ProcessValueComma();
-            continue;
-label_16:
-            ++this._charPos;
-            if (this._currentState != JsonReader.State.Array && this._currentState != JsonReader.State.ArrayStart && this._currentState != JsonReader.State.PostValue)
-              throw this.CreateUnexpectedCharacterException(ch);
-            this.SetToken(JsonToken.EndArray);
-            return (byte[]) null;
-label_19:
-            this.ProcessCarriageReturn(false);
-            continue;
-label_20:
-            this.ProcessLineFeed();
-            continue;
-label_21:
-            ++this._charPos;
-            continue;
-label_22:
-            ++this._charPos;
-          }
-          while (char.IsWhiteSpace(ch));
-          throw this.CreateUnexpectedCharacterException(ch);
-        case JsonReader.State.PostValue:
-          if (this.ParsePostValue(true))
-            return (byte[]) null;
-          goto case JsonReader.State.Start;
-        case JsonReader.State.Finished:
-          this.ReadFinished();
-          return (byte[]) null;
-        default:
-          throw JsonReaderException.Create((JsonReader) this, "Unexpected state: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.CurrentState));
-      }
-    }
-
-    private object ReadStringValue(ReadType readType)
-    {
-      this.EnsureBuffer();
-      switch (this._currentState)
-      {
-        case JsonReader.State.Start:
-        case JsonReader.State.Property:
-        case JsonReader.State.ArrayStart:
-        case JsonReader.State.Array:
-        case JsonReader.State.ConstructorStart:
-        case JsonReader.State.Constructor:
-          char ch;
-          do
-          {
-            do
-            {
-              ch = this._chars[this._charPos];
-              switch (ch)
-              {
-                case char.MinValue:
-                  continue;
-                case '\t':
-                case ' ':
-                  goto label_28;
-                case '\n':
-                  goto label_27;
-                case '\r':
-                  goto label_26;
-                case '"':
-                case '\'':
-                  goto label_6;
-                case ',':
-                  goto label_22;
-                case '-':
-                  goto label_7;
-                case '.':
-                case '0':
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                case '6':
-                case '7':
-                case '8':
-                case '9':
-                  goto label_10;
-                case '/':
-                  goto label_21;
-                case 'I':
-                  goto label_18;
-                case 'N':
-                  goto label_19;
-                case ']':
-                  goto label_23;
-                case 'f':
-                case 't':
-                  goto label_13;
-                case 'n':
-                  goto label_20;
-                default:
-                  goto label_29;
-              }
-            }
-            while (!this.ReadNullChar());
-            this.SetToken(JsonToken.None, (object) null, false);
-            return (object) null;
-label_6:
-            this.ParseString(ch, readType);
-            return this.FinishReadQuotedStringValue(readType);
-label_7:
-            if (this.EnsureChars(1, true) && this._chars[this._charPos + 1] == 'I')
-              return this.ParseNumberNegativeInfinity(readType);
-            this.ParseNumber(readType);
-            return this.Value;
-label_10:
-            if (readType != ReadType.ReadAsString)
-            {
-              ++this._charPos;
-              throw this.CreateUnexpectedCharacterException(ch);
-            }
-            this.ParseNumber(ReadType.ReadAsString);
-            return this.Value;
-label_13:
-            if (readType != ReadType.ReadAsString)
-            {
-              ++this._charPos;
-              throw this.CreateUnexpectedCharacterException(ch);
-            }
-            string str = ch == 't' ? JsonConvert.True : JsonConvert.False;
-            if (!this.MatchValueWithTrailingSeparator(str))
-              throw this.CreateUnexpectedCharacterException(this._chars[this._charPos]);
-            this.SetToken(JsonToken.String, (object) str);
-            return (object) str;
-label_18:
-            return this.ParseNumberPositiveInfinity(readType);
-label_19:
-            return this.ParseNumberNaN(readType);
-label_20:
-            this.HandleNull();
-            return (object) null;
-label_21:
-            this.ParseComment(false);
-            continue;
-label_22:
-            this.ProcessValueComma();
-            continue;
-label_23:
-            ++this._charPos;
-            if (this._currentState != JsonReader.State.Array && this._currentState != JsonReader.State.ArrayStart && this._currentState != JsonReader.State.PostValue)
-              throw this.CreateUnexpectedCharacterException(ch);
-            this.SetToken(JsonToken.EndArray);
-            return (object) null;
-label_26:
-            this.ProcessCarriageReturn(false);
-            continue;
-label_27:
-            this.ProcessLineFeed();
-            continue;
-label_28:
-            ++this._charPos;
-            continue;
-label_29:
-            ++this._charPos;
-          }
-          while (char.IsWhiteSpace(ch));
-          throw this.CreateUnexpectedCharacterException(ch);
-        case JsonReader.State.PostValue:
-          if (this.ParsePostValue(true))
-            return (object) null;
-          goto case JsonReader.State.Start;
-        case JsonReader.State.Finished:
-          this.ReadFinished();
-          return (object) null;
-        default:
-          throw JsonReaderException.Create((JsonReader) this, "Unexpected state: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.CurrentState));
-      }
-    }
-
-    private object FinishReadQuotedStringValue(ReadType readType)
-    {
-      switch (readType)
-      {
-        case ReadType.ReadAsBytes:
-        case ReadType.ReadAsString:
-          return this.Value;
-        case ReadType.ReadAsDateTime:
-          return this.Value is DateTime dateTime ? (object) dateTime : (object) this.ReadDateTimeString((string) this.Value);
-        case ReadType.ReadAsDateTimeOffset:
-          return this.Value is DateTimeOffset dateTimeOffset ? (object) dateTimeOffset : (object) this.ReadDateTimeOffsetString((string) this.Value);
-        default:
-          throw new ArgumentOutOfRangeException(nameof (readType));
-      }
-    }
-
-    private JsonReaderException CreateUnexpectedCharacterException(char c)
-    {
-      return JsonReaderException.Create((JsonReader) this, "Unexpected character encountered while parsing value: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) c));
-    }
-
-    public override bool? ReadAsBoolean()
-    {
-      this.EnsureBuffer();
-      switch (this._currentState)
-      {
-        case JsonReader.State.Start:
-        case JsonReader.State.Property:
-        case JsonReader.State.ArrayStart:
-        case JsonReader.State.Array:
-        case JsonReader.State.ConstructorStart:
-        case JsonReader.State.Constructor:
-          char ch;
-          do
-          {
-            do
-            {
-              ch = this._chars[this._charPos];
-              switch (ch)
-              {
-                case char.MinValue:
-                  continue;
-                case '\t':
-                case ' ':
-                  goto label_19;
-                case '\n':
-                  goto label_18;
-                case '\r':
-                  goto label_17;
-                case '"':
-                case '\'':
-                  goto label_6;
-                case ',':
-                  goto label_13;
-                case '-':
-                case '.':
-                case '0':
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                case '6':
-                case '7':
-                case '8':
-                case '9':
-                  goto label_8;
-                case '/':
-                  goto label_12;
-                case ']':
-                  goto label_14;
-                case 'f':
-                case 't':
-                  goto label_9;
-                case 'n':
-                  goto label_7;
-                default:
-                  goto label_20;
-              }
-            }
-            while (!this.ReadNullChar());
-            this.SetToken(JsonToken.None, (object) null, false);
-            return new bool?();
-label_6:
-            this.ParseString(ch, ReadType.Read);
-            return this.ReadBooleanString(this._stringReference.ToString());
-label_7:
-            this.HandleNull();
-            return new bool?();
-label_8:
-            this.ParseNumber(ReadType.Read);
-            bool boolean = Convert.ToBoolean(this.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-            this.SetToken(JsonToken.Boolean, (object) boolean, false);
-            return new bool?(boolean);
-label_9:
-            bool flag = ch == 't';
-            if (!this.MatchValueWithTrailingSeparator(flag ? JsonConvert.True : JsonConvert.False))
-              throw this.CreateUnexpectedCharacterException(this._chars[this._charPos]);
-            this.SetToken(JsonToken.Boolean, (object) flag);
-            return new bool?(flag);
-label_12:
-            this.ParseComment(false);
-            continue;
-label_13:
-            this.ProcessValueComma();
-            continue;
-label_14:
-            ++this._charPos;
-            if (this._currentState != JsonReader.State.Array && this._currentState != JsonReader.State.ArrayStart && this._currentState != JsonReader.State.PostValue)
-              throw this.CreateUnexpectedCharacterException(ch);
-            this.SetToken(JsonToken.EndArray);
-            return new bool?();
-label_17:
-            this.ProcessCarriageReturn(false);
-            continue;
-label_18:
-            this.ProcessLineFeed();
-            continue;
-label_19:
-            ++this._charPos;
-            continue;
-label_20:
-            ++this._charPos;
-          }
-          while (char.IsWhiteSpace(ch));
-          throw this.CreateUnexpectedCharacterException(ch);
-        case JsonReader.State.PostValue:
-          if (this.ParsePostValue(true))
-            return new bool?();
-          goto case JsonReader.State.Start;
-        case JsonReader.State.Finished:
-          this.ReadFinished();
-          return new bool?();
-        default:
-          throw JsonReaderException.Create((JsonReader) this, "Unexpected state: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.CurrentState));
-      }
-    }
-
-    private void ProcessValueComma()
-    {
-      ++this._charPos;
-      if (this._currentState != JsonReader.State.PostValue)
-      {
-        this.SetToken(JsonToken.Undefined);
-        JsonReaderException characterException = this.CreateUnexpectedCharacterException(',');
-        --this._charPos;
-        throw characterException;
-      }
-      this.SetStateBasedOnCurrent();
-    }
-
-    private object ReadNumberValue(ReadType readType)
-    {
-      this.EnsureBuffer();
-      switch (this._currentState)
-      {
-        case JsonReader.State.Start:
-        case JsonReader.State.Property:
-        case JsonReader.State.ArrayStart:
-        case JsonReader.State.Array:
-        case JsonReader.State.ConstructorStart:
-        case JsonReader.State.Constructor:
-          char ch;
-          do
-          {
-            do
-            {
-              ch = this._chars[this._charPos];
-              switch (ch)
-              {
-                case char.MinValue:
-                  continue;
-                case '\t':
-                case ' ':
-                  goto label_21;
-                case '\n':
-                  goto label_20;
-                case '\r':
-                  goto label_19;
-                case '"':
-                case '\'':
-                  goto label_6;
-                case ',':
-                  goto label_15;
-                case '-':
-                  goto label_10;
-                case '.':
-                case '0':
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                case '6':
-                case '7':
-                case '8':
-                case '9':
-                  goto label_13;
-                case '/':
-                  goto label_14;
-                case 'I':
-                  goto label_9;
-                case 'N':
-                  goto label_8;
-                case ']':
-                  goto label_16;
-                case 'n':
-                  goto label_7;
-                default:
-                  goto label_22;
-              }
-            }
-            while (!this.ReadNullChar());
-            this.SetToken(JsonToken.None, (object) null, false);
-            return (object) null;
-label_6:
-            this.ParseString(ch, readType);
-            return this.FinishReadQuotedNumber(readType);
-label_7:
-            this.HandleNull();
-            return (object) null;
-label_8:
-            return this.ParseNumberNaN(readType);
-label_9:
-            return this.ParseNumberPositiveInfinity(readType);
-label_10:
-            if (this.EnsureChars(1, true) && this._chars[this._charPos + 1] == 'I')
-              return this.ParseNumberNegativeInfinity(readType);
-            this.ParseNumber(readType);
-            return this.Value;
-label_13:
-            this.ParseNumber(readType);
-            return this.Value;
-label_14:
-            this.ParseComment(false);
-            continue;
-label_15:
-            this.ProcessValueComma();
-            continue;
-label_16:
-            ++this._charPos;
-            if (this._currentState != JsonReader.State.Array && this._currentState != JsonReader.State.ArrayStart && this._currentState != JsonReader.State.PostValue)
-              throw this.CreateUnexpectedCharacterException(ch);
-            this.SetToken(JsonToken.EndArray);
-            return (object) null;
-label_19:
-            this.ProcessCarriageReturn(false);
-            continue;
-label_20:
-            this.ProcessLineFeed();
-            continue;
-label_21:
-            ++this._charPos;
-            continue;
-label_22:
-            ++this._charPos;
-          }
-          while (char.IsWhiteSpace(ch));
-          throw this.CreateUnexpectedCharacterException(ch);
-        case JsonReader.State.PostValue:
-          if (this.ParsePostValue(true))
-            return (object) null;
-          goto case JsonReader.State.Start;
-        case JsonReader.State.Finished:
-          this.ReadFinished();
-          return (object) null;
-        default:
-          throw JsonReaderException.Create((JsonReader) this, "Unexpected state: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.CurrentState));
-      }
-    }
-
-    private object FinishReadQuotedNumber(ReadType readType)
-    {
-      if (readType == ReadType.ReadAsInt32)
-        return (object) this.ReadInt32String(this._stringReference.ToString());
-      if (readType == ReadType.ReadAsDecimal)
-        return (object) this.ReadDecimalString(this._stringReference.ToString());
-      if (readType == ReadType.ReadAsDouble)
-        return (object) this.ReadDoubleString(this._stringReference.ToString());
-      throw new ArgumentOutOfRangeException(nameof (readType));
-    }
-
-    public override DateTimeOffset? ReadAsDateTimeOffset()
-    {
-      return (DateTimeOffset?) this.ReadStringValue(ReadType.ReadAsDateTimeOffset);
-    }
-
-    public override Decimal? ReadAsDecimal()
-    {
-      return (Decimal?) this.ReadNumberValue(ReadType.ReadAsDecimal);
-    }
-
-    public override double? ReadAsDouble() => (double?) this.ReadNumberValue(ReadType.ReadAsDouble);
-
-    private void HandleNull()
-    {
-      if (this.EnsureChars(1, true))
-      {
-        if (this._chars[this._charPos + 1] == 'u')
-        {
-          this.ParseNull();
-        }
-        else
-        {
-          this._charPos += 2;
-          throw this.CreateUnexpectedCharacterException(this._chars[this._charPos - 1]);
-        }
-      }
-      else
-      {
-        this._charPos = this._charsUsed;
-        throw this.CreateUnexpectedEndException();
-      }
-    }
-
-    private void ReadFinished()
-    {
-      if (this.EnsureChars(0, false))
-      {
-        this.EatWhitespace();
-        if (this._isEndOfFile)
-          return;
-        if (this._chars[this._charPos] != '/')
-          throw JsonReaderException.Create((JsonReader) this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._chars[this._charPos]));
-        this.ParseComment(false);
-      }
-      this.SetToken(JsonToken.None);
-    }
-
-    private bool ReadNullChar()
-    {
-      if (this._charsUsed == this._charPos)
-      {
-        if (this.ReadData(false) == 0)
-        {
-          this._isEndOfFile = true;
-          return true;
-        }
-      }
-      else
-        ++this._charPos;
-      return false;
-    }
-
-    private void EnsureBuffer()
-    {
-      if (this._chars != null)
-        return;
-      this._chars = BufferUtils.RentBuffer(this._arrayPool, 1024);
-      this._chars[0] = char.MinValue;
-    }
-
-    private void ReadStringIntoBuffer(char quote)
-    {
-      int charPos1 = this._charPos;
-      int charPos2 = this._charPos;
-      int lastWritePosition = this._charPos;
-      this._stringBuffer.Position = 0;
-      do
-      {
-        char ch1 = this._chars[charPos1++];
-        if (ch1 <= '\r')
-        {
-          if (ch1 != char.MinValue)
-          {
-            if (ch1 != '\n')
-            {
-              if (ch1 == '\r')
-              {
-                this._charPos = charPos1 - 1;
-                this.ProcessCarriageReturn(true);
-                charPos1 = this._charPos;
-              }
-            }
-            else
-            {
-              this._charPos = charPos1 - 1;
-              this.ProcessLineFeed();
-              charPos1 = this._charPos;
-            }
-          }
-          else if (this._charsUsed == charPos1 - 1)
-          {
-            --charPos1;
-            if (this.ReadData(true) == 0)
-            {
-              this._charPos = charPos1;
-              throw JsonReaderException.Create((JsonReader) this, "Unterminated string. Expected delimiter: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) quote));
-            }
-          }
-        }
-        else if (ch1 != '"' && ch1 != '\'')
-        {
-          if (ch1 == '\\')
-          {
-            this._charPos = charPos1;
-            if (!this.EnsureChars(0, true))
-              throw JsonReaderException.Create((JsonReader) this, "Unterminated string. Expected delimiter: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) quote));
-            int writeToPosition = charPos1 - 1;
-            char ch2 = this._chars[charPos1];
-            ++charPos1;
-            char ch3;
-            switch (ch2)
-            {
-              case '"':
-              case '\'':
-              case '/':
-                ch3 = ch2;
-                break;
-              case '\\':
-                ch3 = '\\';
-                break;
-              case 'b':
-                ch3 = '\b';
-                break;
-              case 'f':
-                ch3 = '\f';
-                break;
-              case 'n':
-                ch3 = '\n';
-                break;
-              case 'r':
-                ch3 = '\r';
-                break;
-              case 't':
-                ch3 = '\t';
-                break;
-              case 'u':
-                this._charPos = charPos1;
-                ch3 = this.ParseUnicode();
-                if (StringUtils.IsLowSurrogate(ch3))
-                  ch3 = '?';
-                else if (StringUtils.IsHighSurrogate(ch3))
-                {
-                  bool flag;
-                  do
-                  {
-                    flag = false;
-                    if (this.EnsureChars(2, true) && this._chars[this._charPos] == '\\' && this._chars[this._charPos + 1] == 'u')
-                    {
-                      char writeChar = ch3;
-                      this._charPos += 2;
-                      ch3 = this.ParseUnicode();
-                      if (!StringUtils.IsLowSurrogate(ch3))
-                      {
-                        if (StringUtils.IsHighSurrogate(ch3))
-                        {
-                          writeChar = '?';
-                          flag = true;
-                        }
-                        else
-                          writeChar = '?';
-                      }
-                      this.EnsureBufferNotEmpty();
-                      this.WriteCharToBuffer(writeChar, lastWritePosition, writeToPosition);
-                      lastWritePosition = this._charPos;
-                    }
-                    else
-                      ch3 = '?';
-                  }
-                  while (flag);
-                }
-                charPos1 = this._charPos;
-                break;
-              default:
-                this._charPos = charPos1;
-                throw JsonReaderException.Create((JsonReader) this, "Bad JSON escape sequence: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) ("\\" + ch2.ToString())));
-            }
-            this.EnsureBufferNotEmpty();
-            this.WriteCharToBuffer(ch3, lastWritePosition, writeToPosition);
-            lastWritePosition = charPos1;
-          }
-        }
-      }
-      while ((int) this._chars[charPos1 - 1] != (int) quote);
-      this.FinishReadStringIntoBuffer(charPos1 - 1, charPos2, lastWritePosition);
-    }
-
-    private void FinishReadStringIntoBuffer(
-      int charPos,
-      int initialPosition,
-      int lastWritePosition)
-    {
-      if (initialPosition == lastWritePosition)
-      {
-        this._stringReference = new StringReference(this._chars, initialPosition, charPos - initialPosition);
-      }
-      else
-      {
-        this.EnsureBufferNotEmpty();
-        if (charPos > lastWritePosition)
-          this._stringBuffer.Append(this._arrayPool, this._chars, lastWritePosition, charPos - lastWritePosition);
-        this._stringReference = new StringReference(this._stringBuffer.InternalBuffer, 0, this._stringBuffer.Position);
-      }
-      this._charPos = charPos + 1;
-    }
-
-    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition)
-    {
-      if (writeToPosition > lastWritePosition)
-        this._stringBuffer.Append(this._arrayPool, this._chars, lastWritePosition, writeToPosition - lastWritePosition);
-      this._stringBuffer.Append(this._arrayPool, writeChar);
-    }
-
-    private char ConvertUnicode(bool enoughChars)
-    {
-      if (!enoughChars)
-        throw JsonReaderException.Create((JsonReader) this, "Unexpected end while parsing Unicode escape sequence.");
-      int num1;
-      if (!ConvertUtils.TryHexTextToInt(this._chars, this._charPos, this._charPos + 4, out num1))
-        throw JsonReaderException.Create((JsonReader) this, "Invalid Unicode escape sequence: \\u{0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) new string(this._chars, this._charPos, 4)));
-      int num2 = (int) Convert.ToChar(num1);
-      this._charPos += 4;
-      return (char) num2;
-    }
-
-    private char ParseUnicode() => this.ConvertUnicode(this.EnsureChars(4, true));
-
-    private void ReadNumberIntoBuffer()
-    {
-      int charPos = this._charPos;
-      while (true)
-      {
-        char currentChar;
-        do
-        {
-          currentChar = this._chars[charPos];
-          if (currentChar == char.MinValue)
-            this._charPos = charPos;
-          else
-            goto label_5;
-        }
-        while (this._charsUsed == charPos && this.ReadData(true) != 0);
-        break;
-label_5:
-        if (!this.ReadNumberCharIntoBuffer(currentChar, charPos))
-          ++charPos;
-        else
-          goto label_4;
-      }
-      return;
-label_4:;
-    }
-
-    private bool ReadNumberCharIntoBuffer(char currentChar, int charPos)
-    {
-      switch (currentChar)
-      {
-        case '+':
-        case '-':
-        case '.':
-        case '0':
-        case '1':
-        case '2':
-        case '3':
-        case '4':
-        case '5':
-        case '6':
-        case '7':
-        case '8':
-        case '9':
-        case 'A':
-        case 'B':
-        case 'C':
-        case 'D':
-        case 'E':
-        case 'F':
-        case 'X':
-        case 'a':
-        case 'b':
-        case 'c':
-        case 'd':
-        case 'e':
-        case 'f':
-        case 'x':
-          return false;
-        default:
-          this._charPos = charPos;
-          if (char.IsWhiteSpace(currentChar) || currentChar == ',' || currentChar == '}' || currentChar == ']' || currentChar == ')' || currentChar == '/')
-            return true;
-          throw JsonReaderException.Create((JsonReader) this, "Unexpected character encountered while parsing number: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) currentChar));
-      }
-    }
-
-    private void ClearRecentString()
-    {
-      this._stringBuffer.Position = 0;
-      this._stringReference = new StringReference();
-    }
-
-    private bool ParsePostValue(bool ignoreComments)
-    {
-      char c;
-      while (true)
-      {
-        do
-        {
-          do
-          {
-            c = this._chars[this._charPos];
-            switch (c)
-            {
-              case char.MinValue:
-                if (this._charsUsed == this._charPos)
-                  continue;
-                goto label_4;
-              case '\t':
-              case ' ':
-                goto label_11;
-              case '\n':
-                goto label_13;
-              case '\r':
-                goto label_12;
-              case ')':
-                goto label_7;
-              case ',':
-                goto label_10;
-              case '/':
-                goto label_8;
-              case ']':
-                goto label_6;
-              case '}':
-                goto label_5;
-              default:
-                goto label_14;
-            }
-          }
-          while (this.ReadData(false) != 0);
-          this._currentState = JsonReader.State.Finished;
-          return false;
-label_4:
-          ++this._charPos;
-          continue;
-label_5:
-          ++this._charPos;
-          this.SetToken(JsonToken.EndObject);
-          return true;
-label_6:
-          ++this._charPos;
-          this.SetToken(JsonToken.EndArray);
-          return true;
-label_7:
-          ++this._charPos;
-          this.SetToken(JsonToken.EndConstructor);
-          return true;
-label_8:
-          this.ParseComment(!ignoreComments);
-        }
-        while (ignoreComments);
-        break;
-label_11:
-        ++this._charPos;
-        continue;
-label_12:
-        this.ProcessCarriageReturn(false);
-        continue;
-label_13:
-        this.ProcessLineFeed();
-        continue;
-label_14:
-        if (char.IsWhiteSpace(c))
-          ++this._charPos;
-        else
-          goto label_16;
-      }
-      return true;
-label_10:
-      ++this._charPos;
-      this.SetStateBasedOnCurrent();
-      return false;
-label_16:
-      if (!this.SupportMultipleContent || this.Depth != 0)
-        throw JsonReaderException.Create((JsonReader) this, "After parsing a value an unexpected character was encountered: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) c));
-      this.SetStateBasedOnCurrent();
-      return false;
-    }
-
-    private bool ParseObject()
-    {
-      while (true)
-      {
-        char c;
-        do
-        {
-          c = this._chars[this._charPos];
-          switch (c)
-          {
-            case char.MinValue:
-              if (this._charsUsed == this._charPos)
-                continue;
-              goto label_4;
-            case '\t':
-            case ' ':
-              goto label_9;
-            case '\n':
-              goto label_8;
-            case '\r':
-              goto label_7;
-            case '/':
-              goto label_6;
-            case '}':
-              goto label_5;
-            default:
-              goto label_10;
-          }
-        }
-        while (this.ReadData(false) != 0);
-        break;
-label_4:
-        ++this._charPos;
-        continue;
-label_7:
-        this.ProcessCarriageReturn(false);
-        continue;
-label_8:
-        this.ProcessLineFeed();
-        continue;
-label_9:
-        ++this._charPos;
-        continue;
-label_10:
-        if (char.IsWhiteSpace(c))
-          ++this._charPos;
-        else
-          goto label_12;
-      }
-      return false;
-label_5:
-      this.SetToken(JsonToken.EndObject);
-      ++this._charPos;
-      return true;
-label_6:
-      this.ParseComment(true);
-      return true;
-label_12:
-      return this.ParseProperty();
-    }
-
-    private bool ParseProperty()
-    {
-      char ch = this._chars[this._charPos];
-      char quote;
-      switch (ch)
-      {
-        case '"':
-        case '\'':
-          ++this._charPos;
-          quote = ch;
-          this.ShiftBufferIfNeeded();
-          this.ReadStringIntoBuffer(quote);
-          break;
-        default:
-          if (!this.ValidIdentifierChar(ch))
-            throw JsonReaderException.Create((JsonReader) this, "Invalid property identifier character: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._chars[this._charPos]));
-          quote = char.MinValue;
-          this.ShiftBufferIfNeeded();
-          this.ParseUnquotedProperty();
-          break;
-      }
-      string str = this.NameTable == null ? this._stringReference.ToString() : this.NameTable.Get(this._stringReference.Chars, this._stringReference.StartIndex, this._stringReference.Length) ?? this._stringReference.ToString();
-      this.EatWhitespace();
-      if (this._chars[this._charPos] != ':')
-        throw JsonReaderException.Create((JsonReader) this, "Invalid character after parsing property name. Expected ':' but got: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._chars[this._charPos]));
-      ++this._charPos;
-      this.SetToken(JsonToken.PropertyName, (object) str);
-      this._quoteChar = quote;
-      this.ClearRecentString();
-      return true;
-    }
-
-    private bool ValidIdentifierChar(char value)
-    {
-      return char.IsLetterOrDigit(value) || value == '_' || value == '$';
-    }
-
-    private void ParseUnquotedProperty()
-    {
-      int charPos = this._charPos;
-      char currentChar;
-      do
-      {
-        currentChar = this._chars[this._charPos];
-        if (currentChar == char.MinValue)
-        {
-          if (this._charsUsed == this._charPos)
-          {
-            if (this.ReadData(true) == 0)
-              throw JsonReaderException.Create((JsonReader) this, "Unexpected end while parsing unquoted property name.");
-          }
-          else
-          {
-            this._stringReference = new StringReference(this._chars, charPos, this._charPos - charPos);
-            break;
-          }
-        }
-      }
-      while (!this.ReadUnquotedPropertyReportIfDone(currentChar, charPos));
-    }
-
-    private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition)
-    {
-      if (this.ValidIdentifierChar(currentChar))
-      {
-        ++this._charPos;
-        return false;
-      }
-      if (!char.IsWhiteSpace(currentChar) && currentChar != ':')
-        throw JsonReaderException.Create((JsonReader) this, "Invalid JavaScript property identifier character: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) currentChar));
-      this._stringReference = new StringReference(this._chars, initialPosition, this._charPos - initialPosition);
-      return true;
-    }
-
-    private bool ParseValue()
-    {
-      char ch;
-      while (true)
-      {
-        do
-        {
-          ch = this._chars[this._charPos];
-          switch (ch)
-          {
-            case char.MinValue:
-              if (this._charsUsed == this._charPos)
-                continue;
-              goto label_4;
-            case '\t':
-            case ' ':
-              goto label_30;
-            case '\n':
-              goto label_29;
-            case '\r':
-              goto label_28;
-            case '"':
-            case '\'':
-              goto label_5;
-            case ')':
-              goto label_27;
-            case ',':
-              goto label_26;
-            case '-':
-              goto label_17;
-            case '/':
-              goto label_21;
-            case 'I':
-              goto label_16;
-            case 'N':
-              goto label_15;
-            case '[':
-              goto label_24;
-            case ']':
-              goto label_25;
-            case 'f':
-              goto label_7;
-            case 'n':
-              goto label_8;
-            case 't':
-              goto label_6;
-            case 'u':
-              goto label_22;
-            case '{':
-              goto label_23;
-            default:
-              goto label_31;
-          }
-        }
-        while (this.ReadData(false) != 0);
-        break;
-label_4:
-        ++this._charPos;
-        continue;
-label_28:
-        this.ProcessCarriageReturn(false);
-        continue;
-label_29:
-        this.ProcessLineFeed();
-        continue;
-label_30:
-        ++this._charPos;
-        continue;
-label_31:
-        if (char.IsWhiteSpace(ch))
-          ++this._charPos;
-        else
-          goto label_33;
-      }
-      return false;
-label_5:
-      this.ParseString(ch, ReadType.Read);
-      return true;
-label_6:
-      this.ParseTrue();
-      return true;
-label_7:
-      this.ParseFalse();
-      return true;
-label_8:
-      if (this.EnsureChars(1, true))
-      {
-        switch (this._chars[this._charPos + 1])
-        {
-          case 'e':
-            this.ParseConstructor();
-            break;
-          case 'u':
-            this.ParseNull();
-            break;
-          default:
-            throw this.CreateUnexpectedCharacterException(this._chars[this._charPos]);
-        }
-        return true;
-      }
-      ++this._charPos;
-      throw this.CreateUnexpectedEndException();
-label_15:
-      this.ParseNumberNaN(ReadType.Read);
-      return true;
-label_16:
-      this.ParseNumberPositiveInfinity(ReadType.Read);
-      return true;
-label_17:
-      if (this.EnsureChars(1, true) && this._chars[this._charPos + 1] == 'I')
-        this.ParseNumberNegativeInfinity(ReadType.Read);
-      else
-        this.ParseNumber(ReadType.Read);
-      return true;
-label_21:
-      this.ParseComment(true);
-      return true;
-label_22:
-      this.ParseUndefined();
-      return true;
-label_23:
-      ++this._charPos;
-      this.SetToken(JsonToken.StartObject);
-      return true;
-label_24:
-      ++this._charPos;
-      this.SetToken(JsonToken.StartArray);
-      return true;
-label_25:
-      ++this._charPos;
-      this.SetToken(JsonToken.EndArray);
-      return true;
-label_26:
-      this.SetToken(JsonToken.Undefined);
-      return true;
-label_27:
-      ++this._charPos;
-      this.SetToken(JsonToken.EndConstructor);
-      return true;
-label_33:
-      if (!char.IsNumber(ch) && ch != '-' && ch != '.')
-        throw this.CreateUnexpectedCharacterException(ch);
-      this.ParseNumber(ReadType.Read);
-      return true;
-    }
-
-    private void ProcessLineFeed()
-    {
-      ++this._charPos;
-      this.OnNewLine(this._charPos);
-    }
-
-    private void ProcessCarriageReturn(bool append)
-    {
-      ++this._charPos;
-      this.SetNewLine(this.EnsureChars(1, append));
-    }
-
-    private void EatWhitespace()
-    {
-      while (true)
-      {
-        char c;
-        do
-        {
-          c = this._chars[this._charPos];
-          switch (c)
-          {
-            case char.MinValue:
-              if (this._charsUsed == this._charPos)
-                continue;
-              goto label_5;
-            case '\n':
-              goto label_7;
-            case '\r':
-              goto label_6;
-            case ' ':
-              goto label_9;
-            default:
-              goto label_8;
-          }
-        }
-        while (this.ReadData(false) != 0);
-        break;
-label_5:
-        ++this._charPos;
-        continue;
-label_6:
-        this.ProcessCarriageReturn(false);
-        continue;
-label_7:
-        this.ProcessLineFeed();
-        continue;
-label_8:
-        if (!char.IsWhiteSpace(c))
-          goto label_4;
-label_9:
-        ++this._charPos;
-      }
-      return;
-label_4:;
-    }
-
-    private void ParseConstructor()
-    {
-      if (!this.MatchValueWithTrailingSeparator("new"))
-        throw JsonReaderException.Create((JsonReader) this, "Unexpected content while parsing JSON.");
-      this.EatWhitespace();
-      int charPos1 = this._charPos;
-      char c;
-      while (true)
-      {
-        do
-        {
-          c = this._chars[this._charPos];
-          if (c == char.MinValue)
-          {
-            if (this._charsUsed != this._charPos)
-              goto label_6;
-          }
-          else
-            goto label_7;
-        }
-        while (this.ReadData(true) != 0);
-        break;
-label_7:
-        if (char.IsLetterOrDigit(c))
-          ++this._charPos;
-        else
-          goto label_9;
-      }
-      throw JsonReaderException.Create((JsonReader) this, "Unexpected end while parsing constructor.");
-label_6:
-      int charPos2 = this._charPos;
-      ++this._charPos;
-      goto label_17;
-label_9:
-      switch (c)
-      {
-        case '\n':
-          charPos2 = this._charPos;
-          this.ProcessLineFeed();
-          break;
-        case '\r':
-          charPos2 = this._charPos;
-          this.ProcessCarriageReturn(true);
-          break;
-        default:
-          if (char.IsWhiteSpace(c))
-          {
-            charPos2 = this._charPos;
-            ++this._charPos;
-            break;
-          }
-          if (c != '(')
-            throw JsonReaderException.Create((JsonReader) this, "Unexpected character while parsing constructor: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) c));
-          charPos2 = this._charPos;
-          break;
-      }
-label_17:
-      this._stringReference = new StringReference(this._chars, charPos1, charPos2 - charPos1);
-      string str = this._stringReference.ToString();
-      this.EatWhitespace();
-      if (this._chars[this._charPos] != '(')
-        throw JsonReaderException.Create((JsonReader) this, "Unexpected character while parsing constructor: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._chars[this._charPos]));
-      ++this._charPos;
-      this.ClearRecentString();
-      this.SetToken(JsonToken.StartConstructor, (object) str);
-    }
-
-    private void ParseNumber(ReadType readType)
-    {
-      this.ShiftBufferIfNeeded();
-      char firstChar = this._chars[this._charPos];
-      int charPos = this._charPos;
-      this.ReadNumberIntoBuffer();
-      this.ParseReadNumber(readType, firstChar, charPos);
-    }
-
-    private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition)
-    {
-      this.SetPostValueState(true);
-      this._stringReference = new StringReference(this._chars, initialPosition, this._charPos - initialPosition);
-      bool flag1 = char.IsDigit(firstChar) && this._stringReference.Length == 1;
-      bool flag2 = firstChar == '0' && this._stringReference.Length > 1 && this._stringReference.Chars[this._stringReference.StartIndex + 1] != '.' && this._stringReference.Chars[this._stringReference.StartIndex + 1] != 'e' && this._stringReference.Chars[this._stringReference.StartIndex + 1] != 'E';
-      JsonToken newToken;
-      object obj;
-      switch (readType)
-      {
-        case ReadType.ReadAsInt32:
-          if (flag1)
-            obj = (object) ((int) firstChar - 48);
-          else if (flag2)
-          {
-            string str = this._stringReference.ToString();
-            try
-            {
-              obj = (object) (str.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt32(str, 16) : Convert.ToInt32(str, 8));
-            }
-            catch (Exception ex)
-            {
-              throw this.ThrowReaderError("Input string '{0}' is not a valid integer.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str), ex);
-            }
-          }
-          else
-          {
-            int num;
-            switch (ConvertUtils.Int32TryParse(this._stringReference.Chars, this._stringReference.StartIndex, this._stringReference.Length, out num))
-            {
-              case ParseResult.Success:
-                obj = (object) num;
-                break;
-              case ParseResult.Overflow:
-                throw this.ThrowReaderError("JSON integer {0} is too large or small for an Int32.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._stringReference.ToString()));
-              default:
-                throw this.ThrowReaderError("Input string '{0}' is not a valid integer.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._stringReference.ToString()));
-            }
-          }
-          newToken = JsonToken.Integer;
-          break;
-        case ReadType.ReadAsString:
-          string s = this._stringReference.ToString();
-          if (flag2)
-          {
-            try
-            {
-              if (s.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
-                Convert.ToInt64(s, 16);
-              else
-                Convert.ToInt64(s, 8);
-            }
-            catch (Exception ex)
-            {
-              throw this.ThrowReaderError("Input string '{0}' is not a valid number.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) s), ex);
-            }
-          }
-          else if (!double.TryParse(s, NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out double _))
-            throw this.ThrowReaderError("Input string '{0}' is not a valid number.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._stringReference.ToString()));
-          newToken = JsonToken.String;
-          obj = (object) s;
-          break;
-        case ReadType.ReadAsDecimal:
-          if (flag1)
-            obj = (object) ((Decimal) firstChar - 48M);
-          else if (flag2)
-          {
-            string str = this._stringReference.ToString();
-            try
-            {
-              obj = (object) Convert.ToDecimal(str.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(str, 16) : Convert.ToInt64(str, 8));
-            }
-            catch (Exception ex)
-            {
-              throw this.ThrowReaderError("Input string '{0}' is not a valid decimal.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str), ex);
-            }
-          }
-          else
-          {
-            Decimal num;
-            if (ConvertUtils.DecimalTryParse(this._stringReference.Chars, this._stringReference.StartIndex, this._stringReference.Length, out num) != ParseResult.Success)
-              throw this.ThrowReaderError("Input string '{0}' is not a valid decimal.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._stringReference.ToString()));
-            obj = (object) num;
-          }
-          newToken = JsonToken.Float;
-          break;
-        case ReadType.ReadAsDouble:
-          if (flag1)
-            obj = (object) ((double) firstChar - 48.0);
-          else if (flag2)
-          {
-            string str = this._stringReference.ToString();
-            try
-            {
-              obj = (object) Convert.ToDouble(str.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(str, 16) : Convert.ToInt64(str, 8));
-            }
-            catch (Exception ex)
-            {
-              throw this.ThrowReaderError("Input string '{0}' is not a valid double.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str), ex);
-            }
-          }
-          else
-          {
-            double result;
-            if (!double.TryParse(this._stringReference.ToString(), NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result))
-              throw this.ThrowReaderError("Input string '{0}' is not a valid double.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._stringReference.ToString()));
-            obj = (object) result;
-          }
-          newToken = JsonToken.Float;
-          break;
-        default:
-          if (flag1)
-          {
-            obj = (object) ((long) firstChar - 48L);
-            newToken = JsonToken.Integer;
-            break;
-          }
-          if (flag2)
-          {
-            string str = this._stringReference.ToString();
-            try
-            {
-              obj = (object) (str.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(str, 16) : Convert.ToInt64(str, 8));
-            }
-            catch (Exception ex)
-            {
-              throw this.ThrowReaderError("Input string '{0}' is not a valid number.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str), ex);
-            }
-            newToken = JsonToken.Integer;
-            break;
-          }
-          long num1;
-          switch (ConvertUtils.Int64TryParse(this._stringReference.Chars, this._stringReference.StartIndex, this._stringReference.Length, out num1))
-          {
-            case ParseResult.Success:
-              obj = (object) num1;
-              newToken = JsonToken.Integer;
-              break;
-            case ParseResult.Overflow:
-              throw this.ThrowReaderError("JSON integer {0} is too large or small for an Int64.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._stringReference.ToString()));
-            default:
-              if (this._floatParseHandling == FloatParseHandling.Decimal)
-              {
-                Decimal num2;
-                if (ConvertUtils.DecimalTryParse(this._stringReference.Chars, this._stringReference.StartIndex, this._stringReference.Length, out num2) != ParseResult.Success)
-                  throw this.ThrowReaderError("Input string '{0}' is not a valid decimal.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._stringReference.ToString()));
-                obj = (object) num2;
-              }
-              else
-              {
-                double result;
-                if (!double.TryParse(this._stringReference.ToString(), NumberStyles.Float, (IFormatProvider) CultureInfo.InvariantCulture, out result))
-                  throw this.ThrowReaderError("Input string '{0}' is not a valid number.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._stringReference.ToString()));
-                obj = (object) result;
-              }
-              newToken = JsonToken.Float;
-              break;
-          }
-          break;
-      }
-      this.ClearRecentString();
-      this.SetToken(newToken, obj, false);
-    }
-
-    private JsonReaderException ThrowReaderError(string message, Exception ex = null)
-    {
-      this.SetToken(JsonToken.Undefined, (object) null, false);
-      return JsonReaderException.Create((JsonReader) this, message, ex);
-    }
-
-    private void ParseComment(bool setToken)
-    {
-      ++this._charPos;
-      if (!this.EnsureChars(1, false))
-        throw JsonReaderException.Create((JsonReader) this, "Unexpected end while parsing comment.");
-      bool flag;
-      if (this._chars[this._charPos] == '*')
-      {
-        flag = false;
-      }
-      else
-      {
-        if (this._chars[this._charPos] != '/')
-          throw JsonReaderException.Create((JsonReader) this, "Error parsing comment. Expected: *, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._chars[this._charPos]));
-        flag = true;
-      }
-      ++this._charPos;
-      int charPos = this._charPos;
-      while (true)
-      {
-        do
-        {
-          do
-          {
-            switch (this._chars[this._charPos])
-            {
-              case char.MinValue:
-                if (this._charsUsed == this._charPos)
-                  continue;
-                goto label_14;
-              case '\n':
-                goto label_20;
-              case '\r':
-                goto label_17;
-              case '*':
-                goto label_15;
-              default:
-                goto label_23;
-            }
-          }
-          while (this.ReadData(true) != 0);
-          if (!flag)
-            throw JsonReaderException.Create((JsonReader) this, "Unexpected end while parsing comment.");
-          this.EndComment(setToken, charPos, this._charPos);
-          return;
-label_14:
-          ++this._charPos;
-          continue;
-label_15:
-          ++this._charPos;
-        }
-        while (flag || !this.EnsureChars(0, true) || this._chars[this._charPos] != '/');
-        break;
-label_17:
-        if (!flag)
-        {
-          this.ProcessCarriageReturn(true);
-          continue;
-        }
-        goto label_18;
-label_20:
-        if (!flag)
-        {
-          this.ProcessLineFeed();
-          continue;
-        }
-        goto label_21;
-label_23:
-        ++this._charPos;
-      }
-      this.EndComment(setToken, charPos, this._charPos - 1);
-      ++this._charPos;
-      return;
-label_18:
-      this.EndComment(setToken, charPos, this._charPos);
-      return;
-label_21:
-      this.EndComment(setToken, charPos, this._charPos);
-    }
-
-    private void EndComment(bool setToken, int initialPosition, int endPosition)
-    {
-      if (!setToken)
-        return;
-      this.SetToken(JsonToken.Comment, (object) new string(this._chars, initialPosition, endPosition - initialPosition));
-    }
-
-    private bool MatchValue(string value)
-    {
-      return this.MatchValue(this.EnsureChars(value.Length - 1, true), value);
-    }
-
-    private bool MatchValue(bool enoughChars, string value)
-    {
-      if (!enoughChars)
-      {
-        this._charPos = this._charsUsed;
-        throw this.CreateUnexpectedEndException();
-      }
-      for (int index = 0; index < value.Length; ++index)
-      {
-        if ((int) this._chars[this._charPos + index] != (int) value[index])
-        {
-          this._charPos += index;
-          return false;
-        }
-      }
-      this._charPos += value.Length;
-      return true;
-    }
-
-    private bool MatchValueWithTrailingSeparator(string value)
-    {
-      if (!this.MatchValue(value))
-        return false;
-      return !this.EnsureChars(0, false) || this.IsSeparator(this._chars[this._charPos]) || this._chars[this._charPos] == char.MinValue;
-    }
-
-    private bool IsSeparator(char c)
-    {
-      switch (c)
-      {
-        case '\t':
-        case '\n':
-        case '\r':
-        case ' ':
-          return true;
-        case ')':
-          if (this.CurrentState == JsonReader.State.Constructor || this.CurrentState == JsonReader.State.ConstructorStart)
-            return true;
-          break;
-        case ',':
-        case ']':
-        case '}':
-          return true;
-        case '/':
-          if (!this.EnsureChars(1, false))
-            return false;
-          char ch = this._chars[this._charPos + 1];
-          return ch == '*' || ch == '/';
-        default:
-          if (char.IsWhiteSpace(c))
-            return true;
-          break;
-      }
-      return false;
-    }
-
-    private void ParseTrue()
-    {
-      if (!this.MatchValueWithTrailingSeparator(JsonConvert.True))
-        throw JsonReaderException.Create((JsonReader) this, "Error parsing boolean value.");
-      this.SetToken(JsonToken.Boolean, (object) true);
-    }
-
-    private void ParseNull()
-    {
-      if (!this.MatchValueWithTrailingSeparator(JsonConvert.Null))
-        throw JsonReaderException.Create((JsonReader) this, "Error parsing null value.");
-      this.SetToken(JsonToken.Null);
-    }
-
-    private void ParseUndefined()
-    {
-      if (!this.MatchValueWithTrailingSeparator(JsonConvert.Undefined))
-        throw JsonReaderException.Create((JsonReader) this, "Error parsing undefined value.");
-      this.SetToken(JsonToken.Undefined);
-    }
-
-    private void ParseFalse()
-    {
-      if (!this.MatchValueWithTrailingSeparator(JsonConvert.False))
-        throw JsonReaderException.Create((JsonReader) this, "Error parsing boolean value.");
-      this.SetToken(JsonToken.Boolean, (object) false);
-    }
-
-    private object ParseNumberNegativeInfinity(ReadType readType)
-    {
-      return this.ParseNumberNegativeInfinity(readType, this.MatchValueWithTrailingSeparator(JsonConvert.NegativeInfinity));
-    }
-
-    private object ParseNumberNegativeInfinity(ReadType readType, bool matched)
-    {
-      if (matched)
-      {
-        if (readType != ReadType.Read)
-        {
-          if (readType != ReadType.ReadAsString)
-          {
-            if (readType != ReadType.ReadAsDouble)
-              goto label_7;
-          }
-          else
-          {
-            this.SetToken(JsonToken.String, (object) JsonConvert.NegativeInfinity);
-            return (object) JsonConvert.NegativeInfinity;
-          }
-        }
-        if (this._floatParseHandling == FloatParseHandling.Double)
-        {
-          this.SetToken(JsonToken.Float, (object) double.NegativeInfinity);
-          return (object) double.NegativeInfinity;
-        }
-label_7:
-        throw JsonReaderException.Create((JsonReader) this, "Cannot read -Infinity value.");
-      }
-      throw JsonReaderException.Create((JsonReader) this, "Error parsing -Infinity value.");
-    }
-
-    private object ParseNumberPositiveInfinity(ReadType readType)
-    {
-      return this.ParseNumberPositiveInfinity(readType, this.MatchValueWithTrailingSeparator(JsonConvert.PositiveInfinity));
-    }
-
-    private object ParseNumberPositiveInfinity(ReadType readType, bool matched)
-    {
-      if (matched)
-      {
-        if (readType != ReadType.Read)
-        {
-          if (readType != ReadType.ReadAsString)
-          {
-            if (readType != ReadType.ReadAsDouble)
-              goto label_7;
-          }
-          else
-          {
-            this.SetToken(JsonToken.String, (object) JsonConvert.PositiveInfinity);
-            return (object) JsonConvert.PositiveInfinity;
-          }
-        }
-        if (this._floatParseHandling == FloatParseHandling.Double)
-        {
-          this.SetToken(JsonToken.Float, (object) double.PositiveInfinity);
-          return (object) double.PositiveInfinity;
-        }
-label_7:
-        throw JsonReaderException.Create((JsonReader) this, "Cannot read Infinity value.");
-      }
-      throw JsonReaderException.Create((JsonReader) this, "Error parsing Infinity value.");
-    }
-
-    private object ParseNumberNaN(ReadType readType)
-    {
-      return this.ParseNumberNaN(readType, this.MatchValueWithTrailingSeparator(JsonConvert.NaN));
-    }
-
-    private object ParseNumberNaN(ReadType readType, bool matched)
-    {
-      if (matched)
-      {
-        if (readType != ReadType.Read)
-        {
-          if (readType != ReadType.ReadAsString)
-          {
-            if (readType != ReadType.ReadAsDouble)
-              goto label_7;
-          }
-          else
-          {
-            this.SetToken(JsonToken.String, (object) JsonConvert.NaN);
-            return (object) JsonConvert.NaN;
-          }
-        }
-        if (this._floatParseHandling == FloatParseHandling.Double)
-        {
-          this.SetToken(JsonToken.Float, (object) double.NaN);
-          return (object) double.NaN;
-        }
-label_7:
-        throw JsonReaderException.Create((JsonReader) this, "Cannot read NaN value.");
-      }
-      throw JsonReaderException.Create((JsonReader) this, "Error parsing NaN value.");
-    }
-
-    public override void Close()
-    {
-      base.Close();
-      if (this._chars != null)
-      {
-        BufferUtils.ReturnBuffer(this._arrayPool, this._chars);
-        this._chars = (char[]) null;
-      }
-      if (this.CloseInput)
-        this._reader?.Close();
-      this._stringBuffer.Clear(this._arrayPool);
-    }
-
-    public bool HasLineInfo() => true;
-
-    public int LineNumber
-    {
-      get
-      {
-        return this.CurrentState == JsonReader.State.Start && this.LinePosition == 0 && this.TokenType != JsonToken.Comment ? 0 : this._lineNumber;
-      }
-    }
-
-    public int LinePosition => this._charPos - this._lineStartPos;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonTextWriter.cs b/MSHALTester/Newtonsoft/Json/JsonTextWriter.cs
deleted file mode 100644
index 554c99c..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonTextWriter.cs
+++ /dev/null
@@ -1,579 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public class JsonTextWriter : JsonWriter
-  {
-    private const int IndentCharBufferSize = 12;
-    private readonly TextWriter _writer;
-    private Base64Encoder _base64Encoder;
-    private char _indentChar;
-    private int _indentation;
-    private char _quoteChar;
-    private bool _quoteName;
-    private bool[] _charEscapeFlags;
-    private char[] _writeBuffer;
-    private IArrayPool<char> _arrayPool;
-    private char[] _indentChars;
-
-    private Base64Encoder Base64Encoder
-    {
-      get
-      {
-        if (this._base64Encoder == null)
-          this._base64Encoder = new Base64Encoder(this._writer);
-        return this._base64Encoder;
-      }
-    }
-
-    public IArrayPool<char> ArrayPool
-    {
-      get => this._arrayPool;
-      set
-      {
-        this._arrayPool = value != null ? value : throw new ArgumentNullException(nameof (value));
-      }
-    }
-
-    public int Indentation
-    {
-      get => this._indentation;
-      set
-      {
-        this._indentation = value >= 0 ? value : throw new ArgumentException("Indentation value must be greater than 0.");
-      }
-    }
-
-    public char QuoteChar
-    {
-      get => this._quoteChar;
-      set
-      {
-        this._quoteChar = value == '"' || value == '\'' ? value : throw new ArgumentException("Invalid JavaScript string quote character. Valid quote characters are ' and \".");
-        this.UpdateCharEscapeFlags();
-      }
-    }
-
-    public char IndentChar
-    {
-      get => this._indentChar;
-      set
-      {
-        if ((int) value == (int) this._indentChar)
-          return;
-        this._indentChar = value;
-        this._indentChars = (char[]) null;
-      }
-    }
-
-    public bool QuoteName
-    {
-      get => this._quoteName;
-      set => this._quoteName = value;
-    }
-
-    public JsonTextWriter(TextWriter textWriter)
-    {
-      this._writer = textWriter != null ? textWriter : throw new ArgumentNullException(nameof (textWriter));
-      this._quoteChar = '"';
-      this._quoteName = true;
-      this._indentChar = ' ';
-      this._indentation = 2;
-      this.UpdateCharEscapeFlags();
-    }
-
-    public override void Flush() => this._writer.Flush();
-
-    public override void Close()
-    {
-      base.Close();
-      this.CloseBufferAndWriter();
-    }
-
-    private void CloseBufferAndWriter()
-    {
-      if (this._writeBuffer != null)
-      {
-        BufferUtils.ReturnBuffer(this._arrayPool, this._writeBuffer);
-        this._writeBuffer = (char[]) null;
-      }
-      if (!this.CloseOutput)
-        return;
-      this._writer?.Close();
-    }
-
-    public override void WriteStartObject()
-    {
-      this.InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
-      this._writer.Write('{');
-    }
-
-    public override void WriteStartArray()
-    {
-      this.InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
-      this._writer.Write('[');
-    }
-
-    public override void WriteStartConstructor(string name)
-    {
-      this.InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
-      this._writer.Write("new ");
-      this._writer.Write(name);
-      this._writer.Write('(');
-    }
-
-    protected override void WriteEnd(JsonToken token)
-    {
-      switch (token)
-      {
-        case JsonToken.EndObject:
-          this._writer.Write('}');
-          break;
-        case JsonToken.EndArray:
-          this._writer.Write(']');
-          break;
-        case JsonToken.EndConstructor:
-          this._writer.Write(')');
-          break;
-        default:
-          throw JsonWriterException.Create((JsonWriter) this, "Invalid JsonToken: " + (object) token, (Exception) null);
-      }
-    }
-
-    public override void WritePropertyName(string name)
-    {
-      this.InternalWritePropertyName(name);
-      this.WriteEscapedString(name, this._quoteName);
-      this._writer.Write(':');
-    }
-
-    public override void WritePropertyName(string name, bool escape)
-    {
-      this.InternalWritePropertyName(name);
-      if (escape)
-      {
-        this.WriteEscapedString(name, this._quoteName);
-      }
-      else
-      {
-        if (this._quoteName)
-          this._writer.Write(this._quoteChar);
-        this._writer.Write(name);
-        if (this._quoteName)
-          this._writer.Write(this._quoteChar);
-      }
-      this._writer.Write(':');
-    }
-
-    internal override void OnStringEscapeHandlingChanged() => this.UpdateCharEscapeFlags();
-
-    private void UpdateCharEscapeFlags()
-    {
-      this._charEscapeFlags = JavaScriptUtils.GetCharEscapeFlags(this.StringEscapeHandling, this._quoteChar);
-    }
-
-    protected override void WriteIndent()
-    {
-      int val1 = this.Top * this._indentation;
-      int index = this.SetIndentChars();
-      this._writer.Write(this._indentChars, 0, index + Math.Min(val1, 12));
-      while ((val1 -= 12) > 0)
-        this._writer.Write(this._indentChars, index, Math.Min(val1, 12));
-    }
-
-    private int SetIndentChars()
-    {
-      string newLine = this._writer.NewLine;
-      int length = newLine.Length;
-      bool flag = this._indentChars != null && this._indentChars.Length == 12 + length;
-      if (flag)
-      {
-        for (int index = 0; index != length; ++index)
-        {
-          if ((int) newLine[index] != (int) this._indentChars[index])
-          {
-            flag = false;
-            break;
-          }
-        }
-      }
-      if (!flag)
-        this._indentChars = (newLine + new string(this._indentChar, 12)).ToCharArray();
-      return length;
-    }
-
-    protected override void WriteValueDelimiter() => this._writer.Write(',');
-
-    protected override void WriteIndentSpace() => this._writer.Write(' ');
-
-    private void WriteValueInternal(string value, JsonToken token) => this._writer.Write(value);
-
-    public override void WriteValue(object value) => base.WriteValue(value);
-
-    public override void WriteNull()
-    {
-      this.InternalWriteValue(JsonToken.Null);
-      this.WriteValueInternal(JsonConvert.Null, JsonToken.Null);
-    }
-
-    public override void WriteUndefined()
-    {
-      this.InternalWriteValue(JsonToken.Undefined);
-      this.WriteValueInternal(JsonConvert.Undefined, JsonToken.Undefined);
-    }
-
-    public override void WriteRaw(string json)
-    {
-      this.InternalWriteRaw();
-      this._writer.Write(json);
-    }
-
-    public override void WriteValue(string value)
-    {
-      this.InternalWriteValue(JsonToken.String);
-      if (value == null)
-        this.WriteValueInternal(JsonConvert.Null, JsonToken.Null);
-      else
-        this.WriteEscapedString(value, true);
-    }
-
-    private void WriteEscapedString(string value, bool quote)
-    {
-      this.EnsureWriteBuffer();
-      JavaScriptUtils.WriteEscapedJavaScriptString(this._writer, value, this._quoteChar, quote, this._charEscapeFlags, this.StringEscapeHandling, this._arrayPool, ref this._writeBuffer);
-    }
-
-    public override void WriteValue(int value)
-    {
-      this.InternalWriteValue(JsonToken.Integer);
-      this.WriteIntegerValue(value);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(uint value)
-    {
-      this.InternalWriteValue(JsonToken.Integer);
-      this.WriteIntegerValue((long) value);
-    }
-
-    public override void WriteValue(long value)
-    {
-      this.InternalWriteValue(JsonToken.Integer);
-      this.WriteIntegerValue(value);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(ulong value)
-    {
-      this.InternalWriteValue(JsonToken.Integer);
-      this.WriteIntegerValue(value, false);
-    }
-
-    public override void WriteValue(float value)
-    {
-      this.InternalWriteValue(JsonToken.Float);
-      this.WriteValueInternal(JsonConvert.ToString(value, this.FloatFormatHandling, this.QuoteChar, false), JsonToken.Float);
-    }
-
-    public override void WriteValue(float? value)
-    {
-      if (!value.HasValue)
-      {
-        this.WriteNull();
-      }
-      else
-      {
-        this.InternalWriteValue(JsonToken.Float);
-        this.WriteValueInternal(JsonConvert.ToString(value.GetValueOrDefault(), this.FloatFormatHandling, this.QuoteChar, true), JsonToken.Float);
-      }
-    }
-
-    public override void WriteValue(double value)
-    {
-      this.InternalWriteValue(JsonToken.Float);
-      this.WriteValueInternal(JsonConvert.ToString(value, this.FloatFormatHandling, this.QuoteChar, false), JsonToken.Float);
-    }
-
-    public override void WriteValue(double? value)
-    {
-      if (!value.HasValue)
-      {
-        this.WriteNull();
-      }
-      else
-      {
-        this.InternalWriteValue(JsonToken.Float);
-        this.WriteValueInternal(JsonConvert.ToString(value.GetValueOrDefault(), this.FloatFormatHandling, this.QuoteChar, true), JsonToken.Float);
-      }
-    }
-
-    public override void WriteValue(bool value)
-    {
-      this.InternalWriteValue(JsonToken.Boolean);
-      this.WriteValueInternal(JsonConvert.ToString(value), JsonToken.Boolean);
-    }
-
-    public override void WriteValue(short value)
-    {
-      this.InternalWriteValue(JsonToken.Integer);
-      this.WriteIntegerValue((int) value);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(ushort value)
-    {
-      this.InternalWriteValue(JsonToken.Integer);
-      this.WriteIntegerValue((int) value);
-    }
-
-    public override void WriteValue(char value)
-    {
-      this.InternalWriteValue(JsonToken.String);
-      this.WriteValueInternal(JsonConvert.ToString(value), JsonToken.String);
-    }
-
-    public override void WriteValue(byte value)
-    {
-      this.InternalWriteValue(JsonToken.Integer);
-      this.WriteIntegerValue((int) value);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(sbyte value)
-    {
-      this.InternalWriteValue(JsonToken.Integer);
-      this.WriteIntegerValue((int) value);
-    }
-
-    public override void WriteValue(Decimal value)
-    {
-      this.InternalWriteValue(JsonToken.Float);
-      this.WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
-    }
-
-    public override void WriteValue(DateTime value)
-    {
-      this.InternalWriteValue(JsonToken.Date);
-      value = DateTimeUtils.EnsureDateTime(value, this.DateTimeZoneHandling);
-      if (string.IsNullOrEmpty(this.DateFormatString))
-      {
-        this._writer.Write(this._writeBuffer, 0, this.WriteValueToBuffer(value));
-      }
-      else
-      {
-        this._writer.Write(this._quoteChar);
-        this._writer.Write(value.ToString(this.DateFormatString, (IFormatProvider) this.Culture));
-        this._writer.Write(this._quoteChar);
-      }
-    }
-
-    private int WriteValueToBuffer(DateTime value)
-    {
-      this.EnsureWriteBuffer();
-      int num1 = 0;
-      char[] writeBuffer1 = this._writeBuffer;
-      int index1 = num1;
-      int start = index1 + 1;
-      int quoteChar1 = (int) this._quoteChar;
-      writeBuffer1[index1] = (char) quoteChar1;
-      int num2 = DateTimeUtils.WriteDateTimeString(this._writeBuffer, start, value, new TimeSpan?(), value.Kind, this.DateFormatHandling);
-      char[] writeBuffer2 = this._writeBuffer;
-      int index2 = num2;
-      int buffer = index2 + 1;
-      int quoteChar2 = (int) this._quoteChar;
-      writeBuffer2[index2] = (char) quoteChar2;
-      return buffer;
-    }
-
-    public override void WriteValue(byte[] value)
-    {
-      if (value == null)
-      {
-        this.WriteNull();
-      }
-      else
-      {
-        this.InternalWriteValue(JsonToken.Bytes);
-        this._writer.Write(this._quoteChar);
-        this.Base64Encoder.Encode(value, 0, value.Length);
-        this.Base64Encoder.Flush();
-        this._writer.Write(this._quoteChar);
-      }
-    }
-
-    public override void WriteValue(DateTimeOffset value)
-    {
-      this.InternalWriteValue(JsonToken.Date);
-      if (string.IsNullOrEmpty(this.DateFormatString))
-      {
-        this._writer.Write(this._writeBuffer, 0, this.WriteValueToBuffer(value));
-      }
-      else
-      {
-        this._writer.Write(this._quoteChar);
-        this._writer.Write(value.ToString(this.DateFormatString, (IFormatProvider) this.Culture));
-        this._writer.Write(this._quoteChar);
-      }
-    }
-
-    private int WriteValueToBuffer(DateTimeOffset value)
-    {
-      this.EnsureWriteBuffer();
-      int num1 = 0;
-      char[] writeBuffer1 = this._writeBuffer;
-      int index1 = num1;
-      int start = index1 + 1;
-      int quoteChar1 = (int) this._quoteChar;
-      writeBuffer1[index1] = (char) quoteChar1;
-      int num2 = DateTimeUtils.WriteDateTimeString(this._writeBuffer, start, this.DateFormatHandling == DateFormatHandling.IsoDateFormat ? value.DateTime : value.UtcDateTime, new TimeSpan?(value.Offset), DateTimeKind.Local, this.DateFormatHandling);
-      char[] writeBuffer2 = this._writeBuffer;
-      int index2 = num2;
-      int buffer = index2 + 1;
-      int quoteChar2 = (int) this._quoteChar;
-      writeBuffer2[index2] = (char) quoteChar2;
-      return buffer;
-    }
-
-    public override void WriteValue(Guid value)
-    {
-      this.InternalWriteValue(JsonToken.String);
-      string str = value.ToString("D", (IFormatProvider) CultureInfo.InvariantCulture);
-      this._writer.Write(this._quoteChar);
-      this._writer.Write(str);
-      this._writer.Write(this._quoteChar);
-    }
-
-    public override void WriteValue(TimeSpan value)
-    {
-      this.InternalWriteValue(JsonToken.String);
-      string str = value.ToString();
-      this._writer.Write(this._quoteChar);
-      this._writer.Write(str);
-      this._writer.Write(this._quoteChar);
-    }
-
-    public override void WriteValue(Uri value)
-    {
-      if (value == (Uri) null)
-      {
-        this.WriteNull();
-      }
-      else
-      {
-        this.InternalWriteValue(JsonToken.String);
-        this.WriteEscapedString(value.OriginalString, true);
-      }
-    }
-
-    public override void WriteComment(string text)
-    {
-      this.InternalWriteComment();
-      this._writer.Write("/*");
-      this._writer.Write(text);
-      this._writer.Write("*/");
-    }
-
-    public override void WriteWhitespace(string ws)
-    {
-      this.InternalWriteWhitespace(ws);
-      this._writer.Write(ws);
-    }
-
-    private void EnsureWriteBuffer()
-    {
-      if (this._writeBuffer != null)
-        return;
-      this._writeBuffer = BufferUtils.RentBuffer(this._arrayPool, 35);
-    }
-
-    private void WriteIntegerValue(long value)
-    {
-      if (value >= 0L && value <= 9L)
-      {
-        this._writer.Write((char) (48UL + (ulong) value));
-      }
-      else
-      {
-        bool negative = value < 0L;
-        this.WriteIntegerValue(negative ? (ulong) -value : (ulong) value, negative);
-      }
-    }
-
-    private void WriteIntegerValue(ulong value, bool negative)
-    {
-      if (!negative & value <= 9UL)
-        this._writer.Write((char) (48UL + value));
-      else
-        this._writer.Write(this._writeBuffer, 0, this.WriteNumberToBuffer(value, negative));
-    }
-
-    private int WriteNumberToBuffer(ulong value, bool negative)
-    {
-      if (value <= (ulong) uint.MaxValue)
-        return this.WriteNumberToBuffer((uint) value, negative);
-      this.EnsureWriteBuffer();
-      int buffer = MathUtils.IntLength(value);
-      if (negative)
-      {
-        ++buffer;
-        this._writeBuffer[0] = '-';
-      }
-      int num1 = buffer;
-      do
-      {
-        ulong num2 = value / 10UL;
-        ulong num3 = value - num2 * 10UL;
-        this._writeBuffer[--num1] = (char) (48UL + num3);
-        value = num2;
-      }
-      while (value != 0UL);
-      return buffer;
-    }
-
-    private void WriteIntegerValue(int value)
-    {
-      if (value >= 0 && value <= 9)
-      {
-        this._writer.Write((char) (48 + value));
-      }
-      else
-      {
-        bool negative = value < 0;
-        this.WriteIntegerValue(negative ? (uint) -value : (uint) value, negative);
-      }
-    }
-
-    private void WriteIntegerValue(uint value, bool negative)
-    {
-      if (!negative & value <= 9U)
-        this._writer.Write((char) (48U + value));
-      else
-        this._writer.Write(this._writeBuffer, 0, this.WriteNumberToBuffer(value, negative));
-    }
-
-    private int WriteNumberToBuffer(uint value, bool negative)
-    {
-      this.EnsureWriteBuffer();
-      int buffer = MathUtils.IntLength((ulong) value);
-      if (negative)
-      {
-        ++buffer;
-        this._writeBuffer[0] = '-';
-      }
-      int num1 = buffer;
-      do
-      {
-        uint num2 = value / 10U;
-        uint num3 = value - num2 * 10U;
-        this._writeBuffer[--num1] = (char) (48U + num3);
-        value = num2;
-      }
-      while (value != 0U);
-      return buffer;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonToken.cs b/MSHALTester/Newtonsoft/Json/JsonToken.cs
deleted file mode 100644
index 09e815d..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonToken.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum JsonToken
-  {
-    None,
-    StartObject,
-    StartArray,
-    StartConstructor,
-    PropertyName,
-    Comment,
-    Raw,
-    Integer,
-    Float,
-    String,
-    Boolean,
-    Null,
-    Undefined,
-    EndObject,
-    EndArray,
-    EndConstructor,
-    Date,
-    Bytes,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonValidatingReader.cs b/MSHALTester/Newtonsoft/Json/JsonValidatingReader.cs
deleted file mode 100644
index 52fb53f..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonValidatingReader.cs
+++ /dev/null
@@ -1,693 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Schema;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Linq;
-using System.Text.RegularExpressions;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public class JsonValidatingReader : JsonReader, IJsonLineInfo
-  {
-    private readonly JsonReader _reader;
-    private readonly Stack<JsonValidatingReader.SchemaScope> _stack;
-    private JsonSchema _schema;
-    private JsonSchemaModel _model;
-    private JsonValidatingReader.SchemaScope _currentScope;
-    private static readonly IList<JsonSchemaModel> EmptySchemaList = (IList<JsonSchemaModel>) new List<JsonSchemaModel>();
-
-    public event Newtonsoft.Json.Schema.ValidationEventHandler ValidationEventHandler;
-
-    public override object Value => this._reader.Value;
-
-    public override int Depth => this._reader.Depth;
-
-    public override string Path => this._reader.Path;
-
-    public override char QuoteChar
-    {
-      get => this._reader.QuoteChar;
-      protected internal set
-      {
-      }
-    }
-
-    public override JsonToken TokenType => this._reader.TokenType;
-
-    public override Type ValueType => this._reader.ValueType;
-
-    private void Push(JsonValidatingReader.SchemaScope scope)
-    {
-      this._stack.Push(scope);
-      this._currentScope = scope;
-    }
-
-    private JsonValidatingReader.SchemaScope Pop()
-    {
-      JsonValidatingReader.SchemaScope schemaScope = this._stack.Pop();
-      this._currentScope = this._stack.Count != 0 ? this._stack.Peek() : (JsonValidatingReader.SchemaScope) null;
-      return schemaScope;
-    }
-
-    private IList<JsonSchemaModel> CurrentSchemas => this._currentScope.Schemas;
-
-    private IList<JsonSchemaModel> CurrentMemberSchemas
-    {
-      get
-      {
-        if (this._currentScope == null)
-          return (IList<JsonSchemaModel>) new List<JsonSchemaModel>((IEnumerable<JsonSchemaModel>) new JsonSchemaModel[1]
-          {
-            this._model
-          });
-        if (this._currentScope.Schemas == null || this._currentScope.Schemas.Count == 0)
-          return JsonValidatingReader.EmptySchemaList;
-        switch (this._currentScope.TokenType)
-        {
-          case JTokenType.None:
-            return this._currentScope.Schemas;
-          case JTokenType.Object:
-            if (this._currentScope.CurrentPropertyName == null)
-              throw new JsonReaderException("CurrentPropertyName has not been set on scope.");
-            IList<JsonSchemaModel> currentMemberSchemas1 = (IList<JsonSchemaModel>) new List<JsonSchemaModel>();
-            foreach (JsonSchemaModel currentSchema in (IEnumerable<JsonSchemaModel>) this.CurrentSchemas)
-            {
-              JsonSchemaModel jsonSchemaModel;
-              if (currentSchema.Properties != null && currentSchema.Properties.TryGetValue(this._currentScope.CurrentPropertyName, out jsonSchemaModel))
-                currentMemberSchemas1.Add(jsonSchemaModel);
-              if (currentSchema.PatternProperties != null)
-              {
-                foreach (KeyValuePair<string, JsonSchemaModel> patternProperty in (IEnumerable<KeyValuePair<string, JsonSchemaModel>>) currentSchema.PatternProperties)
-                {
-                  if (Regex.IsMatch(this._currentScope.CurrentPropertyName, patternProperty.Key))
-                    currentMemberSchemas1.Add(patternProperty.Value);
-                }
-              }
-              if (currentMemberSchemas1.Count == 0 && currentSchema.AllowAdditionalProperties && currentSchema.AdditionalProperties != null)
-                currentMemberSchemas1.Add(currentSchema.AdditionalProperties);
-            }
-            return currentMemberSchemas1;
-          case JTokenType.Array:
-            IList<JsonSchemaModel> currentMemberSchemas2 = (IList<JsonSchemaModel>) new List<JsonSchemaModel>();
-            foreach (JsonSchemaModel currentSchema in (IEnumerable<JsonSchemaModel>) this.CurrentSchemas)
-            {
-              if (!currentSchema.PositionalItemsValidation)
-              {
-                if (currentSchema.Items != null && currentSchema.Items.Count > 0)
-                  currentMemberSchemas2.Add(currentSchema.Items[0]);
-              }
-              else
-              {
-                if (currentSchema.Items != null && currentSchema.Items.Count > 0 && currentSchema.Items.Count > this._currentScope.ArrayItemCount - 1)
-                  currentMemberSchemas2.Add(currentSchema.Items[this._currentScope.ArrayItemCount - 1]);
-                if (currentSchema.AllowAdditionalItems && currentSchema.AdditionalItems != null)
-                  currentMemberSchemas2.Add(currentSchema.AdditionalItems);
-              }
-            }
-            return currentMemberSchemas2;
-          case JTokenType.Constructor:
-            return JsonValidatingReader.EmptySchemaList;
-          default:
-            throw new ArgumentOutOfRangeException("TokenType", "Unexpected token type: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._currentScope.TokenType));
-        }
-      }
-    }
-
-    private void RaiseError(string message, JsonSchemaModel schema)
-    {
-      IJsonLineInfo jsonLineInfo = (IJsonLineInfo) this;
-      this.OnValidationEvent(new JsonSchemaException(jsonLineInfo.HasLineInfo() ? message + " Line {0}, position {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) jsonLineInfo.LineNumber, (object) jsonLineInfo.LinePosition) : message, (Exception) null, this.Path, jsonLineInfo.LineNumber, jsonLineInfo.LinePosition));
-    }
-
-    private void OnValidationEvent(JsonSchemaException exception)
-    {
-      Newtonsoft.Json.Schema.ValidationEventHandler validationEventHandler = this.ValidationEventHandler;
-      if (validationEventHandler == null)
-        throw exception;
-      validationEventHandler((object) this, new ValidationEventArgs(exception));
-    }
-
-    public JsonValidatingReader(JsonReader reader)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      this._reader = reader;
-      this._stack = new Stack<JsonValidatingReader.SchemaScope>();
-    }
-
-    public JsonSchema Schema
-    {
-      get => this._schema;
-      set
-      {
-        if (this.TokenType != JsonToken.None)
-          throw new InvalidOperationException("Cannot change schema while validating JSON.");
-        this._schema = value;
-        this._model = (JsonSchemaModel) null;
-      }
-    }
-
-    public JsonReader Reader => this._reader;
-
-    public override void Close()
-    {
-      base.Close();
-      if (!this.CloseInput)
-        return;
-      this._reader?.Close();
-    }
-
-    private void ValidateNotDisallowed(JsonSchemaModel schema)
-    {
-      if (schema == null)
-        return;
-      JsonSchemaType? currentNodeSchemaType = this.GetCurrentNodeSchemaType();
-      if (!currentNodeSchemaType.HasValue || !JsonSchemaGenerator.HasFlag(new JsonSchemaType?(schema.Disallow), currentNodeSchemaType.GetValueOrDefault()))
-        return;
-      this.RaiseError("Type {0} is disallowed.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) currentNodeSchemaType), schema);
-    }
-
-    private JsonSchemaType? GetCurrentNodeSchemaType()
-    {
-      switch (this._reader.TokenType)
-      {
-        case JsonToken.StartObject:
-          return new JsonSchemaType?(JsonSchemaType.Object);
-        case JsonToken.StartArray:
-          return new JsonSchemaType?(JsonSchemaType.Array);
-        case JsonToken.Integer:
-          return new JsonSchemaType?(JsonSchemaType.Integer);
-        case JsonToken.Float:
-          return new JsonSchemaType?(JsonSchemaType.Float);
-        case JsonToken.String:
-          return new JsonSchemaType?(JsonSchemaType.String);
-        case JsonToken.Boolean:
-          return new JsonSchemaType?(JsonSchemaType.Boolean);
-        case JsonToken.Null:
-          return new JsonSchemaType?(JsonSchemaType.Null);
-        default:
-          return new JsonSchemaType?();
-      }
-    }
-
-    public override int? ReadAsInt32()
-    {
-      int? nullable = this._reader.ReadAsInt32();
-      this.ValidateCurrentToken();
-      return nullable;
-    }
-
-    public override byte[] ReadAsBytes()
-    {
-      byte[] numArray = this._reader.ReadAsBytes();
-      this.ValidateCurrentToken();
-      return numArray;
-    }
-
-    public override Decimal? ReadAsDecimal()
-    {
-      Decimal? nullable = this._reader.ReadAsDecimal();
-      this.ValidateCurrentToken();
-      return nullable;
-    }
-
-    public override double? ReadAsDouble()
-    {
-      double? nullable = this._reader.ReadAsDouble();
-      this.ValidateCurrentToken();
-      return nullable;
-    }
-
-    public override bool? ReadAsBoolean()
-    {
-      bool? nullable = this._reader.ReadAsBoolean();
-      this.ValidateCurrentToken();
-      return nullable;
-    }
-
-    public override string ReadAsString()
-    {
-      string str = this._reader.ReadAsString();
-      this.ValidateCurrentToken();
-      return str;
-    }
-
-    public override DateTime? ReadAsDateTime()
-    {
-      DateTime? nullable = this._reader.ReadAsDateTime();
-      this.ValidateCurrentToken();
-      return nullable;
-    }
-
-    public override DateTimeOffset? ReadAsDateTimeOffset()
-    {
-      DateTimeOffset? nullable = this._reader.ReadAsDateTimeOffset();
-      this.ValidateCurrentToken();
-      return nullable;
-    }
-
-    public override bool Read()
-    {
-      if (!this._reader.Read())
-        return false;
-      if (this._reader.TokenType == JsonToken.Comment)
-        return true;
-      this.ValidateCurrentToken();
-      return true;
-    }
-
-    private void ValidateCurrentToken()
-    {
-      if (this._model == null)
-      {
-        this._model = new JsonSchemaModelBuilder().Build(this._schema);
-        if (!JsonTokenUtils.IsStartToken(this._reader.TokenType))
-          this.Push(new JsonValidatingReader.SchemaScope(JTokenType.None, this.CurrentMemberSchemas));
-      }
-      switch (this._reader.TokenType)
-      {
-        case JsonToken.None:
-          break;
-        case JsonToken.StartObject:
-          this.ProcessValue();
-          this.Push(new JsonValidatingReader.SchemaScope(JTokenType.Object, (IList<JsonSchemaModel>) this.CurrentMemberSchemas.Where<JsonSchemaModel>(new Func<JsonSchemaModel, bool>(this.ValidateObject)).ToList<JsonSchemaModel>()));
-          this.WriteToken(this.CurrentSchemas);
-          break;
-        case JsonToken.StartArray:
-          this.ProcessValue();
-          this.Push(new JsonValidatingReader.SchemaScope(JTokenType.Array, (IList<JsonSchemaModel>) this.CurrentMemberSchemas.Where<JsonSchemaModel>(new Func<JsonSchemaModel, bool>(this.ValidateArray)).ToList<JsonSchemaModel>()));
-          this.WriteToken(this.CurrentSchemas);
-          break;
-        case JsonToken.StartConstructor:
-          this.ProcessValue();
-          this.Push(new JsonValidatingReader.SchemaScope(JTokenType.Constructor, (IList<JsonSchemaModel>) null));
-          this.WriteToken(this.CurrentSchemas);
-          break;
-        case JsonToken.PropertyName:
-          this.WriteToken(this.CurrentSchemas);
-          using (IEnumerator<JsonSchemaModel> enumerator = this.CurrentSchemas.GetEnumerator())
-          {
-            while (enumerator.MoveNext())
-              this.ValidatePropertyName(enumerator.Current);
-            break;
-          }
-        case JsonToken.Raw:
-          this.ProcessValue();
-          break;
-        case JsonToken.Integer:
-          this.ProcessValue();
-          this.WriteToken(this.CurrentMemberSchemas);
-          using (IEnumerator<JsonSchemaModel> enumerator = this.CurrentMemberSchemas.GetEnumerator())
-          {
-            while (enumerator.MoveNext())
-              this.ValidateInteger(enumerator.Current);
-            break;
-          }
-        case JsonToken.Float:
-          this.ProcessValue();
-          this.WriteToken(this.CurrentMemberSchemas);
-          using (IEnumerator<JsonSchemaModel> enumerator = this.CurrentMemberSchemas.GetEnumerator())
-          {
-            while (enumerator.MoveNext())
-              this.ValidateFloat(enumerator.Current);
-            break;
-          }
-        case JsonToken.String:
-          this.ProcessValue();
-          this.WriteToken(this.CurrentMemberSchemas);
-          using (IEnumerator<JsonSchemaModel> enumerator = this.CurrentMemberSchemas.GetEnumerator())
-          {
-            while (enumerator.MoveNext())
-              this.ValidateString(enumerator.Current);
-            break;
-          }
-        case JsonToken.Boolean:
-          this.ProcessValue();
-          this.WriteToken(this.CurrentMemberSchemas);
-          using (IEnumerator<JsonSchemaModel> enumerator = this.CurrentMemberSchemas.GetEnumerator())
-          {
-            while (enumerator.MoveNext())
-              this.ValidateBoolean(enumerator.Current);
-            break;
-          }
-        case JsonToken.Null:
-          this.ProcessValue();
-          this.WriteToken(this.CurrentMemberSchemas);
-          using (IEnumerator<JsonSchemaModel> enumerator = this.CurrentMemberSchemas.GetEnumerator())
-          {
-            while (enumerator.MoveNext())
-              this.ValidateNull(enumerator.Current);
-            break;
-          }
-        case JsonToken.Undefined:
-        case JsonToken.Date:
-        case JsonToken.Bytes:
-          this.WriteToken(this.CurrentMemberSchemas);
-          break;
-        case JsonToken.EndObject:
-          this.WriteToken(this.CurrentSchemas);
-          foreach (JsonSchemaModel currentSchema in (IEnumerable<JsonSchemaModel>) this.CurrentSchemas)
-            this.ValidateEndObject(currentSchema);
-          this.Pop();
-          break;
-        case JsonToken.EndArray:
-          this.WriteToken(this.CurrentSchemas);
-          foreach (JsonSchemaModel currentSchema in (IEnumerable<JsonSchemaModel>) this.CurrentSchemas)
-            this.ValidateEndArray(currentSchema);
-          this.Pop();
-          break;
-        case JsonToken.EndConstructor:
-          this.WriteToken(this.CurrentSchemas);
-          this.Pop();
-          break;
-        default:
-          throw new ArgumentOutOfRangeException();
-      }
-    }
-
-    private void WriteToken(IList<JsonSchemaModel> schemas)
-    {
-      foreach (JsonValidatingReader.SchemaScope schemaScope in this._stack)
-      {
-        bool flag = schemaScope.TokenType == JTokenType.Array && schemaScope.IsUniqueArray && schemaScope.ArrayItemCount > 0;
-        if (flag || schemas.Any<JsonSchemaModel>((Func<JsonSchemaModel, bool>) (s => s.Enum != null)))
-        {
-          if (schemaScope.CurrentItemWriter == null)
-          {
-            if (!JsonTokenUtils.IsEndToken(this._reader.TokenType))
-              schemaScope.CurrentItemWriter = new JTokenWriter();
-            else
-              continue;
-          }
-          schemaScope.CurrentItemWriter.WriteToken(this._reader, false);
-          if (schemaScope.CurrentItemWriter.Top == 0 && this._reader.TokenType != JsonToken.PropertyName)
-          {
-            JToken token = schemaScope.CurrentItemWriter.Token;
-            schemaScope.CurrentItemWriter = (JTokenWriter) null;
-            if (flag)
-            {
-              if (schemaScope.UniqueArrayItems.Contains<JToken>(token, (IEqualityComparer<JToken>) JToken.EqualityComparer))
-                this.RaiseError("Non-unique array item at index {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) (schemaScope.ArrayItemCount - 1)), schemaScope.Schemas.First<JsonSchemaModel>((Func<JsonSchemaModel, bool>) (s => s.UniqueItems)));
-              schemaScope.UniqueArrayItems.Add(token);
-            }
-            else if (schemas.Any<JsonSchemaModel>((Func<JsonSchemaModel, bool>) (s => s.Enum != null)))
-            {
-              foreach (JsonSchemaModel schema in (IEnumerable<JsonSchemaModel>) schemas)
-              {
-                if (schema.Enum != null && !schema.Enum.ContainsValue<JToken>(token, (IEqualityComparer<JToken>) JToken.EqualityComparer))
-                {
-                  StringWriter stringWriter = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-                  token.WriteTo((JsonWriter) new JsonTextWriter((TextWriter) stringWriter));
-                  this.RaiseError("Value {0} is not defined in enum.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) stringWriter.ToString()), schema);
-                }
-              }
-            }
-          }
-        }
-      }
-    }
-
-    private void ValidateEndObject(JsonSchemaModel schema)
-    {
-      if (schema == null)
-        return;
-      Dictionary<string, bool> requiredProperties = this._currentScope.RequiredProperties;
-      if (requiredProperties == null || !requiredProperties.Values.Any<bool>((Func<bool, bool>) (v => !v)))
-        return;
-      this.RaiseError("Required properties are missing from object: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) string.Join(", ", requiredProperties.Where<KeyValuePair<string, bool>>((Func<KeyValuePair<string, bool>, bool>) (kv => !kv.Value)).Select<KeyValuePair<string, bool>, string>((Func<KeyValuePair<string, bool>, string>) (kv => kv.Key)).ToArray<string>())), schema);
-    }
-
-    private void ValidateEndArray(JsonSchemaModel schema)
-    {
-      if (schema == null)
-        return;
-      int arrayItemCount = this._currentScope.ArrayItemCount;
-      if (schema.MaximumItems.HasValue)
-      {
-        int num = arrayItemCount;
-        int? maximumItems = schema.MaximumItems;
-        int valueOrDefault = maximumItems.GetValueOrDefault();
-        if ((num > valueOrDefault ? (maximumItems.HasValue ? 1 : 0) : 0) != 0)
-          this.RaiseError("Array item count {0} exceeds maximum count of {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) arrayItemCount, (object) schema.MaximumItems), schema);
-      }
-      int? minimumItems = schema.MinimumItems;
-      if (!minimumItems.HasValue)
-        return;
-      int num1 = arrayItemCount;
-      minimumItems = schema.MinimumItems;
-      int valueOrDefault1 = minimumItems.GetValueOrDefault();
-      if ((num1 < valueOrDefault1 ? (minimumItems.HasValue ? 1 : 0) : 0) == 0)
-        return;
-      this.RaiseError("Array item count {0} is less than minimum count of {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) arrayItemCount, (object) schema.MinimumItems), schema);
-    }
-
-    private void ValidateNull(JsonSchemaModel schema)
-    {
-      if (schema == null || !this.TestType(schema, JsonSchemaType.Null))
-        return;
-      this.ValidateNotDisallowed(schema);
-    }
-
-    private void ValidateBoolean(JsonSchemaModel schema)
-    {
-      if (schema == null || !this.TestType(schema, JsonSchemaType.Boolean))
-        return;
-      this.ValidateNotDisallowed(schema);
-    }
-
-    private void ValidateString(JsonSchemaModel schema)
-    {
-      if (schema == null || !this.TestType(schema, JsonSchemaType.String))
-        return;
-      this.ValidateNotDisallowed(schema);
-      string input = this._reader.Value.ToString();
-      int? nullable = schema.MaximumLength;
-      if (nullable.HasValue)
-      {
-        int length = input.Length;
-        nullable = schema.MaximumLength;
-        int valueOrDefault = nullable.GetValueOrDefault();
-        if ((length > valueOrDefault ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-          this.RaiseError("String '{0}' exceeds maximum length of {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) input, (object) schema.MaximumLength), schema);
-      }
-      nullable = schema.MinimumLength;
-      if (nullable.HasValue)
-      {
-        int length = input.Length;
-        nullable = schema.MinimumLength;
-        int valueOrDefault = nullable.GetValueOrDefault();
-        if ((length < valueOrDefault ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-          this.RaiseError("String '{0}' is less than minimum length of {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) input, (object) schema.MinimumLength), schema);
-      }
-      if (schema.Patterns == null)
-        return;
-      foreach (string pattern in (IEnumerable<string>) schema.Patterns)
-      {
-        if (!Regex.IsMatch(input, pattern))
-          this.RaiseError("String '{0}' does not match regex pattern '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) input, (object) pattern), schema);
-      }
-    }
-
-    private void ValidateInteger(JsonSchemaModel schema)
-    {
-      if (schema == null || !this.TestType(schema, JsonSchemaType.Integer))
-        return;
-      this.ValidateNotDisallowed(schema);
-      object objA = this._reader.Value;
-      if (schema.Maximum.HasValue)
-      {
-        if (JValue.Compare(JTokenType.Integer, objA, (object) schema.Maximum) > 0)
-          this.RaiseError("Integer {0} exceeds maximum value of {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, objA, (object) schema.Maximum), schema);
-        if (schema.ExclusiveMaximum && JValue.Compare(JTokenType.Integer, objA, (object) schema.Maximum) == 0)
-          this.RaiseError("Integer {0} equals maximum value of {1} and exclusive maximum is true.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, objA, (object) schema.Maximum), schema);
-      }
-      double? nullable = schema.Minimum;
-      if (nullable.HasValue)
-      {
-        if (JValue.Compare(JTokenType.Integer, objA, (object) schema.Minimum) < 0)
-          this.RaiseError("Integer {0} is less than minimum value of {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, objA, (object) schema.Minimum), schema);
-        if (schema.ExclusiveMinimum && JValue.Compare(JTokenType.Integer, objA, (object) schema.Minimum) == 0)
-          this.RaiseError("Integer {0} equals minimum value of {1} and exclusive minimum is true.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, objA, (object) schema.Minimum), schema);
-      }
-      nullable = schema.DivisibleBy;
-      if (!nullable.HasValue)
-        return;
-      double int64 = (double) Convert.ToInt64(objA, (IFormatProvider) CultureInfo.InvariantCulture);
-      nullable = schema.DivisibleBy;
-      double valueOrDefault = nullable.GetValueOrDefault();
-      if (JsonValidatingReader.IsZero(int64 % valueOrDefault))
-        return;
-      this.RaiseError("Integer {0} is not evenly divisible by {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JsonConvert.ToString(objA), (object) schema.DivisibleBy), schema);
-    }
-
-    private void ProcessValue()
-    {
-      if (this._currentScope == null || this._currentScope.TokenType != JTokenType.Array)
-        return;
-      ++this._currentScope.ArrayItemCount;
-      foreach (JsonSchemaModel currentSchema in (IEnumerable<JsonSchemaModel>) this.CurrentSchemas)
-      {
-        if (currentSchema != null && currentSchema.PositionalItemsValidation && !currentSchema.AllowAdditionalItems && (currentSchema.Items == null || this._currentScope.ArrayItemCount - 1 >= currentSchema.Items.Count))
-          this.RaiseError("Index {0} has not been defined and the schema does not allow additional items.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._currentScope.ArrayItemCount), currentSchema);
-      }
-    }
-
-    private void ValidateFloat(JsonSchemaModel schema)
-    {
-      if (schema == null || !this.TestType(schema, JsonSchemaType.Float))
-        return;
-      this.ValidateNotDisallowed(schema);
-      double num1 = Convert.ToDouble(this._reader.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-      double? nullable = schema.Maximum;
-      if (nullable.HasValue)
-      {
-        double num2 = num1;
-        nullable = schema.Maximum;
-        double valueOrDefault1 = nullable.GetValueOrDefault();
-        if ((num2 > valueOrDefault1 ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-          this.RaiseError("Float {0} exceeds maximum value of {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JsonConvert.ToString(num1), (object) schema.Maximum), schema);
-        if (schema.ExclusiveMaximum)
-        {
-          double num3 = num1;
-          nullable = schema.Maximum;
-          double valueOrDefault2 = nullable.GetValueOrDefault();
-          if ((num3 == valueOrDefault2 ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-            this.RaiseError("Float {0} equals maximum value of {1} and exclusive maximum is true.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JsonConvert.ToString(num1), (object) schema.Maximum), schema);
-        }
-      }
-      nullable = schema.Minimum;
-      if (nullable.HasValue)
-      {
-        double num4 = num1;
-        nullable = schema.Minimum;
-        double valueOrDefault3 = nullable.GetValueOrDefault();
-        if ((num4 < valueOrDefault3 ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-          this.RaiseError("Float {0} is less than minimum value of {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JsonConvert.ToString(num1), (object) schema.Minimum), schema);
-        if (schema.ExclusiveMinimum)
-        {
-          double num5 = num1;
-          nullable = schema.Minimum;
-          double valueOrDefault4 = nullable.GetValueOrDefault();
-          if ((num5 == valueOrDefault4 ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-            this.RaiseError("Float {0} equals minimum value of {1} and exclusive minimum is true.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JsonConvert.ToString(num1), (object) schema.Minimum), schema);
-        }
-      }
-      nullable = schema.DivisibleBy;
-      if (!nullable.HasValue)
-        return;
-      double dividend = num1;
-      nullable = schema.DivisibleBy;
-      double valueOrDefault = nullable.GetValueOrDefault();
-      if (JsonValidatingReader.IsZero(JsonValidatingReader.FloatingPointRemainder(dividend, valueOrDefault)))
-        return;
-      this.RaiseError("Float {0} is not evenly divisible by {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JsonConvert.ToString(num1), (object) schema.DivisibleBy), schema);
-    }
-
-    private static double FloatingPointRemainder(double dividend, double divisor)
-    {
-      return dividend - Math.Floor(dividend / divisor) * divisor;
-    }
-
-    private static bool IsZero(double value) => Math.Abs(value) < 4.4408920985006262E-15;
-
-    private void ValidatePropertyName(JsonSchemaModel schema)
-    {
-      if (schema == null)
-        return;
-      string str = Convert.ToString(this._reader.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-      if (this._currentScope.RequiredProperties.ContainsKey(str))
-        this._currentScope.RequiredProperties[str] = true;
-      if (!schema.AllowAdditionalProperties && !this.IsPropertyDefinied(schema, str))
-        this.RaiseError("Property '{0}' has not been defined and the schema does not allow additional properties.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str), schema);
-      this._currentScope.CurrentPropertyName = str;
-    }
-
-    private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName)
-    {
-      if (schema.Properties != null && schema.Properties.ContainsKey(propertyName))
-        return true;
-      if (schema.PatternProperties != null)
-      {
-        foreach (string key in (IEnumerable<string>) schema.PatternProperties.Keys)
-        {
-          if (Regex.IsMatch(propertyName, key))
-            return true;
-        }
-      }
-      return false;
-    }
-
-    private bool ValidateArray(JsonSchemaModel schema)
-    {
-      return schema == null || this.TestType(schema, JsonSchemaType.Array);
-    }
-
-    private bool ValidateObject(JsonSchemaModel schema)
-    {
-      return schema == null || this.TestType(schema, JsonSchemaType.Object);
-    }
-
-    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType)
-    {
-      if (JsonSchemaGenerator.HasFlag(new JsonSchemaType?(currentSchema.Type), currentType))
-        return true;
-      this.RaiseError("Invalid type. Expected {0} but got {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) currentSchema.Type, (object) currentType), currentSchema);
-      return false;
-    }
-
-    bool IJsonLineInfo.HasLineInfo()
-    {
-      return this._reader is IJsonLineInfo reader && reader.HasLineInfo();
-    }
-
-    int IJsonLineInfo.LineNumber => !(this._reader is IJsonLineInfo reader) ? 0 : reader.LineNumber;
-
-    int IJsonLineInfo.LinePosition
-    {
-      get => !(this._reader is IJsonLineInfo reader) ? 0 : reader.LinePosition;
-    }
-
-    private class SchemaScope
-    {
-      private readonly JTokenType _tokenType;
-      private readonly IList<JsonSchemaModel> _schemas;
-      private readonly Dictionary<string, bool> _requiredProperties;
-
-      public string CurrentPropertyName { get; set; }
-
-      public int ArrayItemCount { get; set; }
-
-      public bool IsUniqueArray { get; }
-
-      public IList<JToken> UniqueArrayItems { get; }
-
-      public JTokenWriter CurrentItemWriter { get; set; }
-
-      public IList<JsonSchemaModel> Schemas => this._schemas;
-
-      public Dictionary<string, bool> RequiredProperties => this._requiredProperties;
-
-      public JTokenType TokenType => this._tokenType;
-
-      public SchemaScope(JTokenType tokenType, IList<JsonSchemaModel> schemas)
-      {
-        this._tokenType = tokenType;
-        this._schemas = schemas;
-        this._requiredProperties = schemas.SelectMany<JsonSchemaModel, string>(new Func<JsonSchemaModel, IEnumerable<string>>(this.GetRequiredProperties)).Distinct<string>().ToDictionary<string, string, bool>((Func<string, string>) (p => p), (Func<string, bool>) (p => false));
-        if (tokenType != JTokenType.Array || !schemas.Any<JsonSchemaModel>((Func<JsonSchemaModel, bool>) (s => s.UniqueItems)))
-          return;
-        this.IsUniqueArray = true;
-        this.UniqueArrayItems = (IList<JToken>) new List<JToken>();
-      }
-
-      private IEnumerable<string> GetRequiredProperties(JsonSchemaModel schema)
-      {
-        return schema?.Properties == null ? Enumerable.Empty<string>() : schema.Properties.Where<KeyValuePair<string, JsonSchemaModel>>((Func<KeyValuePair<string, JsonSchemaModel>, bool>) (p => p.Value.Required)).Select<KeyValuePair<string, JsonSchemaModel>, string>((Func<KeyValuePair<string, JsonSchemaModel>, string>) (p => p.Key));
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonWriter.cs b/MSHALTester/Newtonsoft/Json/JsonWriter.cs
deleted file mode 100644
index 7260aef..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonWriter.cs
+++ /dev/null
@@ -1,1209 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public abstract class JsonWriter : IDisposable
-  {
-    private static readonly JsonWriter.State[][] StateArray;
-    internal static readonly JsonWriter.State[][] StateArrayTempate = new JsonWriter.State[8][]
-    {
-      new JsonWriter.State[10]
-      {
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error
-      },
-      new JsonWriter.State[10]
-      {
-        JsonWriter.State.ObjectStart,
-        JsonWriter.State.ObjectStart,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.ObjectStart,
-        JsonWriter.State.ObjectStart,
-        JsonWriter.State.ObjectStart,
-        JsonWriter.State.ObjectStart,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error
-      },
-      new JsonWriter.State[10]
-      {
-        JsonWriter.State.ArrayStart,
-        JsonWriter.State.ArrayStart,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.ArrayStart,
-        JsonWriter.State.ArrayStart,
-        JsonWriter.State.ArrayStart,
-        JsonWriter.State.ArrayStart,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error
-      },
-      new JsonWriter.State[10]
-      {
-        JsonWriter.State.ConstructorStart,
-        JsonWriter.State.ConstructorStart,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.ConstructorStart,
-        JsonWriter.State.ConstructorStart,
-        JsonWriter.State.ConstructorStart,
-        JsonWriter.State.ConstructorStart,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error
-      },
-      new JsonWriter.State[10]
-      {
-        JsonWriter.State.Property,
-        JsonWriter.State.Error,
-        JsonWriter.State.Property,
-        JsonWriter.State.Property,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error
-      },
-      new JsonWriter.State[10]
-      {
-        JsonWriter.State.Start,
-        JsonWriter.State.Property,
-        JsonWriter.State.ObjectStart,
-        JsonWriter.State.Object,
-        JsonWriter.State.ArrayStart,
-        JsonWriter.State.Array,
-        JsonWriter.State.Constructor,
-        JsonWriter.State.Constructor,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error
-      },
-      new JsonWriter.State[10]
-      {
-        JsonWriter.State.Start,
-        JsonWriter.State.Property,
-        JsonWriter.State.ObjectStart,
-        JsonWriter.State.Object,
-        JsonWriter.State.ArrayStart,
-        JsonWriter.State.Array,
-        JsonWriter.State.Constructor,
-        JsonWriter.State.Constructor,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error
-      },
-      new JsonWriter.State[10]
-      {
-        JsonWriter.State.Start,
-        JsonWriter.State.Object,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error,
-        JsonWriter.State.Array,
-        JsonWriter.State.Array,
-        JsonWriter.State.Constructor,
-        JsonWriter.State.Constructor,
-        JsonWriter.State.Error,
-        JsonWriter.State.Error
-      }
-    };
-    private List<JsonPosition> _stack;
-    private JsonPosition _currentPosition;
-    private JsonWriter.State _currentState;
-    private Formatting _formatting;
-    private DateFormatHandling _dateFormatHandling;
-    private DateTimeZoneHandling _dateTimeZoneHandling;
-    private StringEscapeHandling _stringEscapeHandling;
-    private FloatFormatHandling _floatFormatHandling;
-    private string _dateFormatString;
-    private CultureInfo _culture;
-
-    internal static JsonWriter.State[][] BuildStateArray()
-    {
-      List<JsonWriter.State[]> list = ((IEnumerable<JsonWriter.State[]>) JsonWriter.StateArrayTempate).ToList<JsonWriter.State[]>();
-      JsonWriter.State[] stateArray1 = JsonWriter.StateArrayTempate[0];
-      JsonWriter.State[] stateArray2 = JsonWriter.StateArrayTempate[7];
-      foreach (ulong num in EnumUtils.GetEnumValuesAndNames(typeof (JsonToken)).Values)
-      {
-        if (list.Count <= (int) num)
-        {
-          switch ((JsonToken) num)
-          {
-            case JsonToken.Integer:
-            case JsonToken.Float:
-            case JsonToken.String:
-            case JsonToken.Boolean:
-            case JsonToken.Null:
-            case JsonToken.Undefined:
-            case JsonToken.Date:
-            case JsonToken.Bytes:
-              list.Add(stateArray2);
-              continue;
-            default:
-              list.Add(stateArray1);
-              continue;
-          }
-        }
-      }
-      return list.ToArray();
-    }
-
-    static JsonWriter() => JsonWriter.StateArray = JsonWriter.BuildStateArray();
-
-    public bool CloseOutput { get; set; }
-
-    public bool AutoCompleteOnClose { get; set; }
-
-    protected internal int Top
-    {
-      get
-      {
-        List<JsonPosition> stack = this._stack;
-        int count = stack != null ? __nonvirtual (stack.Count) : 0;
-        if (this.Peek() != JsonContainerType.None)
-          ++count;
-        return count;
-      }
-    }
-
-    public WriteState WriteState
-    {
-      get
-      {
-        switch (this._currentState)
-        {
-          case JsonWriter.State.Start:
-            return WriteState.Start;
-          case JsonWriter.State.Property:
-            return WriteState.Property;
-          case JsonWriter.State.ObjectStart:
-          case JsonWriter.State.Object:
-            return WriteState.Object;
-          case JsonWriter.State.ArrayStart:
-          case JsonWriter.State.Array:
-            return WriteState.Array;
-          case JsonWriter.State.ConstructorStart:
-          case JsonWriter.State.Constructor:
-            return WriteState.Constructor;
-          case JsonWriter.State.Closed:
-            return WriteState.Closed;
-          case JsonWriter.State.Error:
-            return WriteState.Error;
-          default:
-            throw JsonWriterException.Create(this, "Invalid state: " + (object) this._currentState, (Exception) null);
-        }
-      }
-    }
-
-    internal string ContainerPath
-    {
-      get
-      {
-        return this._currentPosition.Type == JsonContainerType.None || this._stack == null ? string.Empty : JsonPosition.BuildPath(this._stack, new JsonPosition?());
-      }
-    }
-
-    public string Path
-    {
-      get
-      {
-        return this._currentPosition.Type == JsonContainerType.None ? string.Empty : JsonPosition.BuildPath(this._stack, (this._currentState == JsonWriter.State.ArrayStart || this._currentState == JsonWriter.State.ConstructorStart ? 0 : (this._currentState != JsonWriter.State.ObjectStart ? 1 : 0)) != 0 ? new JsonPosition?(this._currentPosition) : new JsonPosition?());
-      }
-    }
-
-    public Formatting Formatting
-    {
-      get => this._formatting;
-      set
-      {
-        this._formatting = value >= Formatting.None && value <= Formatting.Indented ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public DateFormatHandling DateFormatHandling
-    {
-      get => this._dateFormatHandling;
-      set
-      {
-        this._dateFormatHandling = value >= DateFormatHandling.IsoDateFormat && value <= DateFormatHandling.MicrosoftDateFormat ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public DateTimeZoneHandling DateTimeZoneHandling
-    {
-      get => this._dateTimeZoneHandling;
-      set
-      {
-        this._dateTimeZoneHandling = value >= DateTimeZoneHandling.Local && value <= DateTimeZoneHandling.RoundtripKind ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public StringEscapeHandling StringEscapeHandling
-    {
-      get => this._stringEscapeHandling;
-      set
-      {
-        this._stringEscapeHandling = value >= StringEscapeHandling.Default && value <= StringEscapeHandling.EscapeHtml ? value : throw new ArgumentOutOfRangeException(nameof (value));
-        this.OnStringEscapeHandlingChanged();
-      }
-    }
-
-    internal virtual void OnStringEscapeHandlingChanged()
-    {
-    }
-
-    public FloatFormatHandling FloatFormatHandling
-    {
-      get => this._floatFormatHandling;
-      set
-      {
-        this._floatFormatHandling = value >= FloatFormatHandling.String && value <= FloatFormatHandling.DefaultValue ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public string DateFormatString
-    {
-      get => this._dateFormatString;
-      set => this._dateFormatString = value;
-    }
-
-    public CultureInfo Culture
-    {
-      get => this._culture ?? CultureInfo.InvariantCulture;
-      set => this._culture = value;
-    }
-
-    protected JsonWriter()
-    {
-      this._currentState = JsonWriter.State.Start;
-      this._formatting = Formatting.None;
-      this._dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
-      this.CloseOutput = true;
-      this.AutoCompleteOnClose = true;
-    }
-
-    internal void UpdateScopeWithFinishedValue()
-    {
-      if (!this._currentPosition.HasIndex)
-        return;
-      ++this._currentPosition.Position;
-    }
-
-    private void Push(JsonContainerType value)
-    {
-      if (this._currentPosition.Type != JsonContainerType.None)
-      {
-        if (this._stack == null)
-          this._stack = new List<JsonPosition>();
-        this._stack.Add(this._currentPosition);
-      }
-      this._currentPosition = new JsonPosition(value);
-    }
-
-    private JsonContainerType Pop()
-    {
-      JsonPosition currentPosition = this._currentPosition;
-      if (this._stack != null && this._stack.Count > 0)
-      {
-        this._currentPosition = this._stack[this._stack.Count - 1];
-        this._stack.RemoveAt(this._stack.Count - 1);
-      }
-      else
-        this._currentPosition = new JsonPosition();
-      return currentPosition.Type;
-    }
-
-    private JsonContainerType Peek() => this._currentPosition.Type;
-
-    public abstract void Flush();
-
-    public virtual void Close()
-    {
-      if (!this.AutoCompleteOnClose)
-        return;
-      this.AutoCompleteAll();
-    }
-
-    public virtual void WriteStartObject()
-    {
-      this.InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
-    }
-
-    public virtual void WriteEndObject() => this.InternalWriteEnd(JsonContainerType.Object);
-
-    public virtual void WriteStartArray()
-    {
-      this.InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
-    }
-
-    public virtual void WriteEndArray() => this.InternalWriteEnd(JsonContainerType.Array);
-
-    public virtual void WriteStartConstructor(string name)
-    {
-      this.InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
-    }
-
-    public virtual void WriteEndConstructor()
-    {
-      this.InternalWriteEnd(JsonContainerType.Constructor);
-    }
-
-    public virtual void WritePropertyName(string name) => this.InternalWritePropertyName(name);
-
-    public virtual void WritePropertyName(string name, bool escape) => this.WritePropertyName(name);
-
-    public virtual void WriteEnd() => this.WriteEnd(this.Peek());
-
-    public void WriteToken(JsonReader reader) => this.WriteToken(reader, true);
-
-    public void WriteToken(JsonReader reader, bool writeChildren)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      this.WriteToken(reader, writeChildren, true, true);
-    }
-
-    public void WriteToken(JsonToken token, object value)
-    {
-      switch (token)
-      {
-        case JsonToken.None:
-          break;
-        case JsonToken.StartObject:
-          this.WriteStartObject();
-          break;
-        case JsonToken.StartArray:
-          this.WriteStartArray();
-          break;
-        case JsonToken.StartConstructor:
-          ValidationUtils.ArgumentNotNull(value, nameof (value));
-          this.WriteStartConstructor(value.ToString());
-          break;
-        case JsonToken.PropertyName:
-          ValidationUtils.ArgumentNotNull(value, nameof (value));
-          this.WritePropertyName(value.ToString());
-          break;
-        case JsonToken.Comment:
-          this.WriteComment(value?.ToString());
-          break;
-        case JsonToken.Raw:
-          this.WriteRawValue(value?.ToString());
-          break;
-        case JsonToken.Integer:
-          ValidationUtils.ArgumentNotNull(value, nameof (value));
-          this.WriteValue(Convert.ToInt64(value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case JsonToken.Float:
-          ValidationUtils.ArgumentNotNull(value, nameof (value));
-          switch (value)
-          {
-            case Decimal num1:
-              this.WriteValue(num1);
-              return;
-            case double num2:
-              this.WriteValue(num2);
-              return;
-            case float num3:
-              this.WriteValue(num3);
-              return;
-            default:
-              this.WriteValue(Convert.ToDouble(value, (IFormatProvider) CultureInfo.InvariantCulture));
-              return;
-          }
-        case JsonToken.String:
-          ValidationUtils.ArgumentNotNull(value, nameof (value));
-          this.WriteValue(value.ToString());
-          break;
-        case JsonToken.Boolean:
-          ValidationUtils.ArgumentNotNull(value, nameof (value));
-          this.WriteValue(Convert.ToBoolean(value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case JsonToken.Null:
-          this.WriteNull();
-          break;
-        case JsonToken.Undefined:
-          this.WriteUndefined();
-          break;
-        case JsonToken.EndObject:
-          this.WriteEndObject();
-          break;
-        case JsonToken.EndArray:
-          this.WriteEndArray();
-          break;
-        case JsonToken.EndConstructor:
-          this.WriteEndConstructor();
-          break;
-        case JsonToken.Date:
-          ValidationUtils.ArgumentNotNull(value, nameof (value));
-          if (value is DateTimeOffset dateTimeOffset)
-          {
-            this.WriteValue(dateTimeOffset);
-            break;
-          }
-          this.WriteValue(Convert.ToDateTime(value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case JsonToken.Bytes:
-          ValidationUtils.ArgumentNotNull(value, nameof (value));
-          if (value is Guid guid)
-          {
-            this.WriteValue(guid);
-            break;
-          }
-          this.WriteValue((byte[]) value);
-          break;
-        default:
-          throw MiscellaneousUtils.CreateArgumentOutOfRangeException(nameof (token), (object) token, "Unexpected token type.");
-      }
-    }
-
-    public void WriteToken(JsonToken token) => this.WriteToken(token, (object) null);
-
-    internal virtual void WriteToken(
-      JsonReader reader,
-      bool writeChildren,
-      bool writeDateConstructorAsDate,
-      bool writeComments)
-    {
-      int tokenInitialDepth = this.CalculateWriteTokenInitialDepth(reader);
-      do
-      {
-        if (writeDateConstructorAsDate && reader.TokenType == JsonToken.StartConstructor && string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
-          this.WriteConstructorDate(reader);
-        else if (writeComments || reader.TokenType != JsonToken.Comment)
-          this.WriteToken(reader.TokenType, reader.Value);
-      }
-      while (tokenInitialDepth - 1 < reader.Depth - (JsonTokenUtils.IsEndToken(reader.TokenType) ? 1 : 0) & writeChildren && reader.Read());
-      if (tokenInitialDepth < this.CalculateWriteTokenFinalDepth(reader))
-        throw JsonWriterException.Create(this, "Unexpected end when reading token.", (Exception) null);
-    }
-
-    private int CalculateWriteTokenInitialDepth(JsonReader reader)
-    {
-      JsonToken tokenType = reader.TokenType;
-      if (tokenType == JsonToken.None)
-        return -1;
-      return !JsonTokenUtils.IsStartToken(tokenType) ? reader.Depth + 1 : reader.Depth;
-    }
-
-    private int CalculateWriteTokenFinalDepth(JsonReader reader)
-    {
-      JsonToken tokenType = reader.TokenType;
-      if (tokenType == JsonToken.None)
-        return -1;
-      return !JsonTokenUtils.IsEndToken(tokenType) ? reader.Depth : reader.Depth - 1;
-    }
-
-    private void WriteConstructorDate(JsonReader reader)
-    {
-      if (!reader.Read())
-        throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", (Exception) null);
-      DateTime dateTime = reader.TokenType == JsonToken.Integer ? DateTimeUtils.ConvertJavaScriptTicksToDateTime((long) reader.Value) : throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected Integer, got " + (object) reader.TokenType, (Exception) null);
-      if (!reader.Read())
-        throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", (Exception) null);
-      if (reader.TokenType != JsonToken.EndConstructor)
-        throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected EndConstructor, got " + (object) reader.TokenType, (Exception) null);
-      this.WriteValue(dateTime);
-    }
-
-    private void WriteEnd(JsonContainerType type)
-    {
-      switch (type)
-      {
-        case JsonContainerType.Object:
-          this.WriteEndObject();
-          break;
-        case JsonContainerType.Array:
-          this.WriteEndArray();
-          break;
-        case JsonContainerType.Constructor:
-          this.WriteEndConstructor();
-          break;
-        default:
-          throw JsonWriterException.Create(this, "Unexpected type when writing end: " + (object) type, (Exception) null);
-      }
-    }
-
-    private void AutoCompleteAll()
-    {
-      while (this.Top > 0)
-        this.WriteEnd();
-    }
-
-    private JsonToken GetCloseTokenForType(JsonContainerType type)
-    {
-      switch (type)
-      {
-        case JsonContainerType.Object:
-          return JsonToken.EndObject;
-        case JsonContainerType.Array:
-          return JsonToken.EndArray;
-        case JsonContainerType.Constructor:
-          return JsonToken.EndConstructor;
-        default:
-          throw JsonWriterException.Create(this, "No close token for type: " + (object) type, (Exception) null);
-      }
-    }
-
-    private void AutoCompleteClose(JsonContainerType type)
-    {
-      int levelsToComplete = this.CalculateLevelsToComplete(type);
-      for (int index = 0; index < levelsToComplete; ++index)
-      {
-        JsonToken closeTokenForType = this.GetCloseTokenForType(this.Pop());
-        if (this._currentState == JsonWriter.State.Property)
-          this.WriteNull();
-        if (this._formatting == Formatting.Indented && this._currentState != JsonWriter.State.ObjectStart && this._currentState != JsonWriter.State.ArrayStart)
-          this.WriteIndent();
-        this.WriteEnd(closeTokenForType);
-        this.UpdateCurrentState();
-      }
-    }
-
-    private int CalculateLevelsToComplete(JsonContainerType type)
-    {
-      int num1 = 0;
-      if (this._currentPosition.Type == type)
-      {
-        num1 = 1;
-      }
-      else
-      {
-        int num2 = this.Top - 2;
-        for (int index = num2; index >= 0; --index)
-        {
-          if (this._stack[num2 - index].Type == type)
-          {
-            num1 = index + 2;
-            break;
-          }
-        }
-      }
-      return num1 != 0 ? num1 : throw JsonWriterException.Create(this, "No token to close.", (Exception) null);
-    }
-
-    private void UpdateCurrentState()
-    {
-      JsonContainerType jsonContainerType = this.Peek();
-      switch (jsonContainerType)
-      {
-        case JsonContainerType.None:
-          this._currentState = JsonWriter.State.Start;
-          break;
-        case JsonContainerType.Object:
-          this._currentState = JsonWriter.State.Object;
-          break;
-        case JsonContainerType.Array:
-          this._currentState = JsonWriter.State.Array;
-          break;
-        case JsonContainerType.Constructor:
-          this._currentState = JsonWriter.State.Array;
-          break;
-        default:
-          throw JsonWriterException.Create(this, "Unknown JsonType: " + (object) jsonContainerType, (Exception) null);
-      }
-    }
-
-    protected virtual void WriteEnd(JsonToken token)
-    {
-    }
-
-    protected virtual void WriteIndent()
-    {
-    }
-
-    protected virtual void WriteValueDelimiter()
-    {
-    }
-
-    protected virtual void WriteIndentSpace()
-    {
-    }
-
-    internal void AutoComplete(JsonToken tokenBeingWritten)
-    {
-      JsonWriter.State state = JsonWriter.StateArray[(int) tokenBeingWritten][(int) this._currentState];
-      if (state == JsonWriter.State.Error)
-        throw JsonWriterException.Create(this, "Token {0} in state {1} would result in an invalid JSON object.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) tokenBeingWritten.ToString(), (object) this._currentState.ToString()), (Exception) null);
-      if ((this._currentState == JsonWriter.State.Object || this._currentState == JsonWriter.State.Array || this._currentState == JsonWriter.State.Constructor) && tokenBeingWritten != JsonToken.Comment)
-        this.WriteValueDelimiter();
-      if (this._formatting == Formatting.Indented)
-      {
-        if (this._currentState == JsonWriter.State.Property)
-          this.WriteIndentSpace();
-        if (this._currentState == JsonWriter.State.Array || this._currentState == JsonWriter.State.ArrayStart || this._currentState == JsonWriter.State.Constructor || this._currentState == JsonWriter.State.ConstructorStart || tokenBeingWritten == JsonToken.PropertyName && this._currentState != JsonWriter.State.Start)
-          this.WriteIndent();
-      }
-      this._currentState = state;
-    }
-
-    public virtual void WriteNull() => this.InternalWriteValue(JsonToken.Null);
-
-    public virtual void WriteUndefined() => this.InternalWriteValue(JsonToken.Undefined);
-
-    public virtual void WriteRaw(string json) => this.InternalWriteRaw();
-
-    public virtual void WriteRawValue(string json)
-    {
-      this.UpdateScopeWithFinishedValue();
-      this.AutoComplete(JsonToken.Undefined);
-      this.WriteRaw(json);
-    }
-
-    public virtual void WriteValue(string value) => this.InternalWriteValue(JsonToken.String);
-
-    public virtual void WriteValue(int value) => this.InternalWriteValue(JsonToken.Integer);
-
-    [CLSCompliant(false)]
-    public virtual void WriteValue(uint value) => this.InternalWriteValue(JsonToken.Integer);
-
-    public virtual void WriteValue(long value) => this.InternalWriteValue(JsonToken.Integer);
-
-    [CLSCompliant(false)]
-    public virtual void WriteValue(ulong value) => this.InternalWriteValue(JsonToken.Integer);
-
-    public virtual void WriteValue(float value) => this.InternalWriteValue(JsonToken.Float);
-
-    public virtual void WriteValue(double value) => this.InternalWriteValue(JsonToken.Float);
-
-    public virtual void WriteValue(bool value) => this.InternalWriteValue(JsonToken.Boolean);
-
-    public virtual void WriteValue(short value) => this.InternalWriteValue(JsonToken.Integer);
-
-    [CLSCompliant(false)]
-    public virtual void WriteValue(ushort value) => this.InternalWriteValue(JsonToken.Integer);
-
-    public virtual void WriteValue(char value) => this.InternalWriteValue(JsonToken.String);
-
-    public virtual void WriteValue(byte value) => this.InternalWriteValue(JsonToken.Integer);
-
-    [CLSCompliant(false)]
-    public virtual void WriteValue(sbyte value) => this.InternalWriteValue(JsonToken.Integer);
-
-    public virtual void WriteValue(Decimal value) => this.InternalWriteValue(JsonToken.Float);
-
-    public virtual void WriteValue(DateTime value) => this.InternalWriteValue(JsonToken.Date);
-
-    public virtual void WriteValue(DateTimeOffset value) => this.InternalWriteValue(JsonToken.Date);
-
-    public virtual void WriteValue(Guid value) => this.InternalWriteValue(JsonToken.String);
-
-    public virtual void WriteValue(TimeSpan value) => this.InternalWriteValue(JsonToken.String);
-
-    public virtual void WriteValue(int? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    [CLSCompliant(false)]
-    public virtual void WriteValue(uint? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(long? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    [CLSCompliant(false)]
-    public virtual void WriteValue(ulong? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(float? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(double? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(bool? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(short? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    [CLSCompliant(false)]
-    public virtual void WriteValue(ushort? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(char? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(byte? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    [CLSCompliant(false)]
-    public virtual void WriteValue(sbyte? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(Decimal? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(DateTime? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(DateTimeOffset? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(Guid? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(TimeSpan? value)
-    {
-      if (!value.HasValue)
-        this.WriteNull();
-      else
-        this.WriteValue(value.GetValueOrDefault());
-    }
-
-    public virtual void WriteValue(byte[] value)
-    {
-      if (value == null)
-        this.WriteNull();
-      else
-        this.InternalWriteValue(JsonToken.Bytes);
-    }
-
-    public virtual void WriteValue(Uri value)
-    {
-      if (value == (Uri) null)
-        this.WriteNull();
-      else
-        this.InternalWriteValue(JsonToken.String);
-    }
-
-    public virtual void WriteValue(object value)
-    {
-      if (value == null)
-        this.WriteNull();
-      else
-        JsonWriter.WriteValue(this, ConvertUtils.GetTypeCode(value.GetType()), value);
-    }
-
-    public virtual void WriteComment(string text) => this.InternalWriteComment();
-
-    public virtual void WriteWhitespace(string ws) => this.InternalWriteWhitespace(ws);
-
-    void IDisposable.Dispose()
-    {
-      this.Dispose(true);
-      GC.SuppressFinalize((object) this);
-    }
-
-    protected virtual void Dispose(bool disposing)
-    {
-      if (!(this._currentState != JsonWriter.State.Closed & disposing))
-        return;
-      this.Close();
-    }
-
-    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value)
-    {
-      while (true)
-      {
-        switch (typeCode)
-        {
-          case PrimitiveTypeCode.Char:
-            goto label_1;
-          case PrimitiveTypeCode.CharNullable:
-            goto label_2;
-          case PrimitiveTypeCode.Boolean:
-            goto label_3;
-          case PrimitiveTypeCode.BooleanNullable:
-            goto label_4;
-          case PrimitiveTypeCode.SByte:
-            goto label_5;
-          case PrimitiveTypeCode.SByteNullable:
-            goto label_6;
-          case PrimitiveTypeCode.Int16:
-            goto label_7;
-          case PrimitiveTypeCode.Int16Nullable:
-            goto label_8;
-          case PrimitiveTypeCode.UInt16:
-            goto label_9;
-          case PrimitiveTypeCode.UInt16Nullable:
-            goto label_10;
-          case PrimitiveTypeCode.Int32:
-            goto label_11;
-          case PrimitiveTypeCode.Int32Nullable:
-            goto label_12;
-          case PrimitiveTypeCode.Byte:
-            goto label_13;
-          case PrimitiveTypeCode.ByteNullable:
-            goto label_14;
-          case PrimitiveTypeCode.UInt32:
-            goto label_15;
-          case PrimitiveTypeCode.UInt32Nullable:
-            goto label_16;
-          case PrimitiveTypeCode.Int64:
-            goto label_17;
-          case PrimitiveTypeCode.Int64Nullable:
-            goto label_18;
-          case PrimitiveTypeCode.UInt64:
-            goto label_19;
-          case PrimitiveTypeCode.UInt64Nullable:
-            goto label_20;
-          case PrimitiveTypeCode.Single:
-            goto label_21;
-          case PrimitiveTypeCode.SingleNullable:
-            goto label_22;
-          case PrimitiveTypeCode.Double:
-            goto label_23;
-          case PrimitiveTypeCode.DoubleNullable:
-            goto label_24;
-          case PrimitiveTypeCode.DateTime:
-            goto label_25;
-          case PrimitiveTypeCode.DateTimeNullable:
-            goto label_26;
-          case PrimitiveTypeCode.DateTimeOffset:
-            goto label_27;
-          case PrimitiveTypeCode.DateTimeOffsetNullable:
-            goto label_28;
-          case PrimitiveTypeCode.Decimal:
-            goto label_29;
-          case PrimitiveTypeCode.DecimalNullable:
-            goto label_30;
-          case PrimitiveTypeCode.Guid:
-            goto label_31;
-          case PrimitiveTypeCode.GuidNullable:
-            goto label_32;
-          case PrimitiveTypeCode.TimeSpan:
-            goto label_33;
-          case PrimitiveTypeCode.TimeSpanNullable:
-            goto label_34;
-          case PrimitiveTypeCode.Uri:
-            goto label_35;
-          case PrimitiveTypeCode.String:
-            goto label_36;
-          case PrimitiveTypeCode.Bytes:
-            goto label_37;
-          case PrimitiveTypeCode.DBNull:
-            goto label_38;
-          default:
-            if (value is IConvertible convertible)
-            {
-              JsonWriter.ResolveConvertibleValue(convertible, out typeCode, out value);
-              continue;
-            }
-            goto label_41;
-        }
-      }
-label_1:
-      writer.WriteValue((char) value);
-      return;
-label_2:
-      writer.WriteValue(value == null ? new char?() : new char?((char) value));
-      return;
-label_3:
-      writer.WriteValue((bool) value);
-      return;
-label_4:
-      writer.WriteValue(value == null ? new bool?() : new bool?((bool) value));
-      return;
-label_5:
-      writer.WriteValue((sbyte) value);
-      return;
-label_6:
-      writer.WriteValue(value == null ? new sbyte?() : new sbyte?((sbyte) value));
-      return;
-label_7:
-      writer.WriteValue((short) value);
-      return;
-label_8:
-      writer.WriteValue(value == null ? new short?() : new short?((short) value));
-      return;
-label_9:
-      writer.WriteValue((ushort) value);
-      return;
-label_10:
-      writer.WriteValue(value == null ? new ushort?() : new ushort?((ushort) value));
-      return;
-label_11:
-      writer.WriteValue((int) value);
-      return;
-label_12:
-      writer.WriteValue(value == null ? new int?() : new int?((int) value));
-      return;
-label_13:
-      writer.WriteValue((byte) value);
-      return;
-label_14:
-      writer.WriteValue(value == null ? new byte?() : new byte?((byte) value));
-      return;
-label_15:
-      writer.WriteValue((uint) value);
-      return;
-label_16:
-      writer.WriteValue(value == null ? new uint?() : new uint?((uint) value));
-      return;
-label_17:
-      writer.WriteValue((long) value);
-      return;
-label_18:
-      writer.WriteValue(value == null ? new long?() : new long?((long) value));
-      return;
-label_19:
-      writer.WriteValue((ulong) value);
-      return;
-label_20:
-      writer.WriteValue(value == null ? new ulong?() : new ulong?((ulong) value));
-      return;
-label_21:
-      writer.WriteValue((float) value);
-      return;
-label_22:
-      writer.WriteValue(value == null ? new float?() : new float?((float) value));
-      return;
-label_23:
-      writer.WriteValue((double) value);
-      return;
-label_24:
-      writer.WriteValue(value == null ? new double?() : new double?((double) value));
-      return;
-label_25:
-      writer.WriteValue((DateTime) value);
-      return;
-label_26:
-      writer.WriteValue(value == null ? new DateTime?() : new DateTime?((DateTime) value));
-      return;
-label_27:
-      writer.WriteValue((DateTimeOffset) value);
-      return;
-label_28:
-      writer.WriteValue(value == null ? new DateTimeOffset?() : new DateTimeOffset?((DateTimeOffset) value));
-      return;
-label_29:
-      writer.WriteValue((Decimal) value);
-      return;
-label_30:
-      writer.WriteValue(value == null ? new Decimal?() : new Decimal?((Decimal) value));
-      return;
-label_31:
-      writer.WriteValue((Guid) value);
-      return;
-label_32:
-      writer.WriteValue(value == null ? new Guid?() : new Guid?((Guid) value));
-      return;
-label_33:
-      writer.WriteValue((TimeSpan) value);
-      return;
-label_34:
-      writer.WriteValue(value == null ? new TimeSpan?() : new TimeSpan?((TimeSpan) value));
-      return;
-label_35:
-      writer.WriteValue((Uri) value);
-      return;
-label_36:
-      writer.WriteValue((string) value);
-      return;
-label_37:
-      writer.WriteValue((byte[]) value);
-      return;
-label_38:
-      writer.WriteNull();
-      return;
-label_41:
-      if (value != null)
-        throw JsonWriter.CreateUnsupportedTypeException(writer, value);
-      writer.WriteNull();
-    }
-
-    private static void ResolveConvertibleValue(
-      IConvertible convertible,
-      out PrimitiveTypeCode typeCode,
-      out object value)
-    {
-      TypeInformation typeInformation = ConvertUtils.GetTypeInformation(convertible);
-      typeCode = typeInformation.TypeCode == PrimitiveTypeCode.Object ? PrimitiveTypeCode.String : typeInformation.TypeCode;
-      Type conversionType = typeInformation.TypeCode == PrimitiveTypeCode.Object ? typeof (string) : typeInformation.Type;
-      value = convertible.ToType(conversionType, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    private static JsonWriterException CreateUnsupportedTypeException(
-      JsonWriter writer,
-      object value)
-    {
-      return JsonWriterException.Create(writer, "Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType()), (Exception) null);
-    }
-
-    protected void SetWriteState(JsonToken token, object value)
-    {
-      switch (token)
-      {
-        case JsonToken.StartObject:
-          this.InternalWriteStart(token, JsonContainerType.Object);
-          break;
-        case JsonToken.StartArray:
-          this.InternalWriteStart(token, JsonContainerType.Array);
-          break;
-        case JsonToken.StartConstructor:
-          this.InternalWriteStart(token, JsonContainerType.Constructor);
-          break;
-        case JsonToken.PropertyName:
-          if (!(value is string))
-            throw new ArgumentException("A name is required when setting property name state.", nameof (value));
-          this.InternalWritePropertyName((string) value);
-          break;
-        case JsonToken.Comment:
-          this.InternalWriteComment();
-          break;
-        case JsonToken.Raw:
-          this.InternalWriteRaw();
-          break;
-        case JsonToken.Integer:
-        case JsonToken.Float:
-        case JsonToken.String:
-        case JsonToken.Boolean:
-        case JsonToken.Null:
-        case JsonToken.Undefined:
-        case JsonToken.Date:
-        case JsonToken.Bytes:
-          this.InternalWriteValue(token);
-          break;
-        case JsonToken.EndObject:
-          this.InternalWriteEnd(JsonContainerType.Object);
-          break;
-        case JsonToken.EndArray:
-          this.InternalWriteEnd(JsonContainerType.Array);
-          break;
-        case JsonToken.EndConstructor:
-          this.InternalWriteEnd(JsonContainerType.Constructor);
-          break;
-        default:
-          throw new ArgumentOutOfRangeException(nameof (token));
-      }
-    }
-
-    internal void InternalWriteEnd(JsonContainerType container)
-    {
-      this.AutoCompleteClose(container);
-    }
-
-    internal void InternalWritePropertyName(string name)
-    {
-      this._currentPosition.PropertyName = name;
-      this.AutoComplete(JsonToken.PropertyName);
-    }
-
-    internal void InternalWriteRaw()
-    {
-    }
-
-    internal void InternalWriteStart(JsonToken token, JsonContainerType container)
-    {
-      this.UpdateScopeWithFinishedValue();
-      this.AutoComplete(token);
-      this.Push(container);
-    }
-
-    internal void InternalWriteValue(JsonToken token)
-    {
-      this.UpdateScopeWithFinishedValue();
-      this.AutoComplete(token);
-    }
-
-    internal void InternalWriteWhitespace(string ws)
-    {
-      if (ws != null && !StringUtils.IsWhiteSpace(ws))
-        throw JsonWriterException.Create(this, "Only white space characters should be used.", (Exception) null);
-    }
-
-    internal void InternalWriteComment() => this.AutoComplete(JsonToken.Comment);
-
-    internal enum State
-    {
-      Start,
-      Property,
-      ObjectStart,
-      Object,
-      ArrayStart,
-      Array,
-      ConstructorStart,
-      Constructor,
-      Closed,
-      Error,
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/JsonWriterException.cs b/MSHALTester/Newtonsoft/Json/JsonWriterException.cs
deleted file mode 100644
index eba3390..0000000
--- a/MSHALTester/Newtonsoft/Json/JsonWriterException.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [Serializable]
-  public class JsonWriterException : JsonException
-  {
-    public string Path { get; }
-
-    public JsonWriterException()
-    {
-    }
-
-    public JsonWriterException(string message)
-      : base(message)
-    {
-    }
-
-    public JsonWriterException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-
-    public JsonWriterException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public JsonWriterException(string message, string path, Exception innerException)
-      : base(message, innerException)
-    {
-      this.Path = path;
-    }
-
-    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex)
-    {
-      return JsonWriterException.Create(writer.ContainerPath, message, ex);
-    }
-
-    internal static JsonWriterException Create(string path, string message, Exception ex)
-    {
-      message = JsonPosition.FormatMessage((IJsonLineInfo) null, path, message);
-      return new JsonWriterException(message, path, ex);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/CommentHandling.cs b/MSHALTester/Newtonsoft/Json/Linq/CommentHandling.cs
deleted file mode 100644
index abaed9a..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/CommentHandling.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public enum CommentHandling
-  {
-    Ignore,
-    Load,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/Extensions.cs b/MSHALTester/Newtonsoft/Json/Linq/Extensions.cs
deleted file mode 100644
index 92a6df0..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/Extensions.cs
+++ /dev/null
@@ -1,151 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public static class Extensions
-  {
-    public static IJEnumerable<JToken> Ancestors<T>(this IEnumerable<T> source) where T : JToken
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      return source.SelectMany<T, JToken>((Func<T, IEnumerable<JToken>>) (j => j.Ancestors())).AsJEnumerable();
-    }
-
-    public static IJEnumerable<JToken> AncestorsAndSelf<T>(this IEnumerable<T> source) where T : JToken
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      return source.SelectMany<T, JToken>((Func<T, IEnumerable<JToken>>) (j => j.AncestorsAndSelf())).AsJEnumerable();
-    }
-
-    public static IJEnumerable<JToken> Descendants<T>(this IEnumerable<T> source) where T : JContainer
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      return source.SelectMany<T, JToken>((Func<T, IEnumerable<JToken>>) (j => j.Descendants())).AsJEnumerable();
-    }
-
-    public static IJEnumerable<JToken> DescendantsAndSelf<T>(this IEnumerable<T> source) where T : JContainer
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      return source.SelectMany<T, JToken>((Func<T, IEnumerable<JToken>>) (j => j.DescendantsAndSelf())).AsJEnumerable();
-    }
-
-    public static IJEnumerable<JProperty> Properties(this IEnumerable<JObject> source)
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      return source.SelectMany<JObject, JProperty>((Func<JObject, IEnumerable<JProperty>>) (d => d.Properties())).AsJEnumerable<JProperty>();
-    }
-
-    public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source, object key)
-    {
-      return source.Values<JToken, JToken>(key).AsJEnumerable();
-    }
-
-    public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source)
-    {
-      return source.Values((object) null);
-    }
-
-    public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source, object key)
-    {
-      return source.Values<JToken, U>(key);
-    }
-
-    public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source)
-    {
-      return source.Values<JToken, U>((object) null);
-    }
-
-    public static U Value<U>(this IEnumerable<JToken> value) => value.Value<JToken, U>();
-
-    public static U Value<T, U>(this IEnumerable<T> value) where T : JToken
-    {
-      ValidationUtils.ArgumentNotNull((object) value, nameof (value));
-      return value is JToken token ? token.Convert<JToken, U>() : throw new ArgumentException("Source value must be a JToken.");
-    }
-
-    internal static IEnumerable<U> Values<T, U>(this IEnumerable<T> source, object key) where T : JToken
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      if (key == null)
-      {
-        foreach (T obj in source)
-        {
-          T token = obj;
-          if (token is JValue token1)
-          {
-            yield return token1.Convert<JValue, U>();
-          }
-          else
-          {
-            foreach (JToken child in token.Children())
-              yield return child.Convert<JToken, U>();
-          }
-          token = default (T);
-        }
-      }
-      else
-      {
-        foreach (T obj in source)
-        {
-          JToken token = obj[key];
-          if (token != null)
-            yield return token.Convert<JToken, U>();
-        }
-      }
-    }
-
-    public static IJEnumerable<JToken> Children<T>(this IEnumerable<T> source) where T : JToken
-    {
-      return source.Children<T, JToken>().AsJEnumerable();
-    }
-
-    public static IEnumerable<U> Children<T, U>(this IEnumerable<T> source) where T : JToken
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      return source.SelectMany<T, JToken>((Func<T, IEnumerable<JToken>>) (c => (IEnumerable<JToken>) c.Children())).Convert<JToken, U>();
-    }
-
-    internal static IEnumerable<U> Convert<T, U>(this IEnumerable<T> source) where T : JToken
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      foreach (T token in source)
-        yield return token.Convert<JToken, U>();
-    }
-
-    internal static U Convert<T, U>(this T token) where T : JToken
-    {
-      if ((object) token == null)
-        return default (U);
-      if ((object) token is U && typeof (U) != typeof (IComparable) && typeof (U) != typeof (IFormattable))
-        return (U) (object) token;
-      if (!(token is JValue jvalue))
-        throw new InvalidCastException("Cannot cast {0} to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token.GetType(), (object) typeof (T)));
-      if (jvalue.Value is U u)
-        return u;
-      Type type = typeof (U);
-      if (ReflectionUtils.IsNullableType(type))
-      {
-        if (jvalue.Value == null)
-          return default (U);
-        type = Nullable.GetUnderlyingType(type);
-      }
-      return (U) System.Convert.ChangeType(jvalue.Value, type, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static IJEnumerable<JToken> AsJEnumerable(this IEnumerable<JToken> source)
-    {
-      return source.AsJEnumerable<JToken>();
-    }
-
-    public static IJEnumerable<T> AsJEnumerable<T>(this IEnumerable<T> source) where T : JToken
-    {
-      if (source == null)
-        return (IJEnumerable<T>) null;
-      return source is IJEnumerable<T> ? (IJEnumerable<T>) source : (IJEnumerable<T>) new JEnumerable<T>(source);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/IJEnumerable`1.cs b/MSHALTester/Newtonsoft/Json/Linq/IJEnumerable`1.cs
deleted file mode 100644
index cde269c..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/IJEnumerable`1.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-using System.Collections;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public interface IJEnumerable<T> : IEnumerable<T>, IEnumerable where T : JToken
-  {
-    IJEnumerable<JToken> this[object key] { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JArray.cs b/MSHALTester/Newtonsoft/Json/Linq/JArray.cs
deleted file mode 100644
index 6930ec3..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JArray.cs
+++ /dev/null
@@ -1,152 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JArray : 
-    JContainer,
-    IList<JToken>,
-    ICollection<JToken>,
-    IEnumerable<JToken>,
-    IEnumerable
-  {
-    private readonly List<JToken> _values = new List<JToken>();
-
-    protected override IList<JToken> ChildrenTokens => (IList<JToken>) this._values;
-
-    public override JTokenType Type => JTokenType.Array;
-
-    public JArray()
-    {
-    }
-
-    public JArray(JArray other)
-      : base((JContainer) other)
-    {
-    }
-
-    public JArray(params object[] content)
-      : this((object) content)
-    {
-    }
-
-    public JArray(object content) => this.Add(content);
-
-    internal override bool DeepEquals(JToken node)
-    {
-      return node is JArray container && this.ContentsEqual((JContainer) container);
-    }
-
-    internal override JToken CloneToken() => (JToken) new JArray(this);
-
-    public static JArray Load(JsonReader reader) => JArray.Load(reader, (JsonLoadSettings) null);
-
-    public static JArray Load(JsonReader reader, JsonLoadSettings settings)
-    {
-      if (reader.TokenType == JsonToken.None && !reader.Read())
-        throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader.");
-      reader.MoveToContent();
-      if (reader.TokenType != JsonToken.StartArray)
-        throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      JArray jarray = new JArray();
-      jarray.SetLineInfo(reader as IJsonLineInfo, settings);
-      jarray.ReadTokenFrom(reader, settings);
-      return jarray;
-    }
-
-    public static JArray Parse(string json) => JArray.Parse(json, (JsonLoadSettings) null);
-
-    public static JArray Parse(string json, JsonLoadSettings settings)
-    {
-      using (JsonReader reader = (JsonReader) new JsonTextReader((TextReader) new StringReader(json)))
-      {
-        JArray jarray = JArray.Load(reader, settings);
-        do
-          ;
-        while (reader.Read());
-        return jarray;
-      }
-    }
-
-    public static JArray FromObject(object o)
-    {
-      return JArray.FromObject(o, JsonSerializer.CreateDefault());
-    }
-
-    public static JArray FromObject(object o, JsonSerializer jsonSerializer)
-    {
-      JToken jtoken = JToken.FromObjectInternal(o, jsonSerializer);
-      return jtoken.Type == JTokenType.Array ? (JArray) jtoken : throw new ArgumentException("Object serialized to {0}. JArray instance expected.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) jtoken.Type));
-    }
-
-    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
-    {
-      writer.WriteStartArray();
-      for (int index = 0; index < this._values.Count; ++index)
-        this._values[index].WriteTo(writer, converters);
-      writer.WriteEndArray();
-    }
-
-    public override JToken this[object key]
-    {
-      get
-      {
-        ValidationUtils.ArgumentNotNull(key, nameof (key));
-        return key is int index ? this.GetItem(index) : throw new ArgumentException("Accessed JArray values with invalid key value: {0}. Int32 array index expected.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) MiscellaneousUtils.ToString(key)));
-      }
-      set
-      {
-        ValidationUtils.ArgumentNotNull(key, nameof (key));
-        if (!(key is int index))
-          throw new ArgumentException("Set JArray values with invalid key value: {0}. Int32 array index expected.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) MiscellaneousUtils.ToString(key)));
-        this.SetItem(index, value);
-      }
-    }
-
-    public JToken this[int index]
-    {
-      get => this.GetItem(index);
-      set => this.SetItem(index, value);
-    }
-
-    internal override int IndexOfItem(JToken item) => this._values.IndexOfReference<JToken>(item);
-
-    internal override void MergeItem(object content, JsonMergeSettings settings)
-    {
-      IEnumerable content1 = this.IsMultiContent(content) || content is JArray ? (IEnumerable) content : (IEnumerable) null;
-      if (content1 == null)
-        return;
-      JContainer.MergeEnumerableContent((JContainer) this, content1, settings);
-    }
-
-    public int IndexOf(JToken item) => this.IndexOfItem(item);
-
-    public void Insert(int index, JToken item) => this.InsertItem(index, item, false);
-
-    public void RemoveAt(int index) => this.RemoveItemAt(index);
-
-    public IEnumerator<JToken> GetEnumerator() => this.Children().GetEnumerator();
-
-    public void Add(JToken item) => this.Add((object) item);
-
-    public void Clear() => this.ClearItems();
-
-    public bool Contains(JToken item) => this.ContainsItem(item);
-
-    public void CopyTo(JToken[] array, int arrayIndex)
-    {
-      this.CopyItemsTo((Array) array, arrayIndex);
-    }
-
-    public bool IsReadOnly => false;
-
-    public bool Remove(JToken item) => this.RemoveItem(item);
-
-    internal override int GetDeepHashCode() => this.ContentsHashCode();
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JConstructor.cs b/MSHALTester/Newtonsoft/Json/Linq/JConstructor.cs
deleted file mode 100644
index 8c0e6de..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JConstructor.cs
+++ /dev/null
@@ -1,121 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JConstructor : JContainer
-  {
-    private string _name;
-    private readonly List<JToken> _values = new List<JToken>();
-
-    protected override IList<JToken> ChildrenTokens => (IList<JToken>) this._values;
-
-    internal override int IndexOfItem(JToken item) => this._values.IndexOfReference<JToken>(item);
-
-    internal override void MergeItem(object content, JsonMergeSettings settings)
-    {
-      if (!(content is JConstructor content1))
-        return;
-      if (content1.Name != null)
-        this.Name = content1.Name;
-      JContainer.MergeEnumerableContent((JContainer) this, (IEnumerable) content1, settings);
-    }
-
-    public string Name
-    {
-      get => this._name;
-      set => this._name = value;
-    }
-
-    public override JTokenType Type => JTokenType.Constructor;
-
-    public JConstructor()
-    {
-    }
-
-    public JConstructor(JConstructor other)
-      : base((JContainer) other)
-    {
-      this._name = other.Name;
-    }
-
-    public JConstructor(string name, params object[] content)
-      : this(name, (object) content)
-    {
-    }
-
-    public JConstructor(string name, object content)
-      : this(name)
-    {
-      this.Add(content);
-    }
-
-    public JConstructor(string name)
-    {
-      switch (name)
-      {
-        case null:
-          throw new ArgumentNullException(nameof (name));
-        case "":
-          throw new ArgumentException("Constructor name cannot be empty.", nameof (name));
-        default:
-          this._name = name;
-          break;
-      }
-    }
-
-    internal override bool DeepEquals(JToken node)
-    {
-      return node is JConstructor container && this._name == container.Name && this.ContentsEqual((JContainer) container);
-    }
-
-    internal override JToken CloneToken() => (JToken) new JConstructor(this);
-
-    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
-    {
-      writer.WriteStartConstructor(this._name);
-      int count = this._values.Count;
-      for (int index = 0; index < count; ++index)
-        this._values[index].WriteTo(writer, converters);
-      writer.WriteEndConstructor();
-    }
-
-    public override JToken this[object key]
-    {
-      get
-      {
-        ValidationUtils.ArgumentNotNull(key, nameof (key));
-        return key is int index ? this.GetItem(index) : throw new ArgumentException("Accessed JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) MiscellaneousUtils.ToString(key)));
-      }
-      set
-      {
-        ValidationUtils.ArgumentNotNull(key, nameof (key));
-        if (!(key is int index))
-          throw new ArgumentException("Set JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) MiscellaneousUtils.ToString(key)));
-        this.SetItem(index, value);
-      }
-    }
-
-    internal override int GetDeepHashCode() => this._name.GetHashCode() ^ this.ContentsHashCode();
-
-    public static JConstructor Load(JsonReader reader)
-    {
-      return JConstructor.Load(reader, (JsonLoadSettings) null);
-    }
-
-    public static JConstructor Load(JsonReader reader, JsonLoadSettings settings)
-    {
-      if (reader.TokenType == JsonToken.None && !reader.Read())
-        throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader.");
-      reader.MoveToContent();
-      JConstructor jconstructor = reader.TokenType == JsonToken.StartConstructor ? new JConstructor((string) reader.Value) : throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      jconstructor.SetLineInfo(reader as IJsonLineInfo, settings);
-      jconstructor.ReadTokenFrom(reader, settings);
-      return jconstructor;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JContainer.cs b/MSHALTester/Newtonsoft/Json/Linq/JContainer.cs
deleted file mode 100644
index 27b9eed..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JContainer.cs
+++ /dev/null
@@ -1,718 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Globalization;
-using System.Threading;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public abstract class JContainer : 
-    JToken,
-    IList<JToken>,
-    ICollection<JToken>,
-    IEnumerable<JToken>,
-    IEnumerable,
-    ITypedList,
-    IBindingList,
-    IList,
-    ICollection
-  {
-    internal ListChangedEventHandler _listChanged;
-    internal AddingNewEventHandler _addingNew;
-    private object _syncRoot;
-    private bool _busy;
-
-    public event ListChangedEventHandler ListChanged
-    {
-      add => this._listChanged += value;
-      remove => this._listChanged -= value;
-    }
-
-    public event AddingNewEventHandler AddingNew
-    {
-      add => this._addingNew += value;
-      remove => this._addingNew -= value;
-    }
-
-    protected abstract IList<JToken> ChildrenTokens { get; }
-
-    internal JContainer()
-    {
-    }
-
-    internal JContainer(JContainer other)
-      : this()
-    {
-      ValidationUtils.ArgumentNotNull((object) other, nameof (other));
-      int index = 0;
-      foreach (JToken content in (IEnumerable<JToken>) other)
-      {
-        this.AddInternal(index, (object) content, false);
-        ++index;
-      }
-    }
-
-    internal void CheckReentrancy()
-    {
-      if (this._busy)
-        throw new InvalidOperationException("Cannot change {0} during a collection change event.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType()));
-    }
-
-    internal virtual IList<JToken> CreateChildrenCollection() => (IList<JToken>) new List<JToken>();
-
-    protected virtual void OnAddingNew(AddingNewEventArgs e)
-    {
-      AddingNewEventHandler addingNew = this._addingNew;
-      if (addingNew == null)
-        return;
-      addingNew((object) this, e);
-    }
-
-    protected virtual void OnListChanged(ListChangedEventArgs e)
-    {
-      ListChangedEventHandler listChanged = this._listChanged;
-      if (listChanged == null)
-        return;
-      this._busy = true;
-      try
-      {
-        listChanged((object) this, e);
-      }
-      finally
-      {
-        this._busy = false;
-      }
-    }
-
-    public override bool HasValues => this.ChildrenTokens.Count > 0;
-
-    internal bool ContentsEqual(JContainer container)
-    {
-      if (container == this)
-        return true;
-      IList<JToken> childrenTokens1 = this.ChildrenTokens;
-      IList<JToken> childrenTokens2 = container.ChildrenTokens;
-      if (childrenTokens1.Count != childrenTokens2.Count)
-        return false;
-      for (int index = 0; index < childrenTokens1.Count; ++index)
-      {
-        if (!childrenTokens1[index].DeepEquals(childrenTokens2[index]))
-          return false;
-      }
-      return true;
-    }
-
-    public override JToken First
-    {
-      get
-      {
-        IList<JToken> childrenTokens = this.ChildrenTokens;
-        return childrenTokens.Count <= 0 ? (JToken) null : childrenTokens[0];
-      }
-    }
-
-    public override JToken Last
-    {
-      get
-      {
-        IList<JToken> childrenTokens = this.ChildrenTokens;
-        int count = childrenTokens.Count;
-        return count <= 0 ? (JToken) null : childrenTokens[count - 1];
-      }
-    }
-
-    public override JEnumerable<JToken> Children()
-    {
-      return new JEnumerable<JToken>((IEnumerable<JToken>) this.ChildrenTokens);
-    }
-
-    public override IEnumerable<T> Values<T>() => this.ChildrenTokens.Convert<JToken, T>();
-
-    public IEnumerable<JToken> Descendants() => this.GetDescendants(false);
-
-    public IEnumerable<JToken> DescendantsAndSelf() => this.GetDescendants(true);
-
-    internal IEnumerable<JToken> GetDescendants(bool self)
-    {
-      JContainer descendant1 = this;
-      if (self)
-        yield return (JToken) descendant1;
-      foreach (JToken o in (IEnumerable<JToken>) descendant1.ChildrenTokens)
-      {
-        yield return o;
-        if (o is JContainer jcontainer)
-        {
-          foreach (JToken descendant2 in jcontainer.Descendants())
-            yield return descendant2;
-        }
-      }
-    }
-
-    internal bool IsMultiContent(object content)
-    {
-      return content is IEnumerable && !(content is string) && !(content is JToken) && !(content is byte[]);
-    }
-
-    internal JToken EnsureParentToken(JToken item, bool skipParentCheck)
-    {
-      if (item == null)
-        return (JToken) JValue.CreateNull();
-      if (skipParentCheck || item.Parent == null && item != this && (!item.HasValues || this.Root != item))
-        return item;
-      item = item.CloneToken();
-      return item;
-    }
-
-    internal abstract int IndexOfItem(JToken item);
-
-    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck)
-    {
-      IList<JToken> childrenTokens = this.ChildrenTokens;
-      if (index > childrenTokens.Count)
-        throw new ArgumentOutOfRangeException(nameof (index), "Index must be within the bounds of the List.");
-      this.CheckReentrancy();
-      item = this.EnsureParentToken(item, skipParentCheck);
-      JToken jtoken1 = index == 0 ? (JToken) null : childrenTokens[index - 1];
-      JToken jtoken2 = index == childrenTokens.Count ? (JToken) null : childrenTokens[index];
-      this.ValidateToken(item, (JToken) null);
-      item.Parent = this;
-      item.Previous = jtoken1;
-      if (jtoken1 != null)
-        jtoken1.Next = item;
-      item.Next = jtoken2;
-      if (jtoken2 != null)
-        jtoken2.Previous = item;
-      childrenTokens.Insert(index, item);
-      if (this._listChanged == null)
-        return;
-      this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, index));
-    }
-
-    internal virtual void RemoveItemAt(int index)
-    {
-      IList<JToken> childrenTokens = this.ChildrenTokens;
-      if (index < 0)
-        throw new ArgumentOutOfRangeException(nameof (index), "Index is less than 0.");
-      if (index >= childrenTokens.Count)
-        throw new ArgumentOutOfRangeException(nameof (index), "Index is equal to or greater than Count.");
-      this.CheckReentrancy();
-      JToken jtoken1 = childrenTokens[index];
-      JToken jtoken2 = index == 0 ? (JToken) null : childrenTokens[index - 1];
-      JToken jtoken3 = index == childrenTokens.Count - 1 ? (JToken) null : childrenTokens[index + 1];
-      if (jtoken2 != null)
-        jtoken2.Next = jtoken3;
-      if (jtoken3 != null)
-        jtoken3.Previous = jtoken2;
-      jtoken1.Parent = (JContainer) null;
-      jtoken1.Previous = (JToken) null;
-      jtoken1.Next = (JToken) null;
-      childrenTokens.RemoveAt(index);
-      if (this._listChanged == null)
-        return;
-      this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));
-    }
-
-    internal virtual bool RemoveItem(JToken item)
-    {
-      int index = this.IndexOfItem(item);
-      if (index < 0)
-        return false;
-      this.RemoveItemAt(index);
-      return true;
-    }
-
-    internal virtual JToken GetItem(int index) => this.ChildrenTokens[index];
-
-    internal virtual void SetItem(int index, JToken item)
-    {
-      IList<JToken> childrenTokens = this.ChildrenTokens;
-      if (index < 0)
-        throw new ArgumentOutOfRangeException(nameof (index), "Index is less than 0.");
-      if (index >= childrenTokens.Count)
-        throw new ArgumentOutOfRangeException(nameof (index), "Index is equal to or greater than Count.");
-      JToken jtoken1 = childrenTokens[index];
-      if (JContainer.IsTokenUnchanged(jtoken1, item))
-        return;
-      this.CheckReentrancy();
-      item = this.EnsureParentToken(item, false);
-      this.ValidateToken(item, jtoken1);
-      JToken jtoken2 = index == 0 ? (JToken) null : childrenTokens[index - 1];
-      JToken jtoken3 = index == childrenTokens.Count - 1 ? (JToken) null : childrenTokens[index + 1];
-      item.Parent = this;
-      item.Previous = jtoken2;
-      if (jtoken2 != null)
-        jtoken2.Next = item;
-      item.Next = jtoken3;
-      if (jtoken3 != null)
-        jtoken3.Previous = item;
-      childrenTokens[index] = item;
-      jtoken1.Parent = (JContainer) null;
-      jtoken1.Previous = (JToken) null;
-      jtoken1.Next = (JToken) null;
-      if (this._listChanged == null)
-        return;
-      this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
-    }
-
-    internal virtual void ClearItems()
-    {
-      this.CheckReentrancy();
-      IList<JToken> childrenTokens = this.ChildrenTokens;
-      foreach (JToken jtoken in (IEnumerable<JToken>) childrenTokens)
-      {
-        jtoken.Parent = (JContainer) null;
-        jtoken.Previous = (JToken) null;
-        jtoken.Next = (JToken) null;
-      }
-      childrenTokens.Clear();
-      if (this._listChanged == null)
-        return;
-      this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
-    }
-
-    internal virtual void ReplaceItem(JToken existing, JToken replacement)
-    {
-      if (existing == null || existing.Parent != this)
-        return;
-      this.SetItem(this.IndexOfItem(existing), replacement);
-    }
-
-    internal virtual bool ContainsItem(JToken item) => this.IndexOfItem(item) != -1;
-
-    internal virtual void CopyItemsTo(Array array, int arrayIndex)
-    {
-      if (array == null)
-        throw new ArgumentNullException(nameof (array));
-      if (arrayIndex < 0)
-        throw new ArgumentOutOfRangeException(nameof (arrayIndex), "arrayIndex is less than 0.");
-      if (arrayIndex >= array.Length && arrayIndex != 0)
-        throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
-      if (this.Count > array.Length - arrayIndex)
-        throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
-      int num = 0;
-      foreach (JToken childrenToken in (IEnumerable<JToken>) this.ChildrenTokens)
-      {
-        array.SetValue((object) childrenToken, arrayIndex + num);
-        ++num;
-      }
-    }
-
-    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue)
-    {
-      if (!(currentValue is JValue jvalue))
-        return false;
-      return jvalue.Type == JTokenType.Null && newValue == null || jvalue.Equals((object) newValue);
-    }
-
-    internal virtual void ValidateToken(JToken o, JToken existing)
-    {
-      ValidationUtils.ArgumentNotNull((object) o, nameof (o));
-      if (o.Type == JTokenType.Property)
-        throw new ArgumentException("Can not add {0} to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) o.GetType(), (object) this.GetType()));
-    }
-
-    public virtual void Add(object content)
-    {
-      this.AddInternal(this.ChildrenTokens.Count, content, false);
-    }
-
-    internal void AddAndSkipParentCheck(JToken token)
-    {
-      this.AddInternal(this.ChildrenTokens.Count, (object) token, true);
-    }
-
-    public void AddFirst(object content) => this.AddInternal(0, content, false);
-
-    internal void AddInternal(int index, object content, bool skipParentCheck)
-    {
-      if (this.IsMultiContent(content))
-      {
-        IEnumerable enumerable = (IEnumerable) content;
-        int index1 = index;
-        foreach (object content1 in enumerable)
-        {
-          this.AddInternal(index1, content1, skipParentCheck);
-          ++index1;
-        }
-      }
-      else
-      {
-        JToken fromContent = JContainer.CreateFromContent(content);
-        this.InsertItem(index, fromContent, skipParentCheck);
-      }
-    }
-
-    internal static JToken CreateFromContent(object content)
-    {
-      return content is JToken jtoken ? jtoken : (JToken) new JValue(content);
-    }
-
-    public JsonWriter CreateWriter() => (JsonWriter) new JTokenWriter(this);
-
-    public void ReplaceAll(object content)
-    {
-      this.ClearItems();
-      this.Add(content);
-    }
-
-    public void RemoveAll() => this.ClearItems();
-
-    internal abstract void MergeItem(object content, JsonMergeSettings settings);
-
-    public void Merge(object content) => this.MergeItem(content, new JsonMergeSettings());
-
-    public void Merge(object content, JsonMergeSettings settings)
-    {
-      this.MergeItem(content, settings);
-    }
-
-    internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options)
-    {
-      int depth = reader.Depth;
-      if (!reader.Read())
-        throw JsonReaderException.Create(reader, "Error reading {0} from JsonReader.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType().Name));
-      this.ReadContentFrom(reader, options);
-      if (reader.Depth > depth)
-        throw JsonReaderException.Create(reader, "Unexpected end of content while loading {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType().Name));
-    }
-
-    internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings)
-    {
-      ValidationUtils.ArgumentNotNull((object) r, nameof (r));
-      IJsonLineInfo lineInfo = r as IJsonLineInfo;
-      JContainer jcontainer = this;
-      do
-      {
-        if ((jcontainer is JProperty jproperty1 ? jproperty1.Value : (JToken) null) != null)
-        {
-          if (jcontainer == this)
-            break;
-          jcontainer = jcontainer.Parent;
-        }
-        switch (r.TokenType)
-        {
-          case JsonToken.None:
-            continue;
-          case JsonToken.StartObject:
-            JObject content1 = new JObject();
-            content1.SetLineInfo(lineInfo, settings);
-            jcontainer.Add((object) content1);
-            jcontainer = (JContainer) content1;
-            goto case JsonToken.None;
-          case JsonToken.StartArray:
-            JArray content2 = new JArray();
-            content2.SetLineInfo(lineInfo, settings);
-            jcontainer.Add((object) content2);
-            jcontainer = (JContainer) content2;
-            goto case JsonToken.None;
-          case JsonToken.StartConstructor:
-            JConstructor content3 = new JConstructor(r.Value.ToString());
-            content3.SetLineInfo(lineInfo, settings);
-            jcontainer.Add((object) content3);
-            jcontainer = (JContainer) content3;
-            goto case JsonToken.None;
-          case JsonToken.PropertyName:
-            string name = r.Value.ToString();
-            JProperty content4 = new JProperty(name);
-            content4.SetLineInfo(lineInfo, settings);
-            JProperty jproperty2 = ((JObject) jcontainer).Property(name);
-            if (jproperty2 == null)
-              jcontainer.Add((object) content4);
-            else
-              jproperty2.Replace((JToken) content4);
-            jcontainer = (JContainer) content4;
-            goto case JsonToken.None;
-          case JsonToken.Comment:
-            if (settings != null && settings.CommentHandling == CommentHandling.Load)
-            {
-              JValue comment = JValue.CreateComment(r.Value.ToString());
-              comment.SetLineInfo(lineInfo, settings);
-              jcontainer.Add((object) comment);
-              goto case JsonToken.None;
-            }
-            else
-              goto case JsonToken.None;
-          case JsonToken.Integer:
-          case JsonToken.Float:
-          case JsonToken.String:
-          case JsonToken.Boolean:
-          case JsonToken.Date:
-          case JsonToken.Bytes:
-            JValue content5 = new JValue(r.Value);
-            content5.SetLineInfo(lineInfo, settings);
-            jcontainer.Add((object) content5);
-            goto case JsonToken.None;
-          case JsonToken.Null:
-            JValue content6 = JValue.CreateNull();
-            content6.SetLineInfo(lineInfo, settings);
-            jcontainer.Add((object) content6);
-            goto case JsonToken.None;
-          case JsonToken.Undefined:
-            JValue undefined = JValue.CreateUndefined();
-            undefined.SetLineInfo(lineInfo, settings);
-            jcontainer.Add((object) undefined);
-            goto case JsonToken.None;
-          case JsonToken.EndObject:
-            if (jcontainer == this)
-              return;
-            jcontainer = jcontainer.Parent;
-            goto case JsonToken.None;
-          case JsonToken.EndArray:
-            if (jcontainer == this)
-              return;
-            jcontainer = jcontainer.Parent;
-            goto case JsonToken.None;
-          case JsonToken.EndConstructor:
-            if (jcontainer == this)
-              return;
-            jcontainer = jcontainer.Parent;
-            goto case JsonToken.None;
-          default:
-            throw new InvalidOperationException("The JsonReader should not be on a token of type {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) r.TokenType));
-        }
-      }
-      while (r.Read());
-    }
-
-    internal int ContentsHashCode()
-    {
-      int num = 0;
-      foreach (JToken childrenToken in (IEnumerable<JToken>) this.ChildrenTokens)
-        num ^= childrenToken.GetDeepHashCode();
-      return num;
-    }
-
-    string ITypedList.GetListName(PropertyDescriptor[] listAccessors) => string.Empty;
-
-    PropertyDescriptorCollection ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)
-    {
-      return !(this.First is ICustomTypeDescriptor first) ? (PropertyDescriptorCollection) null : first.GetProperties();
-    }
-
-    int IList<JToken>.IndexOf(JToken item) => this.IndexOfItem(item);
-
-    void IList<JToken>.Insert(int index, JToken item) => this.InsertItem(index, item, false);
-
-    void IList<JToken>.RemoveAt(int index) => this.RemoveItemAt(index);
-
-    JToken IList<JToken>.this[int index]
-    {
-      get => this.GetItem(index);
-      set => this.SetItem(index, value);
-    }
-
-    void ICollection<JToken>.Add(JToken item) => this.Add((object) item);
-
-    void ICollection<JToken>.Clear() => this.ClearItems();
-
-    bool ICollection<JToken>.Contains(JToken item) => this.ContainsItem(item);
-
-    void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
-    {
-      this.CopyItemsTo((Array) array, arrayIndex);
-    }
-
-    bool ICollection<JToken>.IsReadOnly => false;
-
-    bool ICollection<JToken>.Remove(JToken item) => this.RemoveItem(item);
-
-    private JToken EnsureValue(object value)
-    {
-      if (value == null)
-        return (JToken) null;
-      return value is JToken jtoken ? jtoken : throw new ArgumentException("Argument is not a JToken.");
-    }
-
-    int IList.Add(object value)
-    {
-      this.Add((object) this.EnsureValue(value));
-      return this.Count - 1;
-    }
-
-    void IList.Clear() => this.ClearItems();
-
-    bool IList.Contains(object value) => this.ContainsItem(this.EnsureValue(value));
-
-    int IList.IndexOf(object value) => this.IndexOfItem(this.EnsureValue(value));
-
-    void IList.Insert(int index, object value)
-    {
-      this.InsertItem(index, this.EnsureValue(value), false);
-    }
-
-    bool IList.IsFixedSize => false;
-
-    bool IList.IsReadOnly => false;
-
-    void IList.Remove(object value) => this.RemoveItem(this.EnsureValue(value));
-
-    void IList.RemoveAt(int index) => this.RemoveItemAt(index);
-
-    object IList.this[int index]
-    {
-      get => (object) this.GetItem(index);
-      set => this.SetItem(index, this.EnsureValue(value));
-    }
-
-    void ICollection.CopyTo(Array array, int index) => this.CopyItemsTo(array, index);
-
-    public int Count => this.ChildrenTokens.Count;
-
-    bool ICollection.IsSynchronized => false;
-
-    object ICollection.SyncRoot
-    {
-      get
-      {
-        if (this._syncRoot == null)
-          Interlocked.CompareExchange(ref this._syncRoot, new object(), (object) null);
-        return this._syncRoot;
-      }
-    }
-
-    void IBindingList.AddIndex(PropertyDescriptor property)
-    {
-    }
-
-    object IBindingList.AddNew()
-    {
-      AddingNewEventArgs e = new AddingNewEventArgs();
-      this.OnAddingNew(e);
-      if (e.NewObject == null)
-        throw new JsonException("Could not determine new value to add to '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType()));
-      JToken content = e.NewObject is JToken ? (JToken) e.NewObject : throw new JsonException("New item to be added to collection must be compatible with {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeof (JToken)));
-      this.Add((object) content);
-      return (object) content;
-    }
-
-    bool IBindingList.AllowEdit => true;
-
-    bool IBindingList.AllowNew => true;
-
-    bool IBindingList.AllowRemove => true;
-
-    void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
-    {
-      throw new NotSupportedException();
-    }
-
-    int IBindingList.Find(PropertyDescriptor property, object key)
-    {
-      throw new NotSupportedException();
-    }
-
-    bool IBindingList.IsSorted => false;
-
-    void IBindingList.RemoveIndex(PropertyDescriptor property)
-    {
-    }
-
-    void IBindingList.RemoveSort() => throw new NotSupportedException();
-
-    ListSortDirection IBindingList.SortDirection => ListSortDirection.Ascending;
-
-    PropertyDescriptor IBindingList.SortProperty => (PropertyDescriptor) null;
-
-    bool IBindingList.SupportsChangeNotification => true;
-
-    bool IBindingList.SupportsSearching => false;
-
-    bool IBindingList.SupportsSorting => false;
-
-    internal static void MergeEnumerableContent(
-      JContainer target,
-      IEnumerable content,
-      JsonMergeSettings settings)
-    {
-      switch (settings.MergeArrayHandling)
-      {
-        case MergeArrayHandling.Concat:
-          IEnumerator enumerator1 = content.GetEnumerator();
-          try
-          {
-            while (enumerator1.MoveNext())
-            {
-              JToken current = (JToken) enumerator1.Current;
-              target.Add((object) current);
-            }
-            break;
-          }
-          finally
-          {
-            if (enumerator1 is IDisposable disposable)
-              disposable.Dispose();
-          }
-        case MergeArrayHandling.Union:
-          HashSet<JToken> jtokenSet = new HashSet<JToken>((IEnumerable<JToken>) target, (IEqualityComparer<JToken>) JToken.EqualityComparer);
-          IEnumerator enumerator2 = content.GetEnumerator();
-          try
-          {
-            while (enumerator2.MoveNext())
-            {
-              JToken current = (JToken) enumerator2.Current;
-              if (jtokenSet.Add(current))
-                target.Add((object) current);
-            }
-            break;
-          }
-          finally
-          {
-            if (enumerator2 is IDisposable disposable)
-              disposable.Dispose();
-          }
-        case MergeArrayHandling.Replace:
-          target.ClearItems();
-          IEnumerator enumerator3 = content.GetEnumerator();
-          try
-          {
-            while (enumerator3.MoveNext())
-            {
-              JToken current = (JToken) enumerator3.Current;
-              target.Add((object) current);
-            }
-            break;
-          }
-          finally
-          {
-            if (enumerator3 is IDisposable disposable)
-              disposable.Dispose();
-          }
-        case MergeArrayHandling.Merge:
-          int key = 0;
-          IEnumerator enumerator4 = content.GetEnumerator();
-          try
-          {
-            while (enumerator4.MoveNext())
-            {
-              object current = enumerator4.Current;
-              if (key < target.Count)
-              {
-                if (target[(object) key] is JContainer jcontainer)
-                  jcontainer.Merge(current, settings);
-                else if (current != null)
-                {
-                  JToken fromContent = JContainer.CreateFromContent(current);
-                  if (fromContent.Type != JTokenType.Null)
-                    target[(object) key] = fromContent;
-                }
-              }
-              else
-                target.Add(current);
-              ++key;
-            }
-            break;
-          }
-          finally
-          {
-            if (enumerator4 is IDisposable disposable)
-              disposable.Dispose();
-          }
-        default:
-          throw new ArgumentOutOfRangeException(nameof (settings), "Unexpected merge array handling when merging JSON.");
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JEnumerable`1.cs b/MSHALTester/Newtonsoft/Json/Linq/JEnumerable`1.cs
deleted file mode 100644
index 2bb8e36..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JEnumerable`1.cs
+++ /dev/null
@@ -1,53 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public readonly struct JEnumerable<T> : 
-    IJEnumerable<T>,
-    IEnumerable<T>,
-    IEnumerable,
-    IEquatable<JEnumerable<T>>
-    where T : JToken
-  {
-    public static readonly JEnumerable<T> Empty = new JEnumerable<T>(Enumerable.Empty<T>());
-    private readonly IEnumerable<T> _enumerable;
-
-    public JEnumerable(IEnumerable<T> enumerable)
-    {
-      ValidationUtils.ArgumentNotNull((object) enumerable, nameof (enumerable));
-      this._enumerable = enumerable;
-    }
-
-    public IEnumerator<T> GetEnumerator()
-    {
-      return ((IEnumerable<T>) ((object) this._enumerable ?? (object) JEnumerable<T>.Empty)).GetEnumerator();
-    }
-
-    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-
-    public IJEnumerable<JToken> this[object key]
-    {
-      get
-      {
-        return this._enumerable == null ? (IJEnumerable<JToken>) JEnumerable<JToken>.Empty : (IJEnumerable<JToken>) new JEnumerable<JToken>(this._enumerable.Values<T, JToken>(key));
-      }
-    }
-
-    public bool Equals(JEnumerable<T> other)
-    {
-      return object.Equals((object) this._enumerable, (object) other._enumerable);
-    }
-
-    public override bool Equals(object obj) => obj is JEnumerable<T> other && this.Equals(other);
-
-    public override int GetHashCode()
-    {
-      return this._enumerable == null ? 0 : this._enumerable.GetHashCode();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JObject.cs b/MSHALTester/Newtonsoft/Json/Linq/JObject.cs
deleted file mode 100644
index 7adbfe7..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JObject.cs
+++ /dev/null
@@ -1,395 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.ComponentModel;
-using System.Globalization;
-using System.IO;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JObject : 
-    JContainer,
-    IDictionary<string, JToken>,
-    ICollection<KeyValuePair<string, JToken>>,
-    IEnumerable<KeyValuePair<string, JToken>>,
-    IEnumerable,
-    INotifyPropertyChanged,
-    ICustomTypeDescriptor,
-    INotifyPropertyChanging
-  {
-    private readonly JPropertyKeyedCollection _properties = new JPropertyKeyedCollection();
-
-    protected override IList<JToken> ChildrenTokens => (IList<JToken>) this._properties;
-
-    public event PropertyChangedEventHandler PropertyChanged;
-
-    public event PropertyChangingEventHandler PropertyChanging;
-
-    public JObject()
-    {
-    }
-
-    public JObject(JObject other)
-      : base((JContainer) other)
-    {
-    }
-
-    public JObject(params object[] content)
-      : this((object) content)
-    {
-    }
-
-    public JObject(object content) => this.Add(content);
-
-    internal override bool DeepEquals(JToken node)
-    {
-      return node is JObject jobject && this._properties.Compare(jobject._properties);
-    }
-
-    internal override int IndexOfItem(JToken item) => this._properties.IndexOfReference(item);
-
-    internal override void InsertItem(int index, JToken item, bool skipParentCheck)
-    {
-      if (item != null && item.Type == JTokenType.Comment)
-        return;
-      base.InsertItem(index, item, skipParentCheck);
-    }
-
-    internal override void ValidateToken(JToken o, JToken existing)
-    {
-      ValidationUtils.ArgumentNotNull((object) o, nameof (o));
-      JProperty jproperty1 = o.Type == JTokenType.Property ? (JProperty) o : throw new ArgumentException("Can not add {0} to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) o.GetType(), (object) this.GetType()));
-      if (existing != null)
-      {
-        JProperty jproperty2 = (JProperty) existing;
-        if (jproperty1.Name == jproperty2.Name)
-          return;
-      }
-      if (this._properties.TryGetValue(jproperty1.Name, out existing))
-        throw new ArgumentException("Can not add property {0} to {1}. Property with the same name already exists on object.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) jproperty1.Name, (object) this.GetType()));
-    }
-
-    internal override void MergeItem(object content, JsonMergeSettings settings)
-    {
-      if (!(content is JObject jobject))
-        return;
-      foreach (KeyValuePair<string, JToken> keyValuePair in jobject)
-      {
-        JProperty jproperty = this.Property(keyValuePair.Key);
-        if (jproperty == null)
-          this.Add(keyValuePair.Key, keyValuePair.Value);
-        else if (keyValuePair.Value != null)
-        {
-          if (!(jproperty.Value is JContainer jcontainer) || jcontainer.Type != keyValuePair.Value.Type)
-          {
-            if (!JObject.IsNull(keyValuePair.Value) || settings != null && settings.MergeNullValueHandling == MergeNullValueHandling.Merge)
-              jproperty.Value = keyValuePair.Value;
-          }
-          else
-            jcontainer.Merge((object) keyValuePair.Value, settings);
-        }
-      }
-    }
-
-    private static bool IsNull(JToken token)
-    {
-      return token.Type == JTokenType.Null || token is JValue jvalue && jvalue.Value == null;
-    }
-
-    internal void InternalPropertyChanged(JProperty childProperty)
-    {
-      this.OnPropertyChanged(childProperty.Name);
-      if (this._listChanged == null)
-        return;
-      this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, this.IndexOfItem((JToken) childProperty)));
-    }
-
-    internal void InternalPropertyChanging(JProperty childProperty)
-    {
-      this.OnPropertyChanging(childProperty.Name);
-    }
-
-    internal override JToken CloneToken() => (JToken) new JObject(this);
-
-    public override JTokenType Type => JTokenType.Object;
-
-    public IEnumerable<JProperty> Properties() => this._properties.Cast<JProperty>();
-
-    public JProperty Property(string name)
-    {
-      if (name == null)
-        return (JProperty) null;
-      JToken jtoken;
-      this._properties.TryGetValue(name, out jtoken);
-      return (JProperty) jtoken;
-    }
-
-    public JEnumerable<JToken> PropertyValues()
-    {
-      return new JEnumerable<JToken>(this.Properties().Select<JProperty, JToken>((Func<JProperty, JToken>) (p => p.Value)));
-    }
-
-    public override JToken this[object key]
-    {
-      get
-      {
-        ValidationUtils.ArgumentNotNull(key, nameof (key));
-        return key is string propertyName ? this[propertyName] : throw new ArgumentException("Accessed JObject values with invalid key value: {0}. Object property name expected.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) MiscellaneousUtils.ToString(key)));
-      }
-      set
-      {
-        ValidationUtils.ArgumentNotNull(key, nameof (key));
-        if (!(key is string propertyName))
-          throw new ArgumentException("Set JObject values with invalid key value: {0}. Object property name expected.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) MiscellaneousUtils.ToString(key)));
-        this[propertyName] = value;
-      }
-    }
-
-    public JToken this[string propertyName]
-    {
-      get
-      {
-        ValidationUtils.ArgumentNotNull((object) propertyName, nameof (propertyName));
-        return this.Property(propertyName)?.Value;
-      }
-      set
-      {
-        JProperty jproperty = this.Property(propertyName);
-        if (jproperty != null)
-        {
-          jproperty.Value = value;
-        }
-        else
-        {
-          this.OnPropertyChanging(propertyName);
-          this.Add((object) new JProperty(propertyName, (object) value));
-          this.OnPropertyChanged(propertyName);
-        }
-      }
-    }
-
-    public static JObject Load(JsonReader reader) => JObject.Load(reader, (JsonLoadSettings) null);
-
-    public static JObject Load(JsonReader reader, JsonLoadSettings settings)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      if (reader.TokenType == JsonToken.None && !reader.Read())
-        throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader.");
-      reader.MoveToContent();
-      if (reader.TokenType != JsonToken.StartObject)
-        throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      JObject jobject = new JObject();
-      jobject.SetLineInfo(reader as IJsonLineInfo, settings);
-      jobject.ReadTokenFrom(reader, settings);
-      return jobject;
-    }
-
-    public static JObject Parse(string json) => JObject.Parse(json, (JsonLoadSettings) null);
-
-    public static JObject Parse(string json, JsonLoadSettings settings)
-    {
-      using (JsonReader reader = (JsonReader) new JsonTextReader((TextReader) new StringReader(json)))
-      {
-        JObject jobject = JObject.Load(reader, settings);
-        do
-          ;
-        while (reader.Read());
-        return jobject;
-      }
-    }
-
-    public static JObject FromObject(object o)
-    {
-      return JObject.FromObject(o, JsonSerializer.CreateDefault());
-    }
-
-    public static JObject FromObject(object o, JsonSerializer jsonSerializer)
-    {
-      JToken jtoken = JToken.FromObjectInternal(o, jsonSerializer);
-      return jtoken == null || jtoken.Type == JTokenType.Object ? (JObject) jtoken : throw new ArgumentException("Object serialized to {0}. JObject instance expected.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) jtoken.Type));
-    }
-
-    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
-    {
-      writer.WriteStartObject();
-      for (int index = 0; index < this._properties.Count; ++index)
-        this._properties[index].WriteTo(writer, converters);
-      writer.WriteEndObject();
-    }
-
-    public JToken GetValue(string propertyName)
-    {
-      return this.GetValue(propertyName, StringComparison.Ordinal);
-    }
-
-    public JToken GetValue(string propertyName, StringComparison comparison)
-    {
-      if (propertyName == null)
-        return (JToken) null;
-      JProperty jproperty = this.Property(propertyName);
-      if (jproperty != null)
-        return jproperty.Value;
-      if (comparison != StringComparison.Ordinal)
-      {
-        foreach (JProperty property in (Collection<JToken>) this._properties)
-        {
-          if (string.Equals(property.Name, propertyName, comparison))
-            return property.Value;
-        }
-      }
-      return (JToken) null;
-    }
-
-    public bool TryGetValue(string propertyName, StringComparison comparison, out JToken value)
-    {
-      value = this.GetValue(propertyName, comparison);
-      return value != null;
-    }
-
-    public void Add(string propertyName, JToken value)
-    {
-      this.Add((object) new JProperty(propertyName, (object) value));
-    }
-
-    public bool ContainsKey(string propertyName)
-    {
-      ValidationUtils.ArgumentNotNull((object) propertyName, nameof (propertyName));
-      return this._properties.Contains(propertyName);
-    }
-
-    ICollection<string> IDictionary<string, JToken>.Keys => this._properties.Keys;
-
-    public bool Remove(string propertyName)
-    {
-      JProperty jproperty = this.Property(propertyName);
-      if (jproperty == null)
-        return false;
-      jproperty.Remove();
-      return true;
-    }
-
-    public bool TryGetValue(string propertyName, out JToken value)
-    {
-      JProperty jproperty = this.Property(propertyName);
-      if (jproperty == null)
-      {
-        value = (JToken) null;
-        return false;
-      }
-      value = jproperty.Value;
-      return true;
-    }
-
-    ICollection<JToken> IDictionary<string, JToken>.Values => throw new NotImplementedException();
-
-    void ICollection<KeyValuePair<string, JToken>>.Add(KeyValuePair<string, JToken> item)
-    {
-      this.Add((object) new JProperty(item.Key, (object) item.Value));
-    }
-
-    void ICollection<KeyValuePair<string, JToken>>.Clear() => this.RemoveAll();
-
-    bool ICollection<KeyValuePair<string, JToken>>.Contains(KeyValuePair<string, JToken> item)
-    {
-      JProperty jproperty = this.Property(item.Key);
-      return jproperty != null && jproperty.Value == item.Value;
-    }
-
-    void ICollection<KeyValuePair<string, JToken>>.CopyTo(
-      KeyValuePair<string, JToken>[] array,
-      int arrayIndex)
-    {
-      if (array == null)
-        throw new ArgumentNullException(nameof (array));
-      if (arrayIndex < 0)
-        throw new ArgumentOutOfRangeException(nameof (arrayIndex), "arrayIndex is less than 0.");
-      if (arrayIndex >= array.Length && arrayIndex != 0)
-        throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
-      if (this.Count > array.Length - arrayIndex)
-        throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
-      int num = 0;
-      foreach (JProperty property in (Collection<JToken>) this._properties)
-      {
-        array[arrayIndex + num] = new KeyValuePair<string, JToken>(property.Name, property.Value);
-        ++num;
-      }
-    }
-
-    bool ICollection<KeyValuePair<string, JToken>>.IsReadOnly => false;
-
-    bool ICollection<KeyValuePair<string, JToken>>.Remove(KeyValuePair<string, JToken> item)
-    {
-      if (!((ICollection<KeyValuePair<string, JToken>>) this).Contains(item))
-        return false;
-      this.Remove(item.Key);
-      return true;
-    }
-
-    internal override int GetDeepHashCode() => this.ContentsHashCode();
-
-    public IEnumerator<KeyValuePair<string, JToken>> GetEnumerator()
-    {
-      foreach (JProperty property in (Collection<JToken>) this._properties)
-        yield return new KeyValuePair<string, JToken>(property.Name, property.Value);
-    }
-
-    protected virtual void OnPropertyChanged(string propertyName)
-    {
-      PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
-      if (propertyChanged == null)
-        return;
-      propertyChanged((object) this, new PropertyChangedEventArgs(propertyName));
-    }
-
-    protected virtual void OnPropertyChanging(string propertyName)
-    {
-      PropertyChangingEventHandler propertyChanging = this.PropertyChanging;
-      if (propertyChanging == null)
-        return;
-      propertyChanging((object) this, new PropertyChangingEventArgs(propertyName));
-    }
-
-    PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties()
-    {
-      return ((ICustomTypeDescriptor) this).GetProperties((Attribute[]) null);
-    }
-
-    PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
-    {
-      PropertyDescriptorCollection properties = new PropertyDescriptorCollection((PropertyDescriptor[]) null);
-      foreach (KeyValuePair<string, JToken> keyValuePair in this)
-        properties.Add((PropertyDescriptor) new JPropertyDescriptor(keyValuePair.Key));
-      return properties;
-    }
-
-    AttributeCollection ICustomTypeDescriptor.GetAttributes() => AttributeCollection.Empty;
-
-    string ICustomTypeDescriptor.GetClassName() => (string) null;
-
-    string ICustomTypeDescriptor.GetComponentName() => (string) null;
-
-    TypeConverter ICustomTypeDescriptor.GetConverter() => new TypeConverter();
-
-    EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() => (EventDescriptor) null;
-
-    PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() => (PropertyDescriptor) null;
-
-    object ICustomTypeDescriptor.GetEditor(System.Type editorBaseType) => (object) null;
-
-    EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
-    {
-      return EventDescriptorCollection.Empty;
-    }
-
-    EventDescriptorCollection ICustomTypeDescriptor.GetEvents() => EventDescriptorCollection.Empty;
-
-    object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
-    {
-      return pd is JPropertyDescriptor ? (object) this : (object) null;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JProperty.cs b/MSHALTester/Newtonsoft/Json/Linq/JProperty.cs
deleted file mode 100644
index 157b39b..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JProperty.cs
+++ /dev/null
@@ -1,230 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JProperty : JContainer
-  {
-    private readonly JProperty.JPropertyList _content = new JProperty.JPropertyList();
-    private readonly string _name;
-
-    protected override IList<JToken> ChildrenTokens => (IList<JToken>) this._content;
-
-    public string Name
-    {
-      [DebuggerStepThrough] get => this._name;
-    }
-
-    public JToken Value
-    {
-      [DebuggerStepThrough] get => this._content._token;
-      set
-      {
-        this.CheckReentrancy();
-        JToken jtoken = value ?? (JToken) JValue.CreateNull();
-        if (this._content._token == null)
-          this.InsertItem(0, jtoken, false);
-        else
-          this.SetItem(0, jtoken);
-      }
-    }
-
-    public JProperty(JProperty other)
-      : base((JContainer) other)
-    {
-      this._name = other.Name;
-    }
-
-    internal override JToken GetItem(int index)
-    {
-      if (index != 0)
-        throw new ArgumentOutOfRangeException();
-      return this.Value;
-    }
-
-    internal override void SetItem(int index, JToken item)
-    {
-      if (index != 0)
-        throw new ArgumentOutOfRangeException();
-      if (JContainer.IsTokenUnchanged(this.Value, item))
-        return;
-      ((JObject) this.Parent)?.InternalPropertyChanging(this);
-      base.SetItem(0, item);
-      ((JObject) this.Parent)?.InternalPropertyChanged(this);
-    }
-
-    internal override bool RemoveItem(JToken item)
-    {
-      throw new JsonException("Cannot add or remove items from {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeof (JProperty)));
-    }
-
-    internal override void RemoveItemAt(int index)
-    {
-      throw new JsonException("Cannot add or remove items from {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeof (JProperty)));
-    }
-
-    internal override int IndexOfItem(JToken item) => this._content.IndexOf(item);
-
-    internal override void InsertItem(int index, JToken item, bool skipParentCheck)
-    {
-      if (item != null && item.Type == JTokenType.Comment)
-        return;
-      if (this.Value != null)
-        throw new JsonException("{0} cannot have multiple values.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeof (JProperty)));
-      base.InsertItem(0, item, false);
-    }
-
-    internal override bool ContainsItem(JToken item) => this.Value == item;
-
-    internal override void MergeItem(object content, JsonMergeSettings settings)
-    {
-      JToken jtoken = content is JProperty jproperty ? jproperty.Value : (JToken) null;
-      if (jtoken == null || jtoken.Type == JTokenType.Null)
-        return;
-      this.Value = jtoken;
-    }
-
-    internal override void ClearItems()
-    {
-      throw new JsonException("Cannot add or remove items from {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeof (JProperty)));
-    }
-
-    internal override bool DeepEquals(JToken node)
-    {
-      return node is JProperty container && this._name == container.Name && this.ContentsEqual((JContainer) container);
-    }
-
-    internal override JToken CloneToken() => (JToken) new JProperty(this);
-
-    public override JTokenType Type
-    {
-      [DebuggerStepThrough] get => JTokenType.Property;
-    }
-
-    internal JProperty(string name)
-    {
-      ValidationUtils.ArgumentNotNull((object) name, nameof (name));
-      this._name = name;
-    }
-
-    public JProperty(string name, params object[] content)
-      : this(name, (object) content)
-    {
-    }
-
-    public JProperty(string name, object content)
-    {
-      ValidationUtils.ArgumentNotNull((object) name, nameof (name));
-      this._name = name;
-      this.Value = this.IsMultiContent(content) ? (JToken) new JArray(content) : JContainer.CreateFromContent(content);
-    }
-
-    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
-    {
-      writer.WritePropertyName(this._name);
-      JToken jtoken = this.Value;
-      if (jtoken != null)
-        jtoken.WriteTo(writer, converters);
-      else
-        writer.WriteNull();
-    }
-
-    internal override int GetDeepHashCode()
-    {
-      int hashCode = this._name.GetHashCode();
-      JToken jtoken = this.Value;
-      int deepHashCode = jtoken != null ? jtoken.GetDeepHashCode() : 0;
-      return hashCode ^ deepHashCode;
-    }
-
-    public static JProperty Load(JsonReader reader)
-    {
-      return JProperty.Load(reader, (JsonLoadSettings) null);
-    }
-
-    public static JProperty Load(JsonReader reader, JsonLoadSettings settings)
-    {
-      if (reader.TokenType == JsonToken.None && !reader.Read())
-        throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader.");
-      reader.MoveToContent();
-      JProperty jproperty = reader.TokenType == JsonToken.PropertyName ? new JProperty((string) reader.Value) : throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      jproperty.SetLineInfo(reader as IJsonLineInfo, settings);
-      jproperty.ReadTokenFrom(reader, settings);
-      return jproperty;
-    }
-
-    private class JPropertyList : 
-      IList<JToken>,
-      ICollection<JToken>,
-      IEnumerable<JToken>,
-      IEnumerable
-    {
-      internal JToken _token;
-
-      public IEnumerator<JToken> GetEnumerator()
-      {
-        if (this._token != null)
-          yield return this._token;
-      }
-
-      IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-
-      public void Add(JToken item) => this._token = item;
-
-      public void Clear() => this._token = (JToken) null;
-
-      public bool Contains(JToken item) => this._token == item;
-
-      public void CopyTo(JToken[] array, int arrayIndex)
-      {
-        if (this._token == null)
-          return;
-        array[arrayIndex] = this._token;
-      }
-
-      public bool Remove(JToken item)
-      {
-        if (this._token != item)
-          return false;
-        this._token = (JToken) null;
-        return true;
-      }
-
-      public int Count => this._token == null ? 0 : 1;
-
-      public bool IsReadOnly => false;
-
-      public int IndexOf(JToken item) => this._token != item ? -1 : 0;
-
-      public void Insert(int index, JToken item)
-      {
-        if (index != 0)
-          return;
-        this._token = item;
-      }
-
-      public void RemoveAt(int index)
-      {
-        if (index != 0)
-          return;
-        this._token = (JToken) null;
-      }
-
-      public JToken this[int index]
-      {
-        get => index != 0 ? (JToken) null : this._token;
-        set
-        {
-          if (index != 0)
-            return;
-          this._token = value;
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JPropertyDescriptor.cs b/MSHALTester/Newtonsoft/Json/Linq/JPropertyDescriptor.cs
deleted file mode 100644
index ac0c62e..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JPropertyDescriptor.cs
+++ /dev/null
@@ -1,43 +0,0 @@
-using System;
-using System.ComponentModel;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JPropertyDescriptor(string name) : PropertyDescriptor(name, (Attribute[]) null)
-  {
-    private static JObject CastInstance(object instance) => (JObject) instance;
-
-    public override bool CanResetValue(object component) => false;
-
-    public override object GetValue(object component)
-    {
-      // ISSUE: explicit non-virtual call
-      return !(component is JObject jobject) ? (object) null : (object) __nonvirtual (jobject[this.Name]);
-    }
-
-    public override void ResetValue(object component)
-    {
-    }
-
-    public override void SetValue(object component, object value)
-    {
-      if (!(component is JObject jobject))
-        return;
-      if (!(value is JToken jtoken1))
-        jtoken1 = (JToken) new JValue(value);
-      JToken jtoken2 = jtoken1;
-      jobject[this.Name] = jtoken2;
-    }
-
-    public override bool ShouldSerializeValue(object component) => false;
-
-    public override Type ComponentType => typeof (JObject);
-
-    public override bool IsReadOnly => false;
-
-    public override Type PropertyType => typeof (object);
-
-    protected override int NameHashCode => base.NameHashCode;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JPropertyKeyedCollection.cs b/MSHALTester/Newtonsoft/Json/Linq/JPropertyKeyedCollection.cs
deleted file mode 100644
index 93a6347..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JPropertyKeyedCollection.cs
+++ /dev/null
@@ -1,173 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Collections.ObjectModel;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  internal class JPropertyKeyedCollection : Collection<JToken>
-  {
-    private static readonly IEqualityComparer<string> Comparer = (IEqualityComparer<string>) StringComparer.Ordinal;
-    private Dictionary<string, JToken> _dictionary;
-
-    public JPropertyKeyedCollection()
-      : base((IList<JToken>) new List<JToken>())
-    {
-    }
-
-    private void AddKey(string key, JToken item)
-    {
-      this.EnsureDictionary();
-      this._dictionary[key] = item;
-    }
-
-    protected void ChangeItemKey(JToken item, string newKey)
-    {
-      string str = this.ContainsItem(item) ? this.GetKeyForItem(item) : throw new ArgumentException("The specified item does not exist in this KeyedCollection.");
-      if (JPropertyKeyedCollection.Comparer.Equals(str, newKey))
-        return;
-      if (newKey != null)
-        this.AddKey(newKey, item);
-      if (str == null)
-        return;
-      this.RemoveKey(str);
-    }
-
-    protected override void ClearItems()
-    {
-      base.ClearItems();
-      this._dictionary?.Clear();
-    }
-
-    public bool Contains(string key)
-    {
-      if (key == null)
-        throw new ArgumentNullException(nameof (key));
-      return this._dictionary != null && this._dictionary.ContainsKey(key);
-    }
-
-    private bool ContainsItem(JToken item)
-    {
-      return this._dictionary != null && this._dictionary.TryGetValue(this.GetKeyForItem(item), out JToken _);
-    }
-
-    private void EnsureDictionary()
-    {
-      if (this._dictionary != null)
-        return;
-      this._dictionary = new Dictionary<string, JToken>(JPropertyKeyedCollection.Comparer);
-    }
-
-    private string GetKeyForItem(JToken item) => ((JProperty) item).Name;
-
-    protected override void InsertItem(int index, JToken item)
-    {
-      this.AddKey(this.GetKeyForItem(item), item);
-      base.InsertItem(index, item);
-    }
-
-    public bool Remove(string key)
-    {
-      if (key == null)
-        throw new ArgumentNullException(nameof (key));
-      return this._dictionary != null && this._dictionary.ContainsKey(key) && this.Remove(this._dictionary[key]);
-    }
-
-    protected override void RemoveItem(int index)
-    {
-      this.RemoveKey(this.GetKeyForItem(this.Items[index]));
-      base.RemoveItem(index);
-    }
-
-    private void RemoveKey(string key) => this._dictionary?.Remove(key);
-
-    protected override void SetItem(int index, JToken item)
-    {
-      string keyForItem1 = this.GetKeyForItem(item);
-      string keyForItem2 = this.GetKeyForItem(this.Items[index]);
-      if (JPropertyKeyedCollection.Comparer.Equals(keyForItem2, keyForItem1))
-      {
-        if (this._dictionary != null)
-          this._dictionary[keyForItem1] = item;
-      }
-      else
-      {
-        this.AddKey(keyForItem1, item);
-        if (keyForItem2 != null)
-          this.RemoveKey(keyForItem2);
-      }
-      base.SetItem(index, item);
-    }
-
-    public JToken this[string key]
-    {
-      get
-      {
-        if (key == null)
-          throw new ArgumentNullException(nameof (key));
-        return this._dictionary != null ? this._dictionary[key] : throw new KeyNotFoundException();
-      }
-    }
-
-    public bool TryGetValue(string key, out JToken value)
-    {
-      if (this._dictionary != null)
-        return this._dictionary.TryGetValue(key, out value);
-      value = (JToken) null;
-      return false;
-    }
-
-    public ICollection<string> Keys
-    {
-      get
-      {
-        this.EnsureDictionary();
-        return (ICollection<string>) this._dictionary.Keys;
-      }
-    }
-
-    public ICollection<JToken> Values
-    {
-      get
-      {
-        this.EnsureDictionary();
-        return (ICollection<JToken>) this._dictionary.Values;
-      }
-    }
-
-    public int IndexOfReference(JToken t)
-    {
-      return ((List<JToken>) this.Items).IndexOfReference<JToken>(t);
-    }
-
-    public bool Compare(JPropertyKeyedCollection other)
-    {
-      if (this == other)
-        return true;
-      Dictionary<string, JToken> dictionary1 = this._dictionary;
-      Dictionary<string, JToken> dictionary2 = other._dictionary;
-      if (dictionary1 == null && dictionary2 == null)
-        return true;
-      if (dictionary1 == null)
-        return dictionary2.Count == 0;
-      if (dictionary2 == null)
-        return dictionary1.Count == 0;
-      if (dictionary1.Count != dictionary2.Count)
-        return false;
-      foreach (KeyValuePair<string, JToken> keyValuePair in dictionary1)
-      {
-        JToken jtoken;
-        if (!dictionary2.TryGetValue(keyValuePair.Key, out jtoken))
-          return false;
-        JProperty jproperty1 = (JProperty) keyValuePair.Value;
-        JProperty jproperty2 = (JProperty) jtoken;
-        if (jproperty1.Value == null)
-          return jproperty2.Value == null;
-        if (!jproperty1.Value.DeepEquals(jproperty2.Value))
-          return false;
-      }
-      return true;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JRaw.cs b/MSHALTester/Newtonsoft/Json/Linq/JRaw.cs
deleted file mode 100644
index 271757f..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JRaw.cs
+++ /dev/null
@@ -1,34 +0,0 @@
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JRaw : JValue
-  {
-    public JRaw(JRaw other)
-      : base((JValue) other)
-    {
-    }
-
-    public JRaw(object rawJson)
-      : base(rawJson, JTokenType.Raw)
-    {
-    }
-
-    public static JRaw Create(JsonReader reader)
-    {
-      using (StringWriter stringWriter = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture))
-      {
-        using (JsonTextWriter jsonTextWriter = new JsonTextWriter((TextWriter) stringWriter))
-        {
-          jsonTextWriter.WriteToken(reader);
-          return new JRaw((object) stringWriter.ToString());
-        }
-      }
-    }
-
-    internal override JToken CloneToken() => (JToken) new JRaw(this);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JToken.cs b/MSHALTester/Newtonsoft/Json/Linq/JToken.cs
deleted file mode 100644
index f70fcdf..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JToken.cs
+++ /dev/null
@@ -1,1291 +0,0 @@
-using Newtonsoft.Json.Linq.JsonPath;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Globalization;
-using System.IO;
-using System.Linq;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public abstract class JToken : 
-    IJEnumerable<JToken>,
-    IEnumerable<JToken>,
-    IEnumerable,
-    IJsonLineInfo,
-    ICloneable
-  {
-    private static JTokenEqualityComparer _equalityComparer;
-    private JContainer _parent;
-    private JToken _previous;
-    private JToken _next;
-    private object _annotations;
-    private static readonly JTokenType[] BooleanTypes = new JTokenType[6]
-    {
-      JTokenType.Integer,
-      JTokenType.Float,
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw,
-      JTokenType.Boolean
-    };
-    private static readonly JTokenType[] NumberTypes = new JTokenType[6]
-    {
-      JTokenType.Integer,
-      JTokenType.Float,
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw,
-      JTokenType.Boolean
-    };
-    private static readonly JTokenType[] StringTypes = new JTokenType[11]
-    {
-      JTokenType.Date,
-      JTokenType.Integer,
-      JTokenType.Float,
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw,
-      JTokenType.Boolean,
-      JTokenType.Bytes,
-      JTokenType.Guid,
-      JTokenType.TimeSpan,
-      JTokenType.Uri
-    };
-    private static readonly JTokenType[] GuidTypes = new JTokenType[5]
-    {
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw,
-      JTokenType.Guid,
-      JTokenType.Bytes
-    };
-    private static readonly JTokenType[] TimeSpanTypes = new JTokenType[4]
-    {
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw,
-      JTokenType.TimeSpan
-    };
-    private static readonly JTokenType[] UriTypes = new JTokenType[4]
-    {
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw,
-      JTokenType.Uri
-    };
-    private static readonly JTokenType[] CharTypes = new JTokenType[5]
-    {
-      JTokenType.Integer,
-      JTokenType.Float,
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw
-    };
-    private static readonly JTokenType[] DateTimeTypes = new JTokenType[4]
-    {
-      JTokenType.Date,
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw
-    };
-    private static readonly JTokenType[] BytesTypes = new JTokenType[5]
-    {
-      JTokenType.Bytes,
-      JTokenType.String,
-      JTokenType.Comment,
-      JTokenType.Raw,
-      JTokenType.Integer
-    };
-
-    public static JTokenEqualityComparer EqualityComparer
-    {
-      get
-      {
-        if (JToken._equalityComparer == null)
-          JToken._equalityComparer = new JTokenEqualityComparer();
-        return JToken._equalityComparer;
-      }
-    }
-
-    public JContainer Parent
-    {
-      [DebuggerStepThrough] get => this._parent;
-      internal set => this._parent = value;
-    }
-
-    public JToken Root
-    {
-      get
-      {
-        JContainer parent = this.Parent;
-        if (parent == null)
-          return this;
-        while (parent.Parent != null)
-          parent = parent.Parent;
-        return (JToken) parent;
-      }
-    }
-
-    internal abstract JToken CloneToken();
-
-    internal abstract bool DeepEquals(JToken node);
-
-    public abstract JTokenType Type { get; }
-
-    public abstract bool HasValues { get; }
-
-    public static bool DeepEquals(JToken t1, JToken t2)
-    {
-      if (t1 == t2)
-        return true;
-      return t1 != null && t2 != null && t1.DeepEquals(t2);
-    }
-
-    public JToken Next
-    {
-      get => this._next;
-      internal set => this._next = value;
-    }
-
-    public JToken Previous
-    {
-      get => this._previous;
-      internal set => this._previous = value;
-    }
-
-    public string Path
-    {
-      get
-      {
-        if (this.Parent == null)
-          return string.Empty;
-        List<JsonPosition> jsonPositionList1 = new List<JsonPosition>();
-        JToken jtoken1 = (JToken) null;
-        for (JToken jtoken2 = this; jtoken2 != null; jtoken2 = (JToken) jtoken2.Parent)
-        {
-          JsonPosition jsonPosition1;
-          switch (jtoken2.Type)
-          {
-            case JTokenType.Array:
-            case JTokenType.Constructor:
-              if (jtoken1 != null)
-              {
-                int num = ((IList<JToken>) jtoken2).IndexOf(jtoken1);
-                List<JsonPosition> jsonPositionList2 = jsonPositionList1;
-                jsonPosition1 = new JsonPosition(JsonContainerType.Array);
-                jsonPosition1.Position = num;
-                JsonPosition jsonPosition2 = jsonPosition1;
-                jsonPositionList2.Add(jsonPosition2);
-                break;
-              }
-              break;
-            case JTokenType.Property:
-              JProperty jproperty = (JProperty) jtoken2;
-              List<JsonPosition> jsonPositionList3 = jsonPositionList1;
-              jsonPosition1 = new JsonPosition(JsonContainerType.Object);
-              jsonPosition1.PropertyName = jproperty.Name;
-              JsonPosition jsonPosition3 = jsonPosition1;
-              jsonPositionList3.Add(jsonPosition3);
-              break;
-          }
-          jtoken1 = jtoken2;
-        }
-        jsonPositionList1.FastReverse<JsonPosition>();
-        return JsonPosition.BuildPath(jsonPositionList1, new JsonPosition?());
-      }
-    }
-
-    internal JToken()
-    {
-    }
-
-    public void AddAfterSelf(object content)
-    {
-      if (this._parent == null)
-        throw new InvalidOperationException("The parent is missing.");
-      this._parent.AddInternal(this._parent.IndexOfItem(this) + 1, content, false);
-    }
-
-    public void AddBeforeSelf(object content)
-    {
-      if (this._parent == null)
-        throw new InvalidOperationException("The parent is missing.");
-      this._parent.AddInternal(this._parent.IndexOfItem(this), content, false);
-    }
-
-    public IEnumerable<JToken> Ancestors() => this.GetAncestors(false);
-
-    public IEnumerable<JToken> AncestorsAndSelf() => this.GetAncestors(true);
-
-    internal IEnumerable<JToken> GetAncestors(bool self)
-    {
-      JToken jtoken = this;
-      JToken current;
-      for (current = self ? jtoken : (JToken) jtoken.Parent; current != null; current = (JToken) current.Parent)
-        yield return current;
-      current = (JToken) null;
-    }
-
-    public IEnumerable<JToken> AfterSelf()
-    {
-      if (this.Parent != null)
-      {
-        JToken o;
-        for (o = this.Next; o != null; o = o.Next)
-          yield return o;
-        o = (JToken) null;
-      }
-    }
-
-    public IEnumerable<JToken> BeforeSelf()
-    {
-      JToken jtoken = this;
-      JToken o;
-      for (o = jtoken.Parent.First; o != jtoken; o = o.Next)
-        yield return o;
-      o = (JToken) null;
-    }
-
-    public virtual JToken this[object key]
-    {
-      get
-      {
-        throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType()));
-      }
-      set
-      {
-        throw new InvalidOperationException("Cannot set child value on {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType()));
-      }
-    }
-
-    public virtual T Value<T>(object key)
-    {
-      JToken token = this[key];
-      return token != null ? token.Convert<JToken, T>() : default (T);
-    }
-
-    public virtual JToken First
-    {
-      get
-      {
-        throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType()));
-      }
-    }
-
-    public virtual JToken Last
-    {
-      get
-      {
-        throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType()));
-      }
-    }
-
-    public virtual JEnumerable<JToken> Children() => JEnumerable<JToken>.Empty;
-
-    public JEnumerable<T> Children<T>() where T : JToken
-    {
-      return new JEnumerable<T>(this.Children().OfType<T>());
-    }
-
-    public virtual IEnumerable<T> Values<T>()
-    {
-      throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.GetType()));
-    }
-
-    public void Remove()
-    {
-      if (this._parent == null)
-        throw new InvalidOperationException("The parent is missing.");
-      this._parent.RemoveItem(this);
-    }
-
-    public void Replace(JToken value)
-    {
-      if (this._parent == null)
-        throw new InvalidOperationException("The parent is missing.");
-      this._parent.ReplaceItem(this, value);
-    }
-
-    public abstract void WriteTo(JsonWriter writer, params JsonConverter[] converters);
-
-    public override string ToString() => this.ToString(Formatting.Indented);
-
-    public string ToString(Formatting formatting, params JsonConverter[] converters)
-    {
-      using (StringWriter stringWriter = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture))
-      {
-        JsonTextWriter writer = new JsonTextWriter((TextWriter) stringWriter);
-        writer.Formatting = formatting;
-        this.WriteTo((JsonWriter) writer, converters);
-        return stringWriter.ToString();
-      }
-    }
-
-    private static JValue EnsureValue(JToken value)
-    {
-      if (value == null)
-        throw new ArgumentNullException(nameof (value));
-      if (value is JProperty jproperty)
-        value = jproperty.Value;
-      return value as JValue;
-    }
-
-    private static string GetType(JToken token)
-    {
-      ValidationUtils.ArgumentNotNull((object) token, nameof (token));
-      if (token is JProperty)
-        token = ((JProperty) token).Value;
-      return token.Type.ToString();
-    }
-
-    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable)
-    {
-      if (Array.IndexOf<JTokenType>(validTypes, o.Type) != -1)
-        return true;
-      if (!nullable)
-        return false;
-      return o.Type == JTokenType.Null || o.Type == JTokenType.Undefined;
-    }
-
-    public static explicit operator bool(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.BooleanTypes, false))
-        throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToBoolean(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator DateTimeOffset(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.DateTimeTypes, false))
-        throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      if (o.Value is DateTimeOffset dateTimeOffset)
-        return dateTimeOffset;
-      return o.Value is string input ? DateTimeOffset.Parse(input, (IFormatProvider) CultureInfo.InvariantCulture) : new DateTimeOffset(Convert.ToDateTime(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator bool?(JToken value)
-    {
-      if (value == null)
-        return new bool?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.BooleanTypes, true))
-        throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new bool?() : new bool?(Convert.ToBoolean(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator long(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to Int64.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToInt64(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator DateTime?(JToken value)
-    {
-      if (value == null)
-        return new DateTime?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.DateTimeTypes, true))
-        throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      if (o.Value is DateTimeOffset dateTimeOffset)
-        return new DateTime?(dateTimeOffset.DateTime);
-      return o.Value == null ? new DateTime?() : new DateTime?(Convert.ToDateTime(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator DateTimeOffset?(JToken value)
-    {
-      if (value == null)
-        return new DateTimeOffset?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.DateTimeTypes, true))
-        throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      if (o.Value == null)
-        return new DateTimeOffset?();
-      if (o.Value is DateTimeOffset dateTimeOffset)
-        return new DateTimeOffset?(dateTimeOffset);
-      return o.Value is string input ? new DateTimeOffset?(DateTimeOffset.Parse(input, (IFormatProvider) CultureInfo.InvariantCulture)) : new DateTimeOffset?(new DateTimeOffset(Convert.ToDateTime(o.Value, (IFormatProvider) CultureInfo.InvariantCulture)));
-    }
-
-    public static explicit operator Decimal?(JToken value)
-    {
-      if (value == null)
-        return new Decimal?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new Decimal?() : new Decimal?(Convert.ToDecimal(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator double?(JToken value)
-    {
-      if (value == null)
-        return new double?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to Double.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new double?() : new double?(Convert.ToDouble(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator char?(JToken value)
-    {
-      if (value == null)
-        return new char?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.CharTypes, true))
-        throw new ArgumentException("Can not convert {0} to Char.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new char?() : new char?(Convert.ToChar(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator int(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to Int32.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToInt32(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator short(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to Int16.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToInt16(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator ushort(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToUInt16(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator char(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.CharTypes, false))
-        throw new ArgumentException("Can not convert {0} to Char.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToChar(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator byte(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to Byte.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToByte(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator sbyte(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to SByte.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToSByte(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator int?(JToken value)
-    {
-      if (value == null)
-        return new int?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to Int32.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new int?() : new int?(Convert.ToInt32(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator short?(JToken value)
-    {
-      if (value == null)
-        return new short?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to Int16.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new short?() : new short?(Convert.ToInt16(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator ushort?(JToken value)
-    {
-      if (value == null)
-        return new ushort?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new ushort?() : new ushort?(Convert.ToUInt16(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator byte?(JToken value)
-    {
-      if (value == null)
-        return new byte?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to Byte.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new byte?() : new byte?(Convert.ToByte(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator sbyte?(JToken value)
-    {
-      if (value == null)
-        return new sbyte?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to SByte.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new sbyte?() : new sbyte?(Convert.ToSByte(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator DateTime(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.DateTimeTypes, false))
-        throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value is DateTimeOffset dateTimeOffset ? dateTimeOffset.DateTime : Convert.ToDateTime(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator long?(JToken value)
-    {
-      if (value == null)
-        return new long?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to Int64.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new long?() : new long?(Convert.ToInt64(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator float?(JToken value)
-    {
-      if (value == null)
-        return new float?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to Single.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new float?() : new float?(Convert.ToSingle(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator Decimal(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToDecimal(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator uint?(JToken value)
-    {
-      if (value == null)
-        return new uint?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new uint?() : new uint?(Convert.ToUInt32(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator ulong?(JToken value)
-    {
-      if (value == null)
-        return new ulong?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, true))
-        throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new ulong?() : new ulong?(Convert.ToUInt64(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator double(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to Double.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToDouble(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator float(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to Single.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToSingle(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator string(JToken value)
-    {
-      if (value == null)
-        return (string) null;
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.StringTypes, true))
-        throw new ArgumentException("Can not convert {0} to String.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      if (o.Value == null)
-        return (string) null;
-      return o.Value is byte[] inArray ? Convert.ToBase64String(inArray) : Convert.ToString(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator uint(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToUInt32(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    [CLSCompliant(false)]
-    public static explicit operator ulong(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.NumberTypes, false))
-        throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return Convert.ToUInt64(o.Value, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static explicit operator byte[](JToken value)
-    {
-      if (value == null)
-        return (byte[]) null;
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.BytesTypes, false))
-        throw new ArgumentException("Can not convert {0} to byte array.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      if (o.Value is string)
-        return Convert.FromBase64String(Convert.ToString(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-      if (o.Value is byte[] numArray)
-        return numArray;
-      throw new ArgumentException("Can not convert {0} to byte array.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-    }
-
-    public static explicit operator Guid(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.GuidTypes, false))
-        throw new ArgumentException("Can not convert {0} to Guid.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      if (o.Value is byte[] b)
-        return new Guid(b);
-      return o.Value is Guid guid ? guid : new Guid(Convert.ToString(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator Guid?(JToken value)
-    {
-      if (value == null)
-        return new Guid?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.GuidTypes, true))
-        throw new ArgumentException("Can not convert {0} to Guid.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      if (o.Value == null)
-        return new Guid?();
-      return o.Value is byte[] b ? new Guid?(new Guid(b)) : new Guid?(!(o.Value is Guid guid) ? new Guid(Convert.ToString(o.Value, (IFormatProvider) CultureInfo.InvariantCulture)) : guid);
-    }
-
-    public static explicit operator TimeSpan(JToken value)
-    {
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.TimeSpanTypes, false))
-        throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value is TimeSpan timeSpan ? timeSpan : ConvertUtils.ParseTimeSpan(Convert.ToString(o.Value, (IFormatProvider) CultureInfo.InvariantCulture));
-    }
-
-    public static explicit operator TimeSpan?(JToken value)
-    {
-      if (value == null)
-        return new TimeSpan?();
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.TimeSpanTypes, true))
-        throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      return o.Value == null ? new TimeSpan?() : new TimeSpan?(!(o.Value is TimeSpan timeSpan) ? ConvertUtils.ParseTimeSpan(Convert.ToString(o.Value, (IFormatProvider) CultureInfo.InvariantCulture)) : timeSpan);
-    }
-
-    public static explicit operator Uri(JToken value)
-    {
-      if (value == null)
-        return (Uri) null;
-      JValue o = JToken.EnsureValue(value);
-      if (o == null || !JToken.ValidateToken((JToken) o, JToken.UriTypes, true))
-        throw new ArgumentException("Can not convert {0} to Uri.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) JToken.GetType(value)));
-      if (o.Value == null)
-        return (Uri) null;
-      return !(o.Value is Uri uri) ? new Uri(Convert.ToString(o.Value, (IFormatProvider) CultureInfo.InvariantCulture)) : uri;
-    }
-
-    public static implicit operator JToken(bool value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(DateTimeOffset value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(byte value) => (JToken) new JValue((long) value);
-
-    public static implicit operator JToken(byte? value) => (JToken) new JValue((object) value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(sbyte value) => (JToken) new JValue((long) value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(sbyte? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(bool? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(long value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(DateTime? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(DateTimeOffset? value)
-    {
-      return (JToken) new JValue((object) value);
-    }
-
-    public static implicit operator JToken(Decimal? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(double? value) => (JToken) new JValue((object) value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(short value) => (JToken) new JValue((long) value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(ushort value) => (JToken) new JValue((long) value);
-
-    public static implicit operator JToken(int value) => (JToken) new JValue((long) value);
-
-    public static implicit operator JToken(int? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(DateTime value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(long? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(float? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(Decimal value) => (JToken) new JValue(value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(short? value) => (JToken) new JValue((object) value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(ushort? value) => (JToken) new JValue((object) value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(uint? value) => (JToken) new JValue((object) value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(ulong? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(double value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(float value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(string value) => (JToken) new JValue(value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(uint value) => (JToken) new JValue((long) value);
-
-    [CLSCompliant(false)]
-    public static implicit operator JToken(ulong value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(byte[] value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(Uri value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(TimeSpan value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(TimeSpan? value) => (JToken) new JValue((object) value);
-
-    public static implicit operator JToken(Guid value) => (JToken) new JValue(value);
-
-    public static implicit operator JToken(Guid? value) => (JToken) new JValue((object) value);
-
-    IEnumerator IEnumerable.GetEnumerator()
-    {
-      return (IEnumerator) ((IEnumerable<JToken>) this).GetEnumerator();
-    }
-
-    IEnumerator<JToken> IEnumerable<JToken>.GetEnumerator() => this.Children().GetEnumerator();
-
-    internal abstract int GetDeepHashCode();
-
-    IJEnumerable<JToken> IJEnumerable<JToken>.this[object key] => (IJEnumerable<JToken>) this[key];
-
-    public JsonReader CreateReader() => (JsonReader) new JTokenReader(this);
-
-    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
-    {
-      ValidationUtils.ArgumentNotNull(o, nameof (o));
-      ValidationUtils.ArgumentNotNull((object) jsonSerializer, nameof (jsonSerializer));
-      using (JTokenWriter jtokenWriter = new JTokenWriter())
-      {
-        jsonSerializer.Serialize((JsonWriter) jtokenWriter, o);
-        return jtokenWriter.Token;
-      }
-    }
-
-    public static JToken FromObject(object o)
-    {
-      return JToken.FromObjectInternal(o, JsonSerializer.CreateDefault());
-    }
-
-    public static JToken FromObject(object o, JsonSerializer jsonSerializer)
-    {
-      return JToken.FromObjectInternal(o, jsonSerializer);
-    }
-
-    public T ToObject<T>() => (T) this.ToObject(typeof (T));
-
-    public object ToObject(System.Type objectType)
-    {
-      if (JsonConvert.DefaultSettings == null)
-      {
-        bool isEnum;
-        PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(objectType, out isEnum);
-        if (isEnum)
-        {
-          if (this.Type == JTokenType.String)
-          {
-            try
-            {
-              return this.ToObject(objectType, JsonSerializer.CreateDefault());
-            }
-            catch (Exception ex)
-            {
-              throw new ArgumentException("Could not convert '{0}' to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) (string) this, (object) (objectType.IsEnum() ? (MemberInfo) objectType : (MemberInfo) Nullable.GetUnderlyingType(objectType)).Name), ex);
-            }
-          }
-          else if (this.Type == JTokenType.Integer)
-            return Enum.ToObject(objectType.IsEnum() ? objectType : Nullable.GetUnderlyingType(objectType), ((JValue) this).Value);
-        }
-        switch (typeCode)
-        {
-          case PrimitiveTypeCode.Char:
-            return (object) (char) this;
-          case PrimitiveTypeCode.CharNullable:
-            return (object) (char?) this;
-          case PrimitiveTypeCode.Boolean:
-            return (object) (bool) this;
-          case PrimitiveTypeCode.BooleanNullable:
-            return (object) (bool?) this;
-          case PrimitiveTypeCode.SByte:
-            return (object) (sbyte) this;
-          case PrimitiveTypeCode.SByteNullable:
-            return (object) (sbyte?) this;
-          case PrimitiveTypeCode.Int16:
-            return (object) (short) this;
-          case PrimitiveTypeCode.Int16Nullable:
-            return (object) (short?) this;
-          case PrimitiveTypeCode.UInt16:
-            return (object) (ushort) this;
-          case PrimitiveTypeCode.UInt16Nullable:
-            return (object) (ushort?) this;
-          case PrimitiveTypeCode.Int32:
-            return (object) (int) this;
-          case PrimitiveTypeCode.Int32Nullable:
-            return (object) (int?) this;
-          case PrimitiveTypeCode.Byte:
-            return (object) (byte) this;
-          case PrimitiveTypeCode.ByteNullable:
-            return (object) (byte?) this;
-          case PrimitiveTypeCode.UInt32:
-            return (object) (uint) this;
-          case PrimitiveTypeCode.UInt32Nullable:
-            return (object) (uint?) this;
-          case PrimitiveTypeCode.Int64:
-            return (object) (long) this;
-          case PrimitiveTypeCode.Int64Nullable:
-            return (object) (long?) this;
-          case PrimitiveTypeCode.UInt64:
-            return (object) (ulong) this;
-          case PrimitiveTypeCode.UInt64Nullable:
-            return (object) (ulong?) this;
-          case PrimitiveTypeCode.Single:
-            return (object) (float) this;
-          case PrimitiveTypeCode.SingleNullable:
-            return (object) (float?) this;
-          case PrimitiveTypeCode.Double:
-            return (object) (double) this;
-          case PrimitiveTypeCode.DoubleNullable:
-            return (object) (double?) this;
-          case PrimitiveTypeCode.DateTime:
-            return (object) (DateTime) this;
-          case PrimitiveTypeCode.DateTimeNullable:
-            return (object) (DateTime?) this;
-          case PrimitiveTypeCode.DateTimeOffset:
-            return (object) (DateTimeOffset) this;
-          case PrimitiveTypeCode.DateTimeOffsetNullable:
-            return (object) (DateTimeOffset?) this;
-          case PrimitiveTypeCode.Decimal:
-            return (object) (Decimal) this;
-          case PrimitiveTypeCode.DecimalNullable:
-            return (object) (Decimal?) this;
-          case PrimitiveTypeCode.Guid:
-            return (object) (Guid) this;
-          case PrimitiveTypeCode.GuidNullable:
-            return (object) (Guid?) this;
-          case PrimitiveTypeCode.TimeSpan:
-            return (object) (TimeSpan) this;
-          case PrimitiveTypeCode.TimeSpanNullable:
-            return (object) (TimeSpan?) this;
-          case PrimitiveTypeCode.Uri:
-            return (object) (Uri) this;
-          case PrimitiveTypeCode.String:
-            return (object) (string) this;
-        }
-      }
-      return this.ToObject(objectType, JsonSerializer.CreateDefault());
-    }
-
-    public T ToObject<T>(JsonSerializer jsonSerializer)
-    {
-      return (T) this.ToObject(typeof (T), jsonSerializer);
-    }
-
-    public object ToObject(System.Type objectType, JsonSerializer jsonSerializer)
-    {
-      ValidationUtils.ArgumentNotNull((object) jsonSerializer, nameof (jsonSerializer));
-      using (JTokenReader reader = new JTokenReader(this))
-        return jsonSerializer.Deserialize((JsonReader) reader, objectType);
-    }
-
-    public static JToken ReadFrom(JsonReader reader)
-    {
-      return JToken.ReadFrom(reader, (JsonLoadSettings) null);
-    }
-
-    public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      if (!(reader.TokenType != JsonToken.None ? reader.TokenType != JsonToken.Comment || settings == null || settings.CommentHandling != CommentHandling.Ignore || reader.ReadAndMoveToContent() : (settings == null || settings.CommentHandling != CommentHandling.Ignore ? reader.Read() : reader.ReadAndMoveToContent())))
-        throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader.");
-      IJsonLineInfo lineInfo = reader as IJsonLineInfo;
-      switch (reader.TokenType)
-      {
-        case JsonToken.StartObject:
-          return (JToken) JObject.Load(reader, settings);
-        case JsonToken.StartArray:
-          return (JToken) JArray.Load(reader, settings);
-        case JsonToken.StartConstructor:
-          return (JToken) JConstructor.Load(reader, settings);
-        case JsonToken.PropertyName:
-          return (JToken) JProperty.Load(reader, settings);
-        case JsonToken.Comment:
-          JValue comment = JValue.CreateComment(reader.Value.ToString());
-          comment.SetLineInfo(lineInfo, settings);
-          return (JToken) comment;
-        case JsonToken.Integer:
-        case JsonToken.Float:
-        case JsonToken.String:
-        case JsonToken.Boolean:
-        case JsonToken.Date:
-        case JsonToken.Bytes:
-          JValue jvalue1 = new JValue(reader.Value);
-          jvalue1.SetLineInfo(lineInfo, settings);
-          return (JToken) jvalue1;
-        case JsonToken.Null:
-          JValue jvalue2 = JValue.CreateNull();
-          jvalue2.SetLineInfo(lineInfo, settings);
-          return (JToken) jvalue2;
-        case JsonToken.Undefined:
-          JValue undefined = JValue.CreateUndefined();
-          undefined.SetLineInfo(lineInfo, settings);
-          return (JToken) undefined;
-        default:
-          throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader. Unexpected token: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-      }
-    }
-
-    public static JToken Parse(string json) => JToken.Parse(json, (JsonLoadSettings) null);
-
-    public static JToken Parse(string json, JsonLoadSettings settings)
-    {
-      using (JsonReader reader = (JsonReader) new JsonTextReader((TextReader) new StringReader(json)))
-      {
-        JToken jtoken = JToken.Load(reader, settings);
-        do
-          ;
-        while (reader.Read());
-        return jtoken;
-      }
-    }
-
-    public static JToken Load(JsonReader reader, JsonLoadSettings settings)
-    {
-      return JToken.ReadFrom(reader, settings);
-    }
-
-    public static JToken Load(JsonReader reader) => JToken.Load(reader, (JsonLoadSettings) null);
-
-    internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings)
-    {
-      if (settings != null && settings.LineInfoHandling != LineInfoHandling.Load || lineInfo == null || !lineInfo.HasLineInfo())
-        return;
-      this.SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
-    }
-
-    internal void SetLineInfo(int lineNumber, int linePosition)
-    {
-      this.AddAnnotation((object) new JToken.LineInfoAnnotation(lineNumber, linePosition));
-    }
-
-    bool IJsonLineInfo.HasLineInfo() => this.Annotation<JToken.LineInfoAnnotation>() != null;
-
-    int IJsonLineInfo.LineNumber
-    {
-      get
-      {
-        JToken.LineInfoAnnotation lineInfoAnnotation = this.Annotation<JToken.LineInfoAnnotation>();
-        return lineInfoAnnotation != null ? lineInfoAnnotation.LineNumber : 0;
-      }
-    }
-
-    int IJsonLineInfo.LinePosition
-    {
-      get
-      {
-        JToken.LineInfoAnnotation lineInfoAnnotation = this.Annotation<JToken.LineInfoAnnotation>();
-        return lineInfoAnnotation != null ? lineInfoAnnotation.LinePosition : 0;
-      }
-    }
-
-    public JToken SelectToken(string path) => this.SelectToken(path, false);
-
-    public JToken SelectToken(string path, bool errorWhenNoMatch)
-    {
-      JPath jpath = new JPath(path);
-      JToken jtoken1 = (JToken) null;
-      int num = errorWhenNoMatch ? 1 : 0;
-      foreach (JToken jtoken2 in jpath.Evaluate(this, this, num != 0))
-        jtoken1 = jtoken1 == null ? jtoken2 : throw new JsonException("Path returned multiple tokens.");
-      return jtoken1;
-    }
-
-    public IEnumerable<JToken> SelectTokens(string path) => this.SelectTokens(path, false);
-
-    public IEnumerable<JToken> SelectTokens(string path, bool errorWhenNoMatch)
-    {
-      return new JPath(path).Evaluate(this, this, errorWhenNoMatch);
-    }
-
-    object ICloneable.Clone() => (object) this.DeepClone();
-
-    public JToken DeepClone() => this.CloneToken();
-
-    public void AddAnnotation(object annotation)
-    {
-      if (annotation == null)
-        throw new ArgumentNullException(nameof (annotation));
-      if (this._annotations == null)
-      {
-        object obj;
-        if (!(annotation is object[]))
-        {
-          obj = annotation;
-        }
-        else
-        {
-          obj = (object) new object[1];
-          obj[0] = annotation;
-        }
-        this._annotations = obj;
-      }
-      else if (!(this._annotations is object[] annotations))
-      {
-        this._annotations = (object) new object[2]
-        {
-          this._annotations,
-          annotation
-        };
-      }
-      else
-      {
-        int index = 0;
-        while (index < annotations.Length && annotations[index] != null)
-          ++index;
-        if (index == annotations.Length)
-        {
-          Array.Resize<object>(ref annotations, index * 2);
-          this._annotations = (object) annotations;
-        }
-        annotations[index] = annotation;
-      }
-    }
-
-    public T Annotation<T>() where T : class
-    {
-      if (this._annotations != null)
-      {
-        if (!(this._annotations is object[] annotations))
-          return this._annotations as T;
-        for (int index = 0; index < annotations.Length; ++index)
-        {
-          object obj1 = annotations[index];
-          if (obj1 != null)
-          {
-            if (obj1 is T obj2)
-              return obj2;
-          }
-          else
-            break;
-        }
-      }
-      return default (T);
-    }
-
-    public object Annotation(System.Type type)
-    {
-      if (type == null)
-        throw new ArgumentNullException(nameof (type));
-      if (this._annotations != null)
-      {
-        if (!(this._annotations is object[] annotations))
-        {
-          if (type.IsInstanceOfType(this._annotations))
-            return this._annotations;
-        }
-        else
-        {
-          for (int index = 0; index < annotations.Length; ++index)
-          {
-            object o = annotations[index];
-            if (o != null)
-            {
-              if (type.IsInstanceOfType(o))
-                return o;
-            }
-            else
-              break;
-          }
-        }
-      }
-      return (object) null;
-    }
-
-    public IEnumerable<T> Annotations<T>() where T : class
-    {
-      if (this._annotations != null)
-      {
-        if (this._annotations is object[] annotations2)
-        {
-          for (int i = 0; i < annotations2.Length; ++i)
-          {
-            object obj1 = annotations2[i];
-            if (obj1 == null)
-              break;
-            if (obj1 is T obj2)
-              yield return obj2;
-          }
-        }
-        else if (this._annotations is T annotations1)
-          yield return annotations1;
-      }
-    }
-
-    public IEnumerable<object> Annotations(System.Type type)
-    {
-      if (type == null)
-        throw new ArgumentNullException(nameof (type));
-      if (this._annotations != null)
-      {
-        if (this._annotations is object[] annotations)
-        {
-          for (int i = 0; i < annotations.Length; ++i)
-          {
-            object o = annotations[i];
-            if (o == null)
-              break;
-            if (type.IsInstanceOfType(o))
-              yield return o;
-          }
-        }
-        else if (type.IsInstanceOfType(this._annotations))
-          yield return this._annotations;
-      }
-    }
-
-    public void RemoveAnnotations<T>() where T : class
-    {
-      if (this._annotations == null)
-        return;
-      if (!(this._annotations is object[] annotations))
-      {
-        if (!(this._annotations is T))
-          return;
-        this._annotations = (object) null;
-      }
-      else
-      {
-        int index = 0;
-        int num = 0;
-        for (; index < annotations.Length; ++index)
-        {
-          object obj = annotations[index];
-          if (obj != null)
-          {
-            if (!(obj is T))
-              annotations[num++] = obj;
-          }
-          else
-            break;
-        }
-        if (num != 0)
-        {
-          while (num < index)
-            annotations[num++] = (object) null;
-        }
-        else
-          this._annotations = (object) null;
-      }
-    }
-
-    public void RemoveAnnotations(System.Type type)
-    {
-      if (type == null)
-        throw new ArgumentNullException(nameof (type));
-      if (this._annotations == null)
-        return;
-      if (!(this._annotations is object[] annotations))
-      {
-        if (!type.IsInstanceOfType(this._annotations))
-          return;
-        this._annotations = (object) null;
-      }
-      else
-      {
-        int index = 0;
-        int num = 0;
-        for (; index < annotations.Length; ++index)
-        {
-          object o = annotations[index];
-          if (o != null)
-          {
-            if (!type.IsInstanceOfType(o))
-              annotations[num++] = o;
-          }
-          else
-            break;
-        }
-        if (num != 0)
-        {
-          while (num < index)
-            annotations[num++] = (object) null;
-        }
-        else
-          this._annotations = (object) null;
-      }
-    }
-
-    private class LineInfoAnnotation
-    {
-      internal readonly int LineNumber;
-      internal readonly int LinePosition;
-
-      public LineInfoAnnotation(int lineNumber, int linePosition)
-      {
-        this.LineNumber = lineNumber;
-        this.LinePosition = linePosition;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JTokenEqualityComparer.cs b/MSHALTester/Newtonsoft/Json/Linq/JTokenEqualityComparer.cs
deleted file mode 100644
index 1e2d116..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JTokenEqualityComparer.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JTokenEqualityComparer : IEqualityComparer<JToken>
-  {
-    public bool Equals(JToken x, JToken y) => JToken.DeepEquals(x, y);
-
-    public int GetHashCode(JToken obj) => obj == null ? 0 : obj.GetDeepHashCode();
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JTokenReader.cs b/MSHALTester/Newtonsoft/Json/Linq/JTokenReader.cs
deleted file mode 100644
index 7d65c47..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JTokenReader.cs
+++ /dev/null
@@ -1,210 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JTokenReader : JsonReader, IJsonLineInfo
-  {
-    private readonly JToken _root;
-    private string _initialPath;
-    private JToken _parent;
-    private JToken _current;
-
-    public JToken CurrentToken => this._current;
-
-    public JTokenReader(JToken token)
-    {
-      ValidationUtils.ArgumentNotNull((object) token, nameof (token));
-      this._root = token;
-    }
-
-    internal JTokenReader(JToken token, string initialPath)
-      : this(token)
-    {
-      this._initialPath = initialPath;
-    }
-
-    public override bool Read()
-    {
-      if (this.CurrentState != JsonReader.State.Start)
-      {
-        if (this._current == null)
-          return false;
-        return this._current is JContainer current && this._parent != current ? this.ReadInto(current) : this.ReadOver(this._current);
-      }
-      this._current = this._root;
-      this.SetToken(this._current);
-      return true;
-    }
-
-    private bool ReadOver(JToken t)
-    {
-      if (t == this._root)
-        return this.ReadToEnd();
-      JToken next = t.Next;
-      if (next == null || next == t || t == t.Parent.Last)
-        return t.Parent == null ? this.ReadToEnd() : this.SetEnd(t.Parent);
-      this._current = next;
-      this.SetToken(this._current);
-      return true;
-    }
-
-    private bool ReadToEnd()
-    {
-      this._current = (JToken) null;
-      this.SetToken(JsonToken.None);
-      return false;
-    }
-
-    private JsonToken? GetEndToken(JContainer c)
-    {
-      switch (c.Type)
-      {
-        case JTokenType.Object:
-          return new JsonToken?(JsonToken.EndObject);
-        case JTokenType.Array:
-          return new JsonToken?(JsonToken.EndArray);
-        case JTokenType.Constructor:
-          return new JsonToken?(JsonToken.EndConstructor);
-        case JTokenType.Property:
-          return new JsonToken?();
-        default:
-          throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", (object) c.Type, "Unexpected JContainer type.");
-      }
-    }
-
-    private bool ReadInto(JContainer c)
-    {
-      JToken first = c.First;
-      if (first == null)
-        return this.SetEnd(c);
-      this.SetToken(first);
-      this._current = first;
-      this._parent = (JToken) c;
-      return true;
-    }
-
-    private bool SetEnd(JContainer c)
-    {
-      JsonToken? endToken = this.GetEndToken(c);
-      if (!endToken.HasValue)
-        return this.ReadOver((JToken) c);
-      this.SetToken(endToken.GetValueOrDefault());
-      this._current = (JToken) c;
-      this._parent = (JToken) c;
-      return true;
-    }
-
-    private void SetToken(JToken token)
-    {
-      switch (token.Type)
-      {
-        case JTokenType.Object:
-          this.SetToken(JsonToken.StartObject);
-          break;
-        case JTokenType.Array:
-          this.SetToken(JsonToken.StartArray);
-          break;
-        case JTokenType.Constructor:
-          this.SetToken(JsonToken.StartConstructor, (object) ((JConstructor) token).Name);
-          break;
-        case JTokenType.Property:
-          this.SetToken(JsonToken.PropertyName, (object) ((JProperty) token).Name);
-          break;
-        case JTokenType.Comment:
-          this.SetToken(JsonToken.Comment, ((JValue) token).Value);
-          break;
-        case JTokenType.Integer:
-          this.SetToken(JsonToken.Integer, ((JValue) token).Value);
-          break;
-        case JTokenType.Float:
-          this.SetToken(JsonToken.Float, ((JValue) token).Value);
-          break;
-        case JTokenType.String:
-          this.SetToken(JsonToken.String, ((JValue) token).Value);
-          break;
-        case JTokenType.Boolean:
-          this.SetToken(JsonToken.Boolean, ((JValue) token).Value);
-          break;
-        case JTokenType.Null:
-          this.SetToken(JsonToken.Null, ((JValue) token).Value);
-          break;
-        case JTokenType.Undefined:
-          this.SetToken(JsonToken.Undefined, ((JValue) token).Value);
-          break;
-        case JTokenType.Date:
-          this.SetToken(JsonToken.Date, ((JValue) token).Value);
-          break;
-        case JTokenType.Raw:
-          this.SetToken(JsonToken.Raw, ((JValue) token).Value);
-          break;
-        case JTokenType.Bytes:
-          this.SetToken(JsonToken.Bytes, ((JValue) token).Value);
-          break;
-        case JTokenType.Guid:
-          this.SetToken(JsonToken.String, (object) this.SafeToString(((JValue) token).Value));
-          break;
-        case JTokenType.Uri:
-          object obj = ((JValue) token).Value;
-          Uri uri = obj as Uri;
-          this.SetToken(JsonToken.String, uri != (Uri) null ? (object) uri.OriginalString : (object) this.SafeToString(obj));
-          break;
-        case JTokenType.TimeSpan:
-          this.SetToken(JsonToken.String, (object) this.SafeToString(((JValue) token).Value));
-          break;
-        default:
-          throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", (object) token.Type, "Unexpected JTokenType.");
-      }
-    }
-
-    private string SafeToString(object value) => value?.ToString();
-
-    bool IJsonLineInfo.HasLineInfo()
-    {
-      if (this.CurrentState == JsonReader.State.Start)
-        return false;
-      IJsonLineInfo current = (IJsonLineInfo) this._current;
-      return current != null && current.HasLineInfo();
-    }
-
-    int IJsonLineInfo.LineNumber
-    {
-      get
-      {
-        if (this.CurrentState == JsonReader.State.Start)
-          return 0;
-        IJsonLineInfo current = (IJsonLineInfo) this._current;
-        return current != null ? current.LineNumber : 0;
-      }
-    }
-
-    int IJsonLineInfo.LinePosition
-    {
-      get
-      {
-        if (this.CurrentState == JsonReader.State.Start)
-          return 0;
-        IJsonLineInfo current = (IJsonLineInfo) this._current;
-        return current != null ? current.LinePosition : 0;
-      }
-    }
-
-    public override string Path
-    {
-      get
-      {
-        string source = base.Path;
-        if (this._initialPath == null)
-          this._initialPath = this._root.Path;
-        if (!string.IsNullOrEmpty(this._initialPath))
-        {
-          if (string.IsNullOrEmpty(source))
-            return this._initialPath;
-          source = !source.StartsWith('[') ? this._initialPath + "." + source : this._initialPath + source;
-        }
-        return source;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JTokenType.cs b/MSHALTester/Newtonsoft/Json/Linq/JTokenType.cs
deleted file mode 100644
index f97e1a4..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JTokenType.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public enum JTokenType
-  {
-    None,
-    Object,
-    Array,
-    Constructor,
-    Property,
-    Comment,
-    Integer,
-    Float,
-    String,
-    Boolean,
-    Null,
-    Undefined,
-    Date,
-    Raw,
-    Bytes,
-    Guid,
-    Uri,
-    TimeSpan,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JTokenWriter.cs b/MSHALTester/Newtonsoft/Json/Linq/JTokenWriter.cs
deleted file mode 100644
index 460189e..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JTokenWriter.cs
+++ /dev/null
@@ -1,292 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JTokenWriter : JsonWriter
-  {
-    private JContainer _token;
-    private JContainer _parent;
-    private JValue _value;
-    private JToken _current;
-
-    public JToken CurrentToken => this._current;
-
-    public JToken Token => this._token != null ? (JToken) this._token : (JToken) this._value;
-
-    public JTokenWriter(JContainer container)
-    {
-      ValidationUtils.ArgumentNotNull((object) container, nameof (container));
-      this._token = container;
-      this._parent = container;
-    }
-
-    public JTokenWriter()
-    {
-    }
-
-    public override void Flush()
-    {
-    }
-
-    public override void Close() => base.Close();
-
-    public override void WriteStartObject()
-    {
-      base.WriteStartObject();
-      this.AddParent((JContainer) new JObject());
-    }
-
-    private void AddParent(JContainer container)
-    {
-      if (this._parent == null)
-        this._token = container;
-      else
-        this._parent.AddAndSkipParentCheck((JToken) container);
-      this._parent = container;
-      this._current = (JToken) container;
-    }
-
-    private void RemoveParent()
-    {
-      this._current = (JToken) this._parent;
-      this._parent = this._parent.Parent;
-      if (this._parent == null || this._parent.Type != JTokenType.Property)
-        return;
-      this._parent = this._parent.Parent;
-    }
-
-    public override void WriteStartArray()
-    {
-      base.WriteStartArray();
-      this.AddParent((JContainer) new JArray());
-    }
-
-    public override void WriteStartConstructor(string name)
-    {
-      base.WriteStartConstructor(name);
-      this.AddParent((JContainer) new JConstructor(name));
-    }
-
-    protected override void WriteEnd(JsonToken token) => this.RemoveParent();
-
-    public override void WritePropertyName(string name)
-    {
-      if (this._parent is JObject parent)
-      {
-        // ISSUE: explicit non-virtual call
-        __nonvirtual (parent.Remove(name));
-      }
-      this.AddParent((JContainer) new JProperty(name));
-      base.WritePropertyName(name);
-    }
-
-    private void AddValue(object value, JsonToken token) => this.AddValue(new JValue(value), token);
-
-    internal void AddValue(JValue value, JsonToken token)
-    {
-      if (this._parent != null)
-      {
-        this._parent.Add((object) value);
-        this._current = this._parent.Last;
-        if (this._parent.Type != JTokenType.Property)
-          return;
-        this._parent = this._parent.Parent;
-      }
-      else
-      {
-        this._value = value ?? JValue.CreateNull();
-        this._current = (JToken) this._value;
-      }
-    }
-
-    public override void WriteValue(object value) => base.WriteValue(value);
-
-    public override void WriteNull()
-    {
-      base.WriteNull();
-      this.AddValue((JValue) null, JsonToken.Null);
-    }
-
-    public override void WriteUndefined()
-    {
-      base.WriteUndefined();
-      this.AddValue((JValue) null, JsonToken.Undefined);
-    }
-
-    public override void WriteRaw(string json)
-    {
-      base.WriteRaw(json);
-      this.AddValue((JValue) new JRaw((object) json), JsonToken.Raw);
-    }
-
-    public override void WriteComment(string text)
-    {
-      base.WriteComment(text);
-      this.AddValue(JValue.CreateComment(text), JsonToken.Comment);
-    }
-
-    public override void WriteValue(string value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.String);
-    }
-
-    public override void WriteValue(int value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Integer);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(uint value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Integer);
-    }
-
-    public override void WriteValue(long value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Integer);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(ulong value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Integer);
-    }
-
-    public override void WriteValue(float value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Float);
-    }
-
-    public override void WriteValue(double value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Float);
-    }
-
-    public override void WriteValue(bool value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Boolean);
-    }
-
-    public override void WriteValue(short value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Integer);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(ushort value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Integer);
-    }
-
-    public override void WriteValue(char value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value.ToString((IFormatProvider) CultureInfo.InvariantCulture), JsonToken.String);
-    }
-
-    public override void WriteValue(byte value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Integer);
-    }
-
-    [CLSCompliant(false)]
-    public override void WriteValue(sbyte value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Integer);
-    }
-
-    public override void WriteValue(Decimal value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Float);
-    }
-
-    public override void WriteValue(DateTime value)
-    {
-      base.WriteValue(value);
-      value = DateTimeUtils.EnsureDateTime(value, this.DateTimeZoneHandling);
-      this.AddValue((object) value, JsonToken.Date);
-    }
-
-    public override void WriteValue(DateTimeOffset value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Date);
-    }
-
-    public override void WriteValue(byte[] value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.Bytes);
-    }
-
-    public override void WriteValue(TimeSpan value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.String);
-    }
-
-    public override void WriteValue(Guid value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.String);
-    }
-
-    public override void WriteValue(Uri value)
-    {
-      base.WriteValue(value);
-      this.AddValue((object) value, JsonToken.String);
-    }
-
-    internal override void WriteToken(
-      JsonReader reader,
-      bool writeChildren,
-      bool writeDateConstructorAsDate,
-      bool writeComments)
-    {
-      if (reader is JTokenReader jtokenReader & writeChildren & writeDateConstructorAsDate & writeComments)
-      {
-        if (jtokenReader.TokenType == JsonToken.None && !jtokenReader.Read())
-          return;
-        JToken content = jtokenReader.CurrentToken.CloneToken();
-        if (this._parent != null)
-        {
-          this._parent.Add((object) content);
-          this._current = this._parent.Last;
-          if (this._parent.Type == JTokenType.Property)
-          {
-            this._parent = this._parent.Parent;
-            this.InternalWriteValue(JsonToken.Null);
-          }
-        }
-        else
-        {
-          this._current = content;
-          if (this._token == null && this._value == null)
-          {
-            this._token = content as JContainer;
-            this._value = content as JValue;
-          }
-        }
-        jtokenReader.Skip();
-      }
-      else
-        base.WriteToken(reader, writeChildren, writeDateConstructorAsDate, writeComments);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JValue.cs b/MSHALTester/Newtonsoft/Json/Linq/JValue.cs
deleted file mode 100644
index b67e2e5..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JValue.cs
+++ /dev/null
@@ -1,453 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JValue : 
-    JToken,
-    IEquatable<JValue>,
-    IFormattable,
-    IComparable,
-    IComparable<JValue>,
-    IConvertible
-  {
-    private JTokenType _valueType;
-    private object _value;
-
-    internal JValue(object value, JTokenType type)
-    {
-      this._value = value;
-      this._valueType = type;
-    }
-
-    public JValue(JValue other)
-      : this(other.Value, other.Type)
-    {
-    }
-
-    public JValue(long value)
-      : this((object) value, JTokenType.Integer)
-    {
-    }
-
-    public JValue(Decimal value)
-      : this((object) value, JTokenType.Float)
-    {
-    }
-
-    public JValue(char value)
-      : this((object) value, JTokenType.String)
-    {
-    }
-
-    [CLSCompliant(false)]
-    public JValue(ulong value)
-      : this((object) value, JTokenType.Integer)
-    {
-    }
-
-    public JValue(double value)
-      : this((object) value, JTokenType.Float)
-    {
-    }
-
-    public JValue(float value)
-      : this((object) value, JTokenType.Float)
-    {
-    }
-
-    public JValue(DateTime value)
-      : this((object) value, JTokenType.Date)
-    {
-    }
-
-    public JValue(DateTimeOffset value)
-      : this((object) value, JTokenType.Date)
-    {
-    }
-
-    public JValue(bool value)
-      : this((object) value, JTokenType.Boolean)
-    {
-    }
-
-    public JValue(string value)
-      : this((object) value, JTokenType.String)
-    {
-    }
-
-    public JValue(Guid value)
-      : this((object) value, JTokenType.Guid)
-    {
-    }
-
-    public JValue(Uri value)
-      : this((object) value, value != (Uri) null ? JTokenType.Uri : JTokenType.Null)
-    {
-    }
-
-    public JValue(TimeSpan value)
-      : this((object) value, JTokenType.TimeSpan)
-    {
-    }
-
-    public JValue(object value)
-      : this(value, JValue.GetValueType(new JTokenType?(), value))
-    {
-    }
-
-    internal override bool DeepEquals(JToken node)
-    {
-      if (!(node is JValue v2))
-        return false;
-      return v2 == this || JValue.ValuesEquals(this, v2);
-    }
-
-    public override bool HasValues => false;
-
-    internal static int Compare(JTokenType valueType, object objA, object objB)
-    {
-      if (objA == objB)
-        return 0;
-      if (objB == null)
-        return 1;
-      if (objA == null)
-        return -1;
-      switch (valueType)
-      {
-        case JTokenType.Comment:
-        case JTokenType.String:
-        case JTokenType.Raw:
-          return string.CompareOrdinal(Convert.ToString(objA, (IFormatProvider) CultureInfo.InvariantCulture), Convert.ToString(objB, (IFormatProvider) CultureInfo.InvariantCulture));
-        case JTokenType.Integer:
-          if (objA is ulong || objB is ulong || objA is Decimal || objB is Decimal)
-            return Convert.ToDecimal(objA, (IFormatProvider) CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, (IFormatProvider) CultureInfo.InvariantCulture));
-          return objA is float || objB is float || objA is double || objB is double ? JValue.CompareFloat(objA, objB) : Convert.ToInt64(objA, (IFormatProvider) CultureInfo.InvariantCulture).CompareTo(Convert.ToInt64(objB, (IFormatProvider) CultureInfo.InvariantCulture));
-        case JTokenType.Float:
-          return objA is ulong || objB is ulong || objA is Decimal || objB is Decimal ? Convert.ToDecimal(objA, (IFormatProvider) CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, (IFormatProvider) CultureInfo.InvariantCulture)) : JValue.CompareFloat(objA, objB);
-        case JTokenType.Boolean:
-          return Convert.ToBoolean(objA, (IFormatProvider) CultureInfo.InvariantCulture).CompareTo(Convert.ToBoolean(objB, (IFormatProvider) CultureInfo.InvariantCulture));
-        case JTokenType.Date:
-          if (objA is DateTime dateTime1)
-          {
-            DateTime dateTime = !(objB is DateTimeOffset dateTimeOffset) ? Convert.ToDateTime(objB, (IFormatProvider) CultureInfo.InvariantCulture) : dateTimeOffset.DateTime;
-            return dateTime1.CompareTo(dateTime);
-          }
-          DateTimeOffset dateTimeOffset1 = (DateTimeOffset) objA;
-          if (!(objB is DateTimeOffset other))
-            other = new DateTimeOffset(Convert.ToDateTime(objB, (IFormatProvider) CultureInfo.InvariantCulture));
-          return dateTimeOffset1.CompareTo(other);
-        case JTokenType.Bytes:
-          return objB is byte[] a2 ? MiscellaneousUtils.ByteArrayCompare(objA as byte[], a2) : throw new ArgumentException("Object must be of type byte[].");
-        case JTokenType.Guid:
-          return objB is Guid guid ? ((Guid) objA).CompareTo(guid) : throw new ArgumentException("Object must be of type Guid.");
-        case JTokenType.Uri:
-          Uri uri = objB as Uri;
-          if (uri == (Uri) null)
-            throw new ArgumentException("Object must be of type Uri.");
-          return Comparer<string>.Default.Compare(((Uri) objA).ToString(), uri.ToString());
-        case JTokenType.TimeSpan:
-          return objB is TimeSpan timeSpan ? ((TimeSpan) objA).CompareTo(timeSpan) : throw new ArgumentException("Object must be of type TimeSpan.");
-        default:
-          throw MiscellaneousUtils.CreateArgumentOutOfRangeException(nameof (valueType), (object) valueType, "Unexpected value type: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) valueType));
-      }
-    }
-
-    private static int CompareFloat(object objA, object objB)
-    {
-      double d1 = Convert.ToDouble(objA, (IFormatProvider) CultureInfo.InvariantCulture);
-      double d2 = Convert.ToDouble(objB, (IFormatProvider) CultureInfo.InvariantCulture);
-      return MathUtils.ApproxEquals(d1, d2) ? 0 : d1.CompareTo(d2);
-    }
-
-    internal override JToken CloneToken() => (JToken) new JValue(this);
-
-    public static JValue CreateComment(string value)
-    {
-      return new JValue((object) value, JTokenType.Comment);
-    }
-
-    public static JValue CreateString(string value)
-    {
-      return new JValue((object) value, JTokenType.String);
-    }
-
-    public static JValue CreateNull() => new JValue((object) null, JTokenType.Null);
-
-    public static JValue CreateUndefined() => new JValue((object) null, JTokenType.Undefined);
-
-    private static JTokenType GetValueType(JTokenType? current, object value)
-    {
-      if (value == null || value == DBNull.Value)
-        return JTokenType.Null;
-      switch (value)
-      {
-        case string _:
-          return JValue.GetStringValueType(current);
-        case long _:
-        case int _:
-        case short _:
-        case sbyte _:
-        case ulong _:
-        case uint _:
-        case ushort _:
-        case byte _:
-          return JTokenType.Integer;
-        case Enum _:
-          return JTokenType.Integer;
-        case double _:
-        case float _:
-        case Decimal _:
-          return JTokenType.Float;
-        case DateTime _:
-          return JTokenType.Date;
-        case DateTimeOffset _:
-          return JTokenType.Date;
-        case byte[] _:
-          return JTokenType.Bytes;
-        case bool _:
-          return JTokenType.Boolean;
-        case Guid _:
-          return JTokenType.Guid;
-        default:
-          if ((object) (value as Uri) != null)
-            return JTokenType.Uri;
-          if (value is TimeSpan)
-            return JTokenType.TimeSpan;
-          throw new ArgumentException("Could not determine JSON object type for type {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType()));
-      }
-    }
-
-    private static JTokenType GetStringValueType(JTokenType? current)
-    {
-      if (!current.HasValue)
-        return JTokenType.String;
-      switch (current.GetValueOrDefault())
-      {
-        case JTokenType.Comment:
-        case JTokenType.String:
-        case JTokenType.Raw:
-          return current.GetValueOrDefault();
-        default:
-          return JTokenType.String;
-      }
-    }
-
-    public override JTokenType Type => this._valueType;
-
-    public object Value
-    {
-      get => this._value;
-      set
-      {
-        if (this._value?.GetType() != value?.GetType())
-          this._valueType = JValue.GetValueType(new JTokenType?(this._valueType), value);
-        this._value = value;
-      }
-    }
-
-    public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
-    {
-      if (converters != null && converters.Length != 0 && this._value != null)
-      {
-        JsonConverter matchingConverter = JsonSerializer.GetMatchingConverter((IList<JsonConverter>) converters, this._value.GetType());
-        if (matchingConverter != null && matchingConverter.CanWrite)
-        {
-          matchingConverter.WriteJson(writer, this._value, JsonSerializer.CreateDefault());
-          return;
-        }
-      }
-      switch (this._valueType)
-      {
-        case JTokenType.Comment:
-          writer.WriteComment(this._value?.ToString());
-          break;
-        case JTokenType.Integer:
-          if (this._value is int num1)
-          {
-            writer.WriteValue(num1);
-            break;
-          }
-          if (this._value is long num2)
-          {
-            writer.WriteValue(num2);
-            break;
-          }
-          object obj1;
-          if ((obj1 = this._value) is ulong)
-          {
-            ulong num3 = (ulong) obj1;
-            writer.WriteValue(num3);
-            break;
-          }
-          writer.WriteValue(Convert.ToInt64(this._value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case JTokenType.Float:
-          if (this._value is Decimal num4)
-          {
-            writer.WriteValue(num4);
-            break;
-          }
-          if (this._value is double num5)
-          {
-            writer.WriteValue(num5);
-            break;
-          }
-          object obj2;
-          if ((obj2 = this._value) is float)
-          {
-            float num6 = (float) obj2;
-            writer.WriteValue(num6);
-            break;
-          }
-          writer.WriteValue(Convert.ToDouble(this._value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case JTokenType.String:
-          writer.WriteValue(this._value?.ToString());
-          break;
-        case JTokenType.Boolean:
-          writer.WriteValue(Convert.ToBoolean(this._value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case JTokenType.Null:
-          writer.WriteNull();
-          break;
-        case JTokenType.Undefined:
-          writer.WriteUndefined();
-          break;
-        case JTokenType.Date:
-          if (this._value is DateTimeOffset dateTimeOffset)
-          {
-            writer.WriteValue(dateTimeOffset);
-            break;
-          }
-          writer.WriteValue(Convert.ToDateTime(this._value, (IFormatProvider) CultureInfo.InvariantCulture));
-          break;
-        case JTokenType.Raw:
-          writer.WriteRawValue(this._value?.ToString());
-          break;
-        case JTokenType.Bytes:
-          writer.WriteValue((byte[]) this._value);
-          break;
-        case JTokenType.Guid:
-          writer.WriteValue(this._value != null ? (Guid?) this._value : new Guid?());
-          break;
-        case JTokenType.Uri:
-          writer.WriteValue((Uri) this._value);
-          break;
-        case JTokenType.TimeSpan:
-          writer.WriteValue(this._value != null ? (TimeSpan?) this._value : new TimeSpan?());
-          break;
-        default:
-          throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", (object) this._valueType, "Unexpected token type.");
-      }
-    }
-
-    internal override int GetDeepHashCode()
-    {
-      int hashCode = this._value != null ? this._value.GetHashCode() : 0;
-      return ((int) this._valueType).GetHashCode() ^ hashCode;
-    }
-
-    private static bool ValuesEquals(JValue v1, JValue v2)
-    {
-      if (v1 == v2)
-        return true;
-      return v1._valueType == v2._valueType && JValue.Compare(v1._valueType, v1._value, v2._value) == 0;
-    }
-
-    public bool Equals(JValue other) => other != null && JValue.ValuesEquals(this, other);
-
-    public override bool Equals(object obj) => this.Equals(obj as JValue);
-
-    public override int GetHashCode() => this._value == null ? 0 : this._value.GetHashCode();
-
-    public override string ToString()
-    {
-      return this._value == null ? string.Empty : this._value.ToString();
-    }
-
-    public string ToString(string format)
-    {
-      return this.ToString(format, (IFormatProvider) CultureInfo.CurrentCulture);
-    }
-
-    public string ToString(IFormatProvider formatProvider)
-    {
-      return this.ToString((string) null, formatProvider);
-    }
-
-    public string ToString(string format, IFormatProvider formatProvider)
-    {
-      if (this._value == null)
-        return string.Empty;
-      return this._value is IFormattable formattable ? formattable.ToString(format, formatProvider) : this._value.ToString();
-    }
-
-    int IComparable.CompareTo(object obj)
-    {
-      if (obj == null)
-        return 1;
-      object objB;
-      JTokenType valueType;
-      if (obj is JValue jvalue)
-      {
-        objB = jvalue.Value;
-        valueType = this._valueType != JTokenType.String || this._valueType == jvalue._valueType ? this._valueType : jvalue._valueType;
-      }
-      else
-      {
-        objB = obj;
-        valueType = this._valueType;
-      }
-      return JValue.Compare(valueType, this._value, objB);
-    }
-
-    public int CompareTo(JValue obj)
-    {
-      return obj == null ? 1 : JValue.Compare(this._valueType != JTokenType.String || this._valueType == obj._valueType ? this._valueType : obj._valueType, this._value, obj._value);
-    }
-
-    TypeCode IConvertible.GetTypeCode()
-    {
-      if (this._value == null)
-        return TypeCode.Empty;
-      return this._value is IConvertible convertible ? convertible.GetTypeCode() : TypeCode.Object;
-    }
-
-    bool IConvertible.ToBoolean(IFormatProvider provider) => (bool) (JToken) this;
-
-    char IConvertible.ToChar(IFormatProvider provider) => (char) (JToken) this;
-
-    sbyte IConvertible.ToSByte(IFormatProvider provider) => (sbyte) (JToken) this;
-
-    byte IConvertible.ToByte(IFormatProvider provider) => (byte) (JToken) this;
-
-    short IConvertible.ToInt16(IFormatProvider provider) => (short) (JToken) this;
-
-    ushort IConvertible.ToUInt16(IFormatProvider provider) => (ushort) (JToken) this;
-
-    int IConvertible.ToInt32(IFormatProvider provider) => (int) (JToken) this;
-
-    uint IConvertible.ToUInt32(IFormatProvider provider) => (uint) (JToken) this;
-
-    long IConvertible.ToInt64(IFormatProvider provider) => (long) (JToken) this;
-
-    ulong IConvertible.ToUInt64(IFormatProvider provider) => (ulong) (JToken) this;
-
-    float IConvertible.ToSingle(IFormatProvider provider) => (float) (JToken) this;
-
-    double IConvertible.ToDouble(IFormatProvider provider) => (double) (JToken) this;
-
-    Decimal IConvertible.ToDecimal(IFormatProvider provider) => (Decimal) (JToken) this;
-
-    DateTime IConvertible.ToDateTime(IFormatProvider provider) => (DateTime) (JToken) this;
-
-    object IConvertible.ToType(System.Type conversionType, IFormatProvider provider)
-    {
-      return this.ToObject(conversionType);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonLoadSettings.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonLoadSettings.cs
deleted file mode 100644
index d36e7e6..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonLoadSettings.cs
+++ /dev/null
@@ -1,35 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JsonLoadSettings
-  {
-    private CommentHandling _commentHandling;
-    private LineInfoHandling _lineInfoHandling;
-
-    public JsonLoadSettings()
-    {
-      this._lineInfoHandling = LineInfoHandling.Load;
-      this._commentHandling = CommentHandling.Ignore;
-    }
-
-    public CommentHandling CommentHandling
-    {
-      get => this._commentHandling;
-      set
-      {
-        this._commentHandling = value >= CommentHandling.Ignore && value <= CommentHandling.Load ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public LineInfoHandling LineInfoHandling
-    {
-      get => this._lineInfoHandling;
-      set
-      {
-        this._lineInfoHandling = value >= LineInfoHandling.Ignore && value <= LineInfoHandling.Load ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonMergeSettings.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonMergeSettings.cs
deleted file mode 100644
index 103a0a0..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonMergeSettings.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public class JsonMergeSettings
-  {
-    private MergeArrayHandling _mergeArrayHandling;
-    private MergeNullValueHandling _mergeNullValueHandling;
-
-    public MergeArrayHandling MergeArrayHandling
-    {
-      get => this._mergeArrayHandling;
-      set
-      {
-        this._mergeArrayHandling = value >= MergeArrayHandling.Concat && value <= MergeArrayHandling.Merge ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public MergeNullValueHandling MergeNullValueHandling
-    {
-      get => this._mergeNullValueHandling;
-      set
-      {
-        this._mergeNullValueHandling = value >= MergeNullValueHandling.Ignore && value <= MergeNullValueHandling.Merge ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArrayIndexFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArrayIndexFilter.cs
deleted file mode 100644
index 44fd77f..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArrayIndexFilter.cs
+++ /dev/null
@@ -1,41 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class ArrayIndexFilter : PathFilter
-  {
-    public int? Index { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      foreach (JToken t1 in current)
-      {
-        int? index = this.Index;
-        if (index.HasValue)
-        {
-          JToken t2 = t1;
-          int num = errorWhenNoMatch ? 1 : 0;
-          index = this.Index;
-          int valueOrDefault = index.GetValueOrDefault();
-          JToken tokenIndex = PathFilter.GetTokenIndex(t2, num != 0, valueOrDefault);
-          if (tokenIndex != null)
-            yield return tokenIndex;
-        }
-        else if (t1 is JArray || t1 is JConstructor)
-        {
-          foreach (JToken jtoken in (IEnumerable<JToken>) t1)
-            yield return jtoken;
-        }
-        else if (errorWhenNoMatch)
-          throw new JsonException("Index * not valid on {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) t1.GetType().Name));
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArrayMultipleIndexFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArrayMultipleIndexFilter.cs
deleted file mode 100644
index d69c226..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArrayMultipleIndexFilter.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class ArrayMultipleIndexFilter : PathFilter
-  {
-    public List<int> Indexes { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      foreach (JToken t in current)
-      {
-        foreach (int index in this.Indexes)
-        {
-          JToken tokenIndex = PathFilter.GetTokenIndex(t, errorWhenNoMatch, index);
-          if (tokenIndex != null)
-            yield return tokenIndex;
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArraySliceFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArraySliceFilter.cs
deleted file mode 100644
index 15993d1..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ArraySliceFilter.cs
+++ /dev/null
@@ -1,92 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class ArraySliceFilter : PathFilter
-  {
-    public int? Start { get; set; }
-
-    public int? End { get; set; }
-
-    public int? Step { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      int? nullable = this.Step;
-      int num1 = 0;
-      if ((nullable.GetValueOrDefault() == num1 ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-        throw new JsonException("Step cannot be zero.");
-      foreach (JToken t in current)
-      {
-        if (t is JArray a)
-        {
-          nullable = this.Step;
-          int stepCount = nullable ?? 1;
-          nullable = this.Start;
-          int val1 = nullable ?? (stepCount > 0 ? 0 : a.Count - 1);
-          nullable = this.End;
-          int stopIndex = nullable ?? (stepCount > 0 ? a.Count : -1);
-          nullable = this.Start;
-          int num2 = 0;
-          if ((nullable.GetValueOrDefault() < num2 ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-            val1 = a.Count + val1;
-          nullable = this.End;
-          int num3 = 0;
-          if ((nullable.GetValueOrDefault() < num3 ? (nullable.HasValue ? 1 : 0) : 0) != 0)
-            stopIndex = a.Count + stopIndex;
-          int index = Math.Min(Math.Max(val1, stepCount > 0 ? 0 : int.MinValue), stepCount > 0 ? a.Count : a.Count - 1);
-          stopIndex = Math.Max(stopIndex, -1);
-          stopIndex = Math.Min(stopIndex, a.Count);
-          bool positiveStep = stepCount > 0;
-          if (this.IsValid(index, stopIndex, positiveStep))
-          {
-            for (int i = index; this.IsValid(i, stopIndex, positiveStep); i += stepCount)
-              yield return a[i];
-          }
-          else if (errorWhenNoMatch)
-          {
-            CultureInfo invariantCulture = CultureInfo.InvariantCulture;
-            nullable = this.Start;
-            string str1;
-            if (!nullable.HasValue)
-            {
-              str1 = "*";
-            }
-            else
-            {
-              nullable = this.Start;
-              str1 = nullable.GetValueOrDefault().ToString((IFormatProvider) CultureInfo.InvariantCulture);
-            }
-            nullable = this.End;
-            string str2;
-            if (!nullable.HasValue)
-            {
-              str2 = "*";
-            }
-            else
-            {
-              nullable = this.End;
-              str2 = nullable.GetValueOrDefault().ToString((IFormatProvider) CultureInfo.InvariantCulture);
-            }
-            throw new JsonException("Array slice of {0} to {1} returned no results.".FormatWith((IFormatProvider) invariantCulture, (object) str1, (object) str2));
-          }
-        }
-        else if (errorWhenNoMatch)
-          throw new JsonException("Array slice is not valid on {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) t.GetType().Name));
-        a = (JArray) null;
-      }
-    }
-
-    private bool IsValid(int index, int stopIndex, bool positiveStep)
-    {
-      return positiveStep ? index < stopIndex : index > stopIndex;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/BooleanQueryExpression.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/BooleanQueryExpression.cs
deleted file mode 100644
index c2d2eed..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/BooleanQueryExpression.cs
+++ /dev/null
@@ -1,158 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Linq;
-using System.Text.RegularExpressions;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class BooleanQueryExpression : QueryExpression
-  {
-    public object Left { get; set; }
-
-    public object Right { get; set; }
-
-    private IEnumerable<JToken> GetResult(JToken root, JToken t, object o)
-    {
-      switch (o)
-      {
-        case JToken jtoken:
-          return (IEnumerable<JToken>) new JToken[1]
-          {
-            jtoken
-          };
-        case List<PathFilter> filters:
-          return JPath.Evaluate(filters, root, t, false);
-        default:
-          return (IEnumerable<JToken>) CollectionUtils.ArrayEmpty<JToken>();
-      }
-    }
-
-    public override bool IsMatch(JToken root, JToken t)
-    {
-      if (this.Operator == QueryOperator.Exists)
-        return this.GetResult(root, t, this.Left).Any<JToken>();
-      using (IEnumerator<JToken> enumerator = this.GetResult(root, t, this.Left).GetEnumerator())
-      {
-        if (enumerator.MoveNext())
-        {
-          IEnumerable<JToken> result = this.GetResult(root, t, this.Right);
-          if (!(result is ICollection<JToken> jtokens1))
-            jtokens1 = (ICollection<JToken>) result.ToList<JToken>();
-          ICollection<JToken> jtokens2 = jtokens1;
-          do
-          {
-            JToken current = enumerator.Current;
-            foreach (JToken rightResult in (IEnumerable<JToken>) jtokens2)
-            {
-              if (this.MatchTokens(current, rightResult))
-                return true;
-            }
-          }
-          while (enumerator.MoveNext());
-        }
-      }
-      return false;
-    }
-
-    private bool MatchTokens(JToken leftResult, JToken rightResult)
-    {
-      if (leftResult is JValue input && rightResult is JValue jvalue)
-      {
-        switch (this.Operator)
-        {
-          case QueryOperator.Equals:
-            if (this.EqualsWithStringCoercion(input, jvalue))
-              return true;
-            break;
-          case QueryOperator.NotEquals:
-            if (!this.EqualsWithStringCoercion(input, jvalue))
-              return true;
-            break;
-          case QueryOperator.Exists:
-            return true;
-          case QueryOperator.LessThan:
-            if (input.CompareTo(jvalue) < 0)
-              return true;
-            break;
-          case QueryOperator.LessThanOrEquals:
-            if (input.CompareTo(jvalue) <= 0)
-              return true;
-            break;
-          case QueryOperator.GreaterThan:
-            if (input.CompareTo(jvalue) > 0)
-              return true;
-            break;
-          case QueryOperator.GreaterThanOrEquals:
-            if (input.CompareTo(jvalue) >= 0)
-              return true;
-            break;
-          case QueryOperator.RegexEquals:
-            if (BooleanQueryExpression.RegexEquals(input, jvalue))
-              return true;
-            break;
-        }
-      }
-      else
-      {
-        switch (this.Operator)
-        {
-          case QueryOperator.NotEquals:
-          case QueryOperator.Exists:
-            return true;
-        }
-      }
-      return false;
-    }
-
-    private static bool RegexEquals(JValue input, JValue pattern)
-    {
-      if (input.Type != JTokenType.String || pattern.Type != JTokenType.String)
-        return false;
-      string str = (string) pattern.Value;
-      int num = str.LastIndexOf('/');
-      string pattern1 = str.Substring(1, num - 1);
-      string optionsText = str.Substring(num + 1);
-      return Regex.IsMatch((string) input.Value, pattern1, MiscellaneousUtils.GetRegexOptions(optionsText));
-    }
-
-    private bool EqualsWithStringCoercion(JValue value, JValue queryValue)
-    {
-      if (value.Equals(queryValue))
-        return true;
-      if (queryValue.Type != JTokenType.String)
-        return false;
-      string b = (string) queryValue.Value;
-      string a;
-      switch (value.Type)
-      {
-        case JTokenType.Date:
-          using (StringWriter stringWriter = StringUtils.CreateStringWriter(64))
-          {
-            if (value.Value is DateTimeOffset dateTimeOffset)
-              DateTimeUtils.WriteDateTimeOffsetString((TextWriter) stringWriter, dateTimeOffset, DateFormatHandling.IsoDateFormat, (string) null, CultureInfo.InvariantCulture);
-            else
-              DateTimeUtils.WriteDateTimeString((TextWriter) stringWriter, (DateTime) value.Value, DateFormatHandling.IsoDateFormat, (string) null, CultureInfo.InvariantCulture);
-            a = stringWriter.ToString();
-            break;
-          }
-        case JTokenType.Bytes:
-          a = Convert.ToBase64String((byte[]) value.Value);
-          break;
-        case JTokenType.Guid:
-        case JTokenType.TimeSpan:
-          a = value.Value.ToString();
-          break;
-        case JTokenType.Uri:
-          a = ((Uri) value.Value).OriginalString;
-          break;
-        default:
-          return false;
-      }
-      return string.Equals(a, b, StringComparison.Ordinal);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/CompositeExpression.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/CompositeExpression.cs
deleted file mode 100644
index 558e28a..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/CompositeExpression.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-using System;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class CompositeExpression : QueryExpression
-  {
-    public List<QueryExpression> Expressions { get; set; }
-
-    public CompositeExpression() => this.Expressions = new List<QueryExpression>();
-
-    public override bool IsMatch(JToken root, JToken t)
-    {
-      switch (this.Operator)
-      {
-        case QueryOperator.And:
-          foreach (QueryExpression expression in this.Expressions)
-          {
-            if (!expression.IsMatch(root, t))
-              return false;
-          }
-          return true;
-        case QueryOperator.Or:
-          foreach (QueryExpression expression in this.Expressions)
-          {
-            if (expression.IsMatch(root, t))
-              return true;
-          }
-          return false;
-        default:
-          throw new ArgumentOutOfRangeException();
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/FieldFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/FieldFilter.cs
deleted file mode 100644
index 3a641e8..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/FieldFilter.cs
+++ /dev/null
@@ -1,42 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class FieldFilter : PathFilter
-  {
-    public string Name { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      foreach (JToken t in current)
-      {
-        if (t is JObject o)
-        {
-          if (this.Name != null)
-          {
-            JToken jtoken = o[this.Name];
-            if (jtoken != null)
-              yield return jtoken;
-            else if (errorWhenNoMatch)
-              throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.Name));
-          }
-          else
-          {
-            foreach (KeyValuePair<string, JToken> keyValuePair in o)
-              yield return keyValuePair.Value;
-          }
-        }
-        else if (errorWhenNoMatch)
-          throw new JsonException("Property '{0}' not valid on {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) (this.Name ?? "*"), (object) t.GetType().Name));
-        o = (JObject) null;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/FieldMultipleFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/FieldMultipleFilter.cs
deleted file mode 100644
index d005b01..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/FieldMultipleFilter.cs
+++ /dev/null
@@ -1,38 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class FieldMultipleFilter : PathFilter
-  {
-    public List<string> Names { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      foreach (JToken t in current)
-      {
-        if (t is JObject o)
-        {
-          foreach (string name in this.Names)
-          {
-            JToken jtoken = o[name];
-            if (jtoken != null)
-              yield return jtoken;
-            if (errorWhenNoMatch)
-              throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) name));
-          }
-        }
-        else if (errorWhenNoMatch)
-          throw new JsonException("Properties {0} not valid on {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) string.Join(", ", this.Names.Select<string, string>((Func<string, string>) (n => "'" + n + "'")).ToArray<string>()), (object) t.GetType().Name));
-        o = (JObject) null;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/JPath.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/JPath.cs
deleted file mode 100644
index 8f36ec1..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/JPath.cs
+++ /dev/null
@@ -1,671 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Text;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class JPath
-  {
-    private static readonly char[] FloatCharacters = new char[3]
-    {
-      '.',
-      'E',
-      'e'
-    };
-    private readonly string _expression;
-    private int _currentIndex;
-
-    public List<PathFilter> Filters { get; }
-
-    public JPath(string expression)
-    {
-      ValidationUtils.ArgumentNotNull((object) expression, nameof (expression));
-      this._expression = expression;
-      this.Filters = new List<PathFilter>();
-      this.ParseMain();
-    }
-
-    private void ParseMain()
-    {
-      int currentIndex1 = this._currentIndex;
-      this.EatWhitespace();
-      if (this._expression.Length == this._currentIndex)
-        return;
-      if (this._expression[this._currentIndex] == '$')
-      {
-        if (this._expression.Length == 1)
-          return;
-        switch (this._expression[this._currentIndex + 1])
-        {
-          case '.':
-          case '[':
-            ++this._currentIndex;
-            currentIndex1 = this._currentIndex;
-            break;
-        }
-      }
-      if (this.ParsePath(this.Filters, currentIndex1, false))
-        return;
-      int currentIndex2 = this._currentIndex;
-      this.EatWhitespace();
-      if (this._currentIndex < this._expression.Length)
-        throw new JsonException("Unexpected character while parsing path: " + this._expression[currentIndex2].ToString());
-    }
-
-    private bool ParsePath(List<PathFilter> filters, int currentPartStartIndex, bool query)
-    {
-      bool scan = false;
-      bool flag1 = false;
-      bool flag2 = false;
-      bool flag3 = false;
-      while (this._currentIndex < this._expression.Length && !flag3)
-      {
-        char indexerOpenChar = this._expression[this._currentIndex];
-        switch (indexerOpenChar)
-        {
-          case ' ':
-            if (this._currentIndex < this._expression.Length)
-            {
-              flag3 = true;
-              continue;
-            }
-            continue;
-          case '(':
-          case '[':
-            if (this._currentIndex > currentPartStartIndex)
-            {
-              string member = this._expression.Substring(currentPartStartIndex, this._currentIndex - currentPartStartIndex);
-              if (member == "*")
-                member = (string) null;
-              filters.Add(JPath.CreatePathFilter(member, scan));
-              scan = false;
-            }
-            filters.Add(this.ParseIndexer(indexerOpenChar, scan));
-            ++this._currentIndex;
-            currentPartStartIndex = this._currentIndex;
-            flag1 = true;
-            flag2 = false;
-            continue;
-          case ')':
-          case ']':
-            flag3 = true;
-            continue;
-          case '.':
-            if (this._currentIndex > currentPartStartIndex)
-            {
-              string member = this._expression.Substring(currentPartStartIndex, this._currentIndex - currentPartStartIndex);
-              if (member == "*")
-                member = (string) null;
-              filters.Add(JPath.CreatePathFilter(member, scan));
-              scan = false;
-            }
-            if (this._currentIndex + 1 < this._expression.Length && this._expression[this._currentIndex + 1] == '.')
-            {
-              scan = true;
-              ++this._currentIndex;
-            }
-            ++this._currentIndex;
-            currentPartStartIndex = this._currentIndex;
-            flag1 = false;
-            flag2 = true;
-            continue;
-          default:
-            if (query && (indexerOpenChar == '=' || indexerOpenChar == '<' || indexerOpenChar == '!' || indexerOpenChar == '>' || indexerOpenChar == '|' || indexerOpenChar == '&'))
-            {
-              flag3 = true;
-              continue;
-            }
-            if (flag1)
-              throw new JsonException("Unexpected character following indexer: " + indexerOpenChar.ToString());
-            ++this._currentIndex;
-            continue;
-        }
-      }
-      bool path = this._currentIndex == this._expression.Length;
-      if (this._currentIndex > currentPartStartIndex)
-      {
-        string member = this._expression.Substring(currentPartStartIndex, this._currentIndex - currentPartStartIndex).TrimEnd();
-        if (member == "*")
-          member = (string) null;
-        filters.Add(JPath.CreatePathFilter(member, scan));
-      }
-      else if (flag2 && path | query)
-        throw new JsonException("Unexpected end while parsing path.");
-      return path;
-    }
-
-    private static PathFilter CreatePathFilter(string member, bool scan)
-    {
-      if (!scan)
-        return (PathFilter) new FieldFilter()
-        {
-          Name = member
-        };
-      return (PathFilter) new ScanFilter() { Name = member };
-    }
-
-    private PathFilter ParseIndexer(char indexerOpenChar, bool scan)
-    {
-      ++this._currentIndex;
-      char indexerCloseChar = indexerOpenChar == '[' ? ']' : ')';
-      this.EnsureLength("Path ended with open indexer.");
-      this.EatWhitespace();
-      if (this._expression[this._currentIndex] == '\'')
-        return this.ParseQuotedField(indexerCloseChar, scan);
-      return this._expression[this._currentIndex] == '?' ? this.ParseQuery(indexerCloseChar, scan) : this.ParseArrayIndexer(indexerCloseChar);
-    }
-
-    private PathFilter ParseArrayIndexer(char indexerCloseChar)
-    {
-      int currentIndex = this._currentIndex;
-      int? nullable1 = new int?();
-      List<int> intList = (List<int>) null;
-      int num = 0;
-      int? nullable2 = new int?();
-      int? nullable3 = new int?();
-      int? nullable4 = new int?();
-      while (this._currentIndex < this._expression.Length)
-      {
-        char c = this._expression[this._currentIndex];
-        if (c == ' ')
-        {
-          nullable1 = new int?(this._currentIndex);
-          this.EatWhitespace();
-        }
-        else
-        {
-          int? nullable5;
-          if ((int) c == (int) indexerCloseChar)
-          {
-            nullable5 = nullable1;
-            int length = (nullable5 ?? this._currentIndex) - currentIndex;
-            if (intList != null)
-            {
-              if (length == 0)
-                throw new JsonException("Array index expected.");
-              int int32 = Convert.ToInt32(this._expression.Substring(currentIndex, length), (IFormatProvider) CultureInfo.InvariantCulture);
-              intList.Add(int32);
-              return (PathFilter) new ArrayMultipleIndexFilter()
-              {
-                Indexes = intList
-              };
-            }
-            if (num > 0)
-            {
-              if (length > 0)
-              {
-                int int32 = Convert.ToInt32(this._expression.Substring(currentIndex, length), (IFormatProvider) CultureInfo.InvariantCulture);
-                if (num == 1)
-                  nullable3 = new int?(int32);
-                else
-                  nullable4 = new int?(int32);
-              }
-              return (PathFilter) new ArraySliceFilter()
-              {
-                Start = nullable2,
-                End = nullable3,
-                Step = nullable4
-              };
-            }
-            if (length == 0)
-              throw new JsonException("Array index expected.");
-            int int32_1 = Convert.ToInt32(this._expression.Substring(currentIndex, length), (IFormatProvider) CultureInfo.InvariantCulture);
-            return (PathFilter) new ArrayIndexFilter()
-            {
-              Index = new int?(int32_1)
-            };
-          }
-          switch (c)
-          {
-            case '*':
-              ++this._currentIndex;
-              this.EnsureLength("Path ended with open indexer.");
-              this.EatWhitespace();
-              if ((int) this._expression[this._currentIndex] != (int) indexerCloseChar)
-                throw new JsonException("Unexpected character while parsing path indexer: " + c.ToString());
-              return (PathFilter) new ArrayIndexFilter();
-            case ',':
-              nullable5 = nullable1;
-              int length1 = (nullable5 ?? this._currentIndex) - currentIndex;
-              if (length1 == 0)
-                throw new JsonException("Array index expected.");
-              if (intList == null)
-                intList = new List<int>();
-              string str = this._expression.Substring(currentIndex, length1);
-              intList.Add(Convert.ToInt32(str, (IFormatProvider) CultureInfo.InvariantCulture));
-              ++this._currentIndex;
-              this.EatWhitespace();
-              currentIndex = this._currentIndex;
-              nullable1 = new int?();
-              continue;
-            case ':':
-              nullable5 = nullable1;
-              int length2 = (nullable5 ?? this._currentIndex) - currentIndex;
-              if (length2 > 0)
-              {
-                int int32 = Convert.ToInt32(this._expression.Substring(currentIndex, length2), (IFormatProvider) CultureInfo.InvariantCulture);
-                switch (num)
-                {
-                  case 0:
-                    nullable2 = new int?(int32);
-                    break;
-                  case 1:
-                    nullable3 = new int?(int32);
-                    break;
-                  default:
-                    nullable4 = new int?(int32);
-                    break;
-                }
-              }
-              ++num;
-              ++this._currentIndex;
-              this.EatWhitespace();
-              currentIndex = this._currentIndex;
-              nullable1 = new int?();
-              continue;
-            default:
-              if (!char.IsDigit(c) && c != '-')
-                throw new JsonException("Unexpected character while parsing path indexer: " + c.ToString());
-              if (nullable1.HasValue)
-                throw new JsonException("Unexpected character while parsing path indexer: " + c.ToString());
-              ++this._currentIndex;
-              continue;
-          }
-        }
-      }
-      throw new JsonException("Path ended with open indexer.");
-    }
-
-    private void EatWhitespace()
-    {
-      while (this._currentIndex < this._expression.Length && this._expression[this._currentIndex] == ' ')
-        ++this._currentIndex;
-    }
-
-    private PathFilter ParseQuery(char indexerCloseChar, bool scan)
-    {
-      ++this._currentIndex;
-      this.EnsureLength("Path ended with open indexer.");
-      if (this._expression[this._currentIndex] != '(')
-        throw new JsonException("Unexpected character while parsing path indexer: " + this._expression[this._currentIndex].ToString());
-      ++this._currentIndex;
-      QueryExpression expression = this.ParseExpression();
-      ++this._currentIndex;
-      this.EnsureLength("Path ended with open indexer.");
-      this.EatWhitespace();
-      if ((int) this._expression[this._currentIndex] != (int) indexerCloseChar)
-        throw new JsonException("Unexpected character while parsing path indexer: " + this._expression[this._currentIndex].ToString());
-      if (!scan)
-        return (PathFilter) new QueryFilter()
-        {
-          Expression = expression
-        };
-      return (PathFilter) new QueryScanFilter()
-      {
-        Expression = expression
-      };
-    }
-
-    private bool TryParseExpression(out List<PathFilter> expressionPath)
-    {
-      if (this._expression[this._currentIndex] == '$')
-      {
-        expressionPath = new List<PathFilter>();
-        expressionPath.Add((PathFilter) RootFilter.Instance);
-      }
-      else if (this._expression[this._currentIndex] == '@')
-      {
-        expressionPath = new List<PathFilter>();
-      }
-      else
-      {
-        expressionPath = (List<PathFilter>) null;
-        return false;
-      }
-      ++this._currentIndex;
-      if (this.ParsePath(expressionPath, this._currentIndex, true))
-        throw new JsonException("Path ended with open query.");
-      return true;
-    }
-
-    private JsonException CreateUnexpectedCharacterException()
-    {
-      return new JsonException("Unexpected character while parsing path query: " + this._expression[this._currentIndex].ToString());
-    }
-
-    private object ParseSide()
-    {
-      this.EatWhitespace();
-      List<PathFilter> expressionPath;
-      if (this.TryParseExpression(out expressionPath))
-      {
-        this.EatWhitespace();
-        this.EnsureLength("Path ended with open query.");
-        return (object) expressionPath;
-      }
-      object obj;
-      if (!this.TryParseValue(out obj))
-        throw this.CreateUnexpectedCharacterException();
-      this.EatWhitespace();
-      this.EnsureLength("Path ended with open query.");
-      return (object) new JValue(obj);
-    }
-
-    private QueryExpression ParseExpression()
-    {
-      QueryExpression expression1 = (QueryExpression) null;
-      CompositeExpression compositeExpression1 = (CompositeExpression) null;
-      while (this._currentIndex < this._expression.Length)
-      {
-        object side = this.ParseSide();
-        object obj = (object) null;
-        QueryOperator queryOperator;
-        if (this._expression[this._currentIndex] == ')' || this._expression[this._currentIndex] == '|' || this._expression[this._currentIndex] == '&')
-        {
-          queryOperator = QueryOperator.Exists;
-        }
-        else
-        {
-          queryOperator = this.ParseOperator();
-          obj = this.ParseSide();
-        }
-        BooleanQueryExpression booleanQueryExpression = new BooleanQueryExpression();
-        booleanQueryExpression.Left = side;
-        booleanQueryExpression.Operator = queryOperator;
-        booleanQueryExpression.Right = obj;
-        BooleanQueryExpression expression2 = booleanQueryExpression;
-        if (this._expression[this._currentIndex] == ')')
-        {
-          if (compositeExpression1 == null)
-            return (QueryExpression) expression2;
-          compositeExpression1.Expressions.Add((QueryExpression) expression2);
-          return expression1;
-        }
-        if (this._expression[this._currentIndex] == '&')
-        {
-          if (!this.Match("&&"))
-            throw this.CreateUnexpectedCharacterException();
-          if (compositeExpression1 == null || compositeExpression1.Operator != QueryOperator.And)
-          {
-            CompositeExpression compositeExpression2 = new CompositeExpression();
-            compositeExpression2.Operator = QueryOperator.And;
-            CompositeExpression compositeExpression3 = compositeExpression2;
-            compositeExpression1?.Expressions.Add((QueryExpression) compositeExpression3);
-            compositeExpression1 = compositeExpression3;
-            if (expression1 == null)
-              expression1 = (QueryExpression) compositeExpression1;
-          }
-          compositeExpression1.Expressions.Add((QueryExpression) expression2);
-        }
-        if (this._expression[this._currentIndex] == '|')
-        {
-          if (!this.Match("||"))
-            throw this.CreateUnexpectedCharacterException();
-          if (compositeExpression1 == null || compositeExpression1.Operator != QueryOperator.Or)
-          {
-            CompositeExpression compositeExpression4 = new CompositeExpression();
-            compositeExpression4.Operator = QueryOperator.Or;
-            CompositeExpression compositeExpression5 = compositeExpression4;
-            compositeExpression1?.Expressions.Add((QueryExpression) compositeExpression5);
-            compositeExpression1 = compositeExpression5;
-            if (expression1 == null)
-              expression1 = (QueryExpression) compositeExpression1;
-          }
-          compositeExpression1.Expressions.Add((QueryExpression) expression2);
-        }
-      }
-      throw new JsonException("Path ended with open query.");
-    }
-
-    private bool TryParseValue(out object value)
-    {
-      char c = this._expression[this._currentIndex];
-      if (c == '\'')
-      {
-        value = (object) this.ReadQuotedString();
-        return true;
-      }
-      if (!char.IsDigit(c))
-      {
-        switch (c)
-        {
-          case '-':
-            break;
-          case '/':
-            value = (object) this.ReadRegexString();
-            return true;
-          case 'f':
-            if (this.Match("false"))
-            {
-              value = (object) false;
-              return true;
-            }
-            goto label_18;
-          case 'n':
-            if (this.Match("null"))
-            {
-              value = (object) null;
-              return true;
-            }
-            goto label_18;
-          case 't':
-            if (this.Match("true"))
-            {
-              value = (object) true;
-              return true;
-            }
-            goto label_18;
-          default:
-            goto label_18;
-        }
-      }
-      StringBuilder stringBuilder = new StringBuilder();
-      stringBuilder.Append(c);
-      for (++this._currentIndex; this._currentIndex < this._expression.Length; ++this._currentIndex)
-      {
-        char ch = this._expression[this._currentIndex];
-        switch (ch)
-        {
-          case ' ':
-          case ')':
-            string s = stringBuilder.ToString();
-            if (s.IndexOfAny(JPath.FloatCharacters) != -1)
-            {
-              double result;
-              int num = double.TryParse(s, NumberStyles.Float | NumberStyles.AllowThousands, (IFormatProvider) CultureInfo.InvariantCulture, out result) ? 1 : 0;
-              value = (object) result;
-              return num != 0;
-            }
-            long result1;
-            int num1 = long.TryParse(s, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result1) ? 1 : 0;
-            value = (object) result1;
-            return num1 != 0;
-          default:
-            stringBuilder.Append(ch);
-            continue;
-        }
-      }
-label_18:
-      value = (object) null;
-      return false;
-    }
-
-    private string ReadQuotedString()
-    {
-      StringBuilder stringBuilder = new StringBuilder();
-      ++this._currentIndex;
-      while (this._currentIndex < this._expression.Length)
-      {
-        char ch1 = this._expression[this._currentIndex];
-        if (ch1 == '\\' && this._currentIndex + 1 < this._expression.Length)
-        {
-          ++this._currentIndex;
-          char ch2 = this._expression[this._currentIndex];
-          char ch3;
-          switch (ch2)
-          {
-            case '"':
-            case '\'':
-            case '/':
-            case '\\':
-              ch3 = ch2;
-              break;
-            case 'b':
-              ch3 = '\b';
-              break;
-            case 'f':
-              ch3 = '\f';
-              break;
-            case 'n':
-              ch3 = '\n';
-              break;
-            case 'r':
-              ch3 = '\r';
-              break;
-            case 't':
-              ch3 = '\t';
-              break;
-            default:
-              throw new JsonException("Unknown escape character: \\" + ch2.ToString());
-          }
-          stringBuilder.Append(ch3);
-          ++this._currentIndex;
-        }
-        else
-        {
-          if (ch1 == '\'')
-          {
-            ++this._currentIndex;
-            return stringBuilder.ToString();
-          }
-          ++this._currentIndex;
-          stringBuilder.Append(ch1);
-        }
-      }
-      throw new JsonException("Path ended with an open string.");
-    }
-
-    private string ReadRegexString()
-    {
-      int currentIndex = this._currentIndex;
-      ++this._currentIndex;
-      while (this._currentIndex < this._expression.Length)
-      {
-        char ch = this._expression[this._currentIndex];
-        if (ch == '\\' && this._currentIndex + 1 < this._expression.Length)
-        {
-          this._currentIndex += 2;
-        }
-        else
-        {
-          if (ch == '/')
-          {
-            ++this._currentIndex;
-            while (this._currentIndex < this._expression.Length && char.IsLetter(this._expression[this._currentIndex]))
-              ++this._currentIndex;
-            return this._expression.Substring(currentIndex, this._currentIndex - currentIndex);
-          }
-          ++this._currentIndex;
-        }
-      }
-      throw new JsonException("Path ended with an open regex.");
-    }
-
-    private bool Match(string s)
-    {
-      int currentIndex = this._currentIndex;
-      foreach (char ch in s)
-      {
-        if (currentIndex >= this._expression.Length || (int) this._expression[currentIndex] != (int) ch)
-          return false;
-        ++currentIndex;
-      }
-      this._currentIndex = currentIndex;
-      return true;
-    }
-
-    private QueryOperator ParseOperator()
-    {
-      if (this._currentIndex + 1 >= this._expression.Length)
-        throw new JsonException("Path ended with open query.");
-      if (this.Match("=="))
-        return QueryOperator.Equals;
-      if (this.Match("=~"))
-        return QueryOperator.RegexEquals;
-      if (this.Match("!=") || this.Match("<>"))
-        return QueryOperator.NotEquals;
-      if (this.Match("<="))
-        return QueryOperator.LessThanOrEquals;
-      if (this.Match("<"))
-        return QueryOperator.LessThan;
-      if (this.Match(">="))
-        return QueryOperator.GreaterThanOrEquals;
-      if (this.Match(">"))
-        return QueryOperator.GreaterThan;
-      throw new JsonException("Could not read query operator.");
-    }
-
-    private PathFilter ParseQuotedField(char indexerCloseChar, bool scan)
-    {
-      List<string> stringList = (List<string>) null;
-      while (this._currentIndex < this._expression.Length)
-      {
-        string member = this.ReadQuotedString();
-        this.EatWhitespace();
-        this.EnsureLength("Path ended with open indexer.");
-        if ((int) this._expression[this._currentIndex] == (int) indexerCloseChar)
-        {
-          if (stringList == null)
-            return JPath.CreatePathFilter(member, scan);
-          stringList.Add(member);
-          if (!scan)
-            return (PathFilter) new FieldMultipleFilter()
-            {
-              Names = stringList
-            };
-          return (PathFilter) new ScanMultipleFilter()
-          {
-            Names = stringList
-          };
-        }
-        if (this._expression[this._currentIndex] != ',')
-          throw new JsonException("Unexpected character while parsing path indexer: " + this._expression[this._currentIndex].ToString());
-        ++this._currentIndex;
-        this.EatWhitespace();
-        if (stringList == null)
-          stringList = new List<string>();
-        stringList.Add(member);
-      }
-      throw new JsonException("Path ended with open indexer.");
-    }
-
-    private void EnsureLength(string message)
-    {
-      if (this._currentIndex >= this._expression.Length)
-        throw new JsonException(message);
-    }
-
-    internal IEnumerable<JToken> Evaluate(JToken root, JToken t, bool errorWhenNoMatch)
-    {
-      return JPath.Evaluate(this.Filters, root, t, errorWhenNoMatch);
-    }
-
-    internal static IEnumerable<JToken> Evaluate(
-      List<PathFilter> filters,
-      JToken root,
-      JToken t,
-      bool errorWhenNoMatch)
-    {
-      IEnumerable<JToken> current = (IEnumerable<JToken>) new JToken[1]
-      {
-        t
-      };
-      foreach (PathFilter filter in filters)
-        current = filter.ExecuteFilter(root, current, errorWhenNoMatch);
-      return current;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/PathFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/PathFilter.cs
deleted file mode 100644
index 6796c07..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/PathFilter.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal abstract class PathFilter
-  {
-    public abstract IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch);
-
-    protected static JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index)
-    {
-      if (t is JArray jarray)
-      {
-        if (jarray.Count > index)
-          return jarray[index];
-        if (errorWhenNoMatch)
-          throw new JsonException("Index {0} outside the bounds of JArray.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) index));
-        return (JToken) null;
-      }
-      if (t is JConstructor jconstructor)
-      {
-        if (jconstructor.Count > index)
-          return jconstructor[(object) index];
-        if (errorWhenNoMatch)
-          throw new JsonException("Index {0} outside the bounds of JConstructor.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) index));
-        return (JToken) null;
-      }
-      if (errorWhenNoMatch)
-        throw new JsonException("Index {0} not valid on {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) index, (object) t.GetType().Name));
-      return (JToken) null;
-    }
-
-    protected static JToken GetNextScanValue(JToken originalParent, JToken container, JToken value)
-    {
-      if (container != null && container.HasValues)
-      {
-        value = container.First;
-      }
-      else
-      {
-        while (value != null && value != originalParent && value == value.Parent.Last)
-          value = (JToken) value.Parent;
-        if (value == null || value == originalParent)
-          return (JToken) null;
-        value = value.Next;
-      }
-      return value;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryExpression.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryExpression.cs
deleted file mode 100644
index b0c877a..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryExpression.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal abstract class QueryExpression
-  {
-    public QueryOperator Operator { get; set; }
-
-    public abstract bool IsMatch(JToken root, JToken t);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryFilter.cs
deleted file mode 100644
index e0cb25d..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryFilter.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class QueryFilter : PathFilter
-  {
-    public QueryExpression Expression { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      foreach (IEnumerable<JToken> jtokens in current)
-      {
-        foreach (JToken t in jtokens)
-        {
-          if (this.Expression.IsMatch(root, t))
-            yield return t;
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryOperator.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryOperator.cs
deleted file mode 100644
index 4e9d661..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryOperator.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal enum QueryOperator
-  {
-    None,
-    Equals,
-    NotEquals,
-    Exists,
-    LessThan,
-    LessThanOrEquals,
-    GreaterThan,
-    GreaterThanOrEquals,
-    And,
-    Or,
-    RegexEquals,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryScanFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryScanFilter.cs
deleted file mode 100644
index 10fc047..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/QueryScanFilter.cs
+++ /dev/null
@@ -1,30 +0,0 @@
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class QueryScanFilter : PathFilter
-  {
-    public QueryExpression Expression { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      foreach (JToken t1 in current)
-      {
-        if (t1 is JContainer jcontainer)
-        {
-          foreach (JToken t2 in jcontainer.DescendantsAndSelf())
-          {
-            if (this.Expression.IsMatch(root, t2))
-              yield return t2;
-          }
-        }
-        else if (this.Expression.IsMatch(root, t1))
-          yield return t1;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/RootFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/RootFilter.cs
deleted file mode 100644
index 388cdb1..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/RootFilter.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class RootFilter : PathFilter
-  {
-    public static readonly RootFilter Instance = new RootFilter();
-
-    private RootFilter()
-    {
-    }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      return (IEnumerable<JToken>) new JToken[1]{ root };
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ScanFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ScanFilter.cs
deleted file mode 100644
index 3eaae06..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ScanFilter.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class ScanFilter : PathFilter
-  {
-    public string Name { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      foreach (JToken c in current)
-      {
-        if (this.Name == null)
-          yield return c;
-        JToken value = c;
-        while (true)
-        {
-          do
-          {
-            value = PathFilter.GetNextScanValue(c, (JToken) (value as JContainer), value);
-            if (value != null)
-            {
-              if (value is JProperty jproperty)
-              {
-                if (jproperty.Name == this.Name)
-                  yield return jproperty.Value;
-              }
-            }
-            else
-              goto label_10;
-          }
-          while (this.Name != null);
-          yield return value;
-        }
-label_10:
-        value = (JToken) null;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ScanMultipleFilter.cs b/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ScanMultipleFilter.cs
deleted file mode 100644
index af400aa..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/JsonPath/ScanMultipleFilter.cs
+++ /dev/null
@@ -1,40 +0,0 @@
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq.JsonPath
-{
-  internal class ScanMultipleFilter : PathFilter
-  {
-    public List<string> Names { get; set; }
-
-    public override IEnumerable<JToken> ExecuteFilter(
-      JToken root,
-      IEnumerable<JToken> current,
-      bool errorWhenNoMatch)
-    {
-      foreach (JToken c in current)
-      {
-        JToken value = c;
-        while (true)
-        {
-          value = PathFilter.GetNextScanValue(c, (JToken) (value as JContainer), value);
-          if (value != null)
-          {
-            if (value is JProperty property)
-            {
-              foreach (string name in this.Names)
-              {
-                if (property.Name == name)
-                  yield return property.Value;
-              }
-            }
-            property = (JProperty) null;
-          }
-          else
-            break;
-        }
-        value = (JToken) null;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/LineInfoHandling.cs b/MSHALTester/Newtonsoft/Json/Linq/LineInfoHandling.cs
deleted file mode 100644
index 124c5b0..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/LineInfoHandling.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public enum LineInfoHandling
-  {
-    Ignore,
-    Load,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/MergeArrayHandling.cs b/MSHALTester/Newtonsoft/Json/Linq/MergeArrayHandling.cs
deleted file mode 100644
index 35bd649..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/MergeArrayHandling.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  public enum MergeArrayHandling
-  {
-    Concat,
-    Union,
-    Replace,
-    Merge,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Linq/MergeNullValueHandling.cs b/MSHALTester/Newtonsoft/Json/Linq/MergeNullValueHandling.cs
deleted file mode 100644
index ea21ad2..0000000
--- a/MSHALTester/Newtonsoft/Json/Linq/MergeNullValueHandling.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Linq
-{
-  [Flags]
-  public enum MergeNullValueHandling
-  {
-    Ignore = 0,
-    Merge = 1,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/MemberSerialization.cs b/MSHALTester/Newtonsoft/Json/MemberSerialization.cs
deleted file mode 100644
index 3d1f104..0000000
--- a/MSHALTester/Newtonsoft/Json/MemberSerialization.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum MemberSerialization
-  {
-    OptOut,
-    OptIn,
-    Fields,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/MetadataPropertyHandling.cs b/MSHALTester/Newtonsoft/Json/MetadataPropertyHandling.cs
deleted file mode 100644
index a0d52ba..0000000
--- a/MSHALTester/Newtonsoft/Json/MetadataPropertyHandling.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum MetadataPropertyHandling
-  {
-    Default,
-    ReadAhead,
-    Ignore,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/MissingMemberHandling.cs b/MSHALTester/Newtonsoft/Json/MissingMemberHandling.cs
deleted file mode 100644
index 694f934..0000000
--- a/MSHALTester/Newtonsoft/Json/MissingMemberHandling.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum MissingMemberHandling
-  {
-    Ignore,
-    Error,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/NullValueHandling.cs b/MSHALTester/Newtonsoft/Json/NullValueHandling.cs
deleted file mode 100644
index f8d9045..0000000
--- a/MSHALTester/Newtonsoft/Json/NullValueHandling.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum NullValueHandling
-  {
-    Include,
-    Ignore,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/ObjectCreationHandling.cs b/MSHALTester/Newtonsoft/Json/ObjectCreationHandling.cs
deleted file mode 100644
index 6325b96..0000000
--- a/MSHALTester/Newtonsoft/Json/ObjectCreationHandling.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum ObjectCreationHandling
-  {
-    Auto,
-    Reuse,
-    Replace,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/PreserveReferencesHandling.cs b/MSHALTester/Newtonsoft/Json/PreserveReferencesHandling.cs
deleted file mode 100644
index aecb25e..0000000
--- a/MSHALTester/Newtonsoft/Json/PreserveReferencesHandling.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [Flags]
-  public enum PreserveReferencesHandling
-  {
-    None = 0,
-    Objects = 1,
-    Arrays = 2,
-    All = Arrays | Objects, // 0x00000003
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/ReadType.cs b/MSHALTester/Newtonsoft/Json/ReadType.cs
deleted file mode 100644
index e65c55a..0000000
--- a/MSHALTester/Newtonsoft/Json/ReadType.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  internal enum ReadType
-  {
-    Read,
-    ReadAsInt32,
-    ReadAsInt64,
-    ReadAsBytes,
-    ReadAsString,
-    ReadAsDecimal,
-    ReadAsDateTime,
-    ReadAsDateTimeOffset,
-    ReadAsDouble,
-    ReadAsBoolean,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/ReferenceLoopHandling.cs b/MSHALTester/Newtonsoft/Json/ReferenceLoopHandling.cs
deleted file mode 100644
index 14f6ee8..0000000
--- a/MSHALTester/Newtonsoft/Json/ReferenceLoopHandling.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum ReferenceLoopHandling
-  {
-    Error,
-    Ignore,
-    Serialize,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Required.cs b/MSHALTester/Newtonsoft/Json/Required.cs
deleted file mode 100644
index 191042b..0000000
--- a/MSHALTester/Newtonsoft/Json/Required.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum Required
-  {
-    Default,
-    AllowNull,
-    Always,
-    DisallowNull,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/Extensions.cs b/MSHALTester/Newtonsoft/Json/Schema/Extensions.cs
deleted file mode 100644
index c4e5993..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/Extensions.cs
+++ /dev/null
@@ -1,57 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public static class Extensions
-  {
-    [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-    public static bool IsValid(this JToken source, JsonSchema schema)
-    {
-      bool valid = true;
-      source.Validate(schema, (ValidationEventHandler) ((sender, args) => valid = false));
-      return valid;
-    }
-
-    [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-    public static bool IsValid(
-      this JToken source,
-      JsonSchema schema,
-      out IList<string> errorMessages)
-    {
-      IList<string> errors = (IList<string>) new List<string>();
-      source.Validate(schema, (ValidationEventHandler) ((sender, args) => errors.Add(args.Message)));
-      errorMessages = errors;
-      return errorMessages.Count == 0;
-    }
-
-    [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-    public static void Validate(this JToken source, JsonSchema schema)
-    {
-      source.Validate(schema, (ValidationEventHandler) null);
-    }
-
-    [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-    public static void Validate(
-      this JToken source,
-      JsonSchema schema,
-      ValidationEventHandler validationEventHandler)
-    {
-      ValidationUtils.ArgumentNotNull((object) source, nameof (source));
-      ValidationUtils.ArgumentNotNull((object) schema, nameof (schema));
-      using (JsonValidatingReader validatingReader = new JsonValidatingReader(source.CreateReader()))
-      {
-        validatingReader.Schema = schema;
-        if (validationEventHandler != null)
-          validatingReader.ValidationEventHandler += validationEventHandler;
-        do
-          ;
-        while (validatingReader.Read());
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchema.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchema.cs
deleted file mode 100644
index e75bbfc..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchema.cs
+++ /dev/null
@@ -1,135 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public class JsonSchema
-  {
-    private readonly string _internalId = Guid.NewGuid().ToString("N");
-
-    public string Id { get; set; }
-
-    public string Title { get; set; }
-
-    public bool? Required { get; set; }
-
-    public bool? ReadOnly { get; set; }
-
-    public bool? Hidden { get; set; }
-
-    public bool? Transient { get; set; }
-
-    public string Description { get; set; }
-
-    public JsonSchemaType? Type { get; set; }
-
-    public string Pattern { get; set; }
-
-    public int? MinimumLength { get; set; }
-
-    public int? MaximumLength { get; set; }
-
-    public double? DivisibleBy { get; set; }
-
-    public double? Minimum { get; set; }
-
-    public double? Maximum { get; set; }
-
-    public bool? ExclusiveMinimum { get; set; }
-
-    public bool? ExclusiveMaximum { get; set; }
-
-    public int? MinimumItems { get; set; }
-
-    public int? MaximumItems { get; set; }
-
-    public IList<JsonSchema> Items { get; set; }
-
-    public bool PositionalItemsValidation { get; set; }
-
-    public JsonSchema AdditionalItems { get; set; }
-
-    public bool AllowAdditionalItems { get; set; }
-
-    public bool UniqueItems { get; set; }
-
-    public IDictionary<string, JsonSchema> Properties { get; set; }
-
-    public JsonSchema AdditionalProperties { get; set; }
-
-    public IDictionary<string, JsonSchema> PatternProperties { get; set; }
-
-    public bool AllowAdditionalProperties { get; set; }
-
-    public string Requires { get; set; }
-
-    public IList<JToken> Enum { get; set; }
-
-    public JsonSchemaType? Disallow { get; set; }
-
-    public JToken Default { get; set; }
-
-    public IList<JsonSchema> Extends { get; set; }
-
-    public string Format { get; set; }
-
-    internal string Location { get; set; }
-
-    internal string InternalId => this._internalId;
-
-    internal string DeferredReference { get; set; }
-
-    internal bool ReferencesResolved { get; set; }
-
-    public JsonSchema()
-    {
-      this.AllowAdditionalProperties = true;
-      this.AllowAdditionalItems = true;
-    }
-
-    public static JsonSchema Read(JsonReader reader)
-    {
-      return JsonSchema.Read(reader, new JsonSchemaResolver());
-    }
-
-    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      ValidationUtils.ArgumentNotNull((object) resolver, nameof (resolver));
-      return new JsonSchemaBuilder(resolver).Read(reader);
-    }
-
-    public static JsonSchema Parse(string json) => JsonSchema.Parse(json, new JsonSchemaResolver());
-
-    public static JsonSchema Parse(string json, JsonSchemaResolver resolver)
-    {
-      ValidationUtils.ArgumentNotNull((object) json, nameof (json));
-      using (JsonReader reader = (JsonReader) new JsonTextReader((TextReader) new StringReader(json)))
-        return JsonSchema.Read(reader, resolver);
-    }
-
-    public void WriteTo(JsonWriter writer) => this.WriteTo(writer, new JsonSchemaResolver());
-
-    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver)
-    {
-      ValidationUtils.ArgumentNotNull((object) writer, nameof (writer));
-      ValidationUtils.ArgumentNotNull((object) resolver, nameof (resolver));
-      new JsonSchemaWriter(writer, resolver).WriteSchema(this);
-    }
-
-    public override string ToString()
-    {
-      StringWriter stringWriter = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-      JsonTextWriter writer = new JsonTextWriter((TextWriter) stringWriter);
-      writer.Formatting = Formatting.Indented;
-      this.WriteTo((JsonWriter) writer);
-      return stringWriter.ToString();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaBuilder.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaBuilder.cs
deleted file mode 100644
index 4437683..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaBuilder.cs
+++ /dev/null
@@ -1,364 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  internal class JsonSchemaBuilder
-  {
-    private readonly IList<JsonSchema> _stack;
-    private readonly JsonSchemaResolver _resolver;
-    private readonly IDictionary<string, JsonSchema> _documentSchemas;
-    private JsonSchema _currentSchema;
-    private JObject _rootSchema;
-
-    public JsonSchemaBuilder(JsonSchemaResolver resolver)
-    {
-      this._stack = (IList<JsonSchema>) new List<JsonSchema>();
-      this._documentSchemas = (IDictionary<string, JsonSchema>) new Dictionary<string, JsonSchema>();
-      this._resolver = resolver;
-    }
-
-    private void Push(JsonSchema value)
-    {
-      this._currentSchema = value;
-      this._stack.Add(value);
-      this._resolver.LoadedSchemas.Add(value);
-      this._documentSchemas.Add(value.Location, value);
-    }
-
-    private JsonSchema Pop()
-    {
-      JsonSchema currentSchema = this._currentSchema;
-      this._stack.RemoveAt(this._stack.Count - 1);
-      this._currentSchema = this._stack.LastOrDefault<JsonSchema>();
-      return currentSchema;
-    }
-
-    private JsonSchema CurrentSchema => this._currentSchema;
-
-    internal JsonSchema Read(JsonReader reader)
-    {
-      JToken token = JToken.ReadFrom(reader);
-      this._rootSchema = token as JObject;
-      JsonSchema schema = this.BuildSchema(token);
-      this.ResolveReferences(schema);
-      return schema;
-    }
-
-    private string UnescapeReference(string reference)
-    {
-      return Uri.UnescapeDataString(reference).Replace("~1", "/").Replace("~0", "~");
-    }
-
-    private JsonSchema ResolveReferences(JsonSchema schema)
-    {
-      if (schema.DeferredReference != null)
-      {
-        string reference1 = schema.DeferredReference;
-        bool flag = reference1.StartsWith("#", StringComparison.Ordinal);
-        if (flag)
-          reference1 = this.UnescapeReference(reference1);
-        JsonSchema jsonSchema = this._resolver.GetSchema(reference1);
-        if (jsonSchema == null)
-        {
-          if (flag)
-          {
-            string[] strArray = schema.DeferredReference.TrimStart('#').Split(new char[1]
-            {
-              '/'
-            }, StringSplitOptions.RemoveEmptyEntries);
-            JToken rootSchema = (JToken) this._rootSchema;
-            foreach (string reference2 in strArray)
-            {
-              string str = this.UnescapeReference(reference2);
-              if (rootSchema.Type == JTokenType.Object)
-                rootSchema = rootSchema[(object) str];
-              else if (rootSchema.Type == JTokenType.Array || rootSchema.Type == JTokenType.Constructor)
-              {
-                int result;
-                rootSchema = !int.TryParse(str, out result) || result < 0 || result >= rootSchema.Count<JToken>() ? (JToken) null : rootSchema[(object) result];
-              }
-              if (rootSchema == null)
-                break;
-            }
-            if (rootSchema != null)
-              jsonSchema = this.BuildSchema(rootSchema);
-          }
-          if (jsonSchema == null)
-            throw new JsonException("Could not resolve schema reference '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) schema.DeferredReference));
-        }
-        schema = jsonSchema;
-      }
-      if (schema.ReferencesResolved)
-        return schema;
-      schema.ReferencesResolved = true;
-      if (schema.Extends != null)
-      {
-        for (int index = 0; index < schema.Extends.Count; ++index)
-          schema.Extends[index] = this.ResolveReferences(schema.Extends[index]);
-      }
-      if (schema.Items != null)
-      {
-        for (int index = 0; index < schema.Items.Count; ++index)
-          schema.Items[index] = this.ResolveReferences(schema.Items[index]);
-      }
-      if (schema.AdditionalItems != null)
-        schema.AdditionalItems = this.ResolveReferences(schema.AdditionalItems);
-      if (schema.PatternProperties != null)
-      {
-        foreach (KeyValuePair<string, JsonSchema> keyValuePair in schema.PatternProperties.ToList<KeyValuePair<string, JsonSchema>>())
-          schema.PatternProperties[keyValuePair.Key] = this.ResolveReferences(keyValuePair.Value);
-      }
-      if (schema.Properties != null)
-      {
-        foreach (KeyValuePair<string, JsonSchema> keyValuePair in schema.Properties.ToList<KeyValuePair<string, JsonSchema>>())
-          schema.Properties[keyValuePair.Key] = this.ResolveReferences(keyValuePair.Value);
-      }
-      if (schema.AdditionalProperties != null)
-        schema.AdditionalProperties = this.ResolveReferences(schema.AdditionalProperties);
-      return schema;
-    }
-
-    private JsonSchema BuildSchema(JToken token)
-    {
-      if (!(token is JObject schemaObject))
-        throw JsonException.Create((IJsonLineInfo) token, token.Path, "Expected object while parsing schema object, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token.Type));
-      JToken jtoken;
-      if (schemaObject.TryGetValue("$ref", out jtoken))
-        return new JsonSchema()
-        {
-          DeferredReference = (string) jtoken
-        };
-      string str = token.Path.Replace(".", "/").Replace("[", "/").Replace("]", string.Empty);
-      if (!string.IsNullOrEmpty(str))
-        str = "/" + str;
-      string key = "#" + str;
-      JsonSchema jsonSchema;
-      if (this._documentSchemas.TryGetValue(key, out jsonSchema))
-        return jsonSchema;
-      this.Push(new JsonSchema() { Location = key });
-      this.ProcessSchemaProperties(schemaObject);
-      return this.Pop();
-    }
-
-    private void ProcessSchemaProperties(JObject schemaObject)
-    {
-      foreach (KeyValuePair<string, JToken> keyValuePair in schemaObject)
-      {
-        switch (keyValuePair.Key)
-        {
-          case "additionalItems":
-            this.ProcessAdditionalItems(keyValuePair.Value);
-            continue;
-          case "additionalProperties":
-            this.ProcessAdditionalProperties(keyValuePair.Value);
-            continue;
-          case "default":
-            this.CurrentSchema.Default = keyValuePair.Value.DeepClone();
-            continue;
-          case "description":
-            this.CurrentSchema.Description = (string) keyValuePair.Value;
-            continue;
-          case "disallow":
-            this.CurrentSchema.Disallow = this.ProcessType(keyValuePair.Value);
-            continue;
-          case "divisibleBy":
-            this.CurrentSchema.DivisibleBy = new double?((double) keyValuePair.Value);
-            continue;
-          case "enum":
-            this.ProcessEnum(keyValuePair.Value);
-            continue;
-          case "exclusiveMaximum":
-            this.CurrentSchema.ExclusiveMaximum = new bool?((bool) keyValuePair.Value);
-            continue;
-          case "exclusiveMinimum":
-            this.CurrentSchema.ExclusiveMinimum = new bool?((bool) keyValuePair.Value);
-            continue;
-          case "extends":
-            this.ProcessExtends(keyValuePair.Value);
-            continue;
-          case "format":
-            this.CurrentSchema.Format = (string) keyValuePair.Value;
-            continue;
-          case "hidden":
-            this.CurrentSchema.Hidden = new bool?((bool) keyValuePair.Value);
-            continue;
-          case "id":
-            this.CurrentSchema.Id = (string) keyValuePair.Value;
-            continue;
-          case "items":
-            this.ProcessItems(keyValuePair.Value);
-            continue;
-          case "maxItems":
-            this.CurrentSchema.MaximumItems = new int?((int) keyValuePair.Value);
-            continue;
-          case "maxLength":
-            this.CurrentSchema.MaximumLength = new int?((int) keyValuePair.Value);
-            continue;
-          case "maximum":
-            this.CurrentSchema.Maximum = new double?((double) keyValuePair.Value);
-            continue;
-          case "minItems":
-            this.CurrentSchema.MinimumItems = new int?((int) keyValuePair.Value);
-            continue;
-          case "minLength":
-            this.CurrentSchema.MinimumLength = new int?((int) keyValuePair.Value);
-            continue;
-          case "minimum":
-            this.CurrentSchema.Minimum = new double?((double) keyValuePair.Value);
-            continue;
-          case "pattern":
-            this.CurrentSchema.Pattern = (string) keyValuePair.Value;
-            continue;
-          case "patternProperties":
-            this.CurrentSchema.PatternProperties = this.ProcessProperties(keyValuePair.Value);
-            continue;
-          case "properties":
-            this.CurrentSchema.Properties = this.ProcessProperties(keyValuePair.Value);
-            continue;
-          case "readonly":
-            this.CurrentSchema.ReadOnly = new bool?((bool) keyValuePair.Value);
-            continue;
-          case "required":
-            this.CurrentSchema.Required = new bool?((bool) keyValuePair.Value);
-            continue;
-          case "requires":
-            this.CurrentSchema.Requires = (string) keyValuePair.Value;
-            continue;
-          case "title":
-            this.CurrentSchema.Title = (string) keyValuePair.Value;
-            continue;
-          case "type":
-            this.CurrentSchema.Type = this.ProcessType(keyValuePair.Value);
-            continue;
-          case "uniqueItems":
-            this.CurrentSchema.UniqueItems = (bool) keyValuePair.Value;
-            continue;
-          default:
-            continue;
-        }
-      }
-    }
-
-    private void ProcessExtends(JToken token)
-    {
-      IList<JsonSchema> jsonSchemaList = (IList<JsonSchema>) new List<JsonSchema>();
-      if (token.Type == JTokenType.Array)
-      {
-        foreach (JToken token1 in (IEnumerable<JToken>) token)
-          jsonSchemaList.Add(this.BuildSchema(token1));
-      }
-      else
-      {
-        JsonSchema jsonSchema = this.BuildSchema(token);
-        if (jsonSchema != null)
-          jsonSchemaList.Add(jsonSchema);
-      }
-      if (jsonSchemaList.Count <= 0)
-        return;
-      this.CurrentSchema.Extends = jsonSchemaList;
-    }
-
-    private void ProcessEnum(JToken token)
-    {
-      if (token.Type != JTokenType.Array)
-        throw JsonException.Create((IJsonLineInfo) token, token.Path, "Expected Array token while parsing enum values, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token.Type));
-      this.CurrentSchema.Enum = (IList<JToken>) new List<JToken>();
-      foreach (JToken jtoken in (IEnumerable<JToken>) token)
-        this.CurrentSchema.Enum.Add(jtoken.DeepClone());
-    }
-
-    private void ProcessAdditionalProperties(JToken token)
-    {
-      if (token.Type == JTokenType.Boolean)
-        this.CurrentSchema.AllowAdditionalProperties = (bool) token;
-      else
-        this.CurrentSchema.AdditionalProperties = this.BuildSchema(token);
-    }
-
-    private void ProcessAdditionalItems(JToken token)
-    {
-      if (token.Type == JTokenType.Boolean)
-        this.CurrentSchema.AllowAdditionalItems = (bool) token;
-      else
-        this.CurrentSchema.AdditionalItems = this.BuildSchema(token);
-    }
-
-    private IDictionary<string, JsonSchema> ProcessProperties(JToken token)
-    {
-      IDictionary<string, JsonSchema> dictionary = (IDictionary<string, JsonSchema>) new Dictionary<string, JsonSchema>();
-      if (token.Type != JTokenType.Object)
-        throw JsonException.Create((IJsonLineInfo) token, token.Path, "Expected Object token while parsing schema properties, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token.Type));
-      foreach (JProperty jproperty in (IEnumerable<JToken>) token)
-      {
-        if (dictionary.ContainsKey(jproperty.Name))
-          throw new JsonException("Property {0} has already been defined in schema.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) jproperty.Name));
-        dictionary.Add(jproperty.Name, this.BuildSchema(jproperty.Value));
-      }
-      return dictionary;
-    }
-
-    private void ProcessItems(JToken token)
-    {
-      this.CurrentSchema.Items = (IList<JsonSchema>) new List<JsonSchema>();
-      switch (token.Type)
-      {
-        case JTokenType.Object:
-          this.CurrentSchema.Items.Add(this.BuildSchema(token));
-          this.CurrentSchema.PositionalItemsValidation = false;
-          break;
-        case JTokenType.Array:
-          this.CurrentSchema.PositionalItemsValidation = true;
-          using (IEnumerator<JToken> enumerator = ((IEnumerable<JToken>) token).GetEnumerator())
-          {
-            while (enumerator.MoveNext())
-              this.CurrentSchema.Items.Add(this.BuildSchema(enumerator.Current));
-            break;
-          }
-        default:
-          throw JsonException.Create((IJsonLineInfo) token, token.Path, "Expected array or JSON schema object, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token.Type));
-      }
-    }
-
-    private JsonSchemaType? ProcessType(JToken token)
-    {
-      switch (token.Type)
-      {
-        case JTokenType.Array:
-          JsonSchemaType? nullable1 = new JsonSchemaType?(JsonSchemaType.None);
-          foreach (JToken jtoken in (IEnumerable<JToken>) token)
-          {
-            if (jtoken.Type != JTokenType.String)
-              throw JsonException.Create((IJsonLineInfo) jtoken, jtoken.Path, "Expected JSON schema type string token, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token.Type));
-            JsonSchemaType? nullable2 = nullable1;
-            JsonSchemaType jsonSchemaType = JsonSchemaBuilder.MapType((string) jtoken);
-            nullable1 = nullable2.HasValue ? new JsonSchemaType?(nullable2.GetValueOrDefault() | jsonSchemaType) : new JsonSchemaType?();
-          }
-          return nullable1;
-        case JTokenType.String:
-          return new JsonSchemaType?(JsonSchemaBuilder.MapType((string) token));
-        default:
-          throw JsonException.Create((IJsonLineInfo) token, token.Path, "Expected array or JSON schema type string token, got {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) token.Type));
-      }
-    }
-
-    internal static JsonSchemaType MapType(string type)
-    {
-      JsonSchemaType jsonSchemaType;
-      if (!JsonSchemaConstants.JsonSchemaTypeMapping.TryGetValue(type, out jsonSchemaType))
-        throw new JsonException("Invalid JSON schema type: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type));
-      return jsonSchemaType;
-    }
-
-    internal static string MapType(JsonSchemaType type)
-    {
-      return JsonSchemaConstants.JsonSchemaTypeMapping.Single<KeyValuePair<string, JsonSchemaType>>((Func<KeyValuePair<string, JsonSchemaType>, bool>) (kv => kv.Value == type)).Key;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaConstants.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaConstants.cs
deleted file mode 100644
index bb70444..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaConstants.cs
+++ /dev/null
@@ -1,78 +0,0 @@
-using System;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  internal static class JsonSchemaConstants
-  {
-    public const string TypePropertyName = "type";
-    public const string PropertiesPropertyName = "properties";
-    public const string ItemsPropertyName = "items";
-    public const string AdditionalItemsPropertyName = "additionalItems";
-    public const string RequiredPropertyName = "required";
-    public const string PatternPropertiesPropertyName = "patternProperties";
-    public const string AdditionalPropertiesPropertyName = "additionalProperties";
-    public const string RequiresPropertyName = "requires";
-    public const string MinimumPropertyName = "minimum";
-    public const string MaximumPropertyName = "maximum";
-    public const string ExclusiveMinimumPropertyName = "exclusiveMinimum";
-    public const string ExclusiveMaximumPropertyName = "exclusiveMaximum";
-    public const string MinimumItemsPropertyName = "minItems";
-    public const string MaximumItemsPropertyName = "maxItems";
-    public const string PatternPropertyName = "pattern";
-    public const string MaximumLengthPropertyName = "maxLength";
-    public const string MinimumLengthPropertyName = "minLength";
-    public const string EnumPropertyName = "enum";
-    public const string ReadOnlyPropertyName = "readonly";
-    public const string TitlePropertyName = "title";
-    public const string DescriptionPropertyName = "description";
-    public const string FormatPropertyName = "format";
-    public const string DefaultPropertyName = "default";
-    public const string TransientPropertyName = "transient";
-    public const string DivisibleByPropertyName = "divisibleBy";
-    public const string HiddenPropertyName = "hidden";
-    public const string DisallowPropertyName = "disallow";
-    public const string ExtendsPropertyName = "extends";
-    public const string IdPropertyName = "id";
-    public const string UniqueItemsPropertyName = "uniqueItems";
-    public const string OptionValuePropertyName = "value";
-    public const string OptionLabelPropertyName = "label";
-    public static readonly IDictionary<string, JsonSchemaType> JsonSchemaTypeMapping = (IDictionary<string, JsonSchemaType>) new Dictionary<string, JsonSchemaType>()
-    {
-      {
-        "string",
-        JsonSchemaType.String
-      },
-      {
-        "object",
-        JsonSchemaType.Object
-      },
-      {
-        "integer",
-        JsonSchemaType.Integer
-      },
-      {
-        "number",
-        JsonSchemaType.Float
-      },
-      {
-        "null",
-        JsonSchemaType.Null
-      },
-      {
-        "boolean",
-        JsonSchemaType.Boolean
-      },
-      {
-        "array",
-        JsonSchemaType.Array
-      },
-      {
-        "any",
-        JsonSchemaType.Any
-      }
-    };
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaException.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaException.cs
deleted file mode 100644
index 50587a3..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaException.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  [Serializable]
-  public class JsonSchemaException : JsonException
-  {
-    public int LineNumber { get; }
-
-    public int LinePosition { get; }
-
-    public string Path { get; }
-
-    public JsonSchemaException()
-    {
-    }
-
-    public JsonSchemaException(string message)
-      : base(message)
-    {
-    }
-
-    public JsonSchemaException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-
-    public JsonSchemaException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    internal JsonSchemaException(
-      string message,
-      Exception innerException,
-      string path,
-      int lineNumber,
-      int linePosition)
-      : base(message, innerException)
-    {
-      this.Path = path;
-      this.LineNumber = lineNumber;
-      this.LinePosition = linePosition;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaGenerator.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaGenerator.cs
deleted file mode 100644
index d9e13b1..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaGenerator.cs
+++ /dev/null
@@ -1,336 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Serialization;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.ComponentModel;
-using System.Globalization;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public class JsonSchemaGenerator
-  {
-    private IContractResolver _contractResolver;
-    private JsonSchemaResolver _resolver;
-    private readonly IList<JsonSchemaGenerator.TypeSchema> _stack = (IList<JsonSchemaGenerator.TypeSchema>) new List<JsonSchemaGenerator.TypeSchema>();
-    private JsonSchema _currentSchema;
-
-    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; set; }
-
-    public IContractResolver ContractResolver
-    {
-      get
-      {
-        return this._contractResolver == null ? DefaultContractResolver.Instance : this._contractResolver;
-      }
-      set => this._contractResolver = value;
-    }
-
-    private JsonSchema CurrentSchema => this._currentSchema;
-
-    private void Push(JsonSchemaGenerator.TypeSchema typeSchema)
-    {
-      this._currentSchema = typeSchema.Schema;
-      this._stack.Add(typeSchema);
-      this._resolver.LoadedSchemas.Add(typeSchema.Schema);
-    }
-
-    private JsonSchemaGenerator.TypeSchema Pop()
-    {
-      JsonSchemaGenerator.TypeSchema typeSchema1 = this._stack[this._stack.Count - 1];
-      this._stack.RemoveAt(this._stack.Count - 1);
-      JsonSchemaGenerator.TypeSchema typeSchema2 = this._stack.LastOrDefault<JsonSchemaGenerator.TypeSchema>();
-      if (typeSchema2 != null)
-      {
-        this._currentSchema = typeSchema2.Schema;
-        return typeSchema1;
-      }
-      this._currentSchema = (JsonSchema) null;
-      return typeSchema1;
-    }
-
-    public JsonSchema Generate(Type type) => this.Generate(type, new JsonSchemaResolver(), false);
-
-    public JsonSchema Generate(Type type, JsonSchemaResolver resolver)
-    {
-      return this.Generate(type, resolver, false);
-    }
-
-    public JsonSchema Generate(Type type, bool rootSchemaNullable)
-    {
-      return this.Generate(type, new JsonSchemaResolver(), rootSchemaNullable);
-    }
-
-    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      ValidationUtils.ArgumentNotNull((object) resolver, nameof (resolver));
-      this._resolver = resolver;
-      return this.GenerateInternal(type, !rootSchemaNullable ? Required.Always : Required.Default, false);
-    }
-
-    private string GetTitle(Type type)
-    {
-      JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>((object) type);
-      return !string.IsNullOrEmpty(cachedAttribute?.Title) ? cachedAttribute.Title : (string) null;
-    }
-
-    private string GetDescription(Type type)
-    {
-      JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>((object) type);
-      if (!string.IsNullOrEmpty(cachedAttribute?.Description))
-        return cachedAttribute.Description;
-      return ReflectionUtils.GetAttribute<DescriptionAttribute>((object) type)?.Description;
-    }
-
-    private string GetTypeId(Type type, bool explicitOnly)
-    {
-      JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>((object) type);
-      if (!string.IsNullOrEmpty(cachedAttribute?.Id))
-        return cachedAttribute.Id;
-      if (explicitOnly)
-        return (string) null;
-      switch (this.UndefinedSchemaIdHandling)
-      {
-        case UndefinedSchemaIdHandling.UseTypeName:
-          return type.FullName;
-        case UndefinedSchemaIdHandling.UseAssemblyQualifiedName:
-          return type.AssemblyQualifiedName;
-        default:
-          return (string) null;
-      }
-    }
-
-    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      string typeId1 = this.GetTypeId(type, false);
-      string typeId2 = this.GetTypeId(type, true);
-      if (!string.IsNullOrEmpty(typeId1))
-      {
-        JsonSchema schema = this._resolver.GetSchema(typeId1);
-        if (schema != null)
-        {
-          if (valueRequired != Required.Always && !JsonSchemaGenerator.HasFlag(schema.Type, JsonSchemaType.Null))
-          {
-            JsonSchema jsonSchema = schema;
-            JsonSchemaType? type1 = jsonSchema.Type;
-            jsonSchema.Type = type1.HasValue ? new JsonSchemaType?(type1.GetValueOrDefault() | JsonSchemaType.Null) : new JsonSchemaType?();
-          }
-          if (required)
-          {
-            bool? required1 = schema.Required;
-            bool flag = true;
-            if ((required1.GetValueOrDefault() == flag ? (!required1.HasValue ? 1 : 0) : 1) != 0)
-              schema.Required = new bool?(true);
-          }
-          return schema;
-        }
-      }
-      if (this._stack.Any<JsonSchemaGenerator.TypeSchema>((Func<JsonSchemaGenerator.TypeSchema, bool>) (tc => tc.Type == type)))
-        throw new JsonException("Unresolved circular reference for type '{0}'. Explicitly define an Id for the type using a JsonObject/JsonArray attribute or automatically generate a type Id using the UndefinedSchemaIdHandling property.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type));
-      JsonContract contract = this.ContractResolver.ResolveContract(type);
-      JsonConverter jsonConverter = contract.Converter ?? contract.InternalConverter;
-      this.Push(new JsonSchemaGenerator.TypeSchema(type, new JsonSchema()));
-      if (typeId2 != null)
-        this.CurrentSchema.Id = typeId2;
-      if (required)
-        this.CurrentSchema.Required = new bool?(true);
-      this.CurrentSchema.Title = this.GetTitle(type);
-      this.CurrentSchema.Description = this.GetDescription(type);
-      if (jsonConverter != null)
-      {
-        this.CurrentSchema.Type = new JsonSchemaType?(JsonSchemaType.Any);
-      }
-      else
-      {
-        switch (contract.ContractType)
-        {
-          case JsonContractType.Object:
-            this.CurrentSchema.Type = new JsonSchemaType?(this.AddNullType(JsonSchemaType.Object, valueRequired));
-            this.CurrentSchema.Id = this.GetTypeId(type, false);
-            this.GenerateObjectSchema(type, (JsonObjectContract) contract);
-            break;
-          case JsonContractType.Array:
-            this.CurrentSchema.Type = new JsonSchemaType?(this.AddNullType(JsonSchemaType.Array, valueRequired));
-            this.CurrentSchema.Id = this.GetTypeId(type, false);
-            JsonArrayAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonArrayAttribute>((object) type);
-            bool flag1 = cachedAttribute == null || cachedAttribute.AllowNullItems;
-            Type collectionItemType = ReflectionUtils.GetCollectionItemType(type);
-            if (collectionItemType != null)
-            {
-              this.CurrentSchema.Items = (IList<JsonSchema>) new List<JsonSchema>();
-              this.CurrentSchema.Items.Add(this.GenerateInternal(collectionItemType, !flag1 ? Required.Always : Required.Default, false));
-              break;
-            }
-            break;
-          case JsonContractType.Primitive:
-            this.CurrentSchema.Type = new JsonSchemaType?(this.GetJsonSchemaType(type, valueRequired));
-            JsonSchemaType? type2 = this.CurrentSchema.Type;
-            JsonSchemaType jsonSchemaType = JsonSchemaType.Integer;
-            if ((type2.GetValueOrDefault() == jsonSchemaType ? (type2.HasValue ? 1 : 0) : 0) != 0 && type.IsEnum() && !type.IsDefined(typeof (FlagsAttribute), true))
-            {
-              this.CurrentSchema.Enum = (IList<JToken>) new List<JToken>();
-              EnumInfo enumValuesAndNames = EnumUtils.GetEnumValuesAndNames(type);
-              for (int index = 0; index < enumValuesAndNames.Names.Length; ++index)
-              {
-                ulong num = enumValuesAndNames.Values[index];
-                this.CurrentSchema.Enum.Add(JToken.FromObject(Enum.ToObject(type, num)));
-              }
-              break;
-            }
-            break;
-          case JsonContractType.String:
-            this.CurrentSchema.Type = new JsonSchemaType?(!ReflectionUtils.IsNullable(contract.UnderlyingType) ? JsonSchemaType.String : this.AddNullType(JsonSchemaType.String, valueRequired));
-            break;
-          case JsonContractType.Dictionary:
-            this.CurrentSchema.Type = new JsonSchemaType?(this.AddNullType(JsonSchemaType.Object, valueRequired));
-            Type keyType;
-            Type valueType;
-            ReflectionUtils.GetDictionaryKeyValueTypes(type, out keyType, out valueType);
-            if (keyType != null && this.ContractResolver.ResolveContract(keyType).ContractType == JsonContractType.Primitive)
-            {
-              this.CurrentSchema.AdditionalProperties = this.GenerateInternal(valueType, Required.Default, false);
-              break;
-            }
-            break;
-          case JsonContractType.Serializable:
-            this.CurrentSchema.Type = new JsonSchemaType?(this.AddNullType(JsonSchemaType.Object, valueRequired));
-            this.CurrentSchema.Id = this.GetTypeId(type, false);
-            this.GenerateISerializableContract(type, (JsonISerializableContract) contract);
-            break;
-          case JsonContractType.Linq:
-            this.CurrentSchema.Type = new JsonSchemaType?(JsonSchemaType.Any);
-            break;
-          default:
-            throw new JsonException("Unexpected contract type: {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract));
-        }
-      }
-      return this.Pop().Schema;
-    }
-
-    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired)
-    {
-      return valueRequired != Required.Always ? type | JsonSchemaType.Null : type;
-    }
-
-    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
-    {
-      return (value & flag) == flag;
-    }
-
-    private void GenerateObjectSchema(Type type, JsonObjectContract contract)
-    {
-      this.CurrentSchema.Properties = (IDictionary<string, JsonSchema>) new Dictionary<string, JsonSchema>();
-      foreach (JsonProperty property in (Collection<JsonProperty>) contract.Properties)
-      {
-        if (!property.Ignored)
-        {
-          NullValueHandling? nullValueHandling1 = property.NullValueHandling;
-          NullValueHandling nullValueHandling2 = NullValueHandling.Ignore;
-          bool flag = (nullValueHandling1.GetValueOrDefault() == nullValueHandling2 ? (nullValueHandling1.HasValue ? 1 : 0) : 0) != 0 || this.HasFlag(property.DefaultValueHandling.GetValueOrDefault(), DefaultValueHandling.Ignore) || property.ShouldSerialize != null || property.GetIsSpecified != null;
-          JsonSchema jsonSchema = this.GenerateInternal(property.PropertyType, property.Required, !flag);
-          if (property.DefaultValue != null)
-            jsonSchema.Default = JToken.FromObject(property.DefaultValue);
-          this.CurrentSchema.Properties.Add(property.PropertyName, jsonSchema);
-        }
-      }
-      if (!type.IsSealed())
-        return;
-      this.CurrentSchema.AllowAdditionalProperties = false;
-    }
-
-    private void GenerateISerializableContract(Type type, JsonISerializableContract contract)
-    {
-      this.CurrentSchema.AllowAdditionalProperties = true;
-    }
-
-    internal static bool HasFlag(JsonSchemaType? value, JsonSchemaType flag)
-    {
-      if (!value.HasValue)
-        return true;
-      JsonSchemaType? nullable1 = value;
-      JsonSchemaType jsonSchemaType1 = flag;
-      JsonSchemaType? nullable2 = nullable1.HasValue ? new JsonSchemaType?(nullable1.GetValueOrDefault() & jsonSchemaType1) : new JsonSchemaType?();
-      JsonSchemaType jsonSchemaType2 = flag;
-      if ((nullable2.GetValueOrDefault() == jsonSchemaType2 ? (nullable2.HasValue ? 1 : 0) : 0) != 0)
-        return true;
-      if (flag == JsonSchemaType.Integer)
-      {
-        nullable1 = value;
-        nullable2 = nullable1.HasValue ? new JsonSchemaType?(nullable1.GetValueOrDefault() & JsonSchemaType.Float) : new JsonSchemaType?();
-        JsonSchemaType jsonSchemaType3 = JsonSchemaType.Float;
-        if ((nullable2.GetValueOrDefault() == jsonSchemaType3 ? (nullable2.HasValue ? 1 : 0) : 0) != 0)
-          return true;
-      }
-      return false;
-    }
-
-    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired)
-    {
-      JsonSchemaType jsonSchemaType = JsonSchemaType.None;
-      if (valueRequired != Required.Always && ReflectionUtils.IsNullable(type))
-      {
-        jsonSchemaType = JsonSchemaType.Null;
-        if (ReflectionUtils.IsNullableType(type))
-          type = Nullable.GetUnderlyingType(type);
-      }
-      PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(type);
-      switch (typeCode)
-      {
-        case PrimitiveTypeCode.Empty:
-        case PrimitiveTypeCode.Object:
-          return jsonSchemaType | JsonSchemaType.String;
-        case PrimitiveTypeCode.Char:
-          return jsonSchemaType | JsonSchemaType.String;
-        case PrimitiveTypeCode.Boolean:
-          return jsonSchemaType | JsonSchemaType.Boolean;
-        case PrimitiveTypeCode.SByte:
-        case PrimitiveTypeCode.Int16:
-        case PrimitiveTypeCode.UInt16:
-        case PrimitiveTypeCode.Int32:
-        case PrimitiveTypeCode.Byte:
-        case PrimitiveTypeCode.UInt32:
-        case PrimitiveTypeCode.Int64:
-        case PrimitiveTypeCode.UInt64:
-          return jsonSchemaType | JsonSchemaType.Integer;
-        case PrimitiveTypeCode.Single:
-        case PrimitiveTypeCode.Double:
-        case PrimitiveTypeCode.Decimal:
-          return jsonSchemaType | JsonSchemaType.Float;
-        case PrimitiveTypeCode.DateTime:
-        case PrimitiveTypeCode.DateTimeOffset:
-          return jsonSchemaType | JsonSchemaType.String;
-        case PrimitiveTypeCode.Guid:
-        case PrimitiveTypeCode.TimeSpan:
-        case PrimitiveTypeCode.Uri:
-        case PrimitiveTypeCode.String:
-        case PrimitiveTypeCode.Bytes:
-          return jsonSchemaType | JsonSchemaType.String;
-        case PrimitiveTypeCode.DBNull:
-          return jsonSchemaType | JsonSchemaType.Null;
-        default:
-          throw new JsonException("Unexpected type code '{0}' for type '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeCode, (object) type));
-      }
-    }
-
-    private class TypeSchema
-    {
-      public Type Type { get; }
-
-      public JsonSchema Schema { get; }
-
-      public TypeSchema(Type type, JsonSchema schema)
-      {
-        ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-        ValidationUtils.ArgumentNotNull((object) schema, nameof (schema));
-        this.Type = type;
-        this.Schema = schema;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaModel.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaModel.cs
deleted file mode 100644
index c3f72ee..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaModel.cs
+++ /dev/null
@@ -1,143 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  internal class JsonSchemaModel
-  {
-    public bool Required { get; set; }
-
-    public JsonSchemaType Type { get; set; }
-
-    public int? MinimumLength { get; set; }
-
-    public int? MaximumLength { get; set; }
-
-    public double? DivisibleBy { get; set; }
-
-    public double? Minimum { get; set; }
-
-    public double? Maximum { get; set; }
-
-    public bool ExclusiveMinimum { get; set; }
-
-    public bool ExclusiveMaximum { get; set; }
-
-    public int? MinimumItems { get; set; }
-
-    public int? MaximumItems { get; set; }
-
-    public IList<string> Patterns { get; set; }
-
-    public IList<JsonSchemaModel> Items { get; set; }
-
-    public IDictionary<string, JsonSchemaModel> Properties { get; set; }
-
-    public IDictionary<string, JsonSchemaModel> PatternProperties { get; set; }
-
-    public JsonSchemaModel AdditionalProperties { get; set; }
-
-    public JsonSchemaModel AdditionalItems { get; set; }
-
-    public bool PositionalItemsValidation { get; set; }
-
-    public bool AllowAdditionalProperties { get; set; }
-
-    public bool AllowAdditionalItems { get; set; }
-
-    public bool UniqueItems { get; set; }
-
-    public IList<JToken> Enum { get; set; }
-
-    public JsonSchemaType Disallow { get; set; }
-
-    public JsonSchemaModel()
-    {
-      this.Type = JsonSchemaType.Any;
-      this.AllowAdditionalProperties = true;
-      this.AllowAdditionalItems = true;
-      this.Required = false;
-    }
-
-    public static JsonSchemaModel Create(IList<JsonSchema> schemata)
-    {
-      JsonSchemaModel model = new JsonSchemaModel();
-      foreach (JsonSchema schema in (IEnumerable<JsonSchema>) schemata)
-        JsonSchemaModel.Combine(model, schema);
-      return model;
-    }
-
-    private static void Combine(JsonSchemaModel model, JsonSchema schema)
-    {
-      JsonSchemaModel jsonSchemaModel1 = model;
-      bool? nullable1;
-      int num1;
-      if (!model.Required)
-      {
-        nullable1 = schema.Required;
-        num1 = (int) nullable1 ?? 0;
-      }
-      else
-        num1 = 1;
-      jsonSchemaModel1.Required = num1 != 0;
-      JsonSchemaModel jsonSchemaModel2 = model;
-      int type = (int) model.Type;
-      JsonSchemaType? nullable2 = schema.Type;
-      int num2 = (int) nullable2 ?? (int) sbyte.MaxValue;
-      int num3 = type & num2;
-      jsonSchemaModel2.Type = (JsonSchemaType) num3;
-      model.MinimumLength = MathUtils.Max(model.MinimumLength, schema.MinimumLength);
-      model.MaximumLength = MathUtils.Min(model.MaximumLength, schema.MaximumLength);
-      model.DivisibleBy = MathUtils.Max(model.DivisibleBy, schema.DivisibleBy);
-      model.Minimum = MathUtils.Max(model.Minimum, schema.Minimum);
-      model.Maximum = MathUtils.Max(model.Maximum, schema.Maximum);
-      JsonSchemaModel jsonSchemaModel3 = model;
-      int num4;
-      if (!model.ExclusiveMinimum)
-      {
-        nullable1 = schema.ExclusiveMinimum;
-        num4 = (int) nullable1 ?? 0;
-      }
-      else
-        num4 = 1;
-      jsonSchemaModel3.ExclusiveMinimum = num4 != 0;
-      JsonSchemaModel jsonSchemaModel4 = model;
-      int num5;
-      if (!model.ExclusiveMaximum)
-      {
-        nullable1 = schema.ExclusiveMaximum;
-        num5 = (int) nullable1 ?? 0;
-      }
-      else
-        num5 = 1;
-      jsonSchemaModel4.ExclusiveMaximum = num5 != 0;
-      model.MinimumItems = MathUtils.Max(model.MinimumItems, schema.MinimumItems);
-      model.MaximumItems = MathUtils.Min(model.MaximumItems, schema.MaximumItems);
-      model.PositionalItemsValidation = model.PositionalItemsValidation || schema.PositionalItemsValidation;
-      model.AllowAdditionalProperties = model.AllowAdditionalProperties && schema.AllowAdditionalProperties;
-      model.AllowAdditionalItems = model.AllowAdditionalItems && schema.AllowAdditionalItems;
-      model.UniqueItems = model.UniqueItems || schema.UniqueItems;
-      if (schema.Enum != null)
-      {
-        if (model.Enum == null)
-          model.Enum = (IList<JToken>) new List<JToken>();
-        model.Enum.AddRangeDistinct<JToken>((IEnumerable<JToken>) schema.Enum, (IEqualityComparer<JToken>) JToken.EqualityComparer);
-      }
-      JsonSchemaModel jsonSchemaModel5 = model;
-      int disallow = (int) model.Disallow;
-      nullable2 = schema.Disallow;
-      int num6 = (int) nullable2 ?? 0;
-      int num7 = disallow | num6;
-      jsonSchemaModel5.Disallow = (JsonSchemaType) num7;
-      if (schema.Pattern == null)
-        return;
-      if (model.Patterns == null)
-        model.Patterns = (IList<string>) new List<string>();
-      model.Patterns.AddDistinct<string>(schema.Pattern);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaModelBuilder.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaModelBuilder.cs
deleted file mode 100644
index c2221d7..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaModelBuilder.cs
+++ /dev/null
@@ -1,134 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  internal class JsonSchemaModelBuilder
-  {
-    private JsonSchemaNodeCollection _nodes = new JsonSchemaNodeCollection();
-    private Dictionary<JsonSchemaNode, JsonSchemaModel> _nodeModels = new Dictionary<JsonSchemaNode, JsonSchemaModel>();
-    private JsonSchemaNode _node;
-
-    public JsonSchemaModel Build(JsonSchema schema)
-    {
-      this._nodes = new JsonSchemaNodeCollection();
-      this._node = this.AddSchema((JsonSchemaNode) null, schema);
-      this._nodeModels = new Dictionary<JsonSchemaNode, JsonSchemaModel>();
-      return this.BuildNodeModel(this._node);
-    }
-
-    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema)
-    {
-      string id;
-      if (existingNode != null)
-      {
-        if (existingNode.Schemas.Contains(schema))
-          return existingNode;
-        id = JsonSchemaNode.GetId(existingNode.Schemas.Union<JsonSchema>((IEnumerable<JsonSchema>) new JsonSchema[1]
-        {
-          schema
-        }));
-      }
-      else
-        id = JsonSchemaNode.GetId((IEnumerable<JsonSchema>) new JsonSchema[1]
-        {
-          schema
-        });
-      if (this._nodes.Contains(id))
-        return this._nodes[id];
-      JsonSchemaNode jsonSchemaNode = existingNode != null ? existingNode.Combine(schema) : new JsonSchemaNode(schema);
-      this._nodes.Add(jsonSchemaNode);
-      this.AddProperties(schema.Properties, (IDictionary<string, JsonSchemaNode>) jsonSchemaNode.Properties);
-      this.AddProperties(schema.PatternProperties, (IDictionary<string, JsonSchemaNode>) jsonSchemaNode.PatternProperties);
-      if (schema.Items != null)
-      {
-        for (int index = 0; index < schema.Items.Count; ++index)
-          this.AddItem(jsonSchemaNode, index, schema.Items[index]);
-      }
-      if (schema.AdditionalItems != null)
-        this.AddAdditionalItems(jsonSchemaNode, schema.AdditionalItems);
-      if (schema.AdditionalProperties != null)
-        this.AddAdditionalProperties(jsonSchemaNode, schema.AdditionalProperties);
-      if (schema.Extends != null)
-      {
-        foreach (JsonSchema extend in (IEnumerable<JsonSchema>) schema.Extends)
-          jsonSchemaNode = this.AddSchema(jsonSchemaNode, extend);
-      }
-      return jsonSchemaNode;
-    }
-
-    public void AddProperties(
-      IDictionary<string, JsonSchema> source,
-      IDictionary<string, JsonSchemaNode> target)
-    {
-      if (source == null)
-        return;
-      foreach (KeyValuePair<string, JsonSchema> keyValuePair in (IEnumerable<KeyValuePair<string, JsonSchema>>) source)
-        this.AddProperty(target, keyValuePair.Key, keyValuePair.Value);
-    }
-
-    public void AddProperty(
-      IDictionary<string, JsonSchemaNode> target,
-      string propertyName,
-      JsonSchema schema)
-    {
-      JsonSchemaNode existingNode;
-      target.TryGetValue(propertyName, out existingNode);
-      target[propertyName] = this.AddSchema(existingNode, schema);
-    }
-
-    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema)
-    {
-      JsonSchemaNode jsonSchemaNode = this.AddSchema(parentNode.Items.Count > index ? parentNode.Items[index] : (JsonSchemaNode) null, schema);
-      if (parentNode.Items.Count <= index)
-        parentNode.Items.Add(jsonSchemaNode);
-      else
-        parentNode.Items[index] = jsonSchemaNode;
-    }
-
-    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema)
-    {
-      parentNode.AdditionalProperties = this.AddSchema(parentNode.AdditionalProperties, schema);
-    }
-
-    public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema)
-    {
-      parentNode.AdditionalItems = this.AddSchema(parentNode.AdditionalItems, schema);
-    }
-
-    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node)
-    {
-      JsonSchemaModel jsonSchemaModel1;
-      if (this._nodeModels.TryGetValue(node, out jsonSchemaModel1))
-        return jsonSchemaModel1;
-      JsonSchemaModel jsonSchemaModel2 = JsonSchemaModel.Create((IList<JsonSchema>) node.Schemas);
-      this._nodeModels[node] = jsonSchemaModel2;
-      foreach (KeyValuePair<string, JsonSchemaNode> property in node.Properties)
-      {
-        if (jsonSchemaModel2.Properties == null)
-          jsonSchemaModel2.Properties = (IDictionary<string, JsonSchemaModel>) new Dictionary<string, JsonSchemaModel>();
-        jsonSchemaModel2.Properties[property.Key] = this.BuildNodeModel(property.Value);
-      }
-      foreach (KeyValuePair<string, JsonSchemaNode> patternProperty in node.PatternProperties)
-      {
-        if (jsonSchemaModel2.PatternProperties == null)
-          jsonSchemaModel2.PatternProperties = (IDictionary<string, JsonSchemaModel>) new Dictionary<string, JsonSchemaModel>();
-        jsonSchemaModel2.PatternProperties[patternProperty.Key] = this.BuildNodeModel(patternProperty.Value);
-      }
-      foreach (JsonSchemaNode node1 in node.Items)
-      {
-        if (jsonSchemaModel2.Items == null)
-          jsonSchemaModel2.Items = (IList<JsonSchemaModel>) new List<JsonSchemaModel>();
-        jsonSchemaModel2.Items.Add(this.BuildNodeModel(node1));
-      }
-      if (node.AdditionalProperties != null)
-        jsonSchemaModel2.AdditionalProperties = this.BuildNodeModel(node.AdditionalProperties);
-      if (node.AdditionalItems != null)
-        jsonSchemaModel2.AdditionalItems = this.BuildNodeModel(node.AdditionalItems);
-      return jsonSchemaModel2;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaNode.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaNode.cs
deleted file mode 100644
index b07d7a8..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaNode.cs
+++ /dev/null
@@ -1,59 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  internal class JsonSchemaNode
-  {
-    public string Id { get; }
-
-    public ReadOnlyCollection<JsonSchema> Schemas { get; }
-
-    public Dictionary<string, JsonSchemaNode> Properties { get; }
-
-    public Dictionary<string, JsonSchemaNode> PatternProperties { get; }
-
-    public List<JsonSchemaNode> Items { get; }
-
-    public JsonSchemaNode AdditionalProperties { get; set; }
-
-    public JsonSchemaNode AdditionalItems { get; set; }
-
-    public JsonSchemaNode(JsonSchema schema)
-    {
-      this.Schemas = new ReadOnlyCollection<JsonSchema>((IList<JsonSchema>) new JsonSchema[1]
-      {
-        schema
-      });
-      this.Properties = new Dictionary<string, JsonSchemaNode>();
-      this.PatternProperties = new Dictionary<string, JsonSchemaNode>();
-      this.Items = new List<JsonSchemaNode>();
-      this.Id = JsonSchemaNode.GetId((IEnumerable<JsonSchema>) this.Schemas);
-    }
-
-    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema)
-    {
-      this.Schemas = new ReadOnlyCollection<JsonSchema>((IList<JsonSchema>) source.Schemas.Union<JsonSchema>((IEnumerable<JsonSchema>) new JsonSchema[1]
-      {
-        schema
-      }).ToList<JsonSchema>());
-      this.Properties = new Dictionary<string, JsonSchemaNode>((IDictionary<string, JsonSchemaNode>) source.Properties);
-      this.PatternProperties = new Dictionary<string, JsonSchemaNode>((IDictionary<string, JsonSchemaNode>) source.PatternProperties);
-      this.Items = new List<JsonSchemaNode>((IEnumerable<JsonSchemaNode>) source.Items);
-      this.AdditionalProperties = source.AdditionalProperties;
-      this.AdditionalItems = source.AdditionalItems;
-      this.Id = JsonSchemaNode.GetId((IEnumerable<JsonSchema>) this.Schemas);
-    }
-
-    public JsonSchemaNode Combine(JsonSchema schema) => new JsonSchemaNode(this, schema);
-
-    public static string GetId(IEnumerable<JsonSchema> schemata)
-    {
-      return string.Join("-", schemata.Select<JsonSchema, string>((Func<JsonSchema, string>) (s => s.InternalId)).OrderBy<string, string>((Func<string, string>) (id => id), (IComparer<string>) StringComparer.Ordinal).ToArray<string>());
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaNodeCollection.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaNodeCollection.cs
deleted file mode 100644
index 9fa8a10..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaNodeCollection.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System;
-using System.Collections.ObjectModel;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  internal class JsonSchemaNodeCollection : KeyedCollection<string, JsonSchemaNode>
-  {
-    protected override string GetKeyForItem(JsonSchemaNode item) => item.Id;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaResolver.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaResolver.cs
deleted file mode 100644
index 30fa69a..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaResolver.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public class JsonSchemaResolver
-  {
-    public IList<JsonSchema> LoadedSchemas { get; protected set; }
-
-    public JsonSchemaResolver() => this.LoadedSchemas = (IList<JsonSchema>) new List<JsonSchema>();
-
-    public virtual JsonSchema GetSchema(string reference)
-    {
-      return this.LoadedSchemas.SingleOrDefault<JsonSchema>((Func<JsonSchema, bool>) (s => string.Equals(s.Id, reference, StringComparison.Ordinal))) ?? this.LoadedSchemas.SingleOrDefault<JsonSchema>((Func<JsonSchema, bool>) (s => string.Equals(s.Location, reference, StringComparison.Ordinal)));
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaType.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaType.cs
deleted file mode 100644
index dae1674..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaType.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Flags]
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public enum JsonSchemaType
-  {
-    None = 0,
-    String = 1,
-    Float = 2,
-    Integer = 4,
-    Boolean = 8,
-    Object = 16, // 0x00000010
-    Array = 32, // 0x00000020
-    Null = 64, // 0x00000040
-    Any = Null | Array | Object | Boolean | Integer | Float | String, // 0x0000007F
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaWriter.cs b/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaWriter.cs
deleted file mode 100644
index 85c6788..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/JsonSchemaWriter.cs
+++ /dev/null
@@ -1,208 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  internal class JsonSchemaWriter
-  {
-    private readonly JsonWriter _writer;
-    private readonly JsonSchemaResolver _resolver;
-
-    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver)
-    {
-      ValidationUtils.ArgumentNotNull((object) writer, nameof (writer));
-      this._writer = writer;
-      this._resolver = resolver;
-    }
-
-    private void ReferenceOrWriteSchema(JsonSchema schema)
-    {
-      if (schema.Id != null && this._resolver.GetSchema(schema.Id) != null)
-      {
-        this._writer.WriteStartObject();
-        this._writer.WritePropertyName("$ref");
-        this._writer.WriteValue(schema.Id);
-        this._writer.WriteEndObject();
-      }
-      else
-        this.WriteSchema(schema);
-    }
-
-    public void WriteSchema(JsonSchema schema)
-    {
-      ValidationUtils.ArgumentNotNull((object) schema, nameof (schema));
-      if (!this._resolver.LoadedSchemas.Contains(schema))
-        this._resolver.LoadedSchemas.Add(schema);
-      this._writer.WriteStartObject();
-      this.WritePropertyIfNotNull(this._writer, "id", (object) schema.Id);
-      this.WritePropertyIfNotNull(this._writer, "title", (object) schema.Title);
-      this.WritePropertyIfNotNull(this._writer, "description", (object) schema.Description);
-      this.WritePropertyIfNotNull(this._writer, "required", (object) schema.Required);
-      this.WritePropertyIfNotNull(this._writer, "readonly", (object) schema.ReadOnly);
-      this.WritePropertyIfNotNull(this._writer, "hidden", (object) schema.Hidden);
-      this.WritePropertyIfNotNull(this._writer, "transient", (object) schema.Transient);
-      if (schema.Type.HasValue)
-        this.WriteType("type", this._writer, schema.Type.GetValueOrDefault());
-      if (!schema.AllowAdditionalProperties)
-      {
-        this._writer.WritePropertyName("additionalProperties");
-        this._writer.WriteValue(schema.AllowAdditionalProperties);
-      }
-      else if (schema.AdditionalProperties != null)
-      {
-        this._writer.WritePropertyName("additionalProperties");
-        this.ReferenceOrWriteSchema(schema.AdditionalProperties);
-      }
-      if (!schema.AllowAdditionalItems)
-      {
-        this._writer.WritePropertyName("additionalItems");
-        this._writer.WriteValue(schema.AllowAdditionalItems);
-      }
-      else if (schema.AdditionalItems != null)
-      {
-        this._writer.WritePropertyName("additionalItems");
-        this.ReferenceOrWriteSchema(schema.AdditionalItems);
-      }
-      this.WriteSchemaDictionaryIfNotNull(this._writer, "properties", schema.Properties);
-      this.WriteSchemaDictionaryIfNotNull(this._writer, "patternProperties", schema.PatternProperties);
-      this.WriteItems(schema);
-      this.WritePropertyIfNotNull(this._writer, "minimum", (object) schema.Minimum);
-      this.WritePropertyIfNotNull(this._writer, "maximum", (object) schema.Maximum);
-      this.WritePropertyIfNotNull(this._writer, "exclusiveMinimum", (object) schema.ExclusiveMinimum);
-      this.WritePropertyIfNotNull(this._writer, "exclusiveMaximum", (object) schema.ExclusiveMaximum);
-      this.WritePropertyIfNotNull(this._writer, "minLength", (object) schema.MinimumLength);
-      this.WritePropertyIfNotNull(this._writer, "maxLength", (object) schema.MaximumLength);
-      this.WritePropertyIfNotNull(this._writer, "minItems", (object) schema.MinimumItems);
-      this.WritePropertyIfNotNull(this._writer, "maxItems", (object) schema.MaximumItems);
-      this.WritePropertyIfNotNull(this._writer, "divisibleBy", (object) schema.DivisibleBy);
-      this.WritePropertyIfNotNull(this._writer, "format", (object) schema.Format);
-      this.WritePropertyIfNotNull(this._writer, "pattern", (object) schema.Pattern);
-      if (schema.Enum != null)
-      {
-        this._writer.WritePropertyName("enum");
-        this._writer.WriteStartArray();
-        foreach (JToken jtoken in (IEnumerable<JToken>) schema.Enum)
-          jtoken.WriteTo(this._writer);
-        this._writer.WriteEndArray();
-      }
-      if (schema.Default != null)
-      {
-        this._writer.WritePropertyName("default");
-        schema.Default.WriteTo(this._writer);
-      }
-      JsonSchemaType? disallow = schema.Disallow;
-      if (disallow.HasValue)
-      {
-        JsonWriter writer = this._writer;
-        disallow = schema.Disallow;
-        int valueOrDefault = (int) disallow.GetValueOrDefault();
-        this.WriteType("disallow", writer, (JsonSchemaType) valueOrDefault);
-      }
-      if (schema.Extends != null && schema.Extends.Count > 0)
-      {
-        this._writer.WritePropertyName("extends");
-        if (schema.Extends.Count == 1)
-        {
-          this.ReferenceOrWriteSchema(schema.Extends[0]);
-        }
-        else
-        {
-          this._writer.WriteStartArray();
-          foreach (JsonSchema extend in (IEnumerable<JsonSchema>) schema.Extends)
-            this.ReferenceOrWriteSchema(extend);
-          this._writer.WriteEndArray();
-        }
-      }
-      this._writer.WriteEndObject();
-    }
-
-    private void WriteSchemaDictionaryIfNotNull(
-      JsonWriter writer,
-      string propertyName,
-      IDictionary<string, JsonSchema> properties)
-    {
-      if (properties == null)
-        return;
-      writer.WritePropertyName(propertyName);
-      writer.WriteStartObject();
-      foreach (KeyValuePair<string, JsonSchema> property in (IEnumerable<KeyValuePair<string, JsonSchema>>) properties)
-      {
-        writer.WritePropertyName(property.Key);
-        this.ReferenceOrWriteSchema(property.Value);
-      }
-      writer.WriteEndObject();
-    }
-
-    private void WriteItems(JsonSchema schema)
-    {
-      if (schema.Items == null && !schema.PositionalItemsValidation)
-        return;
-      this._writer.WritePropertyName("items");
-      if (!schema.PositionalItemsValidation)
-      {
-        if (schema.Items != null && schema.Items.Count > 0)
-        {
-          this.ReferenceOrWriteSchema(schema.Items[0]);
-        }
-        else
-        {
-          this._writer.WriteStartObject();
-          this._writer.WriteEndObject();
-        }
-      }
-      else
-      {
-        this._writer.WriteStartArray();
-        if (schema.Items != null)
-        {
-          foreach (JsonSchema schema1 in (IEnumerable<JsonSchema>) schema.Items)
-            this.ReferenceOrWriteSchema(schema1);
-        }
-        this._writer.WriteEndArray();
-      }
-    }
-
-    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type)
-    {
-      if (Enum.IsDefined(typeof (JsonSchemaType), (object) type))
-      {
-        writer.WritePropertyName(propertyName);
-        writer.WriteValue(JsonSchemaBuilder.MapType(type));
-      }
-      else
-      {
-        IEnumerator<JsonSchemaType> enumerator = EnumUtils.GetFlagsValues<JsonSchemaType>(type).Where<JsonSchemaType>((Func<JsonSchemaType, bool>) (v => v != 0)).GetEnumerator();
-        if (!enumerator.MoveNext())
-          return;
-        writer.WritePropertyName(propertyName);
-        JsonSchemaType current = enumerator.Current;
-        if (enumerator.MoveNext())
-        {
-          writer.WriteStartArray();
-          writer.WriteValue(JsonSchemaBuilder.MapType(current));
-          do
-          {
-            writer.WriteValue(JsonSchemaBuilder.MapType(enumerator.Current));
-          }
-          while (enumerator.MoveNext());
-          writer.WriteEndArray();
-        }
-        else
-          writer.WriteValue(JsonSchemaBuilder.MapType(current));
-      }
-    }
-
-    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value)
-    {
-      if (value == null)
-        return;
-      writer.WritePropertyName(propertyName);
-      writer.WriteValue(value);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/UndefinedSchemaIdHandling.cs b/MSHALTester/Newtonsoft/Json/Schema/UndefinedSchemaIdHandling.cs
deleted file mode 100644
index d5b6a58..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/UndefinedSchemaIdHandling.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public enum UndefinedSchemaIdHandling
-  {
-    None,
-    UseTypeName,
-    UseAssemblyQualifiedName,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/ValidationEventArgs.cs b/MSHALTester/Newtonsoft/Json/Schema/ValidationEventArgs.cs
deleted file mode 100644
index e617e74..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/ValidationEventArgs.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public class ValidationEventArgs : EventArgs
-  {
-    private readonly JsonSchemaException _ex;
-
-    internal ValidationEventArgs(JsonSchemaException ex)
-    {
-      ValidationUtils.ArgumentNotNull((object) ex, nameof (ex));
-      this._ex = ex;
-    }
-
-    public JsonSchemaException Exception => this._ex;
-
-    public string Path => this._ex.Path;
-
-    public string Message => this._ex.Message;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Schema/ValidationEventHandler.cs b/MSHALTester/Newtonsoft/Json/Schema/ValidationEventHandler.cs
deleted file mode 100644
index b744e0c..0000000
--- a/MSHALTester/Newtonsoft/Json/Schema/ValidationEventHandler.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Schema
-{
-  [Obsolete("JSON Schema validation has been moved to its own package. See http://www.newtonsoft.com/jsonschema for more details.")]
-  public delegate void ValidationEventHandler(object sender, ValidationEventArgs e);
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/CachedAttributeGetter`1.cs b/MSHALTester/Newtonsoft/Json/Serialization/CachedAttributeGetter`1.cs
deleted file mode 100644
index d58fab7..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/CachedAttributeGetter`1.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal static class CachedAttributeGetter<T> where T : Attribute
-  {
-    private static readonly ThreadSafeStore<object, T> TypeAttributeCache = new ThreadSafeStore<object, T>(new Func<object, T>(JsonTypeReflector.GetAttribute<T>));
-
-    public static T GetAttribute(object type)
-    {
-      return CachedAttributeGetter<T>.TypeAttributeCache.Get(type);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/CamelCaseNamingStrategy.cs b/MSHALTester/Newtonsoft/Json/Serialization/CamelCaseNamingStrategy.cs
deleted file mode 100644
index d7bdf0f..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/CamelCaseNamingStrategy.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using Newtonsoft.Json.Utilities;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class CamelCaseNamingStrategy : NamingStrategy
-  {
-    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames)
-    {
-      this.ProcessDictionaryKeys = processDictionaryKeys;
-      this.OverrideSpecifiedNames = overrideSpecifiedNames;
-    }
-
-    public CamelCaseNamingStrategy(
-      bool processDictionaryKeys,
-      bool overrideSpecifiedNames,
-      bool processExtensionDataNames)
-      : this(processDictionaryKeys, overrideSpecifiedNames)
-    {
-      this.ProcessExtensionDataNames = processExtensionDataNames;
-    }
-
-    public CamelCaseNamingStrategy()
-    {
-    }
-
-    protected override string ResolvePropertyName(string name) => StringUtils.ToCamelCase(name);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/CamelCasePropertyNamesContractResolver.cs b/MSHALTester/Newtonsoft/Json/Serialization/CamelCasePropertyNamesContractResolver.cs
deleted file mode 100644
index 0d15911..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/CamelCasePropertyNamesContractResolver.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class CamelCasePropertyNamesContractResolver : DefaultContractResolver
-  {
-    private static readonly object TypeContractCacheLock = new object();
-    private static readonly PropertyNameTable NameTable = new PropertyNameTable();
-    private static Dictionary<ResolverContractKey, JsonContract> _contractCache;
-
-    public CamelCasePropertyNamesContractResolver()
-    {
-      CamelCaseNamingStrategy caseNamingStrategy = new CamelCaseNamingStrategy();
-      caseNamingStrategy.ProcessDictionaryKeys = true;
-      caseNamingStrategy.OverrideSpecifiedNames = true;
-      this.NamingStrategy = (NamingStrategy) caseNamingStrategy;
-    }
-
-    public override JsonContract ResolveContract(Type type)
-    {
-      ResolverContractKey key = type != null ? new ResolverContractKey(this.GetType(), type) : throw new ArgumentNullException(nameof (type));
-      Dictionary<ResolverContractKey, JsonContract> contractCache1 = CamelCasePropertyNamesContractResolver._contractCache;
-      JsonContract contract;
-      if (contractCache1 == null || !contractCache1.TryGetValue(key, out contract))
-      {
-        contract = this.CreateContract(type);
-        lock (CamelCasePropertyNamesContractResolver.TypeContractCacheLock)
-        {
-          Dictionary<ResolverContractKey, JsonContract> contractCache2 = CamelCasePropertyNamesContractResolver._contractCache;
-          Dictionary<ResolverContractKey, JsonContract> dictionary = contractCache2 != null ? new Dictionary<ResolverContractKey, JsonContract>((IDictionary<ResolverContractKey, JsonContract>) contractCache2) : new Dictionary<ResolverContractKey, JsonContract>();
-          dictionary[key] = contract;
-          CamelCasePropertyNamesContractResolver._contractCache = dictionary;
-        }
-      }
-      return contract;
-    }
-
-    internal override PropertyNameTable GetNameTable()
-    {
-      return CamelCasePropertyNamesContractResolver.NameTable;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/DefaultContractResolver.cs b/MSHALTester/Newtonsoft/Json/Serialization/DefaultContractResolver.cs
deleted file mode 100644
index 7e0d9ee..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/DefaultContractResolver.cs
+++ /dev/null
@@ -1,935 +0,0 @@
-using Newtonsoft.Json.Converters;
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Globalization;
-using System.Linq;
-using System.Reflection;
-using System.Runtime.CompilerServices;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class DefaultContractResolver : IContractResolver
-  {
-    private static readonly IContractResolver _instance = (IContractResolver) new DefaultContractResolver();
-    private static readonly string[] BlacklistedTypeNames = new string[3]
-    {
-      "System.IO.DriveInfo",
-      "System.IO.FileInfo",
-      "System.IO.DirectoryInfo"
-    };
-    private static readonly JsonConverter[] BuiltInConverters = new JsonConverter[8]
-    {
-      (JsonConverter) new EntityKeyMemberConverter(),
-      (JsonConverter) new XmlNodeConverter(),
-      (JsonConverter) new BinaryConverter(),
-      (JsonConverter) new DataSetConverter(),
-      (JsonConverter) new DataTableConverter(),
-      (JsonConverter) new KeyValuePairConverter(),
-      (JsonConverter) new BsonObjectIdConverter(),
-      (JsonConverter) new RegexConverter()
-    };
-    private readonly PropertyNameTable _nameTable = new PropertyNameTable();
-    private readonly ThreadSafeStore<Type, JsonContract> _contractCache;
-
-    internal static IContractResolver Instance => DefaultContractResolver._instance;
-
-    public bool DynamicCodeGeneration => JsonTypeReflector.DynamicCodeGeneration;
-
-    [Obsolete("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
-    public BindingFlags DefaultMembersSearchFlags { get; set; }
-
-    public bool SerializeCompilerGeneratedMembers { get; set; }
-
-    public bool IgnoreSerializableInterface { get; set; }
-
-    public bool IgnoreSerializableAttribute { get; set; }
-
-    public bool IgnoreIsSpecifiedMembers { get; set; }
-
-    public bool IgnoreShouldSerializeMembers { get; set; }
-
-    public NamingStrategy NamingStrategy { get; set; }
-
-    public DefaultContractResolver()
-    {
-      this.IgnoreSerializableAttribute = true;
-      this.DefaultMembersSearchFlags = BindingFlags.Instance | BindingFlags.Public;
-      this._contractCache = new ThreadSafeStore<Type, JsonContract>(new Func<Type, JsonContract>(this.CreateContract));
-    }
-
-    public virtual JsonContract ResolveContract(Type type)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      return this._contractCache.Get(type);
-    }
-
-    protected virtual List<MemberInfo> GetSerializableMembers(Type objectType)
-    {
-      bool serializableAttribute = this.IgnoreSerializableAttribute;
-      MemberSerialization memberSerialization = JsonTypeReflector.GetObjectMemberSerialization(objectType, serializableAttribute);
-      IEnumerable<MemberInfo> memberInfos = ReflectionUtils.GetFieldsAndProperties(objectType, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).Where<MemberInfo>((Func<MemberInfo, bool>) (m => !ReflectionUtils.IsIndexedProperty(m)));
-      List<MemberInfo> source = new List<MemberInfo>();
-      if (memberSerialization != MemberSerialization.Fields)
-      {
-        DataContractAttribute contractAttribute = JsonTypeReflector.GetDataContractAttribute(objectType);
-        List<MemberInfo> list = ReflectionUtils.GetFieldsAndProperties(objectType, this.DefaultMembersSearchFlags).Where<MemberInfo>((Func<MemberInfo, bool>) (m => !ReflectionUtils.IsIndexedProperty(m))).ToList<MemberInfo>();
-        foreach (MemberInfo memberInfo in memberInfos)
-        {
-          if (this.SerializeCompilerGeneratedMembers || !memberInfo.IsDefined(typeof (CompilerGeneratedAttribute), true))
-          {
-            if (list.Contains(memberInfo))
-              source.Add(memberInfo);
-            else if (JsonTypeReflector.GetAttribute<JsonPropertyAttribute>((object) memberInfo) != null)
-              source.Add(memberInfo);
-            else if (JsonTypeReflector.GetAttribute<JsonRequiredAttribute>((object) memberInfo) != null)
-              source.Add(memberInfo);
-            else if (contractAttribute != null && JsonTypeReflector.GetAttribute<DataMemberAttribute>((object) memberInfo) != null)
-              source.Add(memberInfo);
-            else if (memberSerialization == MemberSerialization.Fields && memberInfo.MemberType() == MemberTypes.Field)
-              source.Add(memberInfo);
-          }
-        }
-        if (objectType.AssignableToTypeName("System.Data.Objects.DataClasses.EntityObject", false, out Type _))
-          source = source.Where<MemberInfo>(new Func<MemberInfo, bool>(this.ShouldSerializeEntityMember)).ToList<MemberInfo>();
-      }
-      else
-      {
-        foreach (MemberInfo memberInfo in memberInfos)
-        {
-          if (memberInfo is FieldInfo fieldInfo && !fieldInfo.IsStatic)
-            source.Add(memberInfo);
-        }
-      }
-      return source;
-    }
-
-    private bool ShouldSerializeEntityMember(MemberInfo memberInfo)
-    {
-      return !(memberInfo is PropertyInfo propertyInfo) || !propertyInfo.PropertyType.IsGenericType() || !(propertyInfo.PropertyType.GetGenericTypeDefinition().FullName == "System.Data.Objects.DataClasses.EntityReference`1");
-    }
-
-    protected virtual JsonObjectContract CreateObjectContract(Type objectType)
-    {
-      JsonObjectContract contract = new JsonObjectContract(objectType);
-      this.InitializeContract((JsonContract) contract);
-      bool serializableAttribute = this.IgnoreSerializableAttribute;
-      contract.MemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(contract.NonNullableUnderlyingType, serializableAttribute);
-      contract.Properties.AddRange<JsonProperty>((IEnumerable<JsonProperty>) this.CreateProperties(contract.NonNullableUnderlyingType, contract.MemberSerialization));
-      Func<string, string> func = (Func<string, string>) null;
-      JsonObjectAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonObjectAttribute>((object) contract.NonNullableUnderlyingType);
-      if (cachedAttribute != null)
-      {
-        contract.ItemRequired = cachedAttribute._itemRequired;
-        contract.ItemNullValueHandling = cachedAttribute._itemNullValueHandling;
-        if (cachedAttribute.NamingStrategyType != null)
-        {
-          NamingStrategy namingStrategy = JsonTypeReflector.GetContainerNamingStrategy((JsonContainerAttribute) cachedAttribute);
-          func = (Func<string, string>) (s => namingStrategy.GetDictionaryKey(s));
-        }
-      }
-      if (func == null)
-        func = new Func<string, string>(this.ResolveExtensionDataName);
-      contract.ExtensionDataNameResolver = func;
-      if (contract.IsInstantiable)
-      {
-        ConstructorInfo attributeConstructor = this.GetAttributeConstructor(contract.NonNullableUnderlyingType);
-        if (attributeConstructor != null)
-        {
-          contract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) attributeConstructor);
-          contract.CreatorParameters.AddRange<JsonProperty>((IEnumerable<JsonProperty>) this.CreateConstructorParameters(attributeConstructor, contract.Properties));
-        }
-        else if (contract.MemberSerialization == MemberSerialization.Fields)
-        {
-          if (JsonTypeReflector.FullyTrusted)
-            contract.DefaultCreator = new Func<object>(contract.GetUninitializedObject);
-        }
-        else if (contract.DefaultCreator == null || contract.DefaultCreatorNonPublic)
-        {
-          ConstructorInfo parameterizedConstructor = this.GetParameterizedConstructor(contract.NonNullableUnderlyingType);
-          if (parameterizedConstructor != null)
-          {
-            contract.ParameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) parameterizedConstructor);
-            contract.CreatorParameters.AddRange<JsonProperty>((IEnumerable<JsonProperty>) this.CreateConstructorParameters(parameterizedConstructor, contract.Properties));
-          }
-        }
-        else if (contract.NonNullableUnderlyingType.IsValueType())
-        {
-          ConstructorInfo immutableConstructor = this.GetImmutableConstructor(contract.NonNullableUnderlyingType, contract.Properties);
-          if (immutableConstructor != null)
-          {
-            contract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) immutableConstructor);
-            contract.CreatorParameters.AddRange<JsonProperty>((IEnumerable<JsonProperty>) this.CreateConstructorParameters(immutableConstructor, contract.Properties));
-          }
-        }
-      }
-      MemberInfo dataMemberForType = this.GetExtensionDataMemberForType(contract.NonNullableUnderlyingType);
-      if (dataMemberForType != null)
-        DefaultContractResolver.SetExtensionDataDelegates(contract, dataMemberForType);
-      if (Array.IndexOf<string>(DefaultContractResolver.BlacklistedTypeNames, objectType.FullName) != -1)
-        contract.OnSerializingCallbacks.Add(new SerializationCallback(DefaultContractResolver.ThrowUnableToSerializeError));
-      return contract;
-    }
-
-    private static void ThrowUnableToSerializeError(object o, StreamingContext context)
-    {
-      throw new JsonSerializationException("Unable to serialize instance of '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) o.GetType()));
-    }
-
-    private MemberInfo GetExtensionDataMemberForType(Type type)
-    {
-      return this.GetClassHierarchyForType(type).SelectMany<Type, MemberInfo>((Func<Type, IEnumerable<MemberInfo>>) (baseType =>
-      {
-        List<MemberInfo> initial = new List<MemberInfo>();
-        initial.AddRange<MemberInfo>((IEnumerable<MemberInfo>) baseType.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
-        initial.AddRange<MemberInfo>((IEnumerable<MemberInfo>) baseType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
-        return (IEnumerable<MemberInfo>) initial;
-      })).LastOrDefault<MemberInfo>((Func<MemberInfo, bool>) (m =>
-      {
-        switch (m.MemberType())
-        {
-          case MemberTypes.Field:
-          case MemberTypes.Property:
-            if (!m.IsDefined(typeof (JsonExtensionDataAttribute), false))
-              return false;
-            if (!ReflectionUtils.CanReadMemberValue(m, true))
-              throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' must have a getter.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) DefaultContractResolver.GetClrTypeFullName(m.DeclaringType), (object) m.Name));
-            Type implementingType;
-            if (ReflectionUtils.ImplementsGenericDefinition(ReflectionUtils.GetMemberUnderlyingType(m), typeof (IDictionary<,>), out implementingType))
-            {
-              Type genericArgument1 = implementingType.GetGenericArguments()[0];
-              Type genericArgument2 = implementingType.GetGenericArguments()[1];
-              Type c = typeof (string);
-              if (genericArgument1.IsAssignableFrom(c) && genericArgument2.IsAssignableFrom(typeof (JToken)))
-                return true;
-            }
-            throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' type must implement IDictionary<string, JToken>.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) DefaultContractResolver.GetClrTypeFullName(m.DeclaringType), (object) m.Name));
-          default:
-            return false;
-        }
-      }));
-    }
-
-    private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member)
-    {
-      JsonExtensionDataAttribute attribute = ReflectionUtils.GetAttribute<JsonExtensionDataAttribute>((object) member);
-      if (attribute == null)
-        return;
-      Type memberUnderlyingType = ReflectionUtils.GetMemberUnderlyingType(member);
-      Type implementingType;
-      ReflectionUtils.ImplementsGenericDefinition(memberUnderlyingType, typeof (IDictionary<,>), out implementingType);
-      Type genericArgument1 = implementingType.GetGenericArguments()[0];
-      Type genericArgument2 = implementingType.GetGenericArguments()[1];
-      Type type;
-      if (ReflectionUtils.IsGenericDefinition(memberUnderlyingType, typeof (IDictionary<,>)))
-        type = typeof (Dictionary<,>).MakeGenericType(genericArgument1, genericArgument2);
-      else
-        type = memberUnderlyingType;
-      Func<object, object> getExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(member);
-      if (attribute.ReadData)
-      {
-        Action<object, object> setExtensionDataDictionary = ReflectionUtils.CanSetMemberValue(member, true, false) ? JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(member) : (Action<object, object>) null;
-        Func<object> createExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type);
-        MethodInfo method = memberUnderlyingType.GetMethod("Add", new Type[2]
-        {
-          genericArgument1,
-          genericArgument2
-        });
-        if (method == null)
-          method = implementingType.GetMethod("Add", new Type[2]
-          {
-            genericArgument1,
-            genericArgument2
-          });
-        MethodCall<object, object> setExtensionDataDictionaryValue = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>((MethodBase) method);
-        ExtensionDataSetter extensionDataSetter = (ExtensionDataSetter) ((o, key, value) =>
-        {
-          object target = getExtensionDataDictionary(o);
-          if (target == null)
-          {
-            if (setExtensionDataDictionary == null)
-              throw new JsonSerializationException("Cannot set value onto extension data member '{0}'. The extension data collection is null and it cannot be set.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) member.Name));
-            target = createExtensionDataDictionary();
-            setExtensionDataDictionary(o, target);
-          }
-          object obj = setExtensionDataDictionaryValue(target, (object) key, value);
-        });
-        contract.ExtensionDataSetter = extensionDataSetter;
-      }
-      if (attribute.WriteData)
-      {
-        ObjectConstructor<object> createEnumerableWrapper = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) ((IEnumerable<ConstructorInfo>) typeof (DefaultContractResolver.EnumerableDictionaryWrapper<,>).MakeGenericType(genericArgument1, genericArgument2).GetConstructors()).First<ConstructorInfo>());
-        ExtensionDataGetter extensionDataGetter = (ExtensionDataGetter) (o =>
-        {
-          object obj = getExtensionDataDictionary(o);
-          if (obj == null)
-            return (IEnumerable<KeyValuePair<object, object>>) null;
-          return (IEnumerable<KeyValuePair<object, object>>) createEnumerableWrapper(obj);
-        });
-        contract.ExtensionDataGetter = extensionDataGetter;
-      }
-      contract.ExtensionDataValueType = genericArgument2;
-    }
-
-    private ConstructorInfo GetAttributeConstructor(Type objectType)
-    {
-      IEnumerator<ConstructorInfo> enumerator = ((IEnumerable<ConstructorInfo>) objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)).Where<ConstructorInfo>((Func<ConstructorInfo, bool>) (c => c.IsDefined(typeof (JsonConstructorAttribute), true))).GetEnumerator();
-      if (enumerator.MoveNext())
-      {
-        ConstructorInfo current = enumerator.Current;
-        if (enumerator.MoveNext())
-          throw new JsonException("Multiple constructors with the JsonConstructorAttribute.");
-        return current;
-      }
-      if (objectType != typeof (Version))
-        return (ConstructorInfo) null;
-      return objectType.GetConstructor(new Type[4]
-      {
-        typeof (int),
-        typeof (int),
-        typeof (int),
-        typeof (int)
-      });
-    }
-
-    private ConstructorInfo GetImmutableConstructor(
-      Type objectType,
-      JsonPropertyCollection memberProperties)
-    {
-      IEnumerator<ConstructorInfo> enumerator = ((IEnumerable<ConstructorInfo>) objectType.GetConstructors()).GetEnumerator();
-      if (enumerator.MoveNext())
-      {
-        ConstructorInfo current = enumerator.Current;
-        if (!enumerator.MoveNext())
-        {
-          ParameterInfo[] parameters = current.GetParameters();
-          if (parameters.Length != 0)
-          {
-            foreach (ParameterInfo parameterInfo in parameters)
-            {
-              JsonProperty jsonProperty = this.MatchProperty(memberProperties, parameterInfo.Name, parameterInfo.ParameterType);
-              if (jsonProperty == null || jsonProperty.Writable)
-                return (ConstructorInfo) null;
-            }
-            return current;
-          }
-        }
-      }
-      return (ConstructorInfo) null;
-    }
-
-    private ConstructorInfo GetParameterizedConstructor(Type objectType)
-    {
-      ConstructorInfo[] constructors = objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
-      return constructors.Length == 1 ? constructors[0] : (ConstructorInfo) null;
-    }
-
-    protected virtual IList<JsonProperty> CreateConstructorParameters(
-      ConstructorInfo constructor,
-      JsonPropertyCollection memberProperties)
-    {
-      ParameterInfo[] parameters = constructor.GetParameters();
-      JsonPropertyCollection constructorParameters = new JsonPropertyCollection(constructor.DeclaringType);
-      foreach (ParameterInfo parameterInfo in parameters)
-      {
-        JsonProperty matchingMemberProperty = this.MatchProperty(memberProperties, parameterInfo.Name, parameterInfo.ParameterType);
-        if (matchingMemberProperty != null || parameterInfo.Name != null)
-        {
-          JsonProperty constructorParameter = this.CreatePropertyFromConstructorParameter(matchingMemberProperty, parameterInfo);
-          if (constructorParameter != null)
-            constructorParameters.AddProperty(constructorParameter);
-        }
-      }
-      return (IList<JsonProperty>) constructorParameters;
-    }
-
-    private JsonProperty MatchProperty(JsonPropertyCollection properties, string name, Type type)
-    {
-      if (name == null)
-        return (JsonProperty) null;
-      JsonProperty closestMatchProperty = properties.GetClosestMatchProperty(name);
-      return closestMatchProperty == null || closestMatchProperty.PropertyType != type ? (JsonProperty) null : closestMatchProperty;
-    }
-
-    protected virtual JsonProperty CreatePropertyFromConstructorParameter(
-      JsonProperty matchingMemberProperty,
-      ParameterInfo parameterInfo)
-    {
-      JsonProperty property = new JsonProperty();
-      property.PropertyType = parameterInfo.ParameterType;
-      property.AttributeProvider = (IAttributeProvider) new ReflectionAttributeProvider((object) parameterInfo);
-      this.SetPropertySettingsFromAttributes(property, (object) parameterInfo, parameterInfo.Name, parameterInfo.Member.DeclaringType, MemberSerialization.OptOut, out bool _);
-      property.Readable = false;
-      property.Writable = true;
-      if (matchingMemberProperty != null)
-      {
-        property.PropertyName = property.PropertyName != parameterInfo.Name ? property.PropertyName : matchingMemberProperty.PropertyName;
-        property.Converter = property.Converter ?? matchingMemberProperty.Converter;
-        if (!property._hasExplicitDefaultValue && matchingMemberProperty._hasExplicitDefaultValue)
-          property.DefaultValue = matchingMemberProperty.DefaultValue;
-        property._required = property._required ?? matchingMemberProperty._required;
-        property.IsReference = property.IsReference ?? matchingMemberProperty.IsReference;
-        property.NullValueHandling = property.NullValueHandling ?? matchingMemberProperty.NullValueHandling;
-        property.DefaultValueHandling = property.DefaultValueHandling ?? matchingMemberProperty.DefaultValueHandling;
-        property.ReferenceLoopHandling = property.ReferenceLoopHandling ?? matchingMemberProperty.ReferenceLoopHandling;
-        property.ObjectCreationHandling = property.ObjectCreationHandling ?? matchingMemberProperty.ObjectCreationHandling;
-        property.TypeNameHandling = property.TypeNameHandling ?? matchingMemberProperty.TypeNameHandling;
-      }
-      return property;
-    }
-
-    protected virtual JsonConverter ResolveContractConverter(Type objectType)
-    {
-      return JsonTypeReflector.GetJsonConverter((object) objectType);
-    }
-
-    private Func<object> GetDefaultCreator(Type createdType)
-    {
-      return JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(createdType);
-    }
-
-    private void InitializeContract(JsonContract contract)
-    {
-      JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>((object) contract.NonNullableUnderlyingType);
-      if (cachedAttribute != null)
-      {
-        contract.IsReference = cachedAttribute._isReference;
-      }
-      else
-      {
-        DataContractAttribute contractAttribute = JsonTypeReflector.GetDataContractAttribute(contract.NonNullableUnderlyingType);
-        if (contractAttribute != null && contractAttribute.IsReference)
-          contract.IsReference = new bool?(true);
-      }
-      contract.Converter = this.ResolveContractConverter(contract.NonNullableUnderlyingType);
-      contract.InternalConverter = JsonSerializer.GetMatchingConverter((IList<JsonConverter>) DefaultContractResolver.BuiltInConverters, contract.NonNullableUnderlyingType);
-      if (contract.IsInstantiable && (ReflectionUtils.HasDefaultConstructor(contract.CreatedType, true) || contract.CreatedType.IsValueType()))
-      {
-        contract.DefaultCreator = this.GetDefaultCreator(contract.CreatedType);
-        contract.DefaultCreatorNonPublic = !contract.CreatedType.IsValueType() && ReflectionUtils.GetDefaultConstructor(contract.CreatedType) == null;
-      }
-      this.ResolveCallbackMethods(contract, contract.NonNullableUnderlyingType);
-    }
-
-    private void ResolveCallbackMethods(JsonContract contract, Type t)
-    {
-      List<SerializationCallback> onSerializing;
-      List<SerializationCallback> onSerialized;
-      List<SerializationCallback> onDeserializing;
-      List<SerializationCallback> onDeserialized;
-      List<SerializationErrorCallback> onError;
-      this.GetCallbackMethodsForType(t, out onSerializing, out onSerialized, out onDeserializing, out onDeserialized, out onError);
-      if (onSerializing != null)
-        contract.OnSerializingCallbacks.AddRange<SerializationCallback>((IEnumerable<SerializationCallback>) onSerializing);
-      if (onSerialized != null)
-        contract.OnSerializedCallbacks.AddRange<SerializationCallback>((IEnumerable<SerializationCallback>) onSerialized);
-      if (onDeserializing != null)
-        contract.OnDeserializingCallbacks.AddRange<SerializationCallback>((IEnumerable<SerializationCallback>) onDeserializing);
-      if (onDeserialized != null)
-        contract.OnDeserializedCallbacks.AddRange<SerializationCallback>((IEnumerable<SerializationCallback>) onDeserialized);
-      if (onError == null)
-        return;
-      contract.OnErrorCallbacks.AddRange<SerializationErrorCallback>((IEnumerable<SerializationErrorCallback>) onError);
-    }
-
-    private void GetCallbackMethodsForType(
-      Type type,
-      out List<SerializationCallback> onSerializing,
-      out List<SerializationCallback> onSerialized,
-      out List<SerializationCallback> onDeserializing,
-      out List<SerializationCallback> onDeserialized,
-      out List<SerializationErrorCallback> onError)
-    {
-      onSerializing = (List<SerializationCallback>) null;
-      onSerialized = (List<SerializationCallback>) null;
-      onDeserializing = (List<SerializationCallback>) null;
-      onDeserialized = (List<SerializationCallback>) null;
-      onError = (List<SerializationErrorCallback>) null;
-      foreach (Type t in this.GetClassHierarchyForType(type))
-      {
-        MethodInfo currentCallback1 = (MethodInfo) null;
-        MethodInfo currentCallback2 = (MethodInfo) null;
-        MethodInfo currentCallback3 = (MethodInfo) null;
-        MethodInfo currentCallback4 = (MethodInfo) null;
-        MethodInfo currentCallback5 = (MethodInfo) null;
-        bool flag1 = DefaultContractResolver.ShouldSkipSerializing(t);
-        bool flag2 = DefaultContractResolver.ShouldSkipDeserialized(t);
-        foreach (MethodInfo method in t.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic))
-        {
-          if (!method.ContainsGenericParameters)
-          {
-            Type prevAttributeType = (Type) null;
-            ParameterInfo[] parameters = method.GetParameters();
-            if (!flag1 && DefaultContractResolver.IsValidCallback(method, parameters, typeof (OnSerializingAttribute), currentCallback1, ref prevAttributeType))
-            {
-              onSerializing = onSerializing ?? new List<SerializationCallback>();
-              onSerializing.Add(JsonContract.CreateSerializationCallback(method));
-              currentCallback1 = method;
-            }
-            if (DefaultContractResolver.IsValidCallback(method, parameters, typeof (OnSerializedAttribute), currentCallback2, ref prevAttributeType))
-            {
-              onSerialized = onSerialized ?? new List<SerializationCallback>();
-              onSerialized.Add(JsonContract.CreateSerializationCallback(method));
-              currentCallback2 = method;
-            }
-            if (DefaultContractResolver.IsValidCallback(method, parameters, typeof (OnDeserializingAttribute), currentCallback3, ref prevAttributeType))
-            {
-              onDeserializing = onDeserializing ?? new List<SerializationCallback>();
-              onDeserializing.Add(JsonContract.CreateSerializationCallback(method));
-              currentCallback3 = method;
-            }
-            if (!flag2 && DefaultContractResolver.IsValidCallback(method, parameters, typeof (OnDeserializedAttribute), currentCallback4, ref prevAttributeType))
-            {
-              onDeserialized = onDeserialized ?? new List<SerializationCallback>();
-              onDeserialized.Add(JsonContract.CreateSerializationCallback(method));
-              currentCallback4 = method;
-            }
-            if (DefaultContractResolver.IsValidCallback(method, parameters, typeof (OnErrorAttribute), currentCallback5, ref prevAttributeType))
-            {
-              onError = onError ?? new List<SerializationErrorCallback>();
-              onError.Add(JsonContract.CreateSerializationErrorCallback(method));
-              currentCallback5 = method;
-            }
-          }
-        }
-      }
-    }
-
-    private static bool IsConcurrentOrObservableCollection(Type t)
-    {
-      if (t.IsGenericType())
-      {
-        string fullName = t.GetGenericTypeDefinition().FullName;
-        if (fullName == "System.Collections.Concurrent.ConcurrentQueue`1" || fullName == "System.Collections.Concurrent.ConcurrentStack`1" || fullName == "System.Collections.Concurrent.ConcurrentBag`1" || fullName == "System.Collections.Concurrent.ConcurrentDictionary`2" || fullName == "System.Collections.ObjectModel.ObservableCollection`1")
-          return true;
-      }
-      return false;
-    }
-
-    private static bool ShouldSkipDeserialized(Type t)
-    {
-      return DefaultContractResolver.IsConcurrentOrObservableCollection(t);
-    }
-
-    private static bool ShouldSkipSerializing(Type t)
-    {
-      return DefaultContractResolver.IsConcurrentOrObservableCollection(t);
-    }
-
-    private List<Type> GetClassHierarchyForType(Type type)
-    {
-      List<Type> hierarchyForType = new List<Type>();
-      for (Type type1 = type; type1 != null && type1 != typeof (object); type1 = type1.BaseType())
-        hierarchyForType.Add(type1);
-      hierarchyForType.Reverse();
-      return hierarchyForType;
-    }
-
-    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType)
-    {
-      JsonDictionaryContract contract = new JsonDictionaryContract(objectType);
-      this.InitializeContract((JsonContract) contract);
-      JsonContainerAttribute attribute = JsonTypeReflector.GetAttribute<JsonContainerAttribute>((object) objectType);
-      if (attribute?.NamingStrategyType != null)
-      {
-        NamingStrategy namingStrategy = JsonTypeReflector.GetContainerNamingStrategy(attribute);
-        contract.DictionaryKeyResolver = (Func<string, string>) (s => namingStrategy.GetDictionaryKey(s));
-      }
-      else
-        contract.DictionaryKeyResolver = new Func<string, string>(this.ResolveDictionaryKey);
-      ConstructorInfo attributeConstructor = this.GetAttributeConstructor(contract.NonNullableUnderlyingType);
-      if (attributeConstructor != null)
-      {
-        ParameterInfo[] parameters = attributeConstructor.GetParameters();
-        Type type1;
-        if (contract.DictionaryKeyType == null || contract.DictionaryValueType == null)
-          type1 = typeof (IDictionary);
-        else
-          type1 = typeof (IEnumerable<>).MakeGenericType(typeof (KeyValuePair<,>).MakeGenericType(contract.DictionaryKeyType, contract.DictionaryValueType));
-        Type type2 = type1;
-        if (parameters.Length == 0)
-        {
-          contract.HasParameterizedCreator = false;
-        }
-        else
-        {
-          if (parameters.Length != 1 || !type2.IsAssignableFrom(parameters[0].ParameterType))
-            throw new JsonException("Constructor for '{0}' must have no parameters or a single parameter that implements '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType, (object) type2));
-          contract.HasParameterizedCreator = true;
-        }
-        contract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) attributeConstructor);
-      }
-      return contract;
-    }
-
-    protected virtual JsonArrayContract CreateArrayContract(Type objectType)
-    {
-      JsonArrayContract contract = new JsonArrayContract(objectType);
-      this.InitializeContract((JsonContract) contract);
-      ConstructorInfo attributeConstructor = this.GetAttributeConstructor(contract.NonNullableUnderlyingType);
-      if (attributeConstructor != null)
-      {
-        ParameterInfo[] parameters = attributeConstructor.GetParameters();
-        Type type1;
-        if (contract.CollectionItemType == null)
-          type1 = typeof (IEnumerable);
-        else
-          type1 = typeof (IEnumerable<>).MakeGenericType(contract.CollectionItemType);
-        Type type2 = type1;
-        if (parameters.Length == 0)
-        {
-          contract.HasParameterizedCreator = false;
-        }
-        else
-        {
-          if (parameters.Length != 1 || !type2.IsAssignableFrom(parameters[0].ParameterType))
-            throw new JsonException("Constructor for '{0}' must have no parameters or a single parameter that implements '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType, (object) type2));
-          contract.HasParameterizedCreator = true;
-        }
-        contract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) attributeConstructor);
-      }
-      return contract;
-    }
-
-    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
-    {
-      JsonPrimitiveContract contract = new JsonPrimitiveContract(objectType);
-      this.InitializeContract((JsonContract) contract);
-      return contract;
-    }
-
-    protected virtual JsonLinqContract CreateLinqContract(Type objectType)
-    {
-      JsonLinqContract contract = new JsonLinqContract(objectType);
-      this.InitializeContract((JsonContract) contract);
-      return contract;
-    }
-
-    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType)
-    {
-      JsonISerializableContract contract = new JsonISerializableContract(objectType);
-      this.InitializeContract((JsonContract) contract);
-      ConstructorInfo constructor = contract.NonNullableUnderlyingType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, (Binder) null, new Type[2]
-      {
-        typeof (SerializationInfo),
-        typeof (StreamingContext)
-      }, (ParameterModifier[]) null);
-      if (constructor != null)
-      {
-        ObjectConstructor<object> parameterizedConstructor = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) constructor);
-        contract.ISerializableCreator = parameterizedConstructor;
-      }
-      return contract;
-    }
-
-    protected virtual JsonStringContract CreateStringContract(Type objectType)
-    {
-      JsonStringContract contract = new JsonStringContract(objectType);
-      this.InitializeContract((JsonContract) contract);
-      return contract;
-    }
-
-    protected virtual JsonContract CreateContract(Type objectType)
-    {
-      if (DefaultContractResolver.IsJsonPrimitiveType(objectType))
-        return (JsonContract) this.CreatePrimitiveContract(objectType);
-      Type type = ReflectionUtils.EnsureNotNullableType(objectType);
-      switch (JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>((object) type))
-      {
-        case JsonObjectAttribute _:
-          return (JsonContract) this.CreateObjectContract(objectType);
-        case JsonArrayAttribute _:
-          return (JsonContract) this.CreateArrayContract(objectType);
-        case JsonDictionaryAttribute _:
-          return (JsonContract) this.CreateDictionaryContract(objectType);
-        default:
-          if (type == typeof (JToken) || type.IsSubclassOf(typeof (JToken)))
-            return (JsonContract) this.CreateLinqContract(objectType);
-          if (CollectionUtils.IsDictionaryType(type))
-            return (JsonContract) this.CreateDictionaryContract(objectType);
-          if (typeof (IEnumerable).IsAssignableFrom(type))
-            return (JsonContract) this.CreateArrayContract(type);
-          if (DefaultContractResolver.CanConvertToString(type))
-            return (JsonContract) this.CreateStringContract(objectType);
-          if (!this.IgnoreSerializableInterface && typeof (ISerializable).IsAssignableFrom(type) && JsonTypeReflector.IsSerializable((object) type))
-            return (JsonContract) this.CreateISerializableContract(objectType);
-          return DefaultContractResolver.IsIConvertible(type) ? (JsonContract) this.CreatePrimitiveContract(type) : (JsonContract) this.CreateObjectContract(objectType);
-      }
-    }
-
-    internal static bool IsJsonPrimitiveType(Type t)
-    {
-      PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(t);
-      return typeCode != PrimitiveTypeCode.Empty && typeCode != PrimitiveTypeCode.Object;
-    }
-
-    internal static bool IsIConvertible(Type t)
-    {
-      return (typeof (IConvertible).IsAssignableFrom(t) || ReflectionUtils.IsNullableType(t) && typeof (IConvertible).IsAssignableFrom(Nullable.GetUnderlyingType(t))) && !typeof (JToken).IsAssignableFrom(t);
-    }
-
-    internal static bool CanConvertToString(Type type)
-    {
-      return JsonTypeReflector.CanTypeDescriptorConvertString(type, out TypeConverter _) || type == typeof (Type) || type.IsSubclassOf(typeof (Type));
-    }
-
-    private static bool IsValidCallback(
-      MethodInfo method,
-      ParameterInfo[] parameters,
-      Type attributeType,
-      MethodInfo currentCallback,
-      ref Type prevAttributeType)
-    {
-      if (!method.IsDefined(attributeType, false))
-        return false;
-      if (currentCallback != null)
-        throw new JsonException("Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) method, (object) currentCallback, (object) DefaultContractResolver.GetClrTypeFullName(method.DeclaringType), (object) attributeType));
-      if (prevAttributeType != null)
-        throw new JsonException("Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) prevAttributeType, (object) attributeType, (object) DefaultContractResolver.GetClrTypeFullName(method.DeclaringType), (object) method));
-      if (method.IsVirtual)
-        throw new JsonException("Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) method, (object) DefaultContractResolver.GetClrTypeFullName(method.DeclaringType), (object) attributeType));
-      if (method.ReturnType != typeof (void))
-        throw new JsonException("Serialization Callback '{1}' in type '{0}' must return void.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) DefaultContractResolver.GetClrTypeFullName(method.DeclaringType), (object) method));
-      if (attributeType == typeof (OnErrorAttribute))
-      {
-        if (parameters == null || parameters.Length != 2 || parameters[0].ParameterType != typeof (StreamingContext) || parameters[1].ParameterType != typeof (ErrorContext))
-          throw new JsonException("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) DefaultContractResolver.GetClrTypeFullName(method.DeclaringType), (object) method, (object) typeof (StreamingContext), (object) typeof (ErrorContext)));
-      }
-      else if (parameters == null || parameters.Length != 1 || parameters[0].ParameterType != typeof (StreamingContext))
-        throw new JsonException("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) DefaultContractResolver.GetClrTypeFullName(method.DeclaringType), (object) method, (object) typeof (StreamingContext)));
-      prevAttributeType = attributeType;
-      return true;
-    }
-
-    internal static string GetClrTypeFullName(Type type)
-    {
-      return type.IsGenericTypeDefinition() || !type.ContainsGenericParameters() ? type.FullName : "{0}.{1}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type.Namespace, (object) type.Name);
-    }
-
-    protected virtual IList<JsonProperty> CreateProperties(
-      Type type,
-      MemberSerialization memberSerialization)
-    {
-      List<MemberInfo> serializableMembers = this.GetSerializableMembers(type);
-      if (serializableMembers == null)
-        throw new JsonSerializationException("Null collection of serializable members returned.");
-      PropertyNameTable nameTable = this.GetNameTable();
-      JsonPropertyCollection source = new JsonPropertyCollection(type);
-      foreach (MemberInfo member in serializableMembers)
-      {
-        JsonProperty property = this.CreateProperty(member, memberSerialization);
-        if (property != null)
-        {
-          lock (nameTable)
-            property.PropertyName = nameTable.Add(property.PropertyName);
-          source.AddProperty(property);
-        }
-      }
-      return (IList<JsonProperty>) source.OrderBy<JsonProperty, int>((Func<JsonProperty, int>) (p => p.Order ?? -1)).ToList<JsonProperty>();
-    }
-
-    internal virtual PropertyNameTable GetNameTable() => this._nameTable;
-
-    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member)
-    {
-      return !this.DynamicCodeGeneration ? (IValueProvider) new ReflectionValueProvider(member) : (IValueProvider) new DynamicValueProvider(member);
-    }
-
-    protected virtual JsonProperty CreateProperty(
-      MemberInfo member,
-      MemberSerialization memberSerialization)
-    {
-      JsonProperty property = new JsonProperty();
-      property.PropertyType = ReflectionUtils.GetMemberUnderlyingType(member);
-      property.DeclaringType = member.DeclaringType;
-      property.ValueProvider = this.CreateMemberValueProvider(member);
-      property.AttributeProvider = (IAttributeProvider) new ReflectionAttributeProvider((object) member);
-      bool allowNonPublicAccess;
-      this.SetPropertySettingsFromAttributes(property, (object) member, member.Name, member.DeclaringType, memberSerialization, out allowNonPublicAccess);
-      if (memberSerialization != MemberSerialization.Fields)
-      {
-        property.Readable = ReflectionUtils.CanReadMemberValue(member, allowNonPublicAccess);
-        property.Writable = ReflectionUtils.CanSetMemberValue(member, allowNonPublicAccess, property.HasMemberAttribute);
-      }
-      else
-      {
-        property.Readable = true;
-        property.Writable = true;
-      }
-      if (!this.IgnoreShouldSerializeMembers)
-        property.ShouldSerialize = this.CreateShouldSerializeTest(member);
-      if (!this.IgnoreIsSpecifiedMembers)
-        this.SetIsSpecifiedActions(property, member, allowNonPublicAccess);
-      return property;
-    }
-
-    private void SetPropertySettingsFromAttributes(
-      JsonProperty property,
-      object attributeProvider,
-      string name,
-      Type declaringType,
-      MemberSerialization memberSerialization,
-      out bool allowNonPublicAccess)
-    {
-      DataContractAttribute contractAttribute = JsonTypeReflector.GetDataContractAttribute(declaringType);
-      MemberInfo memberInfo = attributeProvider as MemberInfo;
-      DataMemberAttribute dataMemberAttribute = contractAttribute == null || memberInfo == null ? (DataMemberAttribute) null : JsonTypeReflector.GetDataMemberAttribute(memberInfo);
-      JsonPropertyAttribute attribute1 = JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(attributeProvider);
-      JsonRequiredAttribute attribute2 = JsonTypeReflector.GetAttribute<JsonRequiredAttribute>(attributeProvider);
-      string str;
-      bool hasSpecifiedName;
-      if (attribute1 != null && attribute1.PropertyName != null)
-      {
-        str = attribute1.PropertyName;
-        hasSpecifiedName = true;
-      }
-      else if (dataMemberAttribute != null && dataMemberAttribute.Name != null)
-      {
-        str = dataMemberAttribute.Name;
-        hasSpecifiedName = true;
-      }
-      else
-      {
-        str = name;
-        hasSpecifiedName = false;
-      }
-      JsonContainerAttribute attribute3 = JsonTypeReflector.GetAttribute<JsonContainerAttribute>((object) declaringType);
-      NamingStrategy namingStrategy = attribute1?.NamingStrategyType == null ? (attribute3?.NamingStrategyType == null ? this.NamingStrategy : JsonTypeReflector.GetContainerNamingStrategy(attribute3)) : JsonTypeReflector.CreateNamingStrategyInstance(attribute1.NamingStrategyType, attribute1.NamingStrategyParameters);
-      property.PropertyName = namingStrategy == null ? this.ResolvePropertyName(str) : namingStrategy.GetPropertyName(str, hasSpecifiedName);
-      property.UnderlyingName = name;
-      bool flag1 = false;
-      if (attribute1 != null)
-      {
-        property._required = attribute1._required;
-        property.Order = attribute1._order;
-        property.DefaultValueHandling = attribute1._defaultValueHandling;
-        flag1 = true;
-        property.NullValueHandling = attribute1._nullValueHandling;
-        property.ReferenceLoopHandling = attribute1._referenceLoopHandling;
-        property.ObjectCreationHandling = attribute1._objectCreationHandling;
-        property.TypeNameHandling = attribute1._typeNameHandling;
-        property.IsReference = attribute1._isReference;
-        property.ItemIsReference = attribute1._itemIsReference;
-        property.ItemConverter = attribute1.ItemConverterType != null ? JsonTypeReflector.CreateJsonConverterInstance(attribute1.ItemConverterType, attribute1.ItemConverterParameters) : (JsonConverter) null;
-        property.ItemReferenceLoopHandling = attribute1._itemReferenceLoopHandling;
-        property.ItemTypeNameHandling = attribute1._itemTypeNameHandling;
-      }
-      else
-      {
-        property.NullValueHandling = new NullValueHandling?();
-        property.ReferenceLoopHandling = new ReferenceLoopHandling?();
-        property.ObjectCreationHandling = new ObjectCreationHandling?();
-        property.TypeNameHandling = new TypeNameHandling?();
-        property.IsReference = new bool?();
-        property.ItemIsReference = new bool?();
-        property.ItemConverter = (JsonConverter) null;
-        property.ItemReferenceLoopHandling = new ReferenceLoopHandling?();
-        property.ItemTypeNameHandling = new TypeNameHandling?();
-        if (dataMemberAttribute != null)
-        {
-          property._required = new Required?(dataMemberAttribute.IsRequired ? Required.AllowNull : Required.Default);
-          property.Order = dataMemberAttribute.Order != -1 ? new int?(dataMemberAttribute.Order) : new int?();
-          property.DefaultValueHandling = !dataMemberAttribute.EmitDefaultValue ? new DefaultValueHandling?(DefaultValueHandling.Ignore) : new DefaultValueHandling?();
-          flag1 = true;
-        }
-      }
-      if (attribute2 != null)
-      {
-        property._required = new Required?(Required.Always);
-        flag1 = true;
-      }
-      property.HasMemberAttribute = flag1;
-      bool flag2 = JsonTypeReflector.GetAttribute<JsonIgnoreAttribute>(attributeProvider) != null || JsonTypeReflector.GetAttribute<JsonExtensionDataAttribute>(attributeProvider) != null || JsonTypeReflector.IsNonSerializable(attributeProvider);
-      if (memberSerialization != MemberSerialization.OptIn)
-      {
-        bool flag3 = false;
-        property.Ignored = flag2 | flag3;
-      }
-      else
-        property.Ignored = flag2 || !flag1;
-      property.Converter = JsonTypeReflector.GetJsonConverter(attributeProvider);
-      DefaultValueAttribute attribute4 = JsonTypeReflector.GetAttribute<DefaultValueAttribute>(attributeProvider);
-      if (attribute4 != null)
-        property.DefaultValue = attribute4.Value;
-      allowNonPublicAccess = false;
-      if ((this.DefaultMembersSearchFlags & BindingFlags.NonPublic) == BindingFlags.NonPublic)
-        allowNonPublicAccess = true;
-      if (flag1)
-        allowNonPublicAccess = true;
-      if (memberSerialization != MemberSerialization.Fields)
-        return;
-      allowNonPublicAccess = true;
-    }
-
-    private Predicate<object> CreateShouldSerializeTest(MemberInfo member)
-    {
-      MethodInfo method = member.DeclaringType.GetMethod("ShouldSerialize" + member.Name, ReflectionUtils.EmptyTypes);
-      if (method == null || method.ReturnType != typeof (bool))
-        return (Predicate<object>) null;
-      MethodCall<object, object> shouldSerializeCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>((MethodBase) method);
-      return (Predicate<object>) (o => (bool) shouldSerializeCall(o));
-    }
-
-    private void SetIsSpecifiedActions(
-      JsonProperty property,
-      MemberInfo member,
-      bool allowNonPublicAccess)
-    {
-      MemberInfo memberInfo = (MemberInfo) member.DeclaringType.GetProperty(member.Name + "Specified", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) ?? (MemberInfo) member.DeclaringType.GetField(member.Name + "Specified", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
-      if (memberInfo == null || ReflectionUtils.GetMemberUnderlyingType(memberInfo) != typeof (bool))
-        return;
-      Func<object, object> specifiedPropertyGet = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(memberInfo);
-      property.GetIsSpecified = (Predicate<object>) (o => (bool) specifiedPropertyGet(o));
-      if (!ReflectionUtils.CanSetMemberValue(memberInfo, allowNonPublicAccess, false))
-        return;
-      property.SetIsSpecified = JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(memberInfo);
-    }
-
-    protected virtual string ResolvePropertyName(string propertyName)
-    {
-      return this.NamingStrategy != null ? this.NamingStrategy.GetPropertyName(propertyName, false) : propertyName;
-    }
-
-    protected virtual string ResolveExtensionDataName(string extensionDataName)
-    {
-      return this.NamingStrategy != null ? this.NamingStrategy.GetExtensionDataName(extensionDataName) : extensionDataName;
-    }
-
-    protected virtual string ResolveDictionaryKey(string dictionaryKey)
-    {
-      return this.NamingStrategy != null ? this.NamingStrategy.GetDictionaryKey(dictionaryKey) : this.ResolvePropertyName(dictionaryKey);
-    }
-
-    public string GetResolvedPropertyName(string propertyName)
-    {
-      return this.ResolvePropertyName(propertyName);
-    }
-
-    internal class EnumerableDictionaryWrapper<TEnumeratorKey, TEnumeratorValue> : 
-      IEnumerable<KeyValuePair<object, object>>,
-      IEnumerable
-    {
-      private readonly IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;
-
-      public EnumerableDictionaryWrapper(
-        IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
-      {
-        ValidationUtils.ArgumentNotNull((object) e, nameof (e));
-        this._e = e;
-      }
-
-      public IEnumerator<KeyValuePair<object, object>> GetEnumerator()
-      {
-        foreach (KeyValuePair<TEnumeratorKey, TEnumeratorValue> keyValuePair in this._e)
-          yield return new KeyValuePair<object, object>((object) keyValuePair.Key, (object) keyValuePair.Value);
-      }
-
-      IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/DefaultNamingStrategy.cs b/MSHALTester/Newtonsoft/Json/Serialization/DefaultNamingStrategy.cs
deleted file mode 100644
index 09e438b..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/DefaultNamingStrategy.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class DefaultNamingStrategy : NamingStrategy
-  {
-    protected override string ResolvePropertyName(string name) => name;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/DefaultReferenceResolver.cs b/MSHALTester/Newtonsoft/Json/Serialization/DefaultReferenceResolver.cs
deleted file mode 100644
index 210fd0f..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/DefaultReferenceResolver.cs
+++ /dev/null
@@ -1,57 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal class DefaultReferenceResolver : IReferenceResolver
-  {
-    private int _referenceCount;
-
-    private BidirectionalDictionary<string, object> GetMappings(object context)
-    {
-      switch (context)
-      {
-        case JsonSerializerInternalBase internalSerializer:
-label_3:
-          return internalSerializer.DefaultReferenceMappings;
-        case JsonSerializerProxy jsonSerializerProxy:
-          internalSerializer = jsonSerializerProxy.GetInternalSerializer();
-          goto label_3;
-        default:
-          throw new JsonException("The DefaultReferenceResolver can only be used internally.");
-      }
-    }
-
-    public object ResolveReference(object context, string reference)
-    {
-      object second;
-      this.GetMappings(context).TryGetByFirst(reference, out second);
-      return second;
-    }
-
-    public string GetReference(object context, object value)
-    {
-      BidirectionalDictionary<string, object> mappings = this.GetMappings(context);
-      string first;
-      if (!mappings.TryGetBySecond(value, out first))
-      {
-        ++this._referenceCount;
-        first = this._referenceCount.ToString((IFormatProvider) CultureInfo.InvariantCulture);
-        mappings.Set(first, value);
-      }
-      return first;
-    }
-
-    public void AddReference(object context, string reference, object value)
-    {
-      this.GetMappings(context).Set(reference, value);
-    }
-
-    public bool IsReferenced(object context, object value)
-    {
-      return this.GetMappings(context).TryGetBySecond(value, out string _);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/DefaultSerializationBinder.cs b/MSHALTester/Newtonsoft/Json/Serialization/DefaultSerializationBinder.cs
deleted file mode 100644
index 60f3925..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/DefaultSerializationBinder.cs
+++ /dev/null
@@ -1,112 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Reflection;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class DefaultSerializationBinder : SerializationBinder, ISerializationBinder
-  {
-    internal static readonly DefaultSerializationBinder Instance = new DefaultSerializationBinder();
-    private readonly ThreadSafeStore<TypeNameKey, Type> _typeCache;
-
-    public DefaultSerializationBinder()
-    {
-      this._typeCache = new ThreadSafeStore<TypeNameKey, Type>(new Func<TypeNameKey, Type>(this.GetTypeFromTypeNameKey));
-    }
-
-    private Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
-    {
-      string assemblyName = typeNameKey.AssemblyName;
-      string typeName = typeNameKey.TypeName;
-      if (assemblyName == null)
-        return Type.GetType(typeName);
-      Assembly assembly1 = Assembly.LoadWithPartialName(assemblyName);
-      if (assembly1 == null)
-      {
-        foreach (Assembly assembly2 in AppDomain.CurrentDomain.GetAssemblies())
-        {
-          if (assembly2.FullName == assemblyName || assembly2.GetName().Name == assemblyName)
-          {
-            assembly1 = assembly2;
-            break;
-          }
-        }
-      }
-      Type typeFromTypeNameKey = assembly1 != null ? assembly1.GetType(typeName) : throw new JsonSerializationException("Could not load assembly '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) assemblyName));
-      if (typeFromTypeNameKey == null)
-      {
-        if (typeName.IndexOf('`') >= 0)
-        {
-          try
-          {
-            typeFromTypeNameKey = this.GetGenericTypeFromTypeName(typeName, assembly1);
-          }
-          catch (Exception ex)
-          {
-            throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeName, (object) assembly1.FullName), ex);
-          }
-        }
-        if (typeFromTypeNameKey == null)
-          throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeName, (object) assembly1.FullName));
-      }
-      return typeFromTypeNameKey;
-    }
-
-    private Type GetGenericTypeFromTypeName(string typeName, Assembly assembly)
-    {
-      Type typeFromTypeName = (Type) null;
-      int length = typeName.IndexOf('[');
-      if (length >= 0)
-      {
-        string name = typeName.Substring(0, length);
-        Type type = assembly.GetType(name);
-        if (type != null)
-        {
-          List<Type> typeList = new List<Type>();
-          int num1 = 0;
-          int startIndex = 0;
-          int num2 = typeName.Length - 1;
-          for (int index = length + 1; index < num2; ++index)
-          {
-            switch (typeName[index])
-            {
-              case '[':
-                if (num1 == 0)
-                  startIndex = index + 1;
-                ++num1;
-                break;
-              case ']':
-                --num1;
-                if (num1 == 0)
-                {
-                  TypeNameKey typeNameKey = ReflectionUtils.SplitFullyQualifiedTypeName(typeName.Substring(startIndex, index - startIndex));
-                  typeList.Add(this.GetTypeByName(typeNameKey));
-                  break;
-                }
-                break;
-            }
-          }
-          typeFromTypeName = type.MakeGenericType(typeList.ToArray());
-        }
-      }
-      return typeFromTypeName;
-    }
-
-    private Type GetTypeByName(TypeNameKey typeNameKey) => this._typeCache.Get(typeNameKey);
-
-    public override Type BindToType(string assemblyName, string typeName)
-    {
-      return this.GetTypeByName(new TypeNameKey(assemblyName, typeName));
-    }
-
-    public void BindToName(Type serializedType, out string assemblyName, out string typeName)
-    {
-      assemblyName = serializedType.Assembly.FullName;
-      typeName = serializedType.FullName;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/DiagnosticsTraceWriter.cs b/MSHALTester/Newtonsoft/Json/Serialization/DiagnosticsTraceWriter.cs
deleted file mode 100644
index f08711a..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/DiagnosticsTraceWriter.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-using System;
-using System.Diagnostics;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class DiagnosticsTraceWriter : ITraceWriter
-  {
-    public TraceLevel LevelFilter { get; set; }
-
-    private TraceEventType GetTraceEventType(TraceLevel level)
-    {
-      switch (level)
-      {
-        case TraceLevel.Error:
-          return TraceEventType.Error;
-        case TraceLevel.Warning:
-          return TraceEventType.Warning;
-        case TraceLevel.Info:
-          return TraceEventType.Information;
-        case TraceLevel.Verbose:
-          return TraceEventType.Verbose;
-        default:
-          throw new ArgumentOutOfRangeException(nameof (level));
-      }
-    }
-
-    public void Trace(TraceLevel level, string message, Exception ex)
-    {
-      if (level == TraceLevel.Off)
-        return;
-      TraceEventCache eventCache = new TraceEventCache();
-      TraceEventType traceEventType = this.GetTraceEventType(level);
-      foreach (TraceListener listener in System.Diagnostics.Trace.Listeners)
-      {
-        if (!listener.IsThreadSafe)
-        {
-          lock (listener)
-            listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
-        }
-        else
-          listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
-        if (System.Diagnostics.Trace.AutoFlush)
-          listener.Flush();
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/DynamicValueProvider.cs b/MSHALTester/Newtonsoft/Json/Serialization/DynamicValueProvider.cs
deleted file mode 100644
index 34b32f6..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/DynamicValueProvider.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class DynamicValueProvider : IValueProvider
-  {
-    private readonly MemberInfo _memberInfo;
-    private Func<object, object> _getter;
-    private Action<object, object> _setter;
-
-    public DynamicValueProvider(MemberInfo memberInfo)
-    {
-      ValidationUtils.ArgumentNotNull((object) memberInfo, nameof (memberInfo));
-      this._memberInfo = memberInfo;
-    }
-
-    public void SetValue(object target, object value)
-    {
-      try
-      {
-        if (this._setter == null)
-          this._setter = DynamicReflectionDelegateFactory.Instance.CreateSet<object>(this._memberInfo);
-        this._setter(target, value);
-      }
-      catch (Exception ex)
-      {
-        throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._memberInfo.Name, (object) target.GetType()), ex);
-      }
-    }
-
-    public object GetValue(object target)
-    {
-      try
-      {
-        if (this._getter == null)
-          this._getter = DynamicReflectionDelegateFactory.Instance.CreateGet<object>(this._memberInfo);
-        return this._getter(target);
-      }
-      catch (Exception ex)
-      {
-        throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._memberInfo.Name, (object) target.GetType()), ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ErrorContext.cs b/MSHALTester/Newtonsoft/Json/Serialization/ErrorContext.cs
deleted file mode 100644
index 1898e21..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ErrorContext.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class ErrorContext
-  {
-    internal ErrorContext(object originalObject, object member, string path, Exception error)
-    {
-      this.OriginalObject = originalObject;
-      this.Member = member;
-      this.Error = error;
-      this.Path = path;
-    }
-
-    internal bool Traced { get; set; }
-
-    public Exception Error { get; }
-
-    public object OriginalObject { get; }
-
-    public object Member { get; }
-
-    public string Path { get; }
-
-    public bool Handled { get; set; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ErrorEventArgs.cs b/MSHALTester/Newtonsoft/Json/Serialization/ErrorEventArgs.cs
deleted file mode 100644
index 0e47215..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ErrorEventArgs.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class ErrorEventArgs : EventArgs
-  {
-    public object CurrentObject { get; }
-
-    public ErrorContext ErrorContext { get; }
-
-    public ErrorEventArgs(object currentObject, ErrorContext errorContext)
-    {
-      this.CurrentObject = currentObject;
-      this.ErrorContext = errorContext;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ExtensionDataGetter.cs b/MSHALTester/Newtonsoft/Json/Serialization/ExtensionDataGetter.cs
deleted file mode 100644
index ea4a02f..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ExtensionDataGetter.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public delegate IEnumerable<KeyValuePair<object, object>> ExtensionDataGetter(object o);
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ExtensionDataSetter.cs b/MSHALTester/Newtonsoft/Json/Serialization/ExtensionDataSetter.cs
deleted file mode 100644
index 6d6b0b1..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ExtensionDataSetter.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public delegate void ExtensionDataSetter(object o, string key, object value);
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/IAttributeProvider.cs b/MSHALTester/Newtonsoft/Json/Serialization/IAttributeProvider.cs
deleted file mode 100644
index e8e1f5e..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/IAttributeProvider.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using System;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public interface IAttributeProvider
-  {
-    IList<Attribute> GetAttributes(bool inherit);
-
-    IList<Attribute> GetAttributes(Type attributeType, bool inherit);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/IContractResolver.cs b/MSHALTester/Newtonsoft/Json/Serialization/IContractResolver.cs
deleted file mode 100644
index d7eef36..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/IContractResolver.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public interface IContractResolver
-  {
-    JsonContract ResolveContract(Type type);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/IReferenceResolver.cs b/MSHALTester/Newtonsoft/Json/Serialization/IReferenceResolver.cs
deleted file mode 100644
index bab5263..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/IReferenceResolver.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public interface IReferenceResolver
-  {
-    object ResolveReference(object context, string reference);
-
-    string GetReference(object context, object value);
-
-    bool IsReferenced(object context, object value);
-
-    void AddReference(object context, string reference, object value);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ISerializationBinder.cs b/MSHALTester/Newtonsoft/Json/Serialization/ISerializationBinder.cs
deleted file mode 100644
index ef7a26a..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ISerializationBinder.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public interface ISerializationBinder
-  {
-    Type BindToType(string assemblyName, string typeName);
-
-    void BindToName(Type serializedType, out string assemblyName, out string typeName);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ITraceWriter.cs b/MSHALTester/Newtonsoft/Json/Serialization/ITraceWriter.cs
deleted file mode 100644
index 098c6a3..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ITraceWriter.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using System;
-using System.Diagnostics;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public interface ITraceWriter
-  {
-    TraceLevel LevelFilter { get; }
-
-    void Trace(TraceLevel level, string message, Exception ex);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/IValueProvider.cs b/MSHALTester/Newtonsoft/Json/Serialization/IValueProvider.cs
deleted file mode 100644
index fde51c9..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/IValueProvider.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public interface IValueProvider
-  {
-    void SetValue(object target, object value);
-
-    object GetValue(object target);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonArrayContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonArrayContract.cs
deleted file mode 100644
index 1793e3e..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonArrayContract.cs
+++ /dev/null
@@ -1,159 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonArrayContract : JsonContainerContract
-  {
-    private readonly Type _genericCollectionDefinitionType;
-    private Type _genericWrapperType;
-    private ObjectConstructor<object> _genericWrapperCreator;
-    private Func<object> _genericTemporaryCollectionCreator;
-    private readonly ConstructorInfo _parameterizedConstructor;
-    private ObjectConstructor<object> _parameterizedCreator;
-    private ObjectConstructor<object> _overrideCreator;
-
-    public Type CollectionItemType { get; }
-
-    public bool IsMultidimensionalArray { get; }
-
-    internal bool IsArray { get; }
-
-    internal bool ShouldCreateWrapper { get; }
-
-    internal bool CanDeserialize { get; private set; }
-
-    internal ObjectConstructor<object> ParameterizedCreator
-    {
-      get
-      {
-        if (this._parameterizedCreator == null)
-          this._parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) this._parameterizedConstructor);
-        return this._parameterizedCreator;
-      }
-    }
-
-    public ObjectConstructor<object> OverrideCreator
-    {
-      get => this._overrideCreator;
-      set
-      {
-        this._overrideCreator = value;
-        this.CanDeserialize = true;
-      }
-    }
-
-    public bool HasParameterizedCreator { get; set; }
-
-    internal bool HasParameterizedCreatorInternal
-    {
-      get
-      {
-        return this.HasParameterizedCreator || this._parameterizedCreator != null || this._parameterizedConstructor != null;
-      }
-    }
-
-    public JsonArrayContract(Type underlyingType)
-      : base(underlyingType)
-    {
-      this.ContractType = JsonContractType.Array;
-      this.IsArray = this.CreatedType.IsArray;
-      bool flag;
-      Type implementingType;
-      if (this.IsArray)
-      {
-        this.CollectionItemType = ReflectionUtils.GetCollectionItemType(this.UnderlyingType);
-        this.IsReadOnlyOrFixedSize = true;
-        this._genericCollectionDefinitionType = typeof (List<>).MakeGenericType(this.CollectionItemType);
-        flag = true;
-        this.IsMultidimensionalArray = this.IsArray && this.UnderlyingType.GetArrayRank() > 1;
-      }
-      else if (typeof (IList).IsAssignableFrom(underlyingType))
-      {
-        this.CollectionItemType = !ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof (ICollection<>), out this._genericCollectionDefinitionType) ? ReflectionUtils.GetCollectionItemType(underlyingType) : this._genericCollectionDefinitionType.GetGenericArguments()[0];
-        if (underlyingType == typeof (IList))
-          this.CreatedType = typeof (List<object>);
-        if (this.CollectionItemType != null)
-          this._parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, this.CollectionItemType);
-        this.IsReadOnlyOrFixedSize = ReflectionUtils.InheritsGenericDefinition(underlyingType, typeof (ReadOnlyCollection<>));
-        flag = true;
-      }
-      else if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof (ICollection<>), out this._genericCollectionDefinitionType))
-      {
-        this.CollectionItemType = this._genericCollectionDefinitionType.GetGenericArguments()[0];
-        if (ReflectionUtils.IsGenericDefinition(underlyingType, typeof (ICollection<>)) || ReflectionUtils.IsGenericDefinition(underlyingType, typeof (IList<>)))
-          this.CreatedType = typeof (List<>).MakeGenericType(this.CollectionItemType);
-        this._parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, this.CollectionItemType);
-        flag = true;
-        this.ShouldCreateWrapper = true;
-      }
-      else if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof (IEnumerable<>), out implementingType))
-      {
-        this.CollectionItemType = implementingType.GetGenericArguments()[0];
-        if (ReflectionUtils.IsGenericDefinition(this.UnderlyingType, typeof (IEnumerable<>)))
-          this.CreatedType = typeof (List<>).MakeGenericType(this.CollectionItemType);
-        this._parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, this.CollectionItemType);
-        if (underlyingType.IsGenericType() && underlyingType.GetGenericTypeDefinition() == typeof (IEnumerable<>))
-        {
-          this._genericCollectionDefinitionType = implementingType;
-          this.IsReadOnlyOrFixedSize = false;
-          this.ShouldCreateWrapper = false;
-          flag = true;
-        }
-        else
-        {
-          this._genericCollectionDefinitionType = typeof (List<>).MakeGenericType(this.CollectionItemType);
-          this.IsReadOnlyOrFixedSize = true;
-          this.ShouldCreateWrapper = true;
-          flag = this.HasParameterizedCreatorInternal;
-        }
-      }
-      else
-      {
-        flag = false;
-        this.ShouldCreateWrapper = true;
-      }
-      this.CanDeserialize = flag;
-      if (this.CollectionItemType != null && ReflectionUtils.IsNullableType(this.CollectionItemType) && (ReflectionUtils.InheritsGenericDefinition(this.CreatedType, typeof (List<>), out implementingType) || this.IsArray && !this.IsMultidimensionalArray))
-        this.ShouldCreateWrapper = true;
-      Type createdType;
-      ObjectConstructor<object> parameterizedCreator;
-      if (!ImmutableCollectionsUtils.TryBuildImmutableForArrayContract(underlyingType, this.CollectionItemType, out createdType, out parameterizedCreator))
-        return;
-      this.CreatedType = createdType;
-      this._parameterizedCreator = parameterizedCreator;
-      this.IsReadOnlyOrFixedSize = true;
-      this.CanDeserialize = true;
-    }
-
-    internal IWrappedCollection CreateWrapper(object list)
-    {
-      if (this._genericWrapperCreator == null)
-      {
-        this._genericWrapperType = typeof (CollectionWrapper<>).MakeGenericType(this.CollectionItemType);
-        Type type;
-        if (ReflectionUtils.InheritsGenericDefinition(this._genericCollectionDefinitionType, typeof (List<>)) || this._genericCollectionDefinitionType.GetGenericTypeDefinition() == typeof (IEnumerable<>))
-          type = typeof (ICollection<>).MakeGenericType(this.CollectionItemType);
-        else
-          type = this._genericCollectionDefinitionType;
-        this._genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) this._genericWrapperType.GetConstructor(new Type[1]
-        {
-          type
-        }));
-      }
-      return (IWrappedCollection) this._genericWrapperCreator(list);
-    }
-
-    internal IList CreateTemporaryCollection()
-    {
-      if (this._genericTemporaryCollectionCreator == null)
-        this._genericTemporaryCollectionCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(typeof (List<>).MakeGenericType(this.IsMultidimensionalArray || this.CollectionItemType == null ? typeof (object) : this.CollectionItemType));
-      return (IList) this._genericTemporaryCollectionCreator();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonContainerContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonContainerContract.cs
deleted file mode 100644
index 8018f5c..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonContainerContract.cs
+++ /dev/null
@@ -1,48 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonContainerContract : JsonContract
-  {
-    private JsonContract _itemContract;
-    private JsonContract _finalItemContract;
-
-    internal JsonContract ItemContract
-    {
-      get => this._itemContract;
-      set
-      {
-        this._itemContract = value;
-        if (this._itemContract != null)
-          this._finalItemContract = this._itemContract.UnderlyingType.IsSealed() ? this._itemContract : (JsonContract) null;
-        else
-          this._finalItemContract = (JsonContract) null;
-      }
-    }
-
-    internal JsonContract FinalItemContract => this._finalItemContract;
-
-    public JsonConverter ItemConverter { get; set; }
-
-    public bool? ItemIsReference { get; set; }
-
-    public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }
-
-    public TypeNameHandling? ItemTypeNameHandling { get; set; }
-
-    internal JsonContainerContract(Type underlyingType)
-      : base(underlyingType)
-    {
-      JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>((object) underlyingType);
-      if (cachedAttribute == null)
-        return;
-      if (cachedAttribute.ItemConverterType != null)
-        this.ItemConverter = JsonTypeReflector.CreateJsonConverterInstance(cachedAttribute.ItemConverterType, cachedAttribute.ItemConverterParameters);
-      this.ItemIsReference = cachedAttribute._itemIsReference;
-      this.ItemReferenceLoopHandling = cachedAttribute._itemReferenceLoopHandling;
-      this.ItemTypeNameHandling = cachedAttribute._itemTypeNameHandling;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonContract.cs
deleted file mode 100644
index 2536b87..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonContract.cs
+++ /dev/null
@@ -1,171 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Reflection;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public abstract class JsonContract
-  {
-    internal bool IsNullable;
-    internal bool IsConvertable;
-    internal bool IsEnum;
-    internal Type NonNullableUnderlyingType;
-    internal ReadType InternalReadType;
-    internal JsonContractType ContractType;
-    internal bool IsReadOnlyOrFixedSize;
-    internal bool IsSealed;
-    internal bool IsInstantiable;
-    private List<SerializationCallback> _onDeserializedCallbacks;
-    private IList<SerializationCallback> _onDeserializingCallbacks;
-    private IList<SerializationCallback> _onSerializedCallbacks;
-    private IList<SerializationCallback> _onSerializingCallbacks;
-    private IList<SerializationErrorCallback> _onErrorCallbacks;
-    private Type _createdType;
-
-    public Type UnderlyingType { get; }
-
-    public Type CreatedType
-    {
-      get => this._createdType;
-      set
-      {
-        this._createdType = value;
-        this.IsSealed = this._createdType.IsSealed();
-        this.IsInstantiable = !this._createdType.IsInterface() && !this._createdType.IsAbstract();
-      }
-    }
-
-    public bool? IsReference { get; set; }
-
-    public JsonConverter Converter { get; set; }
-
-    internal JsonConverter InternalConverter { get; set; }
-
-    public IList<SerializationCallback> OnDeserializedCallbacks
-    {
-      get
-      {
-        if (this._onDeserializedCallbacks == null)
-          this._onDeserializedCallbacks = new List<SerializationCallback>();
-        return (IList<SerializationCallback>) this._onDeserializedCallbacks;
-      }
-    }
-
-    public IList<SerializationCallback> OnDeserializingCallbacks
-    {
-      get
-      {
-        if (this._onDeserializingCallbacks == null)
-          this._onDeserializingCallbacks = (IList<SerializationCallback>) new List<SerializationCallback>();
-        return this._onDeserializingCallbacks;
-      }
-    }
-
-    public IList<SerializationCallback> OnSerializedCallbacks
-    {
-      get
-      {
-        if (this._onSerializedCallbacks == null)
-          this._onSerializedCallbacks = (IList<SerializationCallback>) new List<SerializationCallback>();
-        return this._onSerializedCallbacks;
-      }
-    }
-
-    public IList<SerializationCallback> OnSerializingCallbacks
-    {
-      get
-      {
-        if (this._onSerializingCallbacks == null)
-          this._onSerializingCallbacks = (IList<SerializationCallback>) new List<SerializationCallback>();
-        return this._onSerializingCallbacks;
-      }
-    }
-
-    public IList<SerializationErrorCallback> OnErrorCallbacks
-    {
-      get
-      {
-        if (this._onErrorCallbacks == null)
-          this._onErrorCallbacks = (IList<SerializationErrorCallback>) new List<SerializationErrorCallback>();
-        return this._onErrorCallbacks;
-      }
-    }
-
-    public Func<object> DefaultCreator { get; set; }
-
-    public bool DefaultCreatorNonPublic { get; set; }
-
-    internal JsonContract(Type underlyingType)
-    {
-      ValidationUtils.ArgumentNotNull((object) underlyingType, nameof (underlyingType));
-      this.UnderlyingType = underlyingType;
-      this.IsNullable = ReflectionUtils.IsNullable(underlyingType);
-      this.NonNullableUnderlyingType = !this.IsNullable || !ReflectionUtils.IsNullableType(underlyingType) ? underlyingType : Nullable.GetUnderlyingType(underlyingType);
-      this.CreatedType = this.NonNullableUnderlyingType;
-      this.IsConvertable = ConvertUtils.IsConvertible(this.NonNullableUnderlyingType);
-      this.IsEnum = this.NonNullableUnderlyingType.IsEnum();
-      this.InternalReadType = ReadType.Read;
-    }
-
-    internal void InvokeOnSerializing(object o, StreamingContext context)
-    {
-      if (this._onSerializingCallbacks == null)
-        return;
-      foreach (SerializationCallback serializingCallback in (IEnumerable<SerializationCallback>) this._onSerializingCallbacks)
-        serializingCallback(o, context);
-    }
-
-    internal void InvokeOnSerialized(object o, StreamingContext context)
-    {
-      if (this._onSerializedCallbacks == null)
-        return;
-      foreach (SerializationCallback serializedCallback in (IEnumerable<SerializationCallback>) this._onSerializedCallbacks)
-        serializedCallback(o, context);
-    }
-
-    internal void InvokeOnDeserializing(object o, StreamingContext context)
-    {
-      if (this._onDeserializingCallbacks == null)
-        return;
-      foreach (SerializationCallback deserializingCallback in (IEnumerable<SerializationCallback>) this._onDeserializingCallbacks)
-        deserializingCallback(o, context);
-    }
-
-    internal void InvokeOnDeserialized(object o, StreamingContext context)
-    {
-      if (this._onDeserializedCallbacks == null)
-        return;
-      foreach (SerializationCallback deserializedCallback in this._onDeserializedCallbacks)
-        deserializedCallback(o, context);
-    }
-
-    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
-    {
-      if (this._onErrorCallbacks == null)
-        return;
-      foreach (SerializationErrorCallback onErrorCallback in (IEnumerable<SerializationErrorCallback>) this._onErrorCallbacks)
-        onErrorCallback(o, context, errorContext);
-    }
-
-    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo)
-    {
-      return (SerializationCallback) ((o, context) => callbackMethodInfo.Invoke(o, new object[1]
-      {
-        (object) context
-      }));
-    }
-
-    internal static SerializationErrorCallback CreateSerializationErrorCallback(
-      MethodInfo callbackMethodInfo)
-    {
-      return (SerializationErrorCallback) ((o, context, econtext) => callbackMethodInfo.Invoke(o, new object[2]
-      {
-        (object) context,
-        (object) econtext
-      }));
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonContractType.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonContractType.cs
deleted file mode 100644
index f5ca05b..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonContractType.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal enum JsonContractType
-  {
-    None,
-    Object,
-    Array,
-    Primitive,
-    String,
-    Dictionary,
-    Dynamic,
-    Serializable,
-    Linq,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonDictionaryContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonDictionaryContract.cs
deleted file mode 100644
index cb67378..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonDictionaryContract.cs
+++ /dev/null
@@ -1,114 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonDictionaryContract : JsonContainerContract
-  {
-    private readonly Type _genericCollectionDefinitionType;
-    private Type _genericWrapperType;
-    private ObjectConstructor<object> _genericWrapperCreator;
-    private Func<object> _genericTemporaryDictionaryCreator;
-    private readonly ConstructorInfo _parameterizedConstructor;
-    private ObjectConstructor<object> _overrideCreator;
-    private ObjectConstructor<object> _parameterizedCreator;
-
-    public Func<string, string> DictionaryKeyResolver { get; set; }
-
-    public Type DictionaryKeyType { get; }
-
-    public Type DictionaryValueType { get; }
-
-    internal JsonContract KeyContract { get; set; }
-
-    internal bool ShouldCreateWrapper { get; }
-
-    internal ObjectConstructor<object> ParameterizedCreator
-    {
-      get
-      {
-        if (this._parameterizedCreator == null)
-          this._parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) this._parameterizedConstructor);
-        return this._parameterizedCreator;
-      }
-    }
-
-    public ObjectConstructor<object> OverrideCreator
-    {
-      get => this._overrideCreator;
-      set => this._overrideCreator = value;
-    }
-
-    public bool HasParameterizedCreator { get; set; }
-
-    internal bool HasParameterizedCreatorInternal
-    {
-      get
-      {
-        return this.HasParameterizedCreator || this._parameterizedCreator != null || this._parameterizedConstructor != null;
-      }
-    }
-
-    public JsonDictionaryContract(Type underlyingType)
-      : base(underlyingType)
-    {
-      this.ContractType = JsonContractType.Dictionary;
-      Type keyType;
-      Type valueType;
-      if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof (IDictionary<,>), out this._genericCollectionDefinitionType))
-      {
-        keyType = this._genericCollectionDefinitionType.GetGenericArguments()[0];
-        valueType = this._genericCollectionDefinitionType.GetGenericArguments()[1];
-        if (ReflectionUtils.IsGenericDefinition(this.UnderlyingType, typeof (IDictionary<,>)))
-          this.CreatedType = typeof (Dictionary<,>).MakeGenericType(keyType, valueType);
-        else if (underlyingType.IsGenericType() && underlyingType.GetGenericTypeDefinition().FullName == "System.Collections.Concurrent.ConcurrentDictionary`2")
-          this.ShouldCreateWrapper = true;
-      }
-      else
-      {
-        ReflectionUtils.GetDictionaryKeyValueTypes(this.UnderlyingType, out keyType, out valueType);
-        if (this.UnderlyingType == typeof (IDictionary))
-          this.CreatedType = typeof (Dictionary<object, object>);
-      }
-      if (keyType != null && valueType != null)
-        this._parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(this.CreatedType, typeof (KeyValuePair<,>).MakeGenericType(keyType, valueType), typeof (IDictionary<,>).MakeGenericType(keyType, valueType));
-      if (!typeof (IDictionary).IsAssignableFrom(this.CreatedType))
-        this.ShouldCreateWrapper = true;
-      this.DictionaryKeyType = keyType;
-      this.DictionaryValueType = valueType;
-      if (this.DictionaryValueType != null && ReflectionUtils.IsNullableType(this.DictionaryValueType) && ReflectionUtils.InheritsGenericDefinition(this.CreatedType, typeof (Dictionary<,>), out Type _))
-        this.ShouldCreateWrapper = true;
-      Type createdType;
-      ObjectConstructor<object> parameterizedCreator;
-      if (!ImmutableCollectionsUtils.TryBuildImmutableForDictionaryContract(underlyingType, this.DictionaryKeyType, this.DictionaryValueType, out createdType, out parameterizedCreator))
-        return;
-      this.CreatedType = createdType;
-      this._parameterizedCreator = parameterizedCreator;
-      this.IsReadOnlyOrFixedSize = true;
-    }
-
-    internal IWrappedDictionary CreateWrapper(object dictionary)
-    {
-      if (this._genericWrapperCreator == null)
-      {
-        this._genericWrapperType = typeof (DictionaryWrapper<,>).MakeGenericType(this.DictionaryKeyType, this.DictionaryValueType);
-        this._genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) this._genericWrapperType.GetConstructor(new Type[1]
-        {
-          this._genericCollectionDefinitionType
-        }));
-      }
-      return (IWrappedDictionary) this._genericWrapperCreator(dictionary);
-    }
-
-    internal IDictionary CreateTemporaryDictionary()
-    {
-      if (this._genericTemporaryDictionaryCreator == null)
-        this._genericTemporaryDictionaryCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(typeof (Dictionary<,>).MakeGenericType(this.DictionaryKeyType ?? typeof (object), this.DictionaryValueType ?? typeof (object)));
-      return (IDictionary) this._genericTemporaryDictionaryCreator();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonFormatterConverter.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonFormatterConverter.cs
deleted file mode 100644
index 8550151..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonFormatterConverter.cs
+++ /dev/null
@@ -1,80 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal class JsonFormatterConverter : IFormatterConverter
-  {
-    private readonly JsonSerializerInternalReader _reader;
-    private readonly JsonISerializableContract _contract;
-    private readonly JsonProperty _member;
-
-    public JsonFormatterConverter(
-      JsonSerializerInternalReader reader,
-      JsonISerializableContract contract,
-      JsonProperty member)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      ValidationUtils.ArgumentNotNull((object) contract, nameof (contract));
-      this._reader = reader;
-      this._contract = contract;
-      this._member = member;
-    }
-
-    private T GetTokenValue<T>(object value)
-    {
-      ValidationUtils.ArgumentNotNull(value, nameof (value));
-      return (T) System.Convert.ChangeType(((JValue) value).Value, typeof (T), (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public object Convert(object value, Type type)
-    {
-      ValidationUtils.ArgumentNotNull(value, nameof (value));
-      if (!(value is JToken token))
-        throw new ArgumentException("Value is not a JToken.", nameof (value));
-      return this._reader.CreateISerializableItem(token, type, this._contract, this._member);
-    }
-
-    public object Convert(object value, TypeCode typeCode)
-    {
-      ValidationUtils.ArgumentNotNull(value, nameof (value));
-      if (value is JValue)
-        value = ((JValue) value).Value;
-      return System.Convert.ChangeType(value, typeCode, (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public bool ToBoolean(object value) => this.GetTokenValue<bool>(value);
-
-    public byte ToByte(object value) => this.GetTokenValue<byte>(value);
-
-    public char ToChar(object value) => this.GetTokenValue<char>(value);
-
-    public DateTime ToDateTime(object value) => this.GetTokenValue<DateTime>(value);
-
-    public Decimal ToDecimal(object value) => this.GetTokenValue<Decimal>(value);
-
-    public double ToDouble(object value) => this.GetTokenValue<double>(value);
-
-    public short ToInt16(object value) => this.GetTokenValue<short>(value);
-
-    public int ToInt32(object value) => this.GetTokenValue<int>(value);
-
-    public long ToInt64(object value) => this.GetTokenValue<long>(value);
-
-    public sbyte ToSByte(object value) => this.GetTokenValue<sbyte>(value);
-
-    public float ToSingle(object value) => this.GetTokenValue<float>(value);
-
-    public string ToString(object value) => this.GetTokenValue<string>(value);
-
-    public ushort ToUInt16(object value) => this.GetTokenValue<ushort>(value);
-
-    public uint ToUInt32(object value) => this.GetTokenValue<uint>(value);
-
-    public ulong ToUInt64(object value) => this.GetTokenValue<ulong>(value);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonISerializableContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonISerializableContract.cs
deleted file mode 100644
index bd63fc3..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonISerializableContract.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonISerializableContract : JsonContainerContract
-  {
-    public ObjectConstructor<object> ISerializableCreator { get; set; }
-
-    public JsonISerializableContract(Type underlyingType)
-      : base(underlyingType)
-    {
-      this.ContractType = JsonContractType.Serializable;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonLinqContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonLinqContract.cs
deleted file mode 100644
index 3ea8bcd..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonLinqContract.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonLinqContract : JsonContract
-  {
-    public JsonLinqContract(Type underlyingType)
-      : base(underlyingType)
-    {
-      this.ContractType = JsonContractType.Linq;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonObjectContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonObjectContract.cs
deleted file mode 100644
index f387428..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonObjectContract.cs
+++ /dev/null
@@ -1,112 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.ObjectModel;
-using System.Globalization;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonObjectContract : JsonContainerContract
-  {
-    internal bool ExtensionDataIsJToken;
-    private bool? _hasRequiredOrDefaultValueProperties;
-    private ObjectConstructor<object> _overrideCreator;
-    private ObjectConstructor<object> _parameterizedCreator;
-    private JsonPropertyCollection _creatorParameters;
-    private Type _extensionDataValueType;
-
-    public MemberSerialization MemberSerialization { get; set; }
-
-    public Required? ItemRequired { get; set; }
-
-    public NullValueHandling? ItemNullValueHandling { get; set; }
-
-    public JsonPropertyCollection Properties { get; }
-
-    public JsonPropertyCollection CreatorParameters
-    {
-      get
-      {
-        if (this._creatorParameters == null)
-          this._creatorParameters = new JsonPropertyCollection(this.UnderlyingType);
-        return this._creatorParameters;
-      }
-    }
-
-    public ObjectConstructor<object> OverrideCreator
-    {
-      get => this._overrideCreator;
-      set => this._overrideCreator = value;
-    }
-
-    internal ObjectConstructor<object> ParameterizedCreator
-    {
-      get => this._parameterizedCreator;
-      set => this._parameterizedCreator = value;
-    }
-
-    public ExtensionDataSetter ExtensionDataSetter { get; set; }
-
-    public ExtensionDataGetter ExtensionDataGetter { get; set; }
-
-    public Type ExtensionDataValueType
-    {
-      get => this._extensionDataValueType;
-      set
-      {
-        this._extensionDataValueType = value;
-        this.ExtensionDataIsJToken = value != null && typeof (JToken).IsAssignableFrom(value);
-      }
-    }
-
-    public Func<string, string> ExtensionDataNameResolver { get; set; }
-
-    internal bool HasRequiredOrDefaultValueProperties
-    {
-      get
-      {
-        if (!this._hasRequiredOrDefaultValueProperties.HasValue)
-        {
-          this._hasRequiredOrDefaultValueProperties = new bool?(false);
-          if (this.ItemRequired.GetValueOrDefault(Required.Default) != Required.Default)
-          {
-            this._hasRequiredOrDefaultValueProperties = new bool?(true);
-          }
-          else
-          {
-            foreach (JsonProperty property in (Collection<JsonProperty>) this.Properties)
-            {
-              if (property.Required == Required.Default)
-              {
-                DefaultValueHandling? defaultValueHandling1 = property.DefaultValueHandling;
-                DefaultValueHandling? nullable = defaultValueHandling1.HasValue ? new DefaultValueHandling?(defaultValueHandling1.GetValueOrDefault() & DefaultValueHandling.Populate) : new DefaultValueHandling?();
-                DefaultValueHandling defaultValueHandling2 = DefaultValueHandling.Populate;
-                if ((nullable.GetValueOrDefault() == defaultValueHandling2 ? (nullable.HasValue ? 1 : 0) : 0) == 0)
-                  continue;
-              }
-              this._hasRequiredOrDefaultValueProperties = new bool?(true);
-              break;
-            }
-          }
-        }
-        return this._hasRequiredOrDefaultValueProperties.GetValueOrDefault();
-      }
-    }
-
-    public JsonObjectContract(Type underlyingType)
-      : base(underlyingType)
-    {
-      this.ContractType = JsonContractType.Object;
-      this.Properties = new JsonPropertyCollection(this.UnderlyingType);
-    }
-
-    internal object GetUninitializedObject()
-    {
-      if (!JsonTypeReflector.FullyTrusted)
-        throw new JsonException("Insufficient permissions. Creating an uninitialized '{0}' type requires full trust.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this.NonNullableUnderlyingType));
-      return FormatterServices.GetUninitializedObject(this.NonNullableUnderlyingType);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonPrimitiveContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonPrimitiveContract.cs
deleted file mode 100644
index c3677d1..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonPrimitiveContract.cs
+++ /dev/null
@@ -1,40 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonPrimitiveContract : JsonContract
-  {
-    private static readonly Dictionary<Type, ReadType> ReadTypeMap = new Dictionary<Type, ReadType>()
-    {
-      [typeof (byte[])] = ReadType.ReadAsBytes,
-      [typeof (byte)] = ReadType.ReadAsInt32,
-      [typeof (short)] = ReadType.ReadAsInt32,
-      [typeof (int)] = ReadType.ReadAsInt32,
-      [typeof (Decimal)] = ReadType.ReadAsDecimal,
-      [typeof (bool)] = ReadType.ReadAsBoolean,
-      [typeof (string)] = ReadType.ReadAsString,
-      [typeof (DateTime)] = ReadType.ReadAsDateTime,
-      [typeof (DateTimeOffset)] = ReadType.ReadAsDateTimeOffset,
-      [typeof (float)] = ReadType.ReadAsDouble,
-      [typeof (double)] = ReadType.ReadAsDouble,
-      [typeof (long)] = ReadType.ReadAsInt64
-    };
-
-    internal PrimitiveTypeCode TypeCode { get; set; }
-
-    public JsonPrimitiveContract(Type underlyingType)
-      : base(underlyingType)
-    {
-      this.ContractType = JsonContractType.Primitive;
-      this.TypeCode = ConvertUtils.GetTypeCode(underlyingType);
-      this.IsReadOnlyOrFixedSize = true;
-      ReadType readType;
-      if (!JsonPrimitiveContract.ReadTypeMap.TryGetValue(this.NonNullableUnderlyingType, out readType))
-        return;
-      this.InternalReadType = readType;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonProperty.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonProperty.cs
deleted file mode 100644
index 7083ac7..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonProperty.cs
+++ /dev/null
@@ -1,134 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonProperty
-  {
-    internal Required? _required;
-    internal bool _hasExplicitDefaultValue;
-    private object _defaultValue;
-    private bool _hasGeneratedDefaultValue;
-    private string _propertyName;
-    internal bool _skipPropertyNameEscape;
-    private Type _propertyType;
-
-    internal JsonContract PropertyContract { get; set; }
-
-    public string PropertyName
-    {
-      get => this._propertyName;
-      set
-      {
-        this._propertyName = value;
-        this._skipPropertyNameEscape = !JavaScriptUtils.ShouldEscapeJavaScriptString(this._propertyName, JavaScriptUtils.HtmlCharEscapeFlags);
-      }
-    }
-
-    public Type DeclaringType { get; set; }
-
-    public int? Order { get; set; }
-
-    public string UnderlyingName { get; set; }
-
-    public IValueProvider ValueProvider { get; set; }
-
-    public IAttributeProvider AttributeProvider { get; set; }
-
-    public Type PropertyType
-    {
-      get => this._propertyType;
-      set
-      {
-        if (this._propertyType == value)
-          return;
-        this._propertyType = value;
-        this._hasGeneratedDefaultValue = false;
-      }
-    }
-
-    public JsonConverter Converter { get; set; }
-
-    [Obsolete("MemberConverter is obsolete. Use Converter instead.")]
-    public JsonConverter MemberConverter
-    {
-      get => this.Converter;
-      set => this.Converter = value;
-    }
-
-    public bool Ignored { get; set; }
-
-    public bool Readable { get; set; }
-
-    public bool Writable { get; set; }
-
-    public bool HasMemberAttribute { get; set; }
-
-    public object DefaultValue
-    {
-      get => !this._hasExplicitDefaultValue ? (object) null : this._defaultValue;
-      set
-      {
-        this._hasExplicitDefaultValue = true;
-        this._defaultValue = value;
-      }
-    }
-
-    internal object GetResolvedDefaultValue()
-    {
-      if (this._propertyType == null)
-        return (object) null;
-      if (!this._hasExplicitDefaultValue && !this._hasGeneratedDefaultValue)
-      {
-        this._defaultValue = ReflectionUtils.GetDefaultValue(this.PropertyType);
-        this._hasGeneratedDefaultValue = true;
-      }
-      return this._defaultValue;
-    }
-
-    public Required Required
-    {
-      get => this._required ?? Required.Default;
-      set => this._required = new Required?(value);
-    }
-
-    public bool? IsReference { get; set; }
-
-    public Newtonsoft.Json.NullValueHandling? NullValueHandling { get; set; }
-
-    public Newtonsoft.Json.DefaultValueHandling? DefaultValueHandling { get; set; }
-
-    public Newtonsoft.Json.ReferenceLoopHandling? ReferenceLoopHandling { get; set; }
-
-    public Newtonsoft.Json.ObjectCreationHandling? ObjectCreationHandling { get; set; }
-
-    public Newtonsoft.Json.TypeNameHandling? TypeNameHandling { get; set; }
-
-    public Predicate<object> ShouldSerialize { get; set; }
-
-    public Predicate<object> ShouldDeserialize { get; set; }
-
-    public Predicate<object> GetIsSpecified { get; set; }
-
-    public Action<object, object> SetIsSpecified { get; set; }
-
-    public override string ToString() => this.PropertyName;
-
-    public JsonConverter ItemConverter { get; set; }
-
-    public bool? ItemIsReference { get; set; }
-
-    public Newtonsoft.Json.TypeNameHandling? ItemTypeNameHandling { get; set; }
-
-    public Newtonsoft.Json.ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }
-
-    internal void WritePropertyName(JsonWriter writer)
-    {
-      if (this._skipPropertyNameEscape)
-        writer.WritePropertyName(this.PropertyName, false);
-      else
-        writer.WritePropertyName(this.PropertyName);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonPropertyCollection.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonPropertyCollection.cs
deleted file mode 100644
index dc66760..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonPropertyCollection.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonPropertyCollection : KeyedCollection<string, JsonProperty>
-  {
-    private readonly Type _type;
-    private readonly List<JsonProperty> _list;
-
-    public JsonPropertyCollection(Type type)
-      : base((IEqualityComparer<string>) StringComparer.Ordinal)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      this._type = type;
-      this._list = (List<JsonProperty>) this.Items;
-    }
-
-    protected override string GetKeyForItem(JsonProperty item) => item.PropertyName;
-
-    public void AddProperty(JsonProperty property)
-    {
-      if (this.Contains(property.PropertyName))
-      {
-        if (property.Ignored)
-          return;
-        JsonProperty jsonProperty = this[property.PropertyName];
-        bool flag = true;
-        if (jsonProperty.Ignored)
-        {
-          this.Remove(jsonProperty);
-          flag = false;
-        }
-        else if (property.DeclaringType != null && jsonProperty.DeclaringType != null)
-        {
-          if (property.DeclaringType.IsSubclassOf(jsonProperty.DeclaringType) || jsonProperty.DeclaringType.IsInterface() && property.DeclaringType.ImplementInterface(jsonProperty.DeclaringType))
-          {
-            this.Remove(jsonProperty);
-            flag = false;
-          }
-          if (jsonProperty.DeclaringType.IsSubclassOf(property.DeclaringType) || property.DeclaringType.IsInterface() && jsonProperty.DeclaringType.ImplementInterface(property.DeclaringType) || this._type.ImplementInterface(jsonProperty.DeclaringType) && this._type.ImplementInterface(property.DeclaringType))
-            return;
-        }
-        if (flag)
-          throw new JsonSerializationException("A member with the name '{0}' already exists on '{1}'. Use the JsonPropertyAttribute to specify another name.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName, (object) this._type));
-      }
-      this.Add(property);
-    }
-
-    public JsonProperty GetClosestMatchProperty(string propertyName)
-    {
-      return this.GetProperty(propertyName, StringComparison.Ordinal) ?? this.GetProperty(propertyName, StringComparison.OrdinalIgnoreCase);
-    }
-
-    private bool TryGetValue(string key, out JsonProperty item)
-    {
-      if (this.Dictionary != null)
-        return this.Dictionary.TryGetValue(key, out item);
-      item = (JsonProperty) null;
-      return false;
-    }
-
-    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType)
-    {
-      if (comparisonType == StringComparison.Ordinal)
-      {
-        JsonProperty jsonProperty;
-        return this.TryGetValue(propertyName, out jsonProperty) ? jsonProperty : (JsonProperty) null;
-      }
-      for (int index = 0; index < this._list.Count; ++index)
-      {
-        JsonProperty property = this._list[index];
-        if (string.Equals(propertyName, property.PropertyName, comparisonType))
-          return property;
-      }
-      return (JsonProperty) null;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalBase.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalBase.cs
deleted file mode 100644
index 5546e5a..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalBase.cs
+++ /dev/null
@@ -1,94 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Runtime.CompilerServices;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal abstract class JsonSerializerInternalBase
-  {
-    private ErrorContext _currentErrorContext;
-    private BidirectionalDictionary<string, object> _mappings;
-    internal readonly JsonSerializer Serializer;
-    internal readonly ITraceWriter TraceWriter;
-    protected JsonSerializerProxy InternalSerializer;
-
-    protected JsonSerializerInternalBase(JsonSerializer serializer)
-    {
-      ValidationUtils.ArgumentNotNull((object) serializer, nameof (serializer));
-      this.Serializer = serializer;
-      this.TraceWriter = serializer.TraceWriter;
-    }
-
-    internal BidirectionalDictionary<string, object> DefaultReferenceMappings
-    {
-      get
-      {
-        if (this._mappings == null)
-          this._mappings = new BidirectionalDictionary<string, object>((IEqualityComparer<string>) EqualityComparer<string>.Default, (IEqualityComparer<object>) new JsonSerializerInternalBase.ReferenceEqualsEqualityComparer(), "A different value already has the Id '{0}'.", "A different Id has already been assigned for value '{0}'. This error may be caused by an object being reused multiple times during deserialization and can be fixed with the setting ObjectCreationHandling.Replace.");
-        return this._mappings;
-      }
-    }
-
-    protected NullValueHandling ResolvedNullValueHandling(
-      JsonObjectContract containerContract,
-      JsonProperty property)
-    {
-      return property.NullValueHandling ?? (NullValueHandling?) containerContract?.ItemNullValueHandling ?? this.Serializer._nullValueHandling;
-    }
-
-    private ErrorContext GetErrorContext(
-      object currentObject,
-      object member,
-      string path,
-      Exception error)
-    {
-      if (this._currentErrorContext == null)
-        this._currentErrorContext = new ErrorContext(currentObject, member, path, error);
-      if (this._currentErrorContext.Error != error)
-        throw new InvalidOperationException("Current error context error is different to requested error.");
-      return this._currentErrorContext;
-    }
-
-    protected void ClearErrorContext()
-    {
-      this._currentErrorContext = this._currentErrorContext != null ? (ErrorContext) null : throw new InvalidOperationException("Could not clear error context. Error context is already null.");
-    }
-
-    protected bool IsErrorHandled(
-      object currentObject,
-      JsonContract contract,
-      object keyValue,
-      IJsonLineInfo lineInfo,
-      string path,
-      Exception ex)
-    {
-      ErrorContext errorContext = this.GetErrorContext(currentObject, keyValue, path, ex);
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Error && !errorContext.Traced)
-      {
-        errorContext.Traced = true;
-        string str = this.GetType() == typeof (JsonSerializerInternalWriter) ? "Error serializing" : "Error deserializing";
-        if (contract != null)
-          str = str + " " + (object) contract.UnderlyingType;
-        string message = str + ". " + ex.Message;
-        if (!(ex is JsonException))
-          message = JsonPosition.FormatMessage(lineInfo, path, message);
-        this.TraceWriter.Trace(TraceLevel.Error, message, ex);
-      }
-      if (contract != null && currentObject != null)
-        contract.InvokeOnError(currentObject, this.Serializer.Context, errorContext);
-      if (!errorContext.Handled)
-        this.Serializer.OnError(new ErrorEventArgs(currentObject, errorContext));
-      return errorContext.Handled;
-    }
-
-    private class ReferenceEqualsEqualityComparer : IEqualityComparer<object>
-    {
-      bool IEqualityComparer<object>.Equals(object x, object y) => x == y;
-
-      int IEqualityComparer<object>.GetHashCode(object obj) => RuntimeHelpers.GetHashCode(obj);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalReader.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalReader.cs
deleted file mode 100644
index 927dd60..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalReader.cs
+++ /dev/null
@@ -1,1701 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Collections.ObjectModel;
-using System.Diagnostics;
-using System.Globalization;
-using System.Linq;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal class JsonSerializerInternalReader(JsonSerializer serializer) : JsonSerializerInternalBase(serializer)
-  {
-    public void Populate(JsonReader reader, object target)
-    {
-      ValidationUtils.ArgumentNotNull(target, nameof (target));
-      Type type = target.GetType();
-      JsonContract contract1 = this.Serializer._contractResolver.ResolveContract(type);
-      if (!reader.MoveToContent())
-        throw JsonSerializationException.Create(reader, "No JSON content found.");
-      if (reader.TokenType == JsonToken.StartArray)
-      {
-        JsonArrayContract contract2 = contract1.ContractType == JsonContractType.Array ? (JsonArrayContract) contract1 : throw JsonSerializationException.Create(reader, "Cannot populate JSON array onto type '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type));
-        this.PopulateList(contract2.ShouldCreateWrapper ? (IList) contract2.CreateWrapper(target) : (IList) target, reader, contract2, (JsonProperty) null, (string) null);
-      }
-      else
-      {
-        if (reader.TokenType != JsonToken.StartObject)
-          throw JsonSerializationException.Create(reader, "Unexpected initial token '{0}' when populating object. Expected JSON object or array.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reader.TokenType));
-        reader.ReadAndAssert();
-        string id = (string) null;
-        if (this.Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$id", StringComparison.Ordinal))
-        {
-          reader.ReadAndAssert();
-          id = reader.Value?.ToString();
-          reader.ReadAndAssert();
-        }
-        if (contract1.ContractType == JsonContractType.Dictionary)
-        {
-          JsonDictionaryContract contract3 = (JsonDictionaryContract) contract1;
-          this.PopulateDictionary(contract3.ShouldCreateWrapper ? (IDictionary) contract3.CreateWrapper(target) : (IDictionary) target, reader, contract3, (JsonProperty) null, id);
-        }
-        else
-        {
-          if (contract1.ContractType != JsonContractType.Object)
-            throw JsonSerializationException.Create(reader, "Cannot populate JSON object onto type '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type));
-          this.PopulateObject(target, reader, (JsonObjectContract) contract1, (JsonProperty) null, id);
-        }
-      }
-    }
-
-    private JsonContract GetContractSafe(Type type)
-    {
-      return type == null ? (JsonContract) null : this.Serializer._contractResolver.ResolveContract(type);
-    }
-
-    public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent)
-    {
-      if (reader == null)
-        throw new ArgumentNullException(nameof (reader));
-      JsonContract contractSafe = this.GetContractSafe(objectType);
-      try
-      {
-        JsonConverter converter = this.GetConverter(contractSafe, (JsonConverter) null, (JsonContainerContract) null, (JsonProperty) null);
-        if (reader.TokenType == JsonToken.None && !reader.ReadForType(contractSafe, converter != null))
-        {
-          if (contractSafe != null && !contractSafe.IsNullable)
-            throw JsonSerializationException.Create(reader, "No JSON content found and type '{0}' is not nullable.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contractSafe.UnderlyingType));
-          return (object) null;
-        }
-        object obj = converter == null || !converter.CanRead ? this.CreateValueInternal(reader, objectType, contractSafe, (JsonProperty) null, (JsonContainerContract) null, (JsonProperty) null, (object) null) : this.DeserializeConvertable(converter, reader, objectType, (object) null);
-        if (checkAdditionalContent)
-        {
-          while (reader.Read())
-          {
-            if (reader.TokenType != JsonToken.Comment)
-              throw JsonSerializationException.Create(reader, "Additional text found in JSON string after finishing deserializing object.");
-          }
-        }
-        return obj;
-      }
-      catch (Exception ex)
-      {
-        if (this.IsErrorHandled((object) null, contractSafe, (object) null, reader as IJsonLineInfo, reader.Path, ex))
-        {
-          this.HandleError(reader, false, 0);
-          return (object) null;
-        }
-        this.ClearErrorContext();
-        throw;
-      }
-    }
-
-    private JsonSerializerProxy GetInternalSerializer()
-    {
-      if (this.InternalSerializer == null)
-        this.InternalSerializer = new JsonSerializerProxy(this);
-      return this.InternalSerializer;
-    }
-
-    private JToken CreateJToken(JsonReader reader, JsonContract contract)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      if (contract != null)
-      {
-        if (contract.UnderlyingType == typeof (JRaw))
-          return (JToken) JRaw.Create(reader);
-        if (reader.TokenType == JsonToken.Null && contract.UnderlyingType != typeof (JValue) && contract.UnderlyingType != typeof (JToken))
-          return (JToken) null;
-      }
-      using (JTokenWriter jtokenWriter = new JTokenWriter())
-      {
-        jtokenWriter.WriteToken(reader);
-        return jtokenWriter.Token;
-      }
-    }
-
-    private JToken CreateJObject(JsonReader reader)
-    {
-      ValidationUtils.ArgumentNotNull((object) reader, nameof (reader));
-      using (JTokenWriter jtokenWriter = new JTokenWriter())
-      {
-        jtokenWriter.WriteStartObject();
-        do
-        {
-          if (reader.TokenType == JsonToken.PropertyName)
-          {
-            string str = (string) reader.Value;
-            if (reader.ReadAndMoveToContent())
-            {
-              if (!this.CheckPropertyName(reader, str))
-              {
-                jtokenWriter.WritePropertyName(str);
-                jtokenWriter.WriteToken(reader, true, true, false);
-              }
-            }
-            else
-              break;
-          }
-          else if (reader.TokenType != JsonToken.Comment)
-          {
-            jtokenWriter.WriteEndObject();
-            return jtokenWriter.Token;
-          }
-        }
-        while (reader.Read());
-        throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
-      }
-    }
-
-    private object CreateValueInternal(
-      JsonReader reader,
-      Type objectType,
-      JsonContract contract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerMember,
-      object existingValue)
-    {
-      if (contract != null && contract.ContractType == JsonContractType.Linq)
-        return (object) this.CreateJToken(reader, contract);
-      do
-      {
-        switch (reader.TokenType)
-        {
-          case JsonToken.StartObject:
-            return this.CreateObject(reader, objectType, contract, member, containerContract, containerMember, existingValue);
-          case JsonToken.StartArray:
-            return this.CreateList(reader, objectType, contract, member, existingValue, (string) null);
-          case JsonToken.StartConstructor:
-            string str = reader.Value.ToString();
-            return this.EnsureType(reader, (object) str, CultureInfo.InvariantCulture, contract, objectType);
-          case JsonToken.Comment:
-            continue;
-          case JsonToken.Raw:
-            return (object) new JRaw((object) (string) reader.Value);
-          case JsonToken.Integer:
-          case JsonToken.Float:
-          case JsonToken.Boolean:
-          case JsonToken.Date:
-          case JsonToken.Bytes:
-            return this.EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
-          case JsonToken.String:
-            string s = (string) reader.Value;
-            if (JsonSerializerInternalReader.CoerceEmptyStringToNull(objectType, contract, s))
-              return (object) null;
-            return objectType == typeof (byte[]) ? (object) Convert.FromBase64String(s) : this.EnsureType(reader, (object) s, CultureInfo.InvariantCulture, contract, objectType);
-          case JsonToken.Null:
-          case JsonToken.Undefined:
-            return objectType == typeof (DBNull) ? (object) DBNull.Value : this.EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
-          default:
-            throw JsonSerializationException.Create(reader, "Unexpected token while deserializing object: " + (object) reader.TokenType);
-        }
-      }
-      while (reader.Read());
-      throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
-    }
-
-    private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s)
-    {
-      return string.IsNullOrEmpty(s) && objectType != null && objectType != typeof (string) && objectType != typeof (object) && contract != null && contract.IsNullable;
-    }
-
-    internal string GetExpectedDescription(JsonContract contract)
-    {
-      switch (contract.ContractType)
-      {
-        case JsonContractType.Object:
-        case JsonContractType.Dictionary:
-        case JsonContractType.Serializable:
-          return "JSON object (e.g. {\"name\":\"value\"})";
-        case JsonContractType.Array:
-          return "JSON array (e.g. [1,2,3])";
-        case JsonContractType.Primitive:
-          return "JSON primitive value (e.g. string, number, boolean, null)";
-        case JsonContractType.String:
-          return "JSON string value";
-        default:
-          throw new ArgumentOutOfRangeException();
-      }
-    }
-
-    private JsonConverter GetConverter(
-      JsonContract contract,
-      JsonConverter memberConverter,
-      JsonContainerContract containerContract,
-      JsonProperty containerProperty)
-    {
-      JsonConverter converter = (JsonConverter) null;
-      if (memberConverter != null)
-        converter = memberConverter;
-      else if (containerProperty?.ItemConverter != null)
-        converter = containerProperty.ItemConverter;
-      else if (containerContract?.ItemConverter != null)
-        converter = containerContract.ItemConverter;
-      else if (contract != null)
-      {
-        if (contract.Converter != null)
-        {
-          converter = contract.Converter;
-        }
-        else
-        {
-          JsonConverter matchingConverter;
-          if ((matchingConverter = this.Serializer.GetMatchingConverter(contract.UnderlyingType)) != null)
-            converter = matchingConverter;
-          else if (contract.InternalConverter != null)
-            converter = contract.InternalConverter;
-        }
-      }
-      return converter;
-    }
-
-    private object CreateObject(
-      JsonReader reader,
-      Type objectType,
-      JsonContract contract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerMember,
-      object existingValue)
-    {
-      Type objectType1 = objectType;
-      string id;
-      if (this.Serializer.MetadataPropertyHandling == MetadataPropertyHandling.Ignore)
-      {
-        reader.ReadAndAssert();
-        id = (string) null;
-      }
-      else if (this.Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
-      {
-        if (!(reader is JTokenReader reader1))
-        {
-          reader1 = (JTokenReader) JToken.ReadFrom(reader).CreateReader();
-          reader1.Culture = reader.Culture;
-          reader1.DateFormatString = reader.DateFormatString;
-          reader1.DateParseHandling = reader.DateParseHandling;
-          reader1.DateTimeZoneHandling = reader.DateTimeZoneHandling;
-          reader1.FloatParseHandling = reader.FloatParseHandling;
-          reader1.SupportMultipleContent = reader.SupportMultipleContent;
-          reader1.ReadAndAssert();
-          reader = (JsonReader) reader1;
-        }
-        object newValue;
-        if (this.ReadMetadataPropertiesToken(reader1, ref objectType1, ref contract, member, containerContract, containerMember, existingValue, out newValue, out id))
-          return newValue;
-      }
-      else
-      {
-        reader.ReadAndAssert();
-        object newValue;
-        if (this.ReadMetadataProperties(reader, ref objectType1, ref contract, member, containerContract, containerMember, existingValue, out newValue, out id))
-          return newValue;
-      }
-      if (this.HasNoDefinedType(contract))
-        return (object) this.CreateJObject(reader);
-      switch (contract.ContractType)
-      {
-        case JsonContractType.Object:
-          bool createdFromNonDefaultCreator1 = false;
-          JsonObjectContract jsonObjectContract = (JsonObjectContract) contract;
-          object newObject = existingValue == null || objectType1 != objectType && !objectType1.IsAssignableFrom(existingValue.GetType()) ? this.CreateNewObject(reader, jsonObjectContract, member, containerMember, id, out createdFromNonDefaultCreator1) : existingValue;
-          return createdFromNonDefaultCreator1 ? newObject : this.PopulateObject(newObject, reader, jsonObjectContract, member, id);
-        case JsonContractType.Primitive:
-          JsonPrimitiveContract contract1 = (JsonPrimitiveContract) contract;
-          if (this.Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$value", StringComparison.Ordinal))
-          {
-            reader.ReadAndAssert();
-            if (reader.TokenType == JsonToken.StartObject)
-              throw JsonSerializationException.Create(reader, "Unexpected token when deserializing primitive value: " + (object) reader.TokenType);
-            object valueInternal = this.CreateValueInternal(reader, objectType1, (JsonContract) contract1, member, (JsonContainerContract) null, (JsonProperty) null, existingValue);
-            reader.ReadAndAssert();
-            return valueInternal;
-          }
-          break;
-        case JsonContractType.Dictionary:
-          JsonDictionaryContract contract2 = (JsonDictionaryContract) contract;
-          object obj;
-          if (existingValue == null)
-          {
-            bool createdFromNonDefaultCreator2;
-            IDictionary newDictionary = this.CreateNewDictionary(reader, contract2, out createdFromNonDefaultCreator2);
-            if (createdFromNonDefaultCreator2)
-            {
-              if (id != null)
-                throw JsonSerializationException.Create(reader, "Cannot preserve reference to readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-              if (contract.OnSerializingCallbacks.Count > 0)
-                throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-              if (contract.OnErrorCallbacks.Count > 0)
-                throw JsonSerializationException.Create(reader, "Cannot call OnError on readonly list, or dictionary created from a non-default constructor: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-              if (!contract2.HasParameterizedCreatorInternal)
-                throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size dictionary: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-            }
-            this.PopulateDictionary(newDictionary, reader, contract2, member, id);
-            if (createdFromNonDefaultCreator2)
-              return (contract2.OverrideCreator ?? contract2.ParameterizedCreator)((object) newDictionary);
-            if (newDictionary is IWrappedDictionary)
-              return ((IWrappedDictionary) newDictionary).UnderlyingDictionary;
-            obj = (object) newDictionary;
-          }
-          else
-            obj = this.PopulateDictionary(contract2.ShouldCreateWrapper || !(existingValue is IDictionary) ? (IDictionary) contract2.CreateWrapper(existingValue) : (IDictionary) existingValue, reader, contract2, member, id);
-          return obj;
-        case JsonContractType.Serializable:
-          JsonISerializableContract contract3 = (JsonISerializableContract) contract;
-          return this.CreateISerializable(reader, contract3, member, id);
-      }
-      string message = ("Cannot deserialize the current JSON object (e.g. {{\"name\":\"value\"}}) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type so that it is a normal .NET type (e.g. not a primitive type like integer, not a collection type like an array or List<T>) that can be deserialized from a JSON object. JsonObjectAttribute can also be added to the type to force it to deserialize from a JSON object." + Environment.NewLine).FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType1, (object) this.GetExpectedDescription(contract));
-      throw JsonSerializationException.Create(reader, message);
-    }
-
-    private bool ReadMetadataPropertiesToken(
-      JTokenReader reader,
-      ref Type objectType,
-      ref JsonContract contract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerMember,
-      object existingValue,
-      out object newValue,
-      out string id)
-    {
-      id = (string) null;
-      newValue = (object) null;
-      if (reader.TokenType == JsonToken.StartObject)
-      {
-        JObject currentToken = (JObject) reader.CurrentToken;
-        JToken lineInfo1 = currentToken["$ref"];
-        if (lineInfo1 != null)
-        {
-          JToken jtoken = lineInfo1.Type == JTokenType.String || lineInfo1.Type == JTokenType.Null ? (JToken) lineInfo1.Parent : throw JsonSerializationException.Create((IJsonLineInfo) lineInfo1, lineInfo1.Path, "JSON reference {0} property must have a string or null value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) "$ref"), (Exception) null);
-          JToken lineInfo2 = (JToken) null;
-          if (jtoken.Next != null)
-            lineInfo2 = jtoken.Next;
-          else if (jtoken.Previous != null)
-            lineInfo2 = jtoken.Previous;
-          string reference = (string) lineInfo1;
-          if (reference != null)
-          {
-            if (lineInfo2 != null)
-              throw JsonSerializationException.Create((IJsonLineInfo) lineInfo2, lineInfo2.Path, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) "$ref"), (Exception) null);
-            newValue = this.Serializer.GetReferenceResolver().ResolveReference((object) this, reference);
-            if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-              this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage((IJsonLineInfo) reader, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reference, (object) newValue.GetType())), (Exception) null);
-            reader.Skip();
-            return true;
-          }
-        }
-        JToken jtoken1 = currentToken["$type"];
-        if (jtoken1 != null)
-        {
-          string qualifiedTypeName = (string) jtoken1;
-          JsonReader reader1 = jtoken1.CreateReader();
-          reader1.ReadAndAssert();
-          this.ResolveTypeName(reader1, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
-          if (currentToken["$value"] != null)
-          {
-            while (true)
-            {
-              reader.ReadAndAssert();
-              if (reader.TokenType != JsonToken.PropertyName || !((string) reader.Value == "$value"))
-              {
-                reader.ReadAndAssert();
-                reader.Skip();
-              }
-              else
-                break;
-            }
-            return false;
-          }
-        }
-        JToken jtoken2 = currentToken["$id"];
-        if (jtoken2 != null)
-          id = (string) jtoken2;
-        JToken jtoken3 = currentToken["$values"];
-        if (jtoken3 != null)
-        {
-          JsonReader reader2 = jtoken3.CreateReader();
-          reader2.ReadAndAssert();
-          newValue = this.CreateList(reader2, objectType, contract, member, existingValue, id);
-          reader.Skip();
-          return true;
-        }
-      }
-      reader.ReadAndAssert();
-      return false;
-    }
-
-    private bool ReadMetadataProperties(
-      JsonReader reader,
-      ref Type objectType,
-      ref JsonContract contract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerMember,
-      object existingValue,
-      out object newValue,
-      out string id)
-    {
-      id = (string) null;
-      newValue = (object) null;
-      if (reader.TokenType == JsonToken.PropertyName)
-      {
-        string str = reader.Value.ToString();
-        if (str.Length > 0 && str[0] == '$')
-        {
-          bool flag;
-          do
-          {
-            string a = reader.Value.ToString();
-            if (string.Equals(a, "$ref", StringComparison.Ordinal))
-            {
-              reader.ReadAndAssert();
-              if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null)
-                throw JsonSerializationException.Create(reader, "JSON reference {0} property must have a string or null value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) "$ref"));
-              string reference = reader.Value?.ToString();
-              reader.ReadAndAssert();
-              if (reference != null)
-              {
-                if (reader.TokenType == JsonToken.PropertyName)
-                  throw JsonSerializationException.Create(reader, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) "$ref"));
-                newValue = this.Serializer.GetReferenceResolver().ResolveReference((object) this, reference);
-                if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-                  this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reference, (object) newValue.GetType())), (Exception) null);
-                return true;
-              }
-              flag = true;
-            }
-            else if (string.Equals(a, "$type", StringComparison.Ordinal))
-            {
-              reader.ReadAndAssert();
-              string qualifiedTypeName = reader.Value.ToString();
-              this.ResolveTypeName(reader, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
-              reader.ReadAndAssert();
-              flag = true;
-            }
-            else if (string.Equals(a, "$id", StringComparison.Ordinal))
-            {
-              reader.ReadAndAssert();
-              id = reader.Value?.ToString();
-              reader.ReadAndAssert();
-              flag = true;
-            }
-            else
-            {
-              if (string.Equals(a, "$values", StringComparison.Ordinal))
-              {
-                reader.ReadAndAssert();
-                object list = this.CreateList(reader, objectType, contract, member, existingValue, id);
-                reader.ReadAndAssert();
-                newValue = list;
-                return true;
-              }
-              flag = false;
-            }
-          }
-          while (flag && reader.TokenType == JsonToken.PropertyName);
-        }
-      }
-      return false;
-    }
-
-    private void ResolveTypeName(
-      JsonReader reader,
-      ref Type objectType,
-      ref JsonContract contract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerMember,
-      string qualifiedTypeName)
-    {
-      if (((int) member?.TypeNameHandling ?? (int) containerContract?.ItemTypeNameHandling ?? (int) containerMember?.ItemTypeNameHandling ?? (int) this.Serializer._typeNameHandling) == 0)
-        return;
-      TypeNameKey typeNameKey = ReflectionUtils.SplitFullyQualifiedTypeName(qualifiedTypeName);
-      Type type;
-      try
-      {
-        type = this.Serializer._serializationBinder.BindToType(typeNameKey.AssemblyName, typeNameKey.TypeName);
-      }
-      catch (Exception ex)
-      {
-        throw JsonSerializationException.Create(reader, "Error resolving type specified in JSON '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) qualifiedTypeName), ex);
-      }
-      if (type == null)
-        throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' was not resolved.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) qualifiedTypeName));
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-        this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved type '{0}' to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) qualifiedTypeName, (object) type)), (Exception) null);
-      objectType = objectType == null || objectType.IsAssignableFrom(type) ? type : throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' is not compatible with '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type.AssemblyQualifiedName, (object) objectType.AssemblyQualifiedName));
-      contract = this.GetContractSafe(type);
-    }
-
-    private JsonArrayContract EnsureArrayContract(
-      JsonReader reader,
-      Type objectType,
-      JsonContract contract)
-    {
-      if (contract == null)
-        throw JsonSerializationException.Create(reader, "Could not resolve type '{0}' to a JsonContract.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType));
-      if (contract is JsonArrayContract jsonArrayContract)
-        return jsonArrayContract;
-      string message = ("Cannot deserialize the current JSON array (e.g. [1,2,3]) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection, IList) like List<T> that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array." + Environment.NewLine).FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType, (object) this.GetExpectedDescription(contract));
-      throw JsonSerializationException.Create(reader, message);
-    }
-
-    private object CreateList(
-      JsonReader reader,
-      Type objectType,
-      JsonContract contract,
-      JsonProperty member,
-      object existingValue,
-      string id)
-    {
-      if (this.HasNoDefinedType(contract))
-        return (object) this.CreateJToken(reader, contract);
-      JsonArrayContract contract1 = this.EnsureArrayContract(reader, objectType, contract);
-      object list1;
-      if (existingValue == null)
-      {
-        bool createdFromNonDefaultCreator;
-        IList list2 = this.CreateNewList(reader, contract1, out createdFromNonDefaultCreator);
-        if (createdFromNonDefaultCreator)
-        {
-          if (id != null)
-            throw JsonSerializationException.Create(reader, "Cannot preserve reference to array or readonly list, or list created from a non-default constructor: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-          if (contract.OnSerializingCallbacks.Count > 0)
-            throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-          if (contract.OnErrorCallbacks.Count > 0)
-            throw JsonSerializationException.Create(reader, "Cannot call OnError on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-          if (!contract1.HasParameterizedCreatorInternal && !contract1.IsArray)
-            throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size list: {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-        }
-        if (!contract1.IsMultidimensionalArray)
-          this.PopulateList(list2, reader, contract1, member, id);
-        else
-          this.PopulateMultidimensionalArray(list2, reader, contract1, member, id);
-        if (createdFromNonDefaultCreator)
-        {
-          if (contract1.IsMultidimensionalArray)
-            list2 = (IList) CollectionUtils.ToMultidimensionalArray(list2, contract1.CollectionItemType, contract.CreatedType.GetArrayRank());
-          else if (contract1.IsArray)
-          {
-            Array instance = Array.CreateInstance(contract1.CollectionItemType, list2.Count);
-            list2.CopyTo(instance, 0);
-            list2 = (IList) instance;
-          }
-          else
-            return (contract1.OverrideCreator ?? contract1.ParameterizedCreator)((object) list2);
-        }
-        else if (list2 is IWrappedCollection)
-          return ((IWrappedCollection) list2).UnderlyingCollection;
-        list1 = (object) list2;
-      }
-      else
-      {
-        if (!contract1.CanDeserialize)
-          throw JsonSerializationException.Create(reader, "Cannot populate list type {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.CreatedType));
-        list1 = this.PopulateList(contract1.ShouldCreateWrapper || !(existingValue is IList) ? (IList) contract1.CreateWrapper(existingValue) : (IList) existingValue, reader, contract1, member, id);
-      }
-      return list1;
-    }
-
-    private bool HasNoDefinedType(JsonContract contract)
-    {
-      return contract == null || contract.UnderlyingType == typeof (object) || contract.ContractType == JsonContractType.Linq;
-    }
-
-    private object EnsureType(
-      JsonReader reader,
-      object value,
-      CultureInfo culture,
-      JsonContract contract,
-      Type targetType)
-    {
-      if (targetType == null || ReflectionUtils.GetObjectType(value) == targetType)
-        return value;
-      if (value == null && contract.IsNullable)
-        return (object) null;
-      try
-      {
-        if (!contract.IsConvertable)
-          return ConvertUtils.ConvertOrCast(value, culture, contract.NonNullableUnderlyingType);
-        JsonPrimitiveContract primitiveContract = (JsonPrimitiveContract) contract;
-        if (contract.IsEnum)
-        {
-          if (value is string)
-            return EnumUtils.ParseEnum(contract.NonNullableUnderlyingType, value.ToString(), false);
-          if (ConvertUtils.IsInteger((object) primitiveContract.TypeCode))
-            return Enum.ToObject(contract.NonNullableUnderlyingType, value);
-        }
-        return Convert.ChangeType(value, contract.NonNullableUnderlyingType, (IFormatProvider) culture);
-      }
-      catch (Exception ex)
-      {
-        throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) MiscellaneousUtils.FormatValueForPrint(value), (object) targetType), ex);
-      }
-    }
-
-    private bool SetPropertyValue(
-      JsonProperty property,
-      JsonConverter propertyConverter,
-      JsonContainerContract containerContract,
-      JsonProperty containerProperty,
-      JsonReader reader,
-      object target)
-    {
-      bool useExistingValue;
-      object currentValue;
-      JsonContract propertyContract;
-      bool gottenCurrentValue;
-      if (this.CalculatePropertyDetails(property, ref propertyConverter, containerContract, containerProperty, reader, target, out useExistingValue, out currentValue, out propertyContract, out gottenCurrentValue))
-        return false;
-      object obj;
-      if (propertyConverter != null && propertyConverter.CanRead)
-      {
-        if (!gottenCurrentValue && target != null && property.Readable)
-          currentValue = property.ValueProvider.GetValue(target);
-        obj = this.DeserializeConvertable(propertyConverter, reader, property.PropertyType, currentValue);
-      }
-      else
-        obj = this.CreateValueInternal(reader, property.PropertyType, propertyContract, property, containerContract, containerProperty, useExistingValue ? currentValue : (object) null);
-      if (useExistingValue && obj == currentValue || !this.ShouldSetPropertyValue(property, containerContract as JsonObjectContract, obj))
-        return useExistingValue;
-      property.ValueProvider.SetValue(target, obj);
-      if (property.SetIsSpecified != null)
-      {
-        if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-          this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "IsSpecified for property '{0}' on {1} set to true.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName, (object) property.DeclaringType)), (Exception) null);
-        property.SetIsSpecified(target, (object) true);
-      }
-      return true;
-    }
-
-    private bool CalculatePropertyDetails(
-      JsonProperty property,
-      ref JsonConverter propertyConverter,
-      JsonContainerContract containerContract,
-      JsonProperty containerProperty,
-      JsonReader reader,
-      object target,
-      out bool useExistingValue,
-      out object currentValue,
-      out JsonContract propertyContract,
-      out bool gottenCurrentValue)
-    {
-      currentValue = (object) null;
-      useExistingValue = false;
-      propertyContract = (JsonContract) null;
-      gottenCurrentValue = false;
-      if (property.Ignored)
-        return true;
-      JsonToken tokenType = reader.TokenType;
-      if (property.PropertyContract == null)
-        property.PropertyContract = this.GetContractSafe(property.PropertyType);
-      if (property.ObjectCreationHandling.GetValueOrDefault(this.Serializer._objectCreationHandling) != ObjectCreationHandling.Replace && (tokenType == JsonToken.StartArray || tokenType == JsonToken.StartObject || propertyConverter != null) && property.Readable)
-      {
-        currentValue = property.ValueProvider.GetValue(target);
-        gottenCurrentValue = true;
-        if (currentValue != null)
-        {
-          propertyContract = this.GetContractSafe(currentValue.GetType());
-          useExistingValue = !propertyContract.IsReadOnlyOrFixedSize && !propertyContract.UnderlyingType.IsValueType();
-        }
-      }
-      if (!property.Writable && !useExistingValue || tokenType == JsonToken.Null && this.ResolvedNullValueHandling(containerContract as JsonObjectContract, property) == NullValueHandling.Ignore || this.HasFlag(property.DefaultValueHandling.GetValueOrDefault(this.Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !this.HasFlag(property.DefaultValueHandling.GetValueOrDefault(this.Serializer._defaultValueHandling), DefaultValueHandling.Populate) && JsonTokenUtils.IsPrimitiveToken(tokenType) && MiscellaneousUtils.ValueEquals(reader.Value, property.GetResolvedDefaultValue()))
-        return true;
-      if (currentValue == null)
-      {
-        propertyContract = property.PropertyContract;
-      }
-      else
-      {
-        propertyContract = this.GetContractSafe(currentValue.GetType());
-        if (propertyContract != property.PropertyContract)
-          propertyConverter = this.GetConverter(propertyContract, property.Converter, containerContract, containerProperty);
-      }
-      return false;
-    }
-
-    private void AddReference(JsonReader reader, string id, object value)
-    {
-      try
-      {
-        if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-          this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Read object reference Id '{0}' for {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) id, (object) value.GetType())), (Exception) null);
-        this.Serializer.GetReferenceResolver().AddReference((object) this, id, value);
-      }
-      catch (Exception ex)
-      {
-        throw JsonSerializationException.Create(reader, "Error reading object reference '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) id), ex);
-      }
-    }
-
-    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
-    {
-      return (value & flag) == flag;
-    }
-
-    private bool ShouldSetPropertyValue(
-      JsonProperty property,
-      JsonObjectContract contract,
-      object value)
-    {
-      return (value != null || this.ResolvedNullValueHandling(contract, property) != NullValueHandling.Ignore) && (!this.HasFlag(property.DefaultValueHandling.GetValueOrDefault(this.Serializer._defaultValueHandling), DefaultValueHandling.Ignore) || this.HasFlag(property.DefaultValueHandling.GetValueOrDefault(this.Serializer._defaultValueHandling), DefaultValueHandling.Populate) || !MiscellaneousUtils.ValueEquals(value, property.GetResolvedDefaultValue())) && property.Writable;
-    }
-
-    private IList CreateNewList(
-      JsonReader reader,
-      JsonArrayContract contract,
-      out bool createdFromNonDefaultCreator)
-    {
-      if (!contract.CanDeserialize)
-        throw JsonSerializationException.Create(reader, "Cannot create and populate list type {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.CreatedType));
-      if (contract.OverrideCreator != null)
-      {
-        if (contract.HasParameterizedCreator)
-        {
-          createdFromNonDefaultCreator = true;
-          return contract.CreateTemporaryCollection();
-        }
-        object list = contract.OverrideCreator();
-        if (contract.ShouldCreateWrapper)
-          list = (object) contract.CreateWrapper(list);
-        createdFromNonDefaultCreator = false;
-        return (IList) list;
-      }
-      if (contract.IsReadOnlyOrFixedSize)
-      {
-        createdFromNonDefaultCreator = true;
-        IList list = contract.CreateTemporaryCollection();
-        if (contract.ShouldCreateWrapper)
-          list = (IList) contract.CreateWrapper((object) list);
-        return list;
-      }
-      if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || this.Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
-      {
-        object list = contract.DefaultCreator();
-        if (contract.ShouldCreateWrapper)
-          list = (object) contract.CreateWrapper(list);
-        createdFromNonDefaultCreator = false;
-        return (IList) list;
-      }
-      if (contract.HasParameterizedCreatorInternal)
-      {
-        createdFromNonDefaultCreator = true;
-        return contract.CreateTemporaryCollection();
-      }
-      if (!contract.IsInstantiable)
-        throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-      throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-    }
-
-    private IDictionary CreateNewDictionary(
-      JsonReader reader,
-      JsonDictionaryContract contract,
-      out bool createdFromNonDefaultCreator)
-    {
-      if (contract.OverrideCreator != null)
-      {
-        if (contract.HasParameterizedCreator)
-        {
-          createdFromNonDefaultCreator = true;
-          return contract.CreateTemporaryDictionary();
-        }
-        createdFromNonDefaultCreator = false;
-        return (IDictionary) contract.OverrideCreator();
-      }
-      if (contract.IsReadOnlyOrFixedSize)
-      {
-        createdFromNonDefaultCreator = true;
-        return contract.CreateTemporaryDictionary();
-      }
-      if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || this.Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
-      {
-        object dictionary = contract.DefaultCreator();
-        if (contract.ShouldCreateWrapper)
-          dictionary = (object) contract.CreateWrapper(dictionary);
-        createdFromNonDefaultCreator = false;
-        return (IDictionary) dictionary;
-      }
-      if (contract.HasParameterizedCreatorInternal)
-      {
-        createdFromNonDefaultCreator = true;
-        return contract.CreateTemporaryDictionary();
-      }
-      if (!contract.IsInstantiable)
-        throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-      throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType));
-    }
-
-    private void OnDeserializing(JsonReader reader, JsonContract contract, object value)
-    {
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-        this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType)), (Exception) null);
-      contract.InvokeOnDeserializing(value, this.Serializer._context);
-    }
-
-    private void OnDeserialized(JsonReader reader, JsonContract contract, object value)
-    {
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-        this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType)), (Exception) null);
-      contract.InvokeOnDeserialized(value, this.Serializer._context);
-    }
-
-    private object PopulateDictionary(
-      IDictionary dictionary,
-      JsonReader reader,
-      JsonDictionaryContract contract,
-      JsonProperty containerProperty,
-      string id)
-    {
-      object currentObject = dictionary is IWrappedDictionary wrappedDictionary ? wrappedDictionary.UnderlyingDictionary : (object) dictionary;
-      if (id != null)
-        this.AddReference(reader, id, currentObject);
-      this.OnDeserializing(reader, (JsonContract) contract, currentObject);
-      int depth = reader.Depth;
-      if (contract.KeyContract == null)
-        contract.KeyContract = this.GetContractSafe(contract.DictionaryKeyType);
-      if (contract.ItemContract == null)
-        contract.ItemContract = this.GetContractSafe(contract.DictionaryValueType);
-      JsonConverter converter = contract.ItemConverter ?? this.GetConverter(contract.ItemContract, (JsonConverter) null, (JsonContainerContract) contract, containerProperty);
-      PrimitiveTypeCode primitiveTypeCode = contract.KeyContract is JsonPrimitiveContract keyContract ? keyContract.TypeCode : PrimitiveTypeCode.Empty;
-      bool flag = false;
-      do
-      {
-        switch (reader.TokenType)
-        {
-          case JsonToken.PropertyName:
-            object obj1 = reader.Value;
-            if (!this.CheckPropertyName(reader, obj1.ToString()))
-            {
-              try
-              {
-                try
-                {
-                  switch (primitiveTypeCode)
-                  {
-                    case PrimitiveTypeCode.DateTime:
-                    case PrimitiveTypeCode.DateTimeNullable:
-                      DateTime dt1;
-                      obj1 = DateTimeUtils.TryParseDateTime(obj1.ToString(), reader.DateTimeZoneHandling, reader.DateFormatString, reader.Culture, out dt1) ? (object) dt1 : this.EnsureType(reader, obj1, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType);
-                      break;
-                    case PrimitiveTypeCode.DateTimeOffset:
-                    case PrimitiveTypeCode.DateTimeOffsetNullable:
-                      DateTimeOffset dt2;
-                      obj1 = DateTimeUtils.TryParseDateTimeOffset(obj1.ToString(), reader.DateFormatString, reader.Culture, out dt2) ? (object) dt2 : this.EnsureType(reader, obj1, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType);
-                      break;
-                    default:
-                      obj1 = this.EnsureType(reader, obj1, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType);
-                      break;
-                  }
-                }
-                catch (Exception ex)
-                {
-                  throw JsonSerializationException.Create(reader, "Could not convert string '{0}' to dictionary key type '{1}'. Create a TypeConverter to convert from the string to the key type object.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, reader.Value, (object) contract.DictionaryKeyType), ex);
-                }
-                if (!reader.ReadForType(contract.ItemContract, converter != null))
-                  throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
-                object obj2 = converter == null || !converter.CanRead ? this.CreateValueInternal(reader, contract.DictionaryValueType, contract.ItemContract, (JsonProperty) null, (JsonContainerContract) contract, containerProperty, (object) null) : this.DeserializeConvertable(converter, reader, contract.DictionaryValueType, (object) null);
-                dictionary[obj1] = obj2;
-                goto case JsonToken.Comment;
-              }
-              catch (Exception ex)
-              {
-                if (this.IsErrorHandled(currentObject, (JsonContract) contract, obj1, reader as IJsonLineInfo, reader.Path, ex))
-                {
-                  this.HandleError(reader, true, depth);
-                  goto case JsonToken.Comment;
-                }
-                else
-                  throw;
-              }
-            }
-            else
-              goto case JsonToken.Comment;
-          case JsonToken.Comment:
-            continue;
-          case JsonToken.EndObject:
-            flag = true;
-            goto case JsonToken.Comment;
-          default:
-            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + (object) reader.TokenType);
-        }
-      }
-      while (!flag && reader.Read());
-      if (!flag)
-        this.ThrowUnexpectedEndException(reader, (JsonContract) contract, currentObject, "Unexpected end when deserializing object.");
-      this.OnDeserialized(reader, (JsonContract) contract, currentObject);
-      return currentObject;
-    }
-
-    private object PopulateMultidimensionalArray(
-      IList list,
-      JsonReader reader,
-      JsonArrayContract contract,
-      JsonProperty containerProperty,
-      string id)
-    {
-      int arrayRank = contract.UnderlyingType.GetArrayRank();
-      if (id != null)
-        this.AddReference(reader, id, (object) list);
-      this.OnDeserializing(reader, (JsonContract) contract, (object) list);
-      JsonContract contractSafe = this.GetContractSafe(contract.CollectionItemType);
-      JsonConverter converter = this.GetConverter(contractSafe, (JsonConverter) null, (JsonContainerContract) contract, containerProperty);
-      int? nullable1 = new int?();
-      Stack<IList> listStack = new Stack<IList>();
-      listStack.Push(list);
-      IList list1 = list;
-      bool flag = false;
-      do
-      {
-        int depth = reader.Depth;
-        if (listStack.Count == arrayRank)
-        {
-          try
-          {
-            if (reader.ReadForType(contractSafe, converter != null))
-            {
-              switch (reader.TokenType)
-              {
-                case JsonToken.Comment:
-                  break;
-                case JsonToken.EndArray:
-                  listStack.Pop();
-                  list1 = listStack.Peek();
-                  nullable1 = new int?();
-                  break;
-                default:
-                  object obj = converter == null || !converter.CanRead ? this.CreateValueInternal(reader, contract.CollectionItemType, contractSafe, (JsonProperty) null, (JsonContainerContract) contract, containerProperty, (object) null) : this.DeserializeConvertable(converter, reader, contract.CollectionItemType, (object) null);
-                  list1.Add(obj);
-                  break;
-              }
-            }
-            else
-              break;
-          }
-          catch (Exception ex)
-          {
-            JsonPosition position1 = reader.GetPosition(depth);
-            if (this.IsErrorHandled((object) list, (JsonContract) contract, (object) position1.Position, reader as IJsonLineInfo, reader.Path, ex))
-            {
-              this.HandleError(reader, true, depth + 1);
-              if (nullable1.HasValue)
-              {
-                int? nullable2 = nullable1;
-                int position2 = position1.Position;
-                if ((nullable2.GetValueOrDefault() == position2 ? (nullable2.HasValue ? 1 : 0) : 0) != 0)
-                  throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
-              }
-              nullable1 = new int?(position1.Position);
-            }
-            else
-              throw;
-          }
-        }
-        else if (reader.Read())
-        {
-          switch (reader.TokenType)
-          {
-            case JsonToken.StartArray:
-              IList list2 = (IList) new List<object>();
-              list1.Add((object) list2);
-              listStack.Push(list2);
-              list1 = list2;
-              break;
-            case JsonToken.Comment:
-              break;
-            case JsonToken.EndArray:
-              listStack.Pop();
-              if (listStack.Count > 0)
-              {
-                list1 = listStack.Peek();
-                break;
-              }
-              flag = true;
-              break;
-            default:
-              throw JsonSerializationException.Create(reader, "Unexpected token when deserializing multidimensional array: " + (object) reader.TokenType);
-          }
-        }
-        else
-          break;
-      }
-      while (!flag);
-      if (!flag)
-        this.ThrowUnexpectedEndException(reader, (JsonContract) contract, (object) list, "Unexpected end when deserializing array.");
-      this.OnDeserialized(reader, (JsonContract) contract, (object) list);
-      return (object) list;
-    }
-
-    private void ThrowUnexpectedEndException(
-      JsonReader reader,
-      JsonContract contract,
-      object currentObject,
-      string message)
-    {
-      try
-      {
-        throw JsonSerializationException.Create(reader, message);
-      }
-      catch (Exception ex)
-      {
-        if (this.IsErrorHandled(currentObject, contract, (object) null, reader as IJsonLineInfo, reader.Path, ex))
-          this.HandleError(reader, false, 0);
-        else
-          throw;
-      }
-    }
-
-    private object PopulateList(
-      IList list,
-      JsonReader reader,
-      JsonArrayContract contract,
-      JsonProperty containerProperty,
-      string id)
-    {
-      object currentObject = list is IWrappedCollection wrappedCollection ? wrappedCollection.UnderlyingCollection : (object) list;
-      if (id != null)
-        this.AddReference(reader, id, currentObject);
-      if (list.IsFixedSize)
-      {
-        reader.Skip();
-        return currentObject;
-      }
-      this.OnDeserializing(reader, (JsonContract) contract, currentObject);
-      int depth = reader.Depth;
-      if (contract.ItemContract == null)
-        contract.ItemContract = this.GetContractSafe(contract.CollectionItemType);
-      JsonConverter converter = this.GetConverter(contract.ItemContract, (JsonConverter) null, (JsonContainerContract) contract, containerProperty);
-      int? nullable1 = new int?();
-      bool flag = false;
-      do
-      {
-        try
-        {
-          if (reader.ReadForType(contract.ItemContract, converter != null))
-          {
-            switch (reader.TokenType)
-            {
-              case JsonToken.Comment:
-                break;
-              case JsonToken.EndArray:
-                flag = true;
-                break;
-              default:
-                object obj = converter == null || !converter.CanRead ? this.CreateValueInternal(reader, contract.CollectionItemType, contract.ItemContract, (JsonProperty) null, (JsonContainerContract) contract, containerProperty, (object) null) : this.DeserializeConvertable(converter, reader, contract.CollectionItemType, (object) null);
-                list.Add(obj);
-                break;
-            }
-          }
-          else
-            break;
-        }
-        catch (Exception ex)
-        {
-          JsonPosition position1 = reader.GetPosition(depth);
-          if (this.IsErrorHandled(currentObject, (JsonContract) contract, (object) position1.Position, reader as IJsonLineInfo, reader.Path, ex))
-          {
-            this.HandleError(reader, true, depth + 1);
-            if (nullable1.HasValue)
-            {
-              int? nullable2 = nullable1;
-              int position2 = position1.Position;
-              if ((nullable2.GetValueOrDefault() == position2 ? (nullable2.HasValue ? 1 : 0) : 0) != 0)
-                throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
-            }
-            nullable1 = new int?(position1.Position);
-          }
-          else
-            throw;
-        }
-      }
-      while (!flag);
-      if (!flag)
-        this.ThrowUnexpectedEndException(reader, (JsonContract) contract, currentObject, "Unexpected end when deserializing array.");
-      this.OnDeserialized(reader, (JsonContract) contract, currentObject);
-      return currentObject;
-    }
-
-    private object CreateISerializable(
-      JsonReader reader,
-      JsonISerializableContract contract,
-      JsonProperty member,
-      string id)
-    {
-      Type underlyingType = contract.UnderlyingType;
-      if (!JsonTypeReflector.FullyTrusted)
-      {
-        string message = ("Type '{0}' implements ISerializable but cannot be deserialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine).FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) underlyingType);
-        throw JsonSerializationException.Create(reader, message);
-      }
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-        this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using ISerializable constructor.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType)), (Exception) null);
-      SerializationInfo currentObject = new SerializationInfo(contract.UnderlyingType, (IFormatterConverter) new JsonFormatterConverter(this, contract, member));
-      bool flag = false;
-      do
-      {
-        switch (reader.TokenType)
-        {
-          case JsonToken.PropertyName:
-            string name = reader.Value.ToString();
-            if (!reader.Read())
-              throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) name));
-            currentObject.AddValue(name, (object) JToken.ReadFrom(reader));
-            goto case JsonToken.Comment;
-          case JsonToken.Comment:
-            continue;
-          case JsonToken.EndObject:
-            flag = true;
-            goto case JsonToken.Comment;
-          default:
-            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + (object) reader.TokenType);
-        }
-      }
-      while (!flag && reader.Read());
-      if (!flag)
-        this.ThrowUnexpectedEndException(reader, (JsonContract) contract, (object) currentObject, "Unexpected end when deserializing object.");
-      if (contract.ISerializableCreator == null)
-        throw JsonSerializationException.Create(reader, "ISerializable type '{0}' does not have a valid constructor. To correctly implement ISerializable a constructor that takes SerializationInfo and StreamingContext parameters should be present.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) underlyingType));
-      object iserializable = contract.ISerializableCreator((object) currentObject, (object) this.Serializer._context);
-      if (id != null)
-        this.AddReference(reader, id, iserializable);
-      this.OnDeserializing(reader, (JsonContract) contract, iserializable);
-      this.OnDeserialized(reader, (JsonContract) contract, iserializable);
-      return iserializable;
-    }
-
-    internal object CreateISerializableItem(
-      JToken token,
-      Type type,
-      JsonISerializableContract contract,
-      JsonProperty member)
-    {
-      JsonContract contractSafe = this.GetContractSafe(type);
-      JsonConverter converter = this.GetConverter(contractSafe, (JsonConverter) null, (JsonContainerContract) contract, member);
-      JsonReader reader = token.CreateReader();
-      reader.ReadAndAssert();
-      return converter == null || !converter.CanRead ? this.CreateValueInternal(reader, type, contractSafe, (JsonProperty) null, (JsonContainerContract) contract, member, (object) null) : this.DeserializeConvertable(converter, reader, type, (object) null);
-    }
-
-    private object CreateObjectUsingCreatorWithParameters(
-      JsonReader reader,
-      JsonObjectContract contract,
-      JsonProperty containerProperty,
-      ObjectConstructor<object> creator,
-      string id)
-    {
-      ValidationUtils.ArgumentNotNull((object) creator, nameof (creator));
-      bool flag = contract.HasRequiredOrDefaultValueProperties || this.HasFlag(this.Serializer._defaultValueHandling, DefaultValueHandling.Populate);
-      Type underlyingType = contract.UnderlyingType;
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-      {
-        string str = string.Join(", ", contract.CreatorParameters.Select<JsonProperty, string>((Func<JsonProperty, string>) (p => p.PropertyName)).ToArray<string>());
-        this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using creator with parameters: {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType, (object) str)), (Exception) null);
-      }
-      List<JsonSerializerInternalReader.CreatorPropertyContext> source = this.ResolvePropertyAndCreatorValues(contract, containerProperty, reader, underlyingType);
-      if (flag)
-      {
-        foreach (JsonProperty property1 in (Collection<JsonProperty>) contract.Properties)
-        {
-          JsonProperty property = property1;
-          if (source.All<JsonSerializerInternalReader.CreatorPropertyContext>((Func<JsonSerializerInternalReader.CreatorPropertyContext, bool>) (p => p.Property != property)))
-            source.Add(new JsonSerializerInternalReader.CreatorPropertyContext()
-            {
-              Property = property,
-              Name = property.PropertyName,
-              Presence = new JsonSerializerInternalReader.PropertyPresence?(JsonSerializerInternalReader.PropertyPresence.None)
-            });
-        }
-      }
-      object[] objArray = new object[contract.CreatorParameters.Count];
-      foreach (JsonSerializerInternalReader.CreatorPropertyContext creatorPropertyContext in source)
-      {
-        if (flag && creatorPropertyContext.Property != null && !creatorPropertyContext.Presence.HasValue)
-        {
-          object s = creatorPropertyContext.Value;
-          JsonSerializerInternalReader.PropertyPresence propertyPresence = s != null ? (!(s is string) ? JsonSerializerInternalReader.PropertyPresence.Value : (JsonSerializerInternalReader.CoerceEmptyStringToNull(creatorPropertyContext.Property.PropertyType, creatorPropertyContext.Property.PropertyContract, (string) s) ? JsonSerializerInternalReader.PropertyPresence.Null : JsonSerializerInternalReader.PropertyPresence.Value)) : JsonSerializerInternalReader.PropertyPresence.Null;
-          creatorPropertyContext.Presence = new JsonSerializerInternalReader.PropertyPresence?(propertyPresence);
-        }
-        JsonProperty constructorProperty = creatorPropertyContext.ConstructorProperty;
-        if (constructorProperty == null && creatorPropertyContext.Property != null)
-          constructorProperty = contract.CreatorParameters.ForgivingCaseSensitiveFind<JsonProperty>((Func<JsonProperty, string>) (p => p.PropertyName), creatorPropertyContext.Property.UnderlyingName);
-        if (constructorProperty != null && !constructorProperty.Ignored)
-        {
-          if (flag)
-          {
-            JsonSerializerInternalReader.PropertyPresence? presence = creatorPropertyContext.Presence;
-            JsonSerializerInternalReader.PropertyPresence propertyPresence1 = JsonSerializerInternalReader.PropertyPresence.None;
-            if ((presence.GetValueOrDefault() == propertyPresence1 ? (presence.HasValue ? 1 : 0) : 0) == 0)
-            {
-              presence = creatorPropertyContext.Presence;
-              JsonSerializerInternalReader.PropertyPresence propertyPresence2 = JsonSerializerInternalReader.PropertyPresence.Null;
-              if ((presence.GetValueOrDefault() == propertyPresence2 ? (presence.HasValue ? 1 : 0) : 0) == 0)
-                goto label_25;
-            }
-            if (constructorProperty.PropertyContract == null)
-              constructorProperty.PropertyContract = this.GetContractSafe(constructorProperty.PropertyType);
-            if (this.HasFlag(constructorProperty.DefaultValueHandling.GetValueOrDefault(this.Serializer._defaultValueHandling), DefaultValueHandling.Populate))
-              creatorPropertyContext.Value = this.EnsureType(reader, constructorProperty.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, constructorProperty.PropertyContract, constructorProperty.PropertyType);
-          }
-label_25:
-          int index = contract.CreatorParameters.IndexOf(constructorProperty);
-          objArray[index] = creatorPropertyContext.Value;
-          creatorPropertyContext.Used = true;
-        }
-      }
-      object creatorWithParameters = creator(objArray);
-      if (id != null)
-        this.AddReference(reader, id, creatorWithParameters);
-      this.OnDeserializing(reader, (JsonContract) contract, creatorWithParameters);
-      foreach (JsonSerializerInternalReader.CreatorPropertyContext creatorPropertyContext in source)
-      {
-        if (!creatorPropertyContext.Used && creatorPropertyContext.Property != null && !creatorPropertyContext.Property.Ignored)
-        {
-          JsonSerializerInternalReader.PropertyPresence? presence = creatorPropertyContext.Presence;
-          JsonSerializerInternalReader.PropertyPresence propertyPresence = JsonSerializerInternalReader.PropertyPresence.None;
-          if ((presence.GetValueOrDefault() == propertyPresence ? (presence.HasValue ? 1 : 0) : 0) == 0)
-          {
-            JsonProperty property = creatorPropertyContext.Property;
-            object obj1 = creatorPropertyContext.Value;
-            if (this.ShouldSetPropertyValue(property, contract, obj1))
-            {
-              property.ValueProvider.SetValue(creatorWithParameters, obj1);
-              creatorPropertyContext.Used = true;
-            }
-            else if (!property.Writable && obj1 != null)
-            {
-              JsonContract jsonContract = this.Serializer._contractResolver.ResolveContract(property.PropertyType);
-              if (jsonContract.ContractType == JsonContractType.Array)
-              {
-                JsonArrayContract jsonArrayContract = (JsonArrayContract) jsonContract;
-                if (jsonArrayContract.CanDeserialize && !jsonArrayContract.IsReadOnlyOrFixedSize)
-                {
-                  object list1 = property.ValueProvider.GetValue(creatorWithParameters);
-                  if (list1 != null)
-                  {
-                    IList list2 = jsonArrayContract.ShouldCreateWrapper ? (IList) jsonArrayContract.CreateWrapper(list1) : (IList) list1;
-                    foreach (object obj2 in jsonArrayContract.ShouldCreateWrapper ? (IEnumerable) jsonArrayContract.CreateWrapper(obj1) : (IEnumerable) obj1)
-                      list2.Add(obj2);
-                  }
-                }
-              }
-              else if (jsonContract.ContractType == JsonContractType.Dictionary)
-              {
-                JsonDictionaryContract dictionaryContract = (JsonDictionaryContract) jsonContract;
-                if (!dictionaryContract.IsReadOnlyOrFixedSize)
-                {
-                  object dictionary1 = property.ValueProvider.GetValue(creatorWithParameters);
-                  if (dictionary1 != null)
-                  {
-                    IDictionary dictionary2 = dictionaryContract.ShouldCreateWrapper ? (IDictionary) dictionaryContract.CreateWrapper(dictionary1) : (IDictionary) dictionary1;
-                    IDictionaryEnumerator enumerator = (dictionaryContract.ShouldCreateWrapper ? (IDictionary) dictionaryContract.CreateWrapper(obj1) : (IDictionary) obj1).GetEnumerator();
-                    try
-                    {
-                      while (enumerator.MoveNext())
-                      {
-                        DictionaryEntry entry = enumerator.Entry;
-                        dictionary2[entry.Key] = entry.Value;
-                      }
-                    }
-                    finally
-                    {
-                      if (enumerator is IDisposable disposable)
-                        disposable.Dispose();
-                    }
-                  }
-                }
-              }
-              creatorPropertyContext.Used = true;
-            }
-          }
-        }
-      }
-      if (contract.ExtensionDataSetter != null)
-      {
-        foreach (JsonSerializerInternalReader.CreatorPropertyContext creatorPropertyContext in source)
-        {
-          if (!creatorPropertyContext.Used)
-            contract.ExtensionDataSetter(creatorWithParameters, creatorPropertyContext.Name, creatorPropertyContext.Value);
-        }
-      }
-      if (flag)
-      {
-        foreach (JsonSerializerInternalReader.CreatorPropertyContext creatorPropertyContext in source)
-        {
-          if (creatorPropertyContext.Property != null)
-            this.EndProcessProperty(creatorWithParameters, reader, contract, reader.Depth, creatorPropertyContext.Property, creatorPropertyContext.Presence.GetValueOrDefault(), !creatorPropertyContext.Used);
-        }
-      }
-      this.OnDeserialized(reader, (JsonContract) contract, creatorWithParameters);
-      return creatorWithParameters;
-    }
-
-    private object DeserializeConvertable(
-      JsonConverter converter,
-      JsonReader reader,
-      Type objectType,
-      object existingValue)
-    {
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-        this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0} with converter {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType, (object) converter.GetType())), (Exception) null);
-      object obj = converter.ReadJson(reader, objectType, existingValue, (JsonSerializer) this.GetInternalSerializer());
-      if (this.TraceWriter == null || this.TraceWriter.LevelFilter < TraceLevel.Info)
-        return obj;
-      this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0} with converter {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectType, (object) converter.GetType())), (Exception) null);
-      return obj;
-    }
-
-    private List<JsonSerializerInternalReader.CreatorPropertyContext> ResolvePropertyAndCreatorValues(
-      JsonObjectContract contract,
-      JsonProperty containerProperty,
-      JsonReader reader,
-      Type objectType)
-    {
-      List<JsonSerializerInternalReader.CreatorPropertyContext> creatorPropertyContextList = new List<JsonSerializerInternalReader.CreatorPropertyContext>();
-      bool flag = false;
-      do
-      {
-        switch (reader.TokenType)
-        {
-          case JsonToken.PropertyName:
-            string propertyName = reader.Value.ToString();
-            JsonSerializerInternalReader.CreatorPropertyContext creatorPropertyContext = new JsonSerializerInternalReader.CreatorPropertyContext()
-            {
-              Name = reader.Value.ToString(),
-              ConstructorProperty = contract.CreatorParameters.GetClosestMatchProperty(propertyName),
-              Property = contract.Properties.GetClosestMatchProperty(propertyName)
-            };
-            creatorPropertyContextList.Add(creatorPropertyContext);
-            JsonProperty member = creatorPropertyContext.ConstructorProperty ?? creatorPropertyContext.Property;
-            if (member != null && !member.Ignored)
-            {
-              if (member.PropertyContract == null)
-                member.PropertyContract = this.GetContractSafe(member.PropertyType);
-              JsonConverter converter = this.GetConverter(member.PropertyContract, member.Converter, (JsonContainerContract) contract, containerProperty);
-              if (!reader.ReadForType(member.PropertyContract, converter != null))
-                throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) propertyName));
-              creatorPropertyContext.Value = converter == null || !converter.CanRead ? this.CreateValueInternal(reader, member.PropertyType, member.PropertyContract, member, (JsonContainerContract) contract, containerProperty, (object) null) : this.DeserializeConvertable(converter, reader, member.PropertyType, (object) null);
-              goto case JsonToken.Comment;
-            }
-            else
-            {
-              if (!reader.Read())
-                throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) propertyName));
-              if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-                this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) propertyName, (object) contract.UnderlyingType)), (Exception) null);
-              if (this.Serializer._missingMemberHandling == MissingMemberHandling.Error)
-                throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) propertyName, (object) objectType.Name));
-              if (contract.ExtensionDataSetter != null)
-              {
-                creatorPropertyContext.Value = this.ReadExtensionDataValue(contract, containerProperty, reader);
-                goto case JsonToken.Comment;
-              }
-              else
-              {
-                reader.Skip();
-                goto case JsonToken.Comment;
-              }
-            }
-          case JsonToken.Comment:
-            continue;
-          case JsonToken.EndObject:
-            flag = true;
-            goto case JsonToken.Comment;
-          default:
-            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + (object) reader.TokenType);
-        }
-      }
-      while (!flag && reader.Read());
-      if (!flag)
-        this.ThrowUnexpectedEndException(reader, (JsonContract) contract, (object) null, "Unexpected end when deserializing object.");
-      return creatorPropertyContextList;
-    }
-
-    public object CreateNewObject(
-      JsonReader reader,
-      JsonObjectContract objectContract,
-      JsonProperty containerMember,
-      JsonProperty containerProperty,
-      string id,
-      out bool createdFromNonDefaultCreator)
-    {
-      object newObject = (object) null;
-      if (objectContract.OverrideCreator != null)
-      {
-        if (objectContract.CreatorParameters.Count > 0)
-        {
-          createdFromNonDefaultCreator = true;
-          return this.CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.OverrideCreator, id);
-        }
-        newObject = objectContract.OverrideCreator(CollectionUtils.ArrayEmpty<object>());
-      }
-      else if (objectContract.DefaultCreator != null && (!objectContract.DefaultCreatorNonPublic || this.Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor || objectContract.ParameterizedCreator == null))
-        newObject = objectContract.DefaultCreator();
-      else if (objectContract.ParameterizedCreator != null)
-      {
-        createdFromNonDefaultCreator = true;
-        return this.CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.ParameterizedCreator, id);
-      }
-      if (newObject == null)
-      {
-        if (!objectContract.IsInstantiable)
-          throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectContract.UnderlyingType));
-        throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) objectContract.UnderlyingType));
-      }
-      createdFromNonDefaultCreator = false;
-      return newObject;
-    }
-
-    private object PopulateObject(
-      object newObject,
-      JsonReader reader,
-      JsonObjectContract contract,
-      JsonProperty member,
-      string id)
-    {
-      this.OnDeserializing(reader, (JsonContract) contract, newObject);
-      Dictionary<JsonProperty, JsonSerializerInternalReader.PropertyPresence> dictionary = contract.HasRequiredOrDefaultValueProperties || this.HasFlag(this.Serializer._defaultValueHandling, DefaultValueHandling.Populate) ? contract.Properties.ToDictionary<JsonProperty, JsonProperty, JsonSerializerInternalReader.PropertyPresence>((Func<JsonProperty, JsonProperty>) (m => m), (Func<JsonProperty, JsonSerializerInternalReader.PropertyPresence>) (m => JsonSerializerInternalReader.PropertyPresence.None)) : (Dictionary<JsonProperty, JsonSerializerInternalReader.PropertyPresence>) null;
-      if (id != null)
-        this.AddReference(reader, id, newObject);
-      int depth = reader.Depth;
-      bool flag = false;
-      do
-      {
-        switch (reader.TokenType)
-        {
-          case JsonToken.PropertyName:
-            string str = reader.Value.ToString();
-            if (!this.CheckPropertyName(reader, str))
-            {
-              try
-              {
-                JsonProperty closestMatchProperty = contract.Properties.GetClosestMatchProperty(str);
-                if (closestMatchProperty == null)
-                {
-                  if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-                    this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str, (object) contract.UnderlyingType)), (Exception) null);
-                  if (this.Serializer._missingMemberHandling == MissingMemberHandling.Error)
-                    throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str, (object) contract.UnderlyingType.Name));
-                  if (reader.Read())
-                  {
-                    this.SetExtensionData(contract, member, reader, str, newObject);
-                    goto case JsonToken.Comment;
-                  }
-                  else
-                    goto case JsonToken.Comment;
-                }
-                else if (closestMatchProperty.Ignored || !this.ShouldDeserialize(reader, closestMatchProperty, newObject))
-                {
-                  if (reader.Read())
-                  {
-                    this.SetPropertyPresence(reader, closestMatchProperty, dictionary);
-                    this.SetExtensionData(contract, member, reader, str, newObject);
-                    goto case JsonToken.Comment;
-                  }
-                  else
-                    goto case JsonToken.Comment;
-                }
-                else
-                {
-                  if (closestMatchProperty.PropertyContract == null)
-                    closestMatchProperty.PropertyContract = this.GetContractSafe(closestMatchProperty.PropertyType);
-                  JsonConverter converter = this.GetConverter(closestMatchProperty.PropertyContract, closestMatchProperty.Converter, (JsonContainerContract) contract, member);
-                  if (!reader.ReadForType(closestMatchProperty.PropertyContract, converter != null))
-                    throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str));
-                  this.SetPropertyPresence(reader, closestMatchProperty, dictionary);
-                  if (!this.SetPropertyValue(closestMatchProperty, converter, (JsonContainerContract) contract, member, reader, newObject))
-                  {
-                    this.SetExtensionData(contract, member, reader, str, newObject);
-                    goto case JsonToken.Comment;
-                  }
-                  else
-                    goto case JsonToken.Comment;
-                }
-              }
-              catch (Exception ex)
-              {
-                if (this.IsErrorHandled(newObject, (JsonContract) contract, (object) str, reader as IJsonLineInfo, reader.Path, ex))
-                {
-                  this.HandleError(reader, true, depth);
-                  goto case JsonToken.Comment;
-                }
-                else
-                  throw;
-              }
-            }
-            else
-              goto case JsonToken.Comment;
-          case JsonToken.Comment:
-            continue;
-          case JsonToken.EndObject:
-            flag = true;
-            goto case JsonToken.Comment;
-          default:
-            throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + (object) reader.TokenType);
-        }
-      }
-      while (!flag && reader.Read());
-      if (!flag)
-        this.ThrowUnexpectedEndException(reader, (JsonContract) contract, newObject, "Unexpected end when deserializing object.");
-      if (dictionary != null)
-      {
-        foreach (KeyValuePair<JsonProperty, JsonSerializerInternalReader.PropertyPresence> keyValuePair in dictionary)
-        {
-          JsonProperty key = keyValuePair.Key;
-          JsonSerializerInternalReader.PropertyPresence presence = keyValuePair.Value;
-          this.EndProcessProperty(newObject, reader, contract, depth, key, presence, true);
-        }
-      }
-      this.OnDeserialized(reader, (JsonContract) contract, newObject);
-      return newObject;
-    }
-
-    private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target)
-    {
-      if (property.ShouldDeserialize == null)
-        return true;
-      bool flag = property.ShouldDeserialize(target);
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-        this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage((IJsonLineInfo) null, reader.Path, "ShouldDeserialize result for property '{0}' on {1}: {2}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName, (object) property.DeclaringType, (object) flag)), (Exception) null);
-      return flag;
-    }
-
-    private bool CheckPropertyName(JsonReader reader, string memberName)
-    {
-      if (this.Serializer.MetadataPropertyHandling != MetadataPropertyHandling.ReadAhead || !(memberName == "$id") && !(memberName == "$ref") && !(memberName == "$type") && !(memberName == "$values"))
-        return false;
-      reader.Skip();
-      return true;
-    }
-
-    private void SetExtensionData(
-      JsonObjectContract contract,
-      JsonProperty member,
-      JsonReader reader,
-      string memberName,
-      object o)
-    {
-      if (contract.ExtensionDataSetter != null)
-      {
-        try
-        {
-          object obj = this.ReadExtensionDataValue(contract, member, reader);
-          contract.ExtensionDataSetter(o, memberName, obj);
-        }
-        catch (Exception ex)
-        {
-          throw JsonSerializationException.Create(reader, "Error setting value in extension data for type '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType), ex);
-        }
-      }
-      else
-        reader.Skip();
-    }
-
-    private object ReadExtensionDataValue(
-      JsonObjectContract contract,
-      JsonProperty member,
-      JsonReader reader)
-    {
-      return !contract.ExtensionDataIsJToken ? this.CreateValueInternal(reader, (Type) null, (JsonContract) null, (JsonProperty) null, (JsonContainerContract) contract, member, (object) null) : (object) JToken.ReadFrom(reader);
-    }
-
-    private void EndProcessProperty(
-      object newObject,
-      JsonReader reader,
-      JsonObjectContract contract,
-      int initialDepth,
-      JsonProperty property,
-      JsonSerializerInternalReader.PropertyPresence presence,
-      bool setDefaultValue)
-    {
-      if (presence != JsonSerializerInternalReader.PropertyPresence.None && presence != JsonSerializerInternalReader.PropertyPresence.Null)
-        return;
-      try
-      {
-        Required required = property.Ignored ? Required.Default : (Required) ((int) property._required ?? (int) contract.ItemRequired ?? 0);
-        switch (presence)
-        {
-          case JsonSerializerInternalReader.PropertyPresence.None:
-            if (required == Required.AllowNull || required == Required.Always)
-              throw JsonSerializationException.Create(reader, "Required property '{0}' not found in JSON.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName));
-            if (!setDefaultValue || property.Ignored)
-              break;
-            if (property.PropertyContract == null)
-              property.PropertyContract = this.GetContractSafe(property.PropertyType);
-            if (!this.HasFlag(property.DefaultValueHandling.GetValueOrDefault(this.Serializer._defaultValueHandling), DefaultValueHandling.Populate) || !property.Writable)
-              break;
-            property.ValueProvider.SetValue(newObject, this.EnsureType(reader, property.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, property.PropertyContract, property.PropertyType));
-            break;
-          case JsonSerializerInternalReader.PropertyPresence.Null:
-            if (required == Required.Always)
-              throw JsonSerializationException.Create(reader, "Required property '{0}' expects a value but got null.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName));
-            if (required != Required.DisallowNull)
-              break;
-            throw JsonSerializationException.Create(reader, "Required property '{0}' expects a non-null value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName));
-        }
-      }
-      catch (Exception ex)
-      {
-        if (this.IsErrorHandled(newObject, (JsonContract) contract, (object) property.PropertyName, reader as IJsonLineInfo, reader.Path, ex))
-          this.HandleError(reader, true, initialDepth);
-        else
-          throw;
-      }
-    }
-
-    private void SetPropertyPresence(
-      JsonReader reader,
-      JsonProperty property,
-      Dictionary<JsonProperty, JsonSerializerInternalReader.PropertyPresence> requiredProperties)
-    {
-      if (property == null || requiredProperties == null)
-        return;
-      JsonSerializerInternalReader.PropertyPresence propertyPresence;
-      switch (reader.TokenType)
-      {
-        case JsonToken.String:
-          propertyPresence = JsonSerializerInternalReader.CoerceEmptyStringToNull(property.PropertyType, property.PropertyContract, (string) reader.Value) ? JsonSerializerInternalReader.PropertyPresence.Null : JsonSerializerInternalReader.PropertyPresence.Value;
-          break;
-        case JsonToken.Null:
-        case JsonToken.Undefined:
-          propertyPresence = JsonSerializerInternalReader.PropertyPresence.Null;
-          break;
-        default:
-          propertyPresence = JsonSerializerInternalReader.PropertyPresence.Value;
-          break;
-      }
-      requiredProperties[property] = propertyPresence;
-    }
-
-    private void HandleError(JsonReader reader, bool readPastError, int initialDepth)
-    {
-      this.ClearErrorContext();
-      if (!readPastError)
-        return;
-      reader.Skip();
-      do
-        ;
-      while (reader.Depth > initialDepth && reader.Read());
-    }
-
-    internal enum PropertyPresence
-    {
-      None,
-      Null,
-      Value,
-    }
-
-    internal class CreatorPropertyContext
-    {
-      public string Name;
-      public JsonProperty Property;
-      public JsonProperty ConstructorProperty;
-      public JsonSerializerInternalReader.PropertyPresence? Presence;
-      public object Value;
-      public bool Used;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalWriter.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalWriter.cs
deleted file mode 100644
index 89f6141..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerInternalWriter.cs
+++ /dev/null
@@ -1,813 +0,0 @@
-using Newtonsoft.Json.Linq;
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Diagnostics;
-using System.Globalization;
-using System.IO;
-using System.Linq;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal class JsonSerializerInternalWriter(JsonSerializer serializer) : JsonSerializerInternalBase(serializer)
-  {
-    private Type _rootType;
-    private int _rootLevel;
-    private readonly List<object> _serializeStack = new List<object>();
-
-    public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
-    {
-      if (jsonWriter == null)
-        throw new ArgumentNullException(nameof (jsonWriter));
-      this._rootType = objectType;
-      this._rootLevel = this._serializeStack.Count + 1;
-      JsonContract contractSafe = this.GetContractSafe(value);
-      try
-      {
-        if (this.ShouldWriteReference(value, (JsonProperty) null, contractSafe, (JsonContainerContract) null, (JsonProperty) null))
-          this.WriteReference(jsonWriter, value);
-        else
-          this.SerializeValue(jsonWriter, value, contractSafe, (JsonProperty) null, (JsonContainerContract) null, (JsonProperty) null);
-      }
-      catch (Exception ex)
-      {
-        if (this.IsErrorHandled((object) null, contractSafe, (object) null, (IJsonLineInfo) null, jsonWriter.Path, ex))
-        {
-          this.HandleError(jsonWriter, 0);
-        }
-        else
-        {
-          this.ClearErrorContext();
-          throw;
-        }
-      }
-      finally
-      {
-        this._rootType = (Type) null;
-      }
-    }
-
-    private JsonSerializerProxy GetInternalSerializer()
-    {
-      if (this.InternalSerializer == null)
-        this.InternalSerializer = new JsonSerializerProxy(this);
-      return this.InternalSerializer;
-    }
-
-    private JsonContract GetContractSafe(object value)
-    {
-      return value == null ? (JsonContract) null : this.Serializer._contractResolver.ResolveContract(value.GetType());
-    }
-
-    private void SerializePrimitive(
-      JsonWriter writer,
-      object value,
-      JsonPrimitiveContract contract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerProperty)
-    {
-      if (contract.TypeCode == PrimitiveTypeCode.Bytes && this.ShouldWriteType(TypeNameHandling.Objects, (JsonContract) contract, member, containerContract, containerProperty))
-      {
-        writer.WriteStartObject();
-        this.WriteTypeProperty(writer, contract.CreatedType);
-        writer.WritePropertyName("$value", false);
-        JsonWriter.WriteValue(writer, contract.TypeCode, value);
-        writer.WriteEndObject();
-      }
-      else
-        JsonWriter.WriteValue(writer, contract.TypeCode, value);
-    }
-
-    private void SerializeValue(
-      JsonWriter writer,
-      object value,
-      JsonContract valueContract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerProperty)
-    {
-      if (value == null)
-      {
-        writer.WriteNull();
-      }
-      else
-      {
-        JsonConverter converter = member?.Converter ?? containerProperty?.ItemConverter ?? containerContract?.ItemConverter ?? valueContract.Converter ?? this.Serializer.GetMatchingConverter(valueContract.UnderlyingType) ?? valueContract.InternalConverter;
-        if (converter != null && converter.CanWrite)
-        {
-          this.SerializeConvertable(writer, converter, value, valueContract, containerContract, containerProperty);
-        }
-        else
-        {
-          switch (valueContract.ContractType)
-          {
-            case JsonContractType.Object:
-              this.SerializeObject(writer, value, (JsonObjectContract) valueContract, member, containerContract, containerProperty);
-              break;
-            case JsonContractType.Array:
-              JsonArrayContract contract1 = (JsonArrayContract) valueContract;
-              if (!contract1.IsMultidimensionalArray)
-              {
-                this.SerializeList(writer, (IEnumerable) value, contract1, member, containerContract, containerProperty);
-                break;
-              }
-              this.SerializeMultidimensionalArray(writer, (Array) value, contract1, member, containerContract, containerProperty);
-              break;
-            case JsonContractType.Primitive:
-              this.SerializePrimitive(writer, value, (JsonPrimitiveContract) valueContract, member, containerContract, containerProperty);
-              break;
-            case JsonContractType.String:
-              this.SerializeString(writer, value, (JsonStringContract) valueContract);
-              break;
-            case JsonContractType.Dictionary:
-              JsonDictionaryContract contract2 = (JsonDictionaryContract) valueContract;
-              this.SerializeDictionary(writer, value is IDictionary ? (IDictionary) value : (IDictionary) contract2.CreateWrapper(value), contract2, member, containerContract, containerProperty);
-              break;
-            case JsonContractType.Serializable:
-              this.SerializeISerializable(writer, (ISerializable) value, (JsonISerializableContract) valueContract, member, containerContract, containerProperty);
-              break;
-            case JsonContractType.Linq:
-              ((JToken) value).WriteTo(writer, this.Serializer.Converters.ToArray<JsonConverter>());
-              break;
-          }
-        }
-      }
-    }
-
-    private bool? ResolveIsReference(
-      JsonContract contract,
-      JsonProperty property,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      bool? nullable = new bool?();
-      if (property != null)
-        nullable = property.IsReference;
-      if (!nullable.HasValue && containerProperty != null)
-        nullable = containerProperty.ItemIsReference;
-      if (!nullable.HasValue && collectionContract != null)
-        nullable = collectionContract.ItemIsReference;
-      if (!nullable.HasValue)
-        nullable = contract.IsReference;
-      return nullable;
-    }
-
-    private bool ShouldWriteReference(
-      object value,
-      JsonProperty property,
-      JsonContract valueContract,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      if (value == null || valueContract.ContractType == JsonContractType.Primitive || valueContract.ContractType == JsonContractType.String)
-        return false;
-      bool? nullable = this.ResolveIsReference(valueContract, property, collectionContract, containerProperty);
-      if (!nullable.HasValue)
-        nullable = valueContract.ContractType != JsonContractType.Array ? new bool?(this.HasFlag(this.Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects)) : new bool?(this.HasFlag(this.Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays));
-      return nullable.GetValueOrDefault() && this.Serializer.GetReferenceResolver().IsReferenced((object) this, value);
-    }
-
-    private bool ShouldWriteProperty(
-      object memberValue,
-      JsonObjectContract containerContract,
-      JsonProperty property)
-    {
-      return (memberValue != null || this.ResolvedNullValueHandling(containerContract, property) != NullValueHandling.Ignore) && (!this.HasFlag(property.DefaultValueHandling.GetValueOrDefault(this.Serializer._defaultValueHandling), DefaultValueHandling.Ignore) || !MiscellaneousUtils.ValueEquals(memberValue, property.GetResolvedDefaultValue()));
-    }
-
-    private bool CheckForCircularReference(
-      JsonWriter writer,
-      object value,
-      JsonProperty property,
-      JsonContract contract,
-      JsonContainerContract containerContract,
-      JsonProperty containerProperty)
-    {
-      if (value == null || contract.ContractType == JsonContractType.Primitive || contract.ContractType == JsonContractType.String)
-        return true;
-      ReferenceLoopHandling? nullable = new ReferenceLoopHandling?();
-      if (property != null)
-        nullable = property.ReferenceLoopHandling;
-      if (!nullable.HasValue && containerProperty != null)
-        nullable = containerProperty.ItemReferenceLoopHandling;
-      if (!nullable.HasValue && containerContract != null)
-        nullable = containerContract.ItemReferenceLoopHandling;
-      if ((this.Serializer._equalityComparer != null ? (this._serializeStack.Contains<object>(value, this.Serializer._equalityComparer) ? 1 : 0) : (this._serializeStack.Contains(value) ? 1 : 0)) != 0)
-      {
-        string str = "Self referencing loop detected";
-        if (property != null)
-          str += " for property '{0}'".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName);
-        string message = str + " with type '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType());
-        switch (nullable.GetValueOrDefault(this.Serializer._referenceLoopHandling))
-        {
-          case ReferenceLoopHandling.Error:
-            throw JsonSerializationException.Create((IJsonLineInfo) null, writer.ContainerPath, message, (Exception) null);
-          case ReferenceLoopHandling.Ignore:
-            if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-              this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, message + ". Skipping serializing self referenced value."), (Exception) null);
-            return false;
-          case ReferenceLoopHandling.Serialize:
-            if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-              this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, message + ". Serializing self referenced value."), (Exception) null);
-            return true;
-        }
-      }
-      return true;
-    }
-
-    private void WriteReference(JsonWriter writer, object value)
-    {
-      string reference = this.GetReference(writer, value);
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-        this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "Writing object reference to Id '{0}' for {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reference, (object) value.GetType())), (Exception) null);
-      writer.WriteStartObject();
-      writer.WritePropertyName("$ref", false);
-      writer.WriteValue(reference);
-      writer.WriteEndObject();
-    }
-
-    private string GetReference(JsonWriter writer, object value)
-    {
-      try
-      {
-        return this.Serializer.GetReferenceResolver().GetReference((object) this, value);
-      }
-      catch (Exception ex)
-      {
-        throw JsonSerializationException.Create((IJsonLineInfo) null, writer.ContainerPath, "Error writing object reference for '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType()), ex);
-      }
-    }
-
-    internal static bool TryConvertToString(object value, Type type, out string s)
-    {
-      TypeConverter typeConverter;
-      if (JsonTypeReflector.CanTypeDescriptorConvertString(type, out typeConverter))
-      {
-        s = typeConverter.ConvertToInvariantString(value);
-        return true;
-      }
-      type = value as Type;
-      if (type != null)
-      {
-        s = type.AssemblyQualifiedName;
-        return true;
-      }
-      s = (string) null;
-      return false;
-    }
-
-    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
-    {
-      this.OnSerializing(writer, (JsonContract) contract, value);
-      string s;
-      JsonSerializerInternalWriter.TryConvertToString(value, contract.UnderlyingType, out s);
-      writer.WriteValue(s);
-      this.OnSerialized(writer, (JsonContract) contract, value);
-    }
-
-    private void OnSerializing(JsonWriter writer, JsonContract contract, object value)
-    {
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-        this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "Started serializing {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType)), (Exception) null);
-      contract.InvokeOnSerializing(value, this.Serializer._context);
-    }
-
-    private void OnSerialized(JsonWriter writer, JsonContract contract, object value)
-    {
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-        this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "Finished serializing {0}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) contract.UnderlyingType)), (Exception) null);
-      contract.InvokeOnSerialized(value, this.Serializer._context);
-    }
-
-    private void SerializeObject(
-      JsonWriter writer,
-      object value,
-      JsonObjectContract contract,
-      JsonProperty member,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      this.OnSerializing(writer, (JsonContract) contract, value);
-      this._serializeStack.Add(value);
-      this.WriteObjectStart(writer, value, (JsonContract) contract, member, collectionContract, containerProperty);
-      int top = writer.Top;
-      for (int index = 0; index < contract.Properties.Count; ++index)
-      {
-        JsonProperty property = contract.Properties[index];
-        try
-        {
-          JsonContract memberContract;
-          object memberValue;
-          if (this.CalculatePropertyValues(writer, value, (JsonContainerContract) contract, member, property, out memberContract, out memberValue))
-          {
-            property.WritePropertyName(writer);
-            this.SerializeValue(writer, memberValue, memberContract, property, (JsonContainerContract) contract, member);
-          }
-        }
-        catch (Exception ex)
-        {
-          if (this.IsErrorHandled(value, (JsonContract) contract, (object) property.PropertyName, (IJsonLineInfo) null, writer.ContainerPath, ex))
-            this.HandleError(writer, top);
-          else
-            throw;
-        }
-      }
-      ExtensionDataGetter extensionDataGetter = contract.ExtensionDataGetter;
-      IEnumerable<KeyValuePair<object, object>> keyValuePairs = extensionDataGetter != null ? extensionDataGetter(value) : (IEnumerable<KeyValuePair<object, object>>) null;
-      if (keyValuePairs != null)
-      {
-        foreach (KeyValuePair<object, object> keyValuePair in keyValuePairs)
-        {
-          JsonContract contractSafe1 = this.GetContractSafe(keyValuePair.Key);
-          JsonContract contractSafe2 = this.GetContractSafe(keyValuePair.Value);
-          string propertyName = this.GetPropertyName(writer, keyValuePair.Key, contractSafe1, out bool _);
-          string name = contract.ExtensionDataNameResolver != null ? contract.ExtensionDataNameResolver(propertyName) : propertyName;
-          if (this.ShouldWriteReference(keyValuePair.Value, (JsonProperty) null, contractSafe2, (JsonContainerContract) contract, member))
-          {
-            writer.WritePropertyName(name);
-            this.WriteReference(writer, keyValuePair.Value);
-          }
-          else if (this.CheckForCircularReference(writer, keyValuePair.Value, (JsonProperty) null, contractSafe2, (JsonContainerContract) contract, member))
-          {
-            writer.WritePropertyName(name);
-            this.SerializeValue(writer, keyValuePair.Value, contractSafe2, (JsonProperty) null, (JsonContainerContract) contract, member);
-          }
-        }
-      }
-      writer.WriteEndObject();
-      this._serializeStack.RemoveAt(this._serializeStack.Count - 1);
-      this.OnSerialized(writer, (JsonContract) contract, value);
-    }
-
-    private bool CalculatePropertyValues(
-      JsonWriter writer,
-      object value,
-      JsonContainerContract contract,
-      JsonProperty member,
-      JsonProperty property,
-      out JsonContract memberContract,
-      out object memberValue)
-    {
-      if (!property.Ignored && property.Readable && this.ShouldSerialize(writer, property, value) && this.IsSpecified(writer, property, value))
-      {
-        if (property.PropertyContract == null)
-          property.PropertyContract = this.Serializer._contractResolver.ResolveContract(property.PropertyType);
-        memberValue = property.ValueProvider.GetValue(value);
-        memberContract = property.PropertyContract.IsSealed ? property.PropertyContract : this.GetContractSafe(memberValue);
-        if (this.ShouldWriteProperty(memberValue, contract as JsonObjectContract, property))
-        {
-          if (this.ShouldWriteReference(memberValue, property, memberContract, contract, member))
-          {
-            property.WritePropertyName(writer);
-            this.WriteReference(writer, memberValue);
-            return false;
-          }
-          if (!this.CheckForCircularReference(writer, memberValue, property, memberContract, contract, member))
-            return false;
-          if (memberValue == null)
-          {
-            JsonObjectContract jsonObjectContract = contract as JsonObjectContract;
-            switch ((int) property._required ?? (int) jsonObjectContract?.ItemRequired ?? 0)
-            {
-              case 2:
-                throw JsonSerializationException.Create((IJsonLineInfo) null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName), (Exception) null);
-              case 3:
-                throw JsonSerializationException.Create((IJsonLineInfo) null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a non-null value.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName), (Exception) null);
-            }
-          }
-          return true;
-        }
-      }
-      memberContract = (JsonContract) null;
-      memberValue = (object) null;
-      return false;
-    }
-
-    private void WriteObjectStart(
-      JsonWriter writer,
-      object value,
-      JsonContract contract,
-      JsonProperty member,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      writer.WriteStartObject();
-      if (((int) this.ResolveIsReference(contract, member, collectionContract, containerProperty) ?? (this.HasFlag(this.Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects) ? 1 : 0)) != 0 && (member == null || member.Writable || this.HasCreatorParameter(collectionContract, member)))
-        this.WriteReferenceIdProperty(writer, contract.UnderlyingType, value);
-      if (!this.ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionContract, containerProperty))
-        return;
-      this.WriteTypeProperty(writer, contract.UnderlyingType);
-    }
-
-    private bool HasCreatorParameter(JsonContainerContract contract, JsonProperty property)
-    {
-      return contract is JsonObjectContract jsonObjectContract && jsonObjectContract.CreatorParameters.Contains(property.PropertyName);
-    }
-
-    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value)
-    {
-      string reference = this.GetReference(writer, value);
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-        this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "Writing object reference Id '{0}' for {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) reference, (object) type)), (Exception) null);
-      writer.WritePropertyName("$id", false);
-      writer.WriteValue(reference);
-    }
-
-    private void WriteTypeProperty(JsonWriter writer, Type type)
-    {
-      string typeName = ReflectionUtils.GetTypeName(type, this.Serializer._typeNameAssemblyFormatHandling, this.Serializer._serializationBinder);
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-        this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "Writing type name '{0}' for {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) typeName, (object) type)), (Exception) null);
-      writer.WritePropertyName("$type", false);
-      writer.WriteValue(typeName);
-    }
-
-    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
-    {
-      return (value & flag) == flag;
-    }
-
-    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
-    {
-      return (value & flag) == flag;
-    }
-
-    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag) => (value & flag) == flag;
-
-    private void SerializeConvertable(
-      JsonWriter writer,
-      JsonConverter converter,
-      object value,
-      JsonContract contract,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      if (this.ShouldWriteReference(value, (JsonProperty) null, contract, collectionContract, containerProperty))
-      {
-        this.WriteReference(writer, value);
-      }
-      else
-      {
-        if (!this.CheckForCircularReference(writer, value, (JsonProperty) null, contract, collectionContract, containerProperty))
-          return;
-        this._serializeStack.Add(value);
-        if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-          this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "Started serializing {0} with converter {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType(), (object) converter.GetType())), (Exception) null);
-        converter.WriteJson(writer, value, (JsonSerializer) this.GetInternalSerializer());
-        if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Info)
-          this.TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "Finished serializing {0} with converter {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType(), (object) converter.GetType())), (Exception) null);
-        this._serializeStack.RemoveAt(this._serializeStack.Count - 1);
-      }
-    }
-
-    private void SerializeList(
-      JsonWriter writer,
-      IEnumerable values,
-      JsonArrayContract contract,
-      JsonProperty member,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      object obj1 = values is IWrappedCollection wrappedCollection ? wrappedCollection.UnderlyingCollection : (object) values;
-      this.OnSerializing(writer, (JsonContract) contract, obj1);
-      this._serializeStack.Add(obj1);
-      bool flag = this.WriteStartArray(writer, obj1, contract, member, collectionContract, containerProperty);
-      writer.WriteStartArray();
-      int top = writer.Top;
-      int keyValue = 0;
-      foreach (object obj2 in values)
-      {
-        try
-        {
-          JsonContract jsonContract = contract.FinalItemContract ?? this.GetContractSafe(obj2);
-          if (this.ShouldWriteReference(obj2, (JsonProperty) null, jsonContract, (JsonContainerContract) contract, member))
-            this.WriteReference(writer, obj2);
-          else if (this.CheckForCircularReference(writer, obj2, (JsonProperty) null, jsonContract, (JsonContainerContract) contract, member))
-            this.SerializeValue(writer, obj2, jsonContract, (JsonProperty) null, (JsonContainerContract) contract, member);
-        }
-        catch (Exception ex)
-        {
-          if (this.IsErrorHandled(obj1, (JsonContract) contract, (object) keyValue, (IJsonLineInfo) null, writer.ContainerPath, ex))
-            this.HandleError(writer, top);
-          else
-            throw;
-        }
-        finally
-        {
-          ++keyValue;
-        }
-      }
-      writer.WriteEndArray();
-      if (flag)
-        writer.WriteEndObject();
-      this._serializeStack.RemoveAt(this._serializeStack.Count - 1);
-      this.OnSerialized(writer, (JsonContract) contract, obj1);
-    }
-
-    private void SerializeMultidimensionalArray(
-      JsonWriter writer,
-      Array values,
-      JsonArrayContract contract,
-      JsonProperty member,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      this.OnSerializing(writer, (JsonContract) contract, (object) values);
-      this._serializeStack.Add((object) values);
-      int num = this.WriteStartArray(writer, (object) values, contract, member, collectionContract, containerProperty) ? 1 : 0;
-      this.SerializeMultidimensionalArray(writer, values, contract, member, writer.Top, CollectionUtils.ArrayEmpty<int>());
-      if (num != 0)
-        writer.WriteEndObject();
-      this._serializeStack.RemoveAt(this._serializeStack.Count - 1);
-      this.OnSerialized(writer, (JsonContract) contract, (object) values);
-    }
-
-    private void SerializeMultidimensionalArray(
-      JsonWriter writer,
-      Array values,
-      JsonArrayContract contract,
-      JsonProperty member,
-      int initialDepth,
-      int[] indices)
-    {
-      int length = indices.Length;
-      int[] indices1 = new int[length + 1];
-      for (int index = 0; index < length; ++index)
-        indices1[index] = indices[index];
-      writer.WriteStartArray();
-      for (int lowerBound = values.GetLowerBound(length); lowerBound <= values.GetUpperBound(length); ++lowerBound)
-      {
-        indices1[length] = lowerBound;
-        if (indices1.Length == values.Rank)
-        {
-          object obj = values.GetValue(indices1);
-          try
-          {
-            JsonContract jsonContract = contract.FinalItemContract ?? this.GetContractSafe(obj);
-            if (this.ShouldWriteReference(obj, (JsonProperty) null, jsonContract, (JsonContainerContract) contract, member))
-              this.WriteReference(writer, obj);
-            else if (this.CheckForCircularReference(writer, obj, (JsonProperty) null, jsonContract, (JsonContainerContract) contract, member))
-              this.SerializeValue(writer, obj, jsonContract, (JsonProperty) null, (JsonContainerContract) contract, member);
-          }
-          catch (Exception ex)
-          {
-            if (this.IsErrorHandled((object) values, (JsonContract) contract, (object) lowerBound, (IJsonLineInfo) null, writer.ContainerPath, ex))
-              this.HandleError(writer, initialDepth + 1);
-            else
-              throw;
-          }
-        }
-        else
-          this.SerializeMultidimensionalArray(writer, values, contract, member, initialDepth + 1, indices1);
-      }
-      writer.WriteEndArray();
-    }
-
-    private bool WriteStartArray(
-      JsonWriter writer,
-      object values,
-      JsonArrayContract contract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerProperty)
-    {
-      bool flag1 = ((int) this.ResolveIsReference((JsonContract) contract, member, containerContract, containerProperty) ?? (this.HasFlag(this.Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays) ? 1 : 0)) != 0 && (member == null || member.Writable || this.HasCreatorParameter(containerContract, member));
-      bool flag2 = this.ShouldWriteType(TypeNameHandling.Arrays, (JsonContract) contract, member, containerContract, containerProperty);
-      int num = flag1 | flag2 ? 1 : 0;
-      if (num != 0)
-      {
-        writer.WriteStartObject();
-        if (flag1)
-          this.WriteReferenceIdProperty(writer, contract.UnderlyingType, values);
-        if (flag2)
-          this.WriteTypeProperty(writer, values.GetType());
-        writer.WritePropertyName("$values", false);
-      }
-      if (contract.ItemContract != null)
-        return num != 0;
-      contract.ItemContract = this.Serializer._contractResolver.ResolveContract(contract.CollectionItemType ?? typeof (object));
-      return num != 0;
-    }
-
-    private void SerializeISerializable(
-      JsonWriter writer,
-      ISerializable value,
-      JsonISerializableContract contract,
-      JsonProperty member,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      if (!JsonTypeReflector.FullyTrusted)
-      {
-        string message = ("Type '{0}' implements ISerializable but cannot be serialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine).FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value.GetType());
-        throw JsonSerializationException.Create((IJsonLineInfo) null, writer.ContainerPath, message, (Exception) null);
-      }
-      this.OnSerializing(writer, (JsonContract) contract, (object) value);
-      this._serializeStack.Add((object) value);
-      this.WriteObjectStart(writer, (object) value, (JsonContract) contract, member, collectionContract, containerProperty);
-      SerializationInfo info = new SerializationInfo(contract.UnderlyingType, (IFormatterConverter) new FormatterConverter());
-      value.GetObjectData(info, this.Serializer._context);
-      foreach (SerializationEntry serializationEntry in info)
-      {
-        JsonContract contractSafe = this.GetContractSafe(serializationEntry.Value);
-        if (this.ShouldWriteReference(serializationEntry.Value, (JsonProperty) null, contractSafe, (JsonContainerContract) contract, member))
-        {
-          writer.WritePropertyName(serializationEntry.Name);
-          this.WriteReference(writer, serializationEntry.Value);
-        }
-        else if (this.CheckForCircularReference(writer, serializationEntry.Value, (JsonProperty) null, contractSafe, (JsonContainerContract) contract, member))
-        {
-          writer.WritePropertyName(serializationEntry.Name);
-          this.SerializeValue(writer, serializationEntry.Value, contractSafe, (JsonProperty) null, (JsonContainerContract) contract, member);
-        }
-      }
-      writer.WriteEndObject();
-      this._serializeStack.RemoveAt(this._serializeStack.Count - 1);
-      this.OnSerialized(writer, (JsonContract) contract, (object) value);
-    }
-
-    private bool ShouldWriteDynamicProperty(object memberValue)
-    {
-      return (this.Serializer._nullValueHandling != NullValueHandling.Ignore || memberValue != null) && (!this.HasFlag(this.Serializer._defaultValueHandling, DefaultValueHandling.Ignore) || memberValue != null && !MiscellaneousUtils.ValueEquals(memberValue, ReflectionUtils.GetDefaultValue(memberValue.GetType())));
-    }
-
-    private bool ShouldWriteType(
-      TypeNameHandling typeNameHandlingFlag,
-      JsonContract contract,
-      JsonProperty member,
-      JsonContainerContract containerContract,
-      JsonProperty containerProperty)
-    {
-      TypeNameHandling typeNameHandling = (TypeNameHandling) ((int) member?.TypeNameHandling ?? (int) containerProperty?.ItemTypeNameHandling ?? (int) containerContract?.ItemTypeNameHandling ?? (int) this.Serializer._typeNameHandling);
-      if (this.HasFlag(typeNameHandling, typeNameHandlingFlag))
-        return true;
-      if (this.HasFlag(typeNameHandling, TypeNameHandling.Auto))
-      {
-        if (member != null)
-        {
-          if (contract.NonNullableUnderlyingType != member.PropertyContract.CreatedType)
-            return true;
-        }
-        else if (containerContract != null)
-        {
-          if (containerContract.ItemContract == null || contract.NonNullableUnderlyingType != containerContract.ItemContract.CreatedType)
-            return true;
-        }
-        else if (this._rootType != null && this._serializeStack.Count == this._rootLevel)
-        {
-          JsonContract jsonContract = this.Serializer._contractResolver.ResolveContract(this._rootType);
-          if (contract.NonNullableUnderlyingType != jsonContract.CreatedType)
-            return true;
-        }
-      }
-      return false;
-    }
-
-    private void SerializeDictionary(
-      JsonWriter writer,
-      IDictionary values,
-      JsonDictionaryContract contract,
-      JsonProperty member,
-      JsonContainerContract collectionContract,
-      JsonProperty containerProperty)
-    {
-      object currentObject = values is IWrappedDictionary wrappedDictionary ? wrappedDictionary.UnderlyingDictionary : (object) values;
-      this.OnSerializing(writer, (JsonContract) contract, currentObject);
-      this._serializeStack.Add(currentObject);
-      this.WriteObjectStart(writer, currentObject, (JsonContract) contract, member, collectionContract, containerProperty);
-      if (contract.ItemContract == null)
-        contract.ItemContract = this.Serializer._contractResolver.ResolveContract(contract.DictionaryValueType ?? typeof (object));
-      if (contract.KeyContract == null)
-        contract.KeyContract = this.Serializer._contractResolver.ResolveContract(contract.DictionaryKeyType ?? typeof (object));
-      int top = writer.Top;
-      IDictionaryEnumerator enumerator = values.GetEnumerator();
-      try
-      {
-        while (enumerator.MoveNext())
-        {
-          DictionaryEntry entry = enumerator.Entry;
-          bool escape;
-          string propertyName = this.GetPropertyName(writer, entry.Key, contract.KeyContract, out escape);
-          string str = contract.DictionaryKeyResolver != null ? contract.DictionaryKeyResolver(propertyName) : propertyName;
-          try
-          {
-            object obj = entry.Value;
-            JsonContract jsonContract = contract.FinalItemContract ?? this.GetContractSafe(obj);
-            if (this.ShouldWriteReference(obj, (JsonProperty) null, jsonContract, (JsonContainerContract) contract, member))
-            {
-              writer.WritePropertyName(str, escape);
-              this.WriteReference(writer, obj);
-            }
-            else if (this.CheckForCircularReference(writer, obj, (JsonProperty) null, jsonContract, (JsonContainerContract) contract, member))
-            {
-              writer.WritePropertyName(str, escape);
-              this.SerializeValue(writer, obj, jsonContract, (JsonProperty) null, (JsonContainerContract) contract, member);
-            }
-          }
-          catch (Exception ex)
-          {
-            if (this.IsErrorHandled(currentObject, (JsonContract) contract, (object) str, (IJsonLineInfo) null, writer.ContainerPath, ex))
-              this.HandleError(writer, top);
-            else
-              throw;
-          }
-        }
-      }
-      finally
-      {
-        if (enumerator is IDisposable disposable)
-          disposable.Dispose();
-      }
-      writer.WriteEndObject();
-      this._serializeStack.RemoveAt(this._serializeStack.Count - 1);
-      this.OnSerialized(writer, (JsonContract) contract, currentObject);
-    }
-
-    private string GetPropertyName(
-      JsonWriter writer,
-      object name,
-      JsonContract contract,
-      out bool escape)
-    {
-      if (contract.ContractType == JsonContractType.Primitive)
-      {
-        JsonPrimitiveContract primitiveContract = (JsonPrimitiveContract) contract;
-        switch (primitiveContract.TypeCode)
-        {
-          case PrimitiveTypeCode.Single:
-          case PrimitiveTypeCode.SingleNullable:
-            float num1 = (float) name;
-            escape = false;
-            return num1.ToString("R", (IFormatProvider) CultureInfo.InvariantCulture);
-          case PrimitiveTypeCode.Double:
-          case PrimitiveTypeCode.DoubleNullable:
-            double num2 = (double) name;
-            escape = false;
-            return num2.ToString("R", (IFormatProvider) CultureInfo.InvariantCulture);
-          case PrimitiveTypeCode.DateTime:
-          case PrimitiveTypeCode.DateTimeNullable:
-            DateTime dateTime = DateTimeUtils.EnsureDateTime((DateTime) name, writer.DateTimeZoneHandling);
-            escape = false;
-            StringWriter writer1 = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-            DateTimeUtils.WriteDateTimeString((TextWriter) writer1, dateTime, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
-            return writer1.ToString();
-          case PrimitiveTypeCode.DateTimeOffset:
-          case PrimitiveTypeCode.DateTimeOffsetNullable:
-            escape = false;
-            StringWriter writer2 = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-            DateTimeUtils.WriteDateTimeOffsetString((TextWriter) writer2, (DateTimeOffset) name, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
-            return writer2.ToString();
-          default:
-            escape = true;
-            string name1;
-            return primitiveContract.IsEnum && EnumUtils.TryToString(primitiveContract.NonNullableUnderlyingType, name, false, out name1) ? name1 : Convert.ToString(name, (IFormatProvider) CultureInfo.InvariantCulture);
-        }
-      }
-      else
-      {
-        string s;
-        if (JsonSerializerInternalWriter.TryConvertToString(name, name.GetType(), out s))
-        {
-          escape = true;
-          return s;
-        }
-        escape = true;
-        return name.ToString();
-      }
-    }
-
-    private void HandleError(JsonWriter writer, int initialDepth)
-    {
-      this.ClearErrorContext();
-      if (writer.WriteState == WriteState.Property)
-        writer.WriteNull();
-      while (writer.Top > initialDepth)
-        writer.WriteEnd();
-    }
-
-    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target)
-    {
-      if (property.ShouldSerialize == null)
-        return true;
-      bool flag = property.ShouldSerialize(target);
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-        this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "ShouldSerialize result for property '{0}' on {1}: {2}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName, (object) property.DeclaringType, (object) flag)), (Exception) null);
-      return flag;
-    }
-
-    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target)
-    {
-      if (property.GetIsSpecified == null)
-        return true;
-      bool flag = property.GetIsSpecified(target);
-      if (this.TraceWriter != null && this.TraceWriter.LevelFilter >= TraceLevel.Verbose)
-        this.TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage((IJsonLineInfo) null, writer.Path, "IsSpecified result for property '{0}' on {1}: {2}".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) property.PropertyName, (object) property.DeclaringType, (object) flag)), (Exception) null);
-      return flag;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerProxy.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerProxy.cs
deleted file mode 100644
index b074173..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonSerializerProxy.cs
+++ /dev/null
@@ -1,241 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.Runtime.Serialization;
-using System.Runtime.Serialization.Formatters;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal class JsonSerializerProxy : JsonSerializer
-  {
-    private readonly JsonSerializerInternalReader _serializerReader;
-    private readonly JsonSerializerInternalWriter _serializerWriter;
-    private readonly JsonSerializer _serializer;
-
-    public override event EventHandler<ErrorEventArgs> Error
-    {
-      add => this._serializer.Error += value;
-      remove => this._serializer.Error -= value;
-    }
-
-    public override IReferenceResolver ReferenceResolver
-    {
-      get => this._serializer.ReferenceResolver;
-      set => this._serializer.ReferenceResolver = value;
-    }
-
-    public override ITraceWriter TraceWriter
-    {
-      get => this._serializer.TraceWriter;
-      set => this._serializer.TraceWriter = value;
-    }
-
-    public override IEqualityComparer EqualityComparer
-    {
-      get => this._serializer.EqualityComparer;
-      set => this._serializer.EqualityComparer = value;
-    }
-
-    public override JsonConverterCollection Converters => this._serializer.Converters;
-
-    public override DefaultValueHandling DefaultValueHandling
-    {
-      get => this._serializer.DefaultValueHandling;
-      set => this._serializer.DefaultValueHandling = value;
-    }
-
-    public override IContractResolver ContractResolver
-    {
-      get => this._serializer.ContractResolver;
-      set => this._serializer.ContractResolver = value;
-    }
-
-    public override MissingMemberHandling MissingMemberHandling
-    {
-      get => this._serializer.MissingMemberHandling;
-      set => this._serializer.MissingMemberHandling = value;
-    }
-
-    public override NullValueHandling NullValueHandling
-    {
-      get => this._serializer.NullValueHandling;
-      set => this._serializer.NullValueHandling = value;
-    }
-
-    public override ObjectCreationHandling ObjectCreationHandling
-    {
-      get => this._serializer.ObjectCreationHandling;
-      set => this._serializer.ObjectCreationHandling = value;
-    }
-
-    public override ReferenceLoopHandling ReferenceLoopHandling
-    {
-      get => this._serializer.ReferenceLoopHandling;
-      set => this._serializer.ReferenceLoopHandling = value;
-    }
-
-    public override PreserveReferencesHandling PreserveReferencesHandling
-    {
-      get => this._serializer.PreserveReferencesHandling;
-      set => this._serializer.PreserveReferencesHandling = value;
-    }
-
-    public override TypeNameHandling TypeNameHandling
-    {
-      get => this._serializer.TypeNameHandling;
-      set => this._serializer.TypeNameHandling = value;
-    }
-
-    public override MetadataPropertyHandling MetadataPropertyHandling
-    {
-      get => this._serializer.MetadataPropertyHandling;
-      set => this._serializer.MetadataPropertyHandling = value;
-    }
-
-    [Obsolete("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
-    public override FormatterAssemblyStyle TypeNameAssemblyFormat
-    {
-      get => this._serializer.TypeNameAssemblyFormat;
-      set => this._serializer.TypeNameAssemblyFormat = value;
-    }
-
-    public override TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling
-    {
-      get => this._serializer.TypeNameAssemblyFormatHandling;
-      set => this._serializer.TypeNameAssemblyFormatHandling = value;
-    }
-
-    public override ConstructorHandling ConstructorHandling
-    {
-      get => this._serializer.ConstructorHandling;
-      set => this._serializer.ConstructorHandling = value;
-    }
-
-    [Obsolete("Binder is obsolete. Use SerializationBinder instead.")]
-    public override System.Runtime.Serialization.SerializationBinder Binder
-    {
-      get => this._serializer.Binder;
-      set => this._serializer.Binder = value;
-    }
-
-    public override ISerializationBinder SerializationBinder
-    {
-      get => this._serializer.SerializationBinder;
-      set => this._serializer.SerializationBinder = value;
-    }
-
-    public override StreamingContext Context
-    {
-      get => this._serializer.Context;
-      set => this._serializer.Context = value;
-    }
-
-    public override Formatting Formatting
-    {
-      get => this._serializer.Formatting;
-      set => this._serializer.Formatting = value;
-    }
-
-    public override DateFormatHandling DateFormatHandling
-    {
-      get => this._serializer.DateFormatHandling;
-      set => this._serializer.DateFormatHandling = value;
-    }
-
-    public override DateTimeZoneHandling DateTimeZoneHandling
-    {
-      get => this._serializer.DateTimeZoneHandling;
-      set => this._serializer.DateTimeZoneHandling = value;
-    }
-
-    public override DateParseHandling DateParseHandling
-    {
-      get => this._serializer.DateParseHandling;
-      set => this._serializer.DateParseHandling = value;
-    }
-
-    public override FloatFormatHandling FloatFormatHandling
-    {
-      get => this._serializer.FloatFormatHandling;
-      set => this._serializer.FloatFormatHandling = value;
-    }
-
-    public override FloatParseHandling FloatParseHandling
-    {
-      get => this._serializer.FloatParseHandling;
-      set => this._serializer.FloatParseHandling = value;
-    }
-
-    public override StringEscapeHandling StringEscapeHandling
-    {
-      get => this._serializer.StringEscapeHandling;
-      set => this._serializer.StringEscapeHandling = value;
-    }
-
-    public override string DateFormatString
-    {
-      get => this._serializer.DateFormatString;
-      set => this._serializer.DateFormatString = value;
-    }
-
-    public override CultureInfo Culture
-    {
-      get => this._serializer.Culture;
-      set => this._serializer.Culture = value;
-    }
-
-    public override int? MaxDepth
-    {
-      get => this._serializer.MaxDepth;
-      set => this._serializer.MaxDepth = value;
-    }
-
-    public override bool CheckAdditionalContent
-    {
-      get => this._serializer.CheckAdditionalContent;
-      set => this._serializer.CheckAdditionalContent = value;
-    }
-
-    internal JsonSerializerInternalBase GetInternalSerializer()
-    {
-      return this._serializerReader != null ? (JsonSerializerInternalBase) this._serializerReader : (JsonSerializerInternalBase) this._serializerWriter;
-    }
-
-    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader)
-    {
-      ValidationUtils.ArgumentNotNull((object) serializerReader, nameof (serializerReader));
-      this._serializerReader = serializerReader;
-      this._serializer = serializerReader.Serializer;
-    }
-
-    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter)
-    {
-      ValidationUtils.ArgumentNotNull((object) serializerWriter, nameof (serializerWriter));
-      this._serializerWriter = serializerWriter;
-      this._serializer = serializerWriter.Serializer;
-    }
-
-    internal override object DeserializeInternal(JsonReader reader, Type objectType)
-    {
-      return this._serializerReader != null ? this._serializerReader.Deserialize(reader, objectType, false) : this._serializer.Deserialize(reader, objectType);
-    }
-
-    internal override void PopulateInternal(JsonReader reader, object target)
-    {
-      if (this._serializerReader != null)
-        this._serializerReader.Populate(reader, target);
-      else
-        this._serializer.Populate(reader, target);
-    }
-
-    internal override void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType)
-    {
-      if (this._serializerWriter != null)
-        this._serializerWriter.Serialize(jsonWriter, value, rootType);
-      else
-        this._serializer.Serialize(jsonWriter, value);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonStringContract.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonStringContract.cs
deleted file mode 100644
index 59ee4d5..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonStringContract.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class JsonStringContract : JsonPrimitiveContract
-  {
-    public JsonStringContract(Type underlyingType)
-      : base(underlyingType)
-    {
-      this.ContractType = JsonContractType.String;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/JsonTypeReflector.cs b/MSHALTester/Newtonsoft/Json/Serialization/JsonTypeReflector.cs
deleted file mode 100644
index 1df4476..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/JsonTypeReflector.cs
+++ /dev/null
@@ -1,299 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Globalization;
-using System.Linq;
-using System.Reflection;
-using System.Runtime.Serialization;
-using System.Security.Permissions;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal static class JsonTypeReflector
-  {
-    private static bool? _dynamicCodeGeneration;
-    private static bool? _fullyTrusted;
-    public const string IdPropertyName = "$id";
-    public const string RefPropertyName = "$ref";
-    public const string TypePropertyName = "$type";
-    public const string ValuePropertyName = "$value";
-    public const string ArrayValuesPropertyName = "$values";
-    public const string ShouldSerializePrefix = "ShouldSerialize";
-    public const string SpecifiedPostfix = "Specified";
-    public const string ConcurrentDictionaryTypeName = "System.Collections.Concurrent.ConcurrentDictionary`2";
-    private static readonly ThreadSafeStore<Type, Func<object[], object>> CreatorCache = new ThreadSafeStore<Type, Func<object[], object>>(new Func<Type, Func<object[], object>>(JsonTypeReflector.GetCreator));
-    private static readonly ThreadSafeStore<Type, Type> AssociatedMetadataTypesCache = new ThreadSafeStore<Type, Type>(new Func<Type, Type>(JsonTypeReflector.GetAssociateMetadataTypeFromAttribute));
-    private static ReflectionObject _metadataTypeAttributeReflectionObject;
-
-    public static T GetCachedAttribute<T>(object attributeProvider) where T : Attribute
-    {
-      return CachedAttributeGetter<T>.GetAttribute(attributeProvider);
-    }
-
-    public static bool CanTypeDescriptorConvertString(Type type, out TypeConverter typeConverter)
-    {
-      typeConverter = TypeDescriptor.GetConverter(type);
-      if (typeConverter != null)
-      {
-        Type type1 = typeConverter.GetType();
-        if (!string.Equals(type1.FullName, "System.ComponentModel.ComponentConverter", StringComparison.Ordinal) && !string.Equals(type1.FullName, "System.ComponentModel.ReferenceConverter", StringComparison.Ordinal) && !string.Equals(type1.FullName, "System.Windows.Forms.Design.DataSourceConverter", StringComparison.Ordinal) && type1 != typeof (TypeConverter))
-          return typeConverter.CanConvertTo(typeof (string));
-      }
-      return false;
-    }
-
-    public static DataContractAttribute GetDataContractAttribute(Type type)
-    {
-      for (Type type1 = type; type1 != null; type1 = type1.BaseType())
-      {
-        DataContractAttribute attribute = CachedAttributeGetter<DataContractAttribute>.GetAttribute((object) type1);
-        if (attribute != null)
-          return attribute;
-      }
-      return (DataContractAttribute) null;
-    }
-
-    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo)
-    {
-      if (memberInfo.MemberType() == MemberTypes.Field)
-        return CachedAttributeGetter<DataMemberAttribute>.GetAttribute((object) memberInfo);
-      PropertyInfo propertyInfo = (PropertyInfo) memberInfo;
-      DataMemberAttribute attribute = CachedAttributeGetter<DataMemberAttribute>.GetAttribute((object) propertyInfo);
-      if (attribute == null && propertyInfo.IsVirtual())
-      {
-        for (Type type = propertyInfo.DeclaringType; attribute == null && type != null; type = type.BaseType())
-        {
-          PropertyInfo memberInfoFromType = (PropertyInfo) ReflectionUtils.GetMemberInfoFromType(type, (MemberInfo) propertyInfo);
-          if (memberInfoFromType != null && memberInfoFromType.IsVirtual())
-            attribute = CachedAttributeGetter<DataMemberAttribute>.GetAttribute((object) memberInfoFromType);
-        }
-      }
-      return attribute;
-    }
-
-    public static MemberSerialization GetObjectMemberSerialization(
-      Type objectType,
-      bool ignoreSerializableAttribute)
-    {
-      JsonObjectAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonObjectAttribute>((object) objectType);
-      if (cachedAttribute != null)
-        return cachedAttribute.MemberSerialization;
-      if (JsonTypeReflector.GetDataContractAttribute(objectType) != null)
-        return MemberSerialization.OptIn;
-      return !ignoreSerializableAttribute && JsonTypeReflector.IsSerializable((object) objectType) ? MemberSerialization.Fields : MemberSerialization.OptOut;
-    }
-
-    public static JsonConverter GetJsonConverter(object attributeProvider)
-    {
-      JsonConverterAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonConverterAttribute>(attributeProvider);
-      if (cachedAttribute != null)
-      {
-        Func<object[], object> func = JsonTypeReflector.CreatorCache.Get(cachedAttribute.ConverterType);
-        if (func != null)
-          return (JsonConverter) func(cachedAttribute.ConverterParameters);
-      }
-      return (JsonConverter) null;
-    }
-
-    public static JsonConverter CreateJsonConverterInstance(
-      Type converterType,
-      object[] converterArgs)
-    {
-      return (JsonConverter) JsonTypeReflector.CreatorCache.Get(converterType)(converterArgs);
-    }
-
-    public static NamingStrategy CreateNamingStrategyInstance(
-      Type namingStrategyType,
-      object[] converterArgs)
-    {
-      return (NamingStrategy) JsonTypeReflector.CreatorCache.Get(namingStrategyType)(converterArgs);
-    }
-
-    public static NamingStrategy GetContainerNamingStrategy(
-      JsonContainerAttribute containerAttribute)
-    {
-      if (containerAttribute.NamingStrategyInstance == null)
-      {
-        if (containerAttribute.NamingStrategyType == null)
-          return (NamingStrategy) null;
-        containerAttribute.NamingStrategyInstance = JsonTypeReflector.CreateNamingStrategyInstance(containerAttribute.NamingStrategyType, containerAttribute.NamingStrategyParameters);
-      }
-      return containerAttribute.NamingStrategyInstance;
-    }
-
-    private static Func<object[], object> GetCreator(Type type)
-    {
-      Func<object> defaultConstructor = ReflectionUtils.HasDefaultConstructor(type, false) ? JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type) : (Func<object>) null;
-      return (Func<object[], object>) (parameters =>
-      {
-        try
-        {
-          if (parameters != null)
-          {
-            ConstructorInfo constructor = type.GetConstructor(((IEnumerable<object>) parameters).Select<object, Type>((Func<object, Type>) (param => param.GetType())).ToArray<Type>());
-            if (constructor != null)
-              return JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) constructor)(parameters);
-            throw new JsonException("No matching parameterized constructor found for '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type));
-          }
-          if (defaultConstructor == null)
-            throw new JsonException("No parameterless constructor defined for '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type));
-          return defaultConstructor();
-        }
-        catch (Exception ex)
-        {
-          throw new JsonException("Error creating '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type), ex);
-        }
-      });
-    }
-
-    private static Type GetAssociatedMetadataType(Type type)
-    {
-      return JsonTypeReflector.AssociatedMetadataTypesCache.Get(type);
-    }
-
-    private static Type GetAssociateMetadataTypeFromAttribute(Type type)
-    {
-      foreach (Attribute attribute in ReflectionUtils.GetAttributes((object) type, (Type) null, true))
-      {
-        Type type1 = attribute.GetType();
-        if (string.Equals(type1.FullName, "System.ComponentModel.DataAnnotations.MetadataTypeAttribute", StringComparison.Ordinal))
-        {
-          if (JsonTypeReflector._metadataTypeAttributeReflectionObject == null)
-            JsonTypeReflector._metadataTypeAttributeReflectionObject = ReflectionObject.Create(type1, "MetadataClassType");
-          return (Type) JsonTypeReflector._metadataTypeAttributeReflectionObject.GetValue((object) attribute, "MetadataClassType");
-        }
-      }
-      return (Type) null;
-    }
-
-    private static T GetAttribute<T>(Type type) where T : Attribute
-    {
-      Type associatedMetadataType = JsonTypeReflector.GetAssociatedMetadataType(type);
-      if (associatedMetadataType != null)
-      {
-        T attribute = ReflectionUtils.GetAttribute<T>((object) associatedMetadataType, true);
-        if ((object) attribute != null)
-          return attribute;
-      }
-      T attribute1 = ReflectionUtils.GetAttribute<T>((object) type, true);
-      if ((object) attribute1 != null)
-        return attribute1;
-      foreach (object attributeProvider in type.GetInterfaces())
-      {
-        T attribute2 = ReflectionUtils.GetAttribute<T>(attributeProvider, true);
-        if ((object) attribute2 != null)
-          return attribute2;
-      }
-      return default (T);
-    }
-
-    private static T GetAttribute<T>(MemberInfo memberInfo) where T : Attribute
-    {
-      Type associatedMetadataType = JsonTypeReflector.GetAssociatedMetadataType(memberInfo.DeclaringType);
-      if (associatedMetadataType != null)
-      {
-        MemberInfo memberInfoFromType = ReflectionUtils.GetMemberInfoFromType(associatedMetadataType, memberInfo);
-        if (memberInfoFromType != null)
-        {
-          T attribute = ReflectionUtils.GetAttribute<T>((object) memberInfoFromType, true);
-          if ((object) attribute != null)
-            return attribute;
-        }
-      }
-      T attribute1 = ReflectionUtils.GetAttribute<T>((object) memberInfo, true);
-      if ((object) attribute1 != null)
-        return attribute1;
-      if (memberInfo.DeclaringType != null)
-      {
-        foreach (Type targetType in memberInfo.DeclaringType.GetInterfaces())
-        {
-          MemberInfo memberInfoFromType = ReflectionUtils.GetMemberInfoFromType(targetType, memberInfo);
-          if (memberInfoFromType != null)
-          {
-            T attribute2 = ReflectionUtils.GetAttribute<T>((object) memberInfoFromType, true);
-            if ((object) attribute2 != null)
-              return attribute2;
-          }
-        }
-      }
-      return default (T);
-    }
-
-    public static bool IsNonSerializable(object provider)
-    {
-      return ReflectionUtils.GetAttribute<NonSerializedAttribute>(provider, false) != null;
-    }
-
-    public static bool IsSerializable(object provider)
-    {
-      return ReflectionUtils.GetAttribute<SerializableAttribute>(provider, false) != null;
-    }
-
-    public static T GetAttribute<T>(object provider) where T : Attribute
-    {
-      switch (provider)
-      {
-        case Type type:
-          return JsonTypeReflector.GetAttribute<T>(type);
-        case MemberInfo memberInfo:
-          return JsonTypeReflector.GetAttribute<T>(memberInfo);
-        default:
-          return ReflectionUtils.GetAttribute<T>(provider, true);
-      }
-    }
-
-    public static bool DynamicCodeGeneration
-    {
-      get
-      {
-        if (!JsonTypeReflector._dynamicCodeGeneration.HasValue)
-        {
-          try
-          {
-            new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Demand();
-            new ReflectionPermission(ReflectionPermissionFlag.RestrictedMemberAccess).Demand();
-            new SecurityPermission(SecurityPermissionFlag.SkipVerification).Demand();
-            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
-            new SecurityPermission(PermissionState.Unrestricted).Demand();
-            JsonTypeReflector._dynamicCodeGeneration = new bool?(true);
-          }
-          catch (Exception ex)
-          {
-            JsonTypeReflector._dynamicCodeGeneration = new bool?(false);
-          }
-        }
-        return JsonTypeReflector._dynamicCodeGeneration.GetValueOrDefault();
-      }
-    }
-
-    public static bool FullyTrusted
-    {
-      get
-      {
-        if (!JsonTypeReflector._fullyTrusted.HasValue)
-        {
-          try
-          {
-            new SecurityPermission(PermissionState.Unrestricted).Demand();
-            JsonTypeReflector._fullyTrusted = new bool?(true);
-          }
-          catch (Exception ex)
-          {
-            JsonTypeReflector._fullyTrusted = new bool?(false);
-          }
-        }
-        return JsonTypeReflector._fullyTrusted.GetValueOrDefault();
-      }
-    }
-
-    public static ReflectionDelegateFactory ReflectionDelegateFactory
-    {
-      get
-      {
-        return JsonTypeReflector.DynamicCodeGeneration ? (ReflectionDelegateFactory) DynamicReflectionDelegateFactory.Instance : LateBoundReflectionDelegateFactory.Instance;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/MemoryTraceWriter.cs b/MSHALTester/Newtonsoft/Json/Serialization/MemoryTraceWriter.cs
deleted file mode 100644
index b552e5c..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/MemoryTraceWriter.cs
+++ /dev/null
@@ -1,58 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Globalization;
-using System.Text;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class MemoryTraceWriter : ITraceWriter
-  {
-    private readonly Queue<string> _traceMessages;
-    private readonly object _lock;
-
-    public TraceLevel LevelFilter { get; set; }
-
-    public MemoryTraceWriter()
-    {
-      this.LevelFilter = TraceLevel.Verbose;
-      this._traceMessages = new Queue<string>();
-      this._lock = new object();
-    }
-
-    public void Trace(TraceLevel level, string message, Exception ex)
-    {
-      StringBuilder stringBuilder = new StringBuilder();
-      stringBuilder.Append(DateTime.Now.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff", (IFormatProvider) CultureInfo.InvariantCulture));
-      stringBuilder.Append(" ");
-      stringBuilder.Append(level.ToString("g"));
-      stringBuilder.Append(" ");
-      stringBuilder.Append(message);
-      string str = stringBuilder.ToString();
-      lock (this._lock)
-      {
-        if (this._traceMessages.Count >= 1000)
-          this._traceMessages.Dequeue();
-        this._traceMessages.Enqueue(str);
-      }
-    }
-
-    public IEnumerable<string> GetTraceMessages() => (IEnumerable<string>) this._traceMessages;
-
-    public override string ToString()
-    {
-      lock (this._lock)
-      {
-        StringBuilder stringBuilder = new StringBuilder();
-        foreach (string traceMessage in this._traceMessages)
-        {
-          if (stringBuilder.Length > 0)
-            stringBuilder.AppendLine();
-          stringBuilder.Append(traceMessage);
-        }
-        return stringBuilder.ToString();
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/NamingStrategy.cs b/MSHALTester/Newtonsoft/Json/Serialization/NamingStrategy.cs
deleted file mode 100644
index 78f9fea..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/NamingStrategy.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public abstract class NamingStrategy
-  {
-    public bool ProcessDictionaryKeys { get; set; }
-
-    public bool ProcessExtensionDataNames { get; set; }
-
-    public bool OverrideSpecifiedNames { get; set; }
-
-    public virtual string GetPropertyName(string name, bool hasSpecifiedName)
-    {
-      return hasSpecifiedName && !this.OverrideSpecifiedNames ? name : this.ResolvePropertyName(name);
-    }
-
-    public virtual string GetExtensionDataName(string name)
-    {
-      return !this.ProcessExtensionDataNames ? name : this.ResolvePropertyName(name);
-    }
-
-    public virtual string GetDictionaryKey(string key)
-    {
-      return !this.ProcessDictionaryKeys ? key : this.ResolvePropertyName(key);
-    }
-
-    protected abstract string ResolvePropertyName(string name);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ObjectConstructor`1.cs b/MSHALTester/Newtonsoft/Json/Serialization/ObjectConstructor`1.cs
deleted file mode 100644
index 064b00e..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ObjectConstructor`1.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public delegate object ObjectConstructor<T>(params object[] args);
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/OnErrorAttribute.cs b/MSHALTester/Newtonsoft/Json/Serialization/OnErrorAttribute.cs
deleted file mode 100644
index 7ead566..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/OnErrorAttribute.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  [AttributeUsage(AttributeTargets.Method, Inherited = false)]
-  public sealed class OnErrorAttribute : Attribute
-  {
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ReflectionAttributeProvider.cs b/MSHALTester/Newtonsoft/Json/Serialization/ReflectionAttributeProvider.cs
deleted file mode 100644
index f01102c..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ReflectionAttributeProvider.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Collections.Generic;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class ReflectionAttributeProvider : IAttributeProvider
-  {
-    private readonly object _attributeProvider;
-
-    public ReflectionAttributeProvider(object attributeProvider)
-    {
-      ValidationUtils.ArgumentNotNull(attributeProvider, nameof (attributeProvider));
-      this._attributeProvider = attributeProvider;
-    }
-
-    public IList<Attribute> GetAttributes(bool inherit)
-    {
-      return (IList<Attribute>) ReflectionUtils.GetAttributes(this._attributeProvider, (Type) null, inherit);
-    }
-
-    public IList<Attribute> GetAttributes(Type attributeType, bool inherit)
-    {
-      return (IList<Attribute>) ReflectionUtils.GetAttributes(this._attributeProvider, attributeType, inherit);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ReflectionValueProvider.cs b/MSHALTester/Newtonsoft/Json/Serialization/ReflectionValueProvider.cs
deleted file mode 100644
index 1851ecb..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ReflectionValueProvider.cs
+++ /dev/null
@@ -1,45 +0,0 @@
-using Newtonsoft.Json.Utilities;
-using System;
-using System.Globalization;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class ReflectionValueProvider : IValueProvider
-  {
-    private readonly MemberInfo _memberInfo;
-
-    public ReflectionValueProvider(MemberInfo memberInfo)
-    {
-      ValidationUtils.ArgumentNotNull((object) memberInfo, nameof (memberInfo));
-      this._memberInfo = memberInfo;
-    }
-
-    public void SetValue(object target, object value)
-    {
-      try
-      {
-        ReflectionUtils.SetMemberValue(this._memberInfo, target, value);
-      }
-      catch (Exception ex)
-      {
-        throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._memberInfo.Name, (object) target.GetType()), ex);
-      }
-    }
-
-    public object GetValue(object target)
-    {
-      try
-      {
-        if (this._memberInfo is PropertyInfo memberInfo && memberInfo.PropertyType.IsByRef)
-          throw new InvalidOperationException("Could not create getter for {0}. ByRef return values are not supported.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) memberInfo));
-        return ReflectionUtils.GetMemberValue(this._memberInfo, target);
-      }
-      catch (Exception ex)
-      {
-        throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) this._memberInfo.Name, (object) target.GetType()), ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/ResolverContractKey.cs b/MSHALTester/Newtonsoft/Json/Serialization/ResolverContractKey.cs
deleted file mode 100644
index 02c0d19..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/ResolverContractKey.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal readonly struct ResolverContractKey(Type resolverType, Type contractType) : 
-    IEquatable<ResolverContractKey>
-  {
-    private readonly Type _resolverType = resolverType;
-    private readonly Type _contractType = contractType;
-
-    public override int GetHashCode()
-    {
-      return this._resolverType.GetHashCode() ^ this._contractType.GetHashCode();
-    }
-
-    public override bool Equals(object obj)
-    {
-      return obj is ResolverContractKey other && this.Equals(other);
-    }
-
-    public bool Equals(ResolverContractKey other)
-    {
-      return this._resolverType == other._resolverType && this._contractType == other._contractType;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/SerializationBinderAdapter.cs b/MSHALTester/Newtonsoft/Json/Serialization/SerializationBinderAdapter.cs
deleted file mode 100644
index f78d8d2..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/SerializationBinderAdapter.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal class SerializationBinderAdapter : ISerializationBinder
-  {
-    public readonly SerializationBinder SerializationBinder;
-
-    public SerializationBinderAdapter(SerializationBinder serializationBinder)
-    {
-      this.SerializationBinder = serializationBinder;
-    }
-
-    public Type BindToType(string assemblyName, string typeName)
-    {
-      return this.SerializationBinder.BindToType(assemblyName, typeName);
-    }
-
-    public void BindToName(Type serializedType, out string assemblyName, out string typeName)
-    {
-      assemblyName = (string) null;
-      typeName = (string) null;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/SerializationCallback.cs b/MSHALTester/Newtonsoft/Json/Serialization/SerializationCallback.cs
deleted file mode 100644
index d5fcd07..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/SerializationCallback.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public delegate void SerializationCallback(object o, StreamingContext context);
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/SerializationErrorCallback.cs b/MSHALTester/Newtonsoft/Json/Serialization/SerializationErrorCallback.cs
deleted file mode 100644
index f98a922..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/SerializationErrorCallback.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public delegate void SerializationErrorCallback(
-    object o,
-    StreamingContext context,
-    ErrorContext errorContext);
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/SnakeCaseNamingStrategy.cs b/MSHALTester/Newtonsoft/Json/Serialization/SnakeCaseNamingStrategy.cs
deleted file mode 100644
index 04131f6..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/SnakeCaseNamingStrategy.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using Newtonsoft.Json.Utilities;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  public class SnakeCaseNamingStrategy : NamingStrategy
-  {
-    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames)
-    {
-      this.ProcessDictionaryKeys = processDictionaryKeys;
-      this.OverrideSpecifiedNames = overrideSpecifiedNames;
-    }
-
-    public SnakeCaseNamingStrategy(
-      bool processDictionaryKeys,
-      bool overrideSpecifiedNames,
-      bool processExtensionDataNames)
-      : this(processDictionaryKeys, overrideSpecifiedNames)
-    {
-      this.ProcessExtensionDataNames = processExtensionDataNames;
-    }
-
-    public SnakeCaseNamingStrategy()
-    {
-    }
-
-    protected override string ResolvePropertyName(string name) => StringUtils.ToSnakeCase(name);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/TraceJsonReader.cs b/MSHALTester/Newtonsoft/Json/Serialization/TraceJsonReader.cs
deleted file mode 100644
index 78b9e1c..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/TraceJsonReader.cs
+++ /dev/null
@@ -1,126 +0,0 @@
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal class TraceJsonReader : JsonReader, IJsonLineInfo
-  {
-    private readonly JsonReader _innerReader;
-    private readonly JsonTextWriter _textWriter;
-    private readonly StringWriter _sw;
-
-    public TraceJsonReader(JsonReader innerReader)
-    {
-      this._innerReader = innerReader;
-      this._sw = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-      this._sw.Write("Deserialized JSON: " + Environment.NewLine);
-      this._textWriter = new JsonTextWriter((TextWriter) this._sw);
-      this._textWriter.Formatting = Formatting.Indented;
-    }
-
-    public string GetDeserializedJsonMessage() => this._sw.ToString();
-
-    public override bool Read()
-    {
-      int num = this._innerReader.Read() ? 1 : 0;
-      this.WriteCurrentToken();
-      return num != 0;
-    }
-
-    public override int? ReadAsInt32()
-    {
-      int? nullable = this._innerReader.ReadAsInt32();
-      this.WriteCurrentToken();
-      return nullable;
-    }
-
-    public override string ReadAsString()
-    {
-      string str = this._innerReader.ReadAsString();
-      this.WriteCurrentToken();
-      return str;
-    }
-
-    public override byte[] ReadAsBytes()
-    {
-      byte[] numArray = this._innerReader.ReadAsBytes();
-      this.WriteCurrentToken();
-      return numArray;
-    }
-
-    public override Decimal? ReadAsDecimal()
-    {
-      Decimal? nullable = this._innerReader.ReadAsDecimal();
-      this.WriteCurrentToken();
-      return nullable;
-    }
-
-    public override double? ReadAsDouble()
-    {
-      double? nullable = this._innerReader.ReadAsDouble();
-      this.WriteCurrentToken();
-      return nullable;
-    }
-
-    public override bool? ReadAsBoolean()
-    {
-      bool? nullable = this._innerReader.ReadAsBoolean();
-      this.WriteCurrentToken();
-      return nullable;
-    }
-
-    public override DateTime? ReadAsDateTime()
-    {
-      DateTime? nullable = this._innerReader.ReadAsDateTime();
-      this.WriteCurrentToken();
-      return nullable;
-    }
-
-    public override DateTimeOffset? ReadAsDateTimeOffset()
-    {
-      DateTimeOffset? nullable = this._innerReader.ReadAsDateTimeOffset();
-      this.WriteCurrentToken();
-      return nullable;
-    }
-
-    public void WriteCurrentToken()
-    {
-      this._textWriter.WriteToken(this._innerReader, false, false, true);
-    }
-
-    public override int Depth => this._innerReader.Depth;
-
-    public override string Path => this._innerReader.Path;
-
-    public override char QuoteChar
-    {
-      get => this._innerReader.QuoteChar;
-      protected internal set => this._innerReader.QuoteChar = value;
-    }
-
-    public override JsonToken TokenType => this._innerReader.TokenType;
-
-    public override object Value => this._innerReader.Value;
-
-    public override Type ValueType => this._innerReader.ValueType;
-
-    public override void Close() => this._innerReader.Close();
-
-    bool IJsonLineInfo.HasLineInfo()
-    {
-      return this._innerReader is IJsonLineInfo innerReader && innerReader.HasLineInfo();
-    }
-
-    int IJsonLineInfo.LineNumber
-    {
-      get => !(this._innerReader is IJsonLineInfo innerReader) ? 0 : innerReader.LineNumber;
-    }
-
-    int IJsonLineInfo.LinePosition
-    {
-      get => !(this._innerReader is IJsonLineInfo innerReader) ? 0 : innerReader.LinePosition;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Serialization/TraceJsonWriter.cs b/MSHALTester/Newtonsoft/Json/Serialization/TraceJsonWriter.cs
deleted file mode 100644
index 149151b..0000000
--- a/MSHALTester/Newtonsoft/Json/Serialization/TraceJsonWriter.cs
+++ /dev/null
@@ -1,467 +0,0 @@
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json.Serialization
-{
-  internal class TraceJsonWriter : JsonWriter
-  {
-    private readonly JsonWriter _innerWriter;
-    private readonly JsonTextWriter _textWriter;
-    private readonly StringWriter _sw;
-
-    public TraceJsonWriter(JsonWriter innerWriter)
-    {
-      this._innerWriter = innerWriter;
-      this._sw = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-      this._sw.Write("Serialized JSON: " + Environment.NewLine);
-      this._textWriter = new JsonTextWriter((TextWriter) this._sw);
-      this._textWriter.Formatting = Formatting.Indented;
-      this._textWriter.Culture = innerWriter.Culture;
-      this._textWriter.DateFormatHandling = innerWriter.DateFormatHandling;
-      this._textWriter.DateFormatString = innerWriter.DateFormatString;
-      this._textWriter.DateTimeZoneHandling = innerWriter.DateTimeZoneHandling;
-      this._textWriter.FloatFormatHandling = innerWriter.FloatFormatHandling;
-    }
-
-    public string GetSerializedJsonMessage() => this._sw.ToString();
-
-    public override void WriteValue(Decimal value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(Decimal? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(bool value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(bool? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(byte value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(byte? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(char value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(char? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(byte[] value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value == null)
-        base.WriteUndefined();
-      else
-        base.WriteValue(value);
-    }
-
-    public override void WriteValue(DateTime value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(DateTime? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(DateTimeOffset value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(DateTimeOffset? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(double value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(double? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteUndefined()
-    {
-      this._textWriter.WriteUndefined();
-      this._innerWriter.WriteUndefined();
-      base.WriteUndefined();
-    }
-
-    public override void WriteNull()
-    {
-      this._textWriter.WriteNull();
-      this._innerWriter.WriteNull();
-      base.WriteUndefined();
-    }
-
-    public override void WriteValue(float value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(float? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(Guid value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(Guid? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(int value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(int? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(long value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(long? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(object value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value == null)
-        base.WriteUndefined();
-      else
-        this.InternalWriteValue(JsonToken.String);
-    }
-
-    public override void WriteValue(sbyte value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(sbyte? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(short value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(short? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(string value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(TimeSpan value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(TimeSpan? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(uint value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(uint? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(ulong value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(ulong? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteValue(Uri value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value == (Uri) null)
-        base.WriteUndefined();
-      else
-        base.WriteValue(value);
-    }
-
-    public override void WriteValue(ushort value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      base.WriteValue(value);
-    }
-
-    public override void WriteValue(ushort? value)
-    {
-      this._textWriter.WriteValue(value);
-      this._innerWriter.WriteValue(value);
-      if (value.HasValue)
-        base.WriteValue(value.GetValueOrDefault());
-      else
-        base.WriteUndefined();
-    }
-
-    public override void WriteWhitespace(string ws)
-    {
-      this._textWriter.WriteWhitespace(ws);
-      this._innerWriter.WriteWhitespace(ws);
-      base.WriteWhitespace(ws);
-    }
-
-    public override void WriteComment(string text)
-    {
-      this._textWriter.WriteComment(text);
-      this._innerWriter.WriteComment(text);
-      base.WriteComment(text);
-    }
-
-    public override void WriteStartArray()
-    {
-      this._textWriter.WriteStartArray();
-      this._innerWriter.WriteStartArray();
-      base.WriteStartArray();
-    }
-
-    public override void WriteEndArray()
-    {
-      this._textWriter.WriteEndArray();
-      this._innerWriter.WriteEndArray();
-      base.WriteEndArray();
-    }
-
-    public override void WriteStartConstructor(string name)
-    {
-      this._textWriter.WriteStartConstructor(name);
-      this._innerWriter.WriteStartConstructor(name);
-      base.WriteStartConstructor(name);
-    }
-
-    public override void WriteEndConstructor()
-    {
-      this._textWriter.WriteEndConstructor();
-      this._innerWriter.WriteEndConstructor();
-      base.WriteEndConstructor();
-    }
-
-    public override void WritePropertyName(string name)
-    {
-      this._textWriter.WritePropertyName(name);
-      this._innerWriter.WritePropertyName(name);
-      base.WritePropertyName(name);
-    }
-
-    public override void WritePropertyName(string name, bool escape)
-    {
-      this._textWriter.WritePropertyName(name, escape);
-      this._innerWriter.WritePropertyName(name, escape);
-      base.WritePropertyName(name);
-    }
-
-    public override void WriteStartObject()
-    {
-      this._textWriter.WriteStartObject();
-      this._innerWriter.WriteStartObject();
-      base.WriteStartObject();
-    }
-
-    public override void WriteEndObject()
-    {
-      this._textWriter.WriteEndObject();
-      this._innerWriter.WriteEndObject();
-      base.WriteEndObject();
-    }
-
-    public override void WriteRawValue(string json)
-    {
-      this._textWriter.WriteRawValue(json);
-      this._innerWriter.WriteRawValue(json);
-      this.InternalWriteValue(JsonToken.Undefined);
-    }
-
-    public override void WriteRaw(string json)
-    {
-      this._textWriter.WriteRaw(json);
-      this._innerWriter.WriteRaw(json);
-      base.WriteRaw(json);
-    }
-
-    public override void Close()
-    {
-      this._textWriter.Close();
-      this._innerWriter.Close();
-      base.Close();
-    }
-
-    public override void Flush()
-    {
-      this._textWriter.Flush();
-      this._innerWriter.Flush();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/StringEscapeHandling.cs b/MSHALTester/Newtonsoft/Json/StringEscapeHandling.cs
deleted file mode 100644
index 4a84e8e..0000000
--- a/MSHALTester/Newtonsoft/Json/StringEscapeHandling.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum StringEscapeHandling
-  {
-    Default,
-    EscapeNonAscii,
-    EscapeHtml,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/TypeNameAssemblyFormatHandling.cs b/MSHALTester/Newtonsoft/Json/TypeNameAssemblyFormatHandling.cs
deleted file mode 100644
index 8478dc5..0000000
--- a/MSHALTester/Newtonsoft/Json/TypeNameAssemblyFormatHandling.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum TypeNameAssemblyFormatHandling
-  {
-    Simple,
-    Full,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/TypeNameHandling.cs b/MSHALTester/Newtonsoft/Json/TypeNameHandling.cs
deleted file mode 100644
index 45b30a5..0000000
--- a/MSHALTester/Newtonsoft/Json/TypeNameHandling.cs
+++ /dev/null
@@ -1,15 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json
-{
-  [Flags]
-  public enum TypeNameHandling
-  {
-    None = 0,
-    Objects = 1,
-    Arrays = 2,
-    All = Arrays | Objects, // 0x00000003
-    Auto = 4,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/Base64Encoder.cs b/MSHALTester/Newtonsoft/Json/Utilities/Base64Encoder.cs
deleted file mode 100644
index 0ce4b66..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/Base64Encoder.cs
+++ /dev/null
@@ -1,95 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class Base64Encoder
-  {
-    private const int Base64LineSize = 76;
-    private const int LineSizeInBytes = 57;
-    private readonly char[] _charsLine = new char[76];
-    private readonly TextWriter _writer;
-    private byte[] _leftOverBytes;
-    private int _leftOverBytesCount;
-
-    public Base64Encoder(TextWriter writer)
-    {
-      ValidationUtils.ArgumentNotNull((object) writer, nameof (writer));
-      this._writer = writer;
-    }
-
-    private void ValidateEncode(byte[] buffer, int index, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (index < 0)
-        throw new ArgumentOutOfRangeException(nameof (index));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (count > buffer.Length - index)
-        throw new ArgumentOutOfRangeException(nameof (count));
-    }
-
-    public void Encode(byte[] buffer, int index, int count)
-    {
-      this.ValidateEncode(buffer, index, count);
-      if (this._leftOverBytesCount > 0)
-      {
-        if (this.FulfillFromLeftover(buffer, index, ref count))
-          return;
-        this.WriteChars(this._charsLine, 0, Convert.ToBase64CharArray(this._leftOverBytes, 0, 3, this._charsLine, 0));
-      }
-      this.StoreLeftOverBytes(buffer, index, ref count);
-      int num = index + count;
-      int length = 57;
-      for (; index < num; index += length)
-      {
-        if (index + length > num)
-          length = num - index;
-        this.WriteChars(this._charsLine, 0, Convert.ToBase64CharArray(buffer, index, length, this._charsLine, 0));
-      }
-    }
-
-    private void StoreLeftOverBytes(byte[] buffer, int index, ref int count)
-    {
-      int num = count % 3;
-      if (num > 0)
-      {
-        count -= num;
-        if (this._leftOverBytes == null)
-          this._leftOverBytes = new byte[3];
-        for (int index1 = 0; index1 < num; ++index1)
-          this._leftOverBytes[index1] = buffer[index + count + index1];
-      }
-      this._leftOverBytesCount = num;
-    }
-
-    private bool FulfillFromLeftover(byte[] buffer, int index, ref int count)
-    {
-      int leftOverBytesCount = this._leftOverBytesCount;
-      while (leftOverBytesCount < 3 && count > 0)
-      {
-        this._leftOverBytes[leftOverBytesCount++] = buffer[index++];
-        --count;
-      }
-      if (count != 0 || leftOverBytesCount >= 3)
-        return false;
-      this._leftOverBytesCount = leftOverBytesCount;
-      return true;
-    }
-
-    public void Flush()
-    {
-      if (this._leftOverBytesCount <= 0)
-        return;
-      this.WriteChars(this._charsLine, 0, Convert.ToBase64CharArray(this._leftOverBytes, 0, this._leftOverBytesCount, this._charsLine, 0));
-      this._leftOverBytesCount = 0;
-    }
-
-    private void WriteChars(char[] chars, int index, int count)
-    {
-      this._writer.Write(chars, index, count);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/BidirectionalDictionary`2.cs b/MSHALTester/Newtonsoft/Json/Utilities/BidirectionalDictionary`2.cs
deleted file mode 100644
index 7016dde..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/BidirectionalDictionary`2.cs
+++ /dev/null
@@ -1,61 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class BidirectionalDictionary<TFirst, TSecond>
-  {
-    private readonly IDictionary<TFirst, TSecond> _firstToSecond;
-    private readonly IDictionary<TSecond, TFirst> _secondToFirst;
-    private readonly string _duplicateFirstErrorMessage;
-    private readonly string _duplicateSecondErrorMessage;
-
-    public BidirectionalDictionary()
-      : this((IEqualityComparer<TFirst>) EqualityComparer<TFirst>.Default, (IEqualityComparer<TSecond>) EqualityComparer<TSecond>.Default)
-    {
-    }
-
-    public BidirectionalDictionary(
-      IEqualityComparer<TFirst> firstEqualityComparer,
-      IEqualityComparer<TSecond> secondEqualityComparer)
-      : this(firstEqualityComparer, secondEqualityComparer, "Duplicate item already exists for '{0}'.", "Duplicate item already exists for '{0}'.")
-    {
-    }
-
-    public BidirectionalDictionary(
-      IEqualityComparer<TFirst> firstEqualityComparer,
-      IEqualityComparer<TSecond> secondEqualityComparer,
-      string duplicateFirstErrorMessage,
-      string duplicateSecondErrorMessage)
-    {
-      this._firstToSecond = (IDictionary<TFirst, TSecond>) new Dictionary<TFirst, TSecond>(firstEqualityComparer);
-      this._secondToFirst = (IDictionary<TSecond, TFirst>) new Dictionary<TSecond, TFirst>(secondEqualityComparer);
-      this._duplicateFirstErrorMessage = duplicateFirstErrorMessage;
-      this._duplicateSecondErrorMessage = duplicateSecondErrorMessage;
-    }
-
-    public void Set(TFirst first, TSecond second)
-    {
-      TSecond second1;
-      if (this._firstToSecond.TryGetValue(first, out second1) && !second1.Equals((object) second))
-        throw new ArgumentException(this._duplicateFirstErrorMessage.FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) first));
-      TFirst first1;
-      if (this._secondToFirst.TryGetValue(second, out first1) && !first1.Equals((object) first))
-        throw new ArgumentException(this._duplicateSecondErrorMessage.FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) second));
-      this._firstToSecond.Add(first, second);
-      this._secondToFirst.Add(second, first);
-    }
-
-    public bool TryGetByFirst(TFirst first, out TSecond second)
-    {
-      return this._firstToSecond.TryGetValue(first, out second);
-    }
-
-    public bool TryGetBySecond(TSecond second, out TFirst first)
-    {
-      return this._secondToFirst.TryGetValue(second, out first);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/BufferUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/BufferUtils.cs
deleted file mode 100644
index 06e79b6..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/BufferUtils.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class BufferUtils
-  {
-    public static char[] RentBuffer(IArrayPool<char> bufferPool, int minSize)
-    {
-      return bufferPool == null ? new char[minSize] : bufferPool.Rent(minSize);
-    }
-
-    public static void ReturnBuffer(IArrayPool<char> bufferPool, char[] buffer)
-    {
-      bufferPool?.Return(buffer);
-    }
-
-    public static char[] EnsureBufferSize(IArrayPool<char> bufferPool, int size, char[] buffer)
-    {
-      if (bufferPool == null)
-        return new char[size];
-      if (buffer != null)
-        bufferPool.Return(buffer);
-      return bufferPool.Rent(size);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/CollectionUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/CollectionUtils.cs
deleted file mode 100644
index f17ed7a..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/CollectionUtils.cs
+++ /dev/null
@@ -1,229 +0,0 @@
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class CollectionUtils
-  {
-    public static bool IsNullOrEmpty<T>(ICollection<T> collection)
-    {
-      return collection == null || collection.Count == 0;
-    }
-
-    public static void AddRange<T>(this IList<T> initial, IEnumerable<T> collection)
-    {
-      if (initial == null)
-        throw new ArgumentNullException(nameof (initial));
-      if (collection == null)
-        return;
-      foreach (T obj in collection)
-        initial.Add(obj);
-    }
-
-    public static void AddRange<T>(this IList<T> initial, IEnumerable collection)
-    {
-      ValidationUtils.ArgumentNotNull((object) initial, nameof (initial));
-      CollectionUtils.AddRange<T>(initial, collection.Cast<T>());
-    }
-
-    public static bool IsDictionaryType(Type type)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      return typeof (IDictionary).IsAssignableFrom(type) || ReflectionUtils.ImplementsGenericDefinition(type, typeof (IDictionary<,>));
-    }
-
-    public static ConstructorInfo ResolveEnumerableCollectionConstructor(
-      Type collectionType,
-      Type collectionItemType)
-    {
-      Type constructorArgumentType = typeof (IList<>).MakeGenericType(collectionItemType);
-      return CollectionUtils.ResolveEnumerableCollectionConstructor(collectionType, collectionItemType, constructorArgumentType);
-    }
-
-    public static ConstructorInfo ResolveEnumerableCollectionConstructor(
-      Type collectionType,
-      Type collectionItemType,
-      Type constructorArgumentType)
-    {
-      Type type = typeof (IEnumerable<>).MakeGenericType(collectionItemType);
-      ConstructorInfo constructorInfo = (ConstructorInfo) null;
-      foreach (ConstructorInfo constructor in collectionType.GetConstructors(BindingFlags.Instance | BindingFlags.Public))
-      {
-        IList<ParameterInfo> parameters = (IList<ParameterInfo>) constructor.GetParameters();
-        if (parameters.Count == 1)
-        {
-          Type parameterType = parameters[0].ParameterType;
-          if (type == parameterType)
-          {
-            constructorInfo = constructor;
-            break;
-          }
-          if (constructorInfo == null && parameterType.IsAssignableFrom(constructorArgumentType))
-            constructorInfo = constructor;
-        }
-      }
-      return constructorInfo;
-    }
-
-    public static bool AddDistinct<T>(this IList<T> list, T value)
-    {
-      return list.AddDistinct<T>(value, (IEqualityComparer<T>) EqualityComparer<T>.Default);
-    }
-
-    public static bool AddDistinct<T>(this IList<T> list, T value, IEqualityComparer<T> comparer)
-    {
-      if (list.ContainsValue<T>(value, comparer))
-        return false;
-      list.Add(value);
-      return true;
-    }
-
-    public static bool ContainsValue<TSource>(
-      this IEnumerable<TSource> source,
-      TSource value,
-      IEqualityComparer<TSource> comparer)
-    {
-      if (comparer == null)
-        comparer = (IEqualityComparer<TSource>) EqualityComparer<TSource>.Default;
-      if (source == null)
-        throw new ArgumentNullException(nameof (source));
-      foreach (TSource x in source)
-      {
-        if (comparer.Equals(x, value))
-          return true;
-      }
-      return false;
-    }
-
-    public static bool AddRangeDistinct<T>(
-      this IList<T> list,
-      IEnumerable<T> values,
-      IEqualityComparer<T> comparer)
-    {
-      bool flag = true;
-      foreach (T obj in values)
-      {
-        if (!list.AddDistinct<T>(obj, comparer))
-          flag = false;
-      }
-      return flag;
-    }
-
-    public static int IndexOf<T>(this IEnumerable<T> collection, Func<T, bool> predicate)
-    {
-      int num = 0;
-      foreach (T obj in collection)
-      {
-        if (predicate(obj))
-          return num;
-        ++num;
-      }
-      return -1;
-    }
-
-    public static bool Contains<T>(this List<T> list, T value, IEqualityComparer comparer)
-    {
-      for (int index = 0; index < list.Count; ++index)
-      {
-        if (comparer.Equals((object) value, (object) list[index]))
-          return true;
-      }
-      return false;
-    }
-
-    public static int IndexOfReference<T>(this List<T> list, T item)
-    {
-      for (int index = 0; index < list.Count; ++index)
-      {
-        if ((object) item == (object) list[index])
-          return index;
-      }
-      return -1;
-    }
-
-    public static void FastReverse<T>(this List<T> list)
-    {
-      int index1 = 0;
-      for (int index2 = list.Count - 1; index1 < index2; --index2)
-      {
-        T obj = list[index1];
-        list[index1] = list[index2];
-        list[index2] = obj;
-        ++index1;
-      }
-    }
-
-    private static IList<int> GetDimensions(IList values, int dimensionsCount)
-    {
-      IList<int> dimensions = (IList<int>) new List<int>();
-      IList list1 = values;
-      while (true)
-      {
-        dimensions.Add(list1.Count);
-        if (dimensions.Count != dimensionsCount && list1.Count != 0 && list1[0] is IList list2)
-          list1 = list2;
-        else
-          break;
-      }
-      return dimensions;
-    }
-
-    private static void CopyFromJaggedToMultidimensionalArray(
-      IList values,
-      Array multidimensionalArray,
-      int[] indices)
-    {
-      int length1 = indices.Length;
-      if (length1 == multidimensionalArray.Rank)
-      {
-        multidimensionalArray.SetValue(CollectionUtils.JaggedArrayGetValue(values, indices), indices);
-      }
-      else
-      {
-        int length2 = multidimensionalArray.GetLength(length1);
-        if (((ICollection) CollectionUtils.JaggedArrayGetValue(values, indices)).Count != length2)
-          throw new Exception("Cannot deserialize non-cubical array as multidimensional array.");
-        int[] indices1 = new int[length1 + 1];
-        for (int index = 0; index < length1; ++index)
-          indices1[index] = indices[index];
-        for (int index = 0; index < multidimensionalArray.GetLength(length1); ++index)
-        {
-          indices1[length1] = index;
-          CollectionUtils.CopyFromJaggedToMultidimensionalArray(values, multidimensionalArray, indices1);
-        }
-      }
-    }
-
-    private static object JaggedArrayGetValue(IList values, int[] indices)
-    {
-      IList list = values;
-      for (int index1 = 0; index1 < indices.Length; ++index1)
-      {
-        int index2 = indices[index1];
-        if (index1 == indices.Length - 1)
-          return list[index2];
-        list = (IList) list[index2];
-      }
-      return (object) list;
-    }
-
-    public static Array ToMultidimensionalArray(IList values, Type type, int rank)
-    {
-      IList<int> dimensions = CollectionUtils.GetDimensions(values, rank);
-      while (dimensions.Count < rank)
-        dimensions.Add(0);
-      Array instance = Array.CreateInstance(type, dimensions.ToArray<int>());
-      CollectionUtils.CopyFromJaggedToMultidimensionalArray(values, instance, CollectionUtils.ArrayEmpty<int>());
-      return instance;
-    }
-
-    public static T[] ArrayEmpty<T>()
-    {
-      return Enumerable.Empty<T>() is T[] objArray ? objArray : new T[0];
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/CollectionWrapper`1.cs b/MSHALTester/Newtonsoft/Json/Utilities/CollectionWrapper`1.cs
deleted file mode 100644
index 9cb9d43..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/CollectionWrapper`1.cs
+++ /dev/null
@@ -1,194 +0,0 @@
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Linq;
-using System.Threading;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class CollectionWrapper<T> : 
-    ICollection<T>,
-    IEnumerable<T>,
-    IEnumerable,
-    IWrappedCollection,
-    IList,
-    ICollection
-  {
-    private readonly IList _list;
-    private readonly ICollection<T> _genericCollection;
-    private object _syncRoot;
-
-    public CollectionWrapper(IList list)
-    {
-      ValidationUtils.ArgumentNotNull((object) list, nameof (list));
-      if (list is ICollection<T> objs)
-        this._genericCollection = objs;
-      else
-        this._list = list;
-    }
-
-    public CollectionWrapper(ICollection<T> list)
-    {
-      ValidationUtils.ArgumentNotNull((object) list, nameof (list));
-      this._genericCollection = list;
-    }
-
-    public virtual void Add(T item)
-    {
-      if (this._genericCollection != null)
-        this._genericCollection.Add(item);
-      else
-        this._list.Add((object) item);
-    }
-
-    public virtual void Clear()
-    {
-      if (this._genericCollection != null)
-        this._genericCollection.Clear();
-      else
-        this._list.Clear();
-    }
-
-    public virtual bool Contains(T item)
-    {
-      return this._genericCollection != null ? this._genericCollection.Contains(item) : this._list.Contains((object) item);
-    }
-
-    public virtual void CopyTo(T[] array, int arrayIndex)
-    {
-      if (this._genericCollection != null)
-        this._genericCollection.CopyTo(array, arrayIndex);
-      else
-        this._list.CopyTo((Array) array, arrayIndex);
-    }
-
-    public virtual int Count
-    {
-      get => this._genericCollection != null ? this._genericCollection.Count : this._list.Count;
-    }
-
-    public virtual bool IsReadOnly
-    {
-      get
-      {
-        return this._genericCollection != null ? this._genericCollection.IsReadOnly : this._list.IsReadOnly;
-      }
-    }
-
-    public virtual bool Remove(T item)
-    {
-      if (this._genericCollection != null)
-        return this._genericCollection.Remove(item);
-      int num = this._list.Contains((object) item) ? 1 : 0;
-      if (num == 0)
-        return num != 0;
-      this._list.Remove((object) item);
-      return num != 0;
-    }
-
-    public virtual IEnumerator<T> GetEnumerator()
-    {
-      return ((IEnumerable<T>) this._genericCollection ?? this._list.Cast<T>()).GetEnumerator();
-    }
-
-    IEnumerator IEnumerable.GetEnumerator()
-    {
-      return ((IEnumerable) this._genericCollection ?? (IEnumerable) this._list).GetEnumerator();
-    }
-
-    int IList.Add(object value)
-    {
-      CollectionWrapper<T>.VerifyValueType(value);
-      this.Add((T) value);
-      return this.Count - 1;
-    }
-
-    bool IList.Contains(object value)
-    {
-      return CollectionWrapper<T>.IsCompatibleObject(value) && this.Contains((T) value);
-    }
-
-    int IList.IndexOf(object value)
-    {
-      if (this._genericCollection != null)
-        throw new InvalidOperationException("Wrapped ICollection<T> does not support IndexOf.");
-      return CollectionWrapper<T>.IsCompatibleObject(value) ? this._list.IndexOf((object) (T) value) : -1;
-    }
-
-    void IList.RemoveAt(int index)
-    {
-      if (this._genericCollection != null)
-        throw new InvalidOperationException("Wrapped ICollection<T> does not support RemoveAt.");
-      this._list.RemoveAt(index);
-    }
-
-    void IList.Insert(int index, object value)
-    {
-      if (this._genericCollection != null)
-        throw new InvalidOperationException("Wrapped ICollection<T> does not support Insert.");
-      CollectionWrapper<T>.VerifyValueType(value);
-      this._list.Insert(index, (object) (T) value);
-    }
-
-    bool IList.IsFixedSize
-    {
-      get
-      {
-        return this._genericCollection != null ? this._genericCollection.IsReadOnly : this._list.IsFixedSize;
-      }
-    }
-
-    void IList.Remove(object value)
-    {
-      if (!CollectionWrapper<T>.IsCompatibleObject(value))
-        return;
-      this.Remove((T) value);
-    }
-
-    object IList.this[int index]
-    {
-      get
-      {
-        if (this._genericCollection != null)
-          throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
-        return this._list[index];
-      }
-      set
-      {
-        if (this._genericCollection != null)
-          throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
-        CollectionWrapper<T>.VerifyValueType(value);
-        this._list[index] = (object) (T) value;
-      }
-    }
-
-    void ICollection.CopyTo(Array array, int arrayIndex) => this.CopyTo((T[]) array, arrayIndex);
-
-    bool ICollection.IsSynchronized => false;
-
-    object ICollection.SyncRoot
-    {
-      get
-      {
-        if (this._syncRoot == null)
-          Interlocked.CompareExchange(ref this._syncRoot, new object(), (object) null);
-        return this._syncRoot;
-      }
-    }
-
-    private static void VerifyValueType(object value)
-    {
-      if (!CollectionWrapper<T>.IsCompatibleObject(value))
-        throw new ArgumentException("The value '{0}' is not of type '{1}' and cannot be used in this generic collection.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, value, (object) typeof (T)), nameof (value));
-    }
-
-    private static bool IsCompatibleObject(object value)
-    {
-      return value is T || value == null && (!typeof (T).IsValueType() || ReflectionUtils.IsNullableType(typeof (T)));
-    }
-
-    public object UnderlyingCollection => (object) this._genericCollection ?? (object) this._list;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ConvertUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/ConvertUtils.cs
deleted file mode 100644
index ab460eb..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ConvertUtils.cs
+++ /dev/null
@@ -1,880 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Globalization;
-using System.Reflection;
-using System.Text.RegularExpressions;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class ConvertUtils
-  {
-    private static readonly Dictionary<Type, PrimitiveTypeCode> TypeCodeMap = new Dictionary<Type, PrimitiveTypeCode>()
-    {
-      {
-        typeof (char),
-        PrimitiveTypeCode.Char
-      },
-      {
-        typeof (char?),
-        PrimitiveTypeCode.CharNullable
-      },
-      {
-        typeof (bool),
-        PrimitiveTypeCode.Boolean
-      },
-      {
-        typeof (bool?),
-        PrimitiveTypeCode.BooleanNullable
-      },
-      {
-        typeof (sbyte),
-        PrimitiveTypeCode.SByte
-      },
-      {
-        typeof (sbyte?),
-        PrimitiveTypeCode.SByteNullable
-      },
-      {
-        typeof (short),
-        PrimitiveTypeCode.Int16
-      },
-      {
-        typeof (short?),
-        PrimitiveTypeCode.Int16Nullable
-      },
-      {
-        typeof (ushort),
-        PrimitiveTypeCode.UInt16
-      },
-      {
-        typeof (ushort?),
-        PrimitiveTypeCode.UInt16Nullable
-      },
-      {
-        typeof (int),
-        PrimitiveTypeCode.Int32
-      },
-      {
-        typeof (int?),
-        PrimitiveTypeCode.Int32Nullable
-      },
-      {
-        typeof (byte),
-        PrimitiveTypeCode.Byte
-      },
-      {
-        typeof (byte?),
-        PrimitiveTypeCode.ByteNullable
-      },
-      {
-        typeof (uint),
-        PrimitiveTypeCode.UInt32
-      },
-      {
-        typeof (uint?),
-        PrimitiveTypeCode.UInt32Nullable
-      },
-      {
-        typeof (long),
-        PrimitiveTypeCode.Int64
-      },
-      {
-        typeof (long?),
-        PrimitiveTypeCode.Int64Nullable
-      },
-      {
-        typeof (ulong),
-        PrimitiveTypeCode.UInt64
-      },
-      {
-        typeof (ulong?),
-        PrimitiveTypeCode.UInt64Nullable
-      },
-      {
-        typeof (float),
-        PrimitiveTypeCode.Single
-      },
-      {
-        typeof (float?),
-        PrimitiveTypeCode.SingleNullable
-      },
-      {
-        typeof (double),
-        PrimitiveTypeCode.Double
-      },
-      {
-        typeof (double?),
-        PrimitiveTypeCode.DoubleNullable
-      },
-      {
-        typeof (DateTime),
-        PrimitiveTypeCode.DateTime
-      },
-      {
-        typeof (DateTime?),
-        PrimitiveTypeCode.DateTimeNullable
-      },
-      {
-        typeof (DateTimeOffset),
-        PrimitiveTypeCode.DateTimeOffset
-      },
-      {
-        typeof (DateTimeOffset?),
-        PrimitiveTypeCode.DateTimeOffsetNullable
-      },
-      {
-        typeof (Decimal),
-        PrimitiveTypeCode.Decimal
-      },
-      {
-        typeof (Decimal?),
-        PrimitiveTypeCode.DecimalNullable
-      },
-      {
-        typeof (Guid),
-        PrimitiveTypeCode.Guid
-      },
-      {
-        typeof (Guid?),
-        PrimitiveTypeCode.GuidNullable
-      },
-      {
-        typeof (TimeSpan),
-        PrimitiveTypeCode.TimeSpan
-      },
-      {
-        typeof (TimeSpan?),
-        PrimitiveTypeCode.TimeSpanNullable
-      },
-      {
-        typeof (Uri),
-        PrimitiveTypeCode.Uri
-      },
-      {
-        typeof (string),
-        PrimitiveTypeCode.String
-      },
-      {
-        typeof (byte[]),
-        PrimitiveTypeCode.Bytes
-      },
-      {
-        typeof (DBNull),
-        PrimitiveTypeCode.DBNull
-      }
-    };
-    private static readonly TypeInformation[] PrimitiveTypeCodes = new TypeInformation[19]
-    {
-      new TypeInformation()
-      {
-        Type = typeof (object),
-        TypeCode = PrimitiveTypeCode.Empty
-      },
-      new TypeInformation()
-      {
-        Type = typeof (object),
-        TypeCode = PrimitiveTypeCode.Object
-      },
-      new TypeInformation()
-      {
-        Type = typeof (object),
-        TypeCode = PrimitiveTypeCode.DBNull
-      },
-      new TypeInformation()
-      {
-        Type = typeof (bool),
-        TypeCode = PrimitiveTypeCode.Boolean
-      },
-      new TypeInformation()
-      {
-        Type = typeof (char),
-        TypeCode = PrimitiveTypeCode.Char
-      },
-      new TypeInformation()
-      {
-        Type = typeof (sbyte),
-        TypeCode = PrimitiveTypeCode.SByte
-      },
-      new TypeInformation()
-      {
-        Type = typeof (byte),
-        TypeCode = PrimitiveTypeCode.Byte
-      },
-      new TypeInformation()
-      {
-        Type = typeof (short),
-        TypeCode = PrimitiveTypeCode.Int16
-      },
-      new TypeInformation()
-      {
-        Type = typeof (ushort),
-        TypeCode = PrimitiveTypeCode.UInt16
-      },
-      new TypeInformation()
-      {
-        Type = typeof (int),
-        TypeCode = PrimitiveTypeCode.Int32
-      },
-      new TypeInformation()
-      {
-        Type = typeof (uint),
-        TypeCode = PrimitiveTypeCode.UInt32
-      },
-      new TypeInformation()
-      {
-        Type = typeof (long),
-        TypeCode = PrimitiveTypeCode.Int64
-      },
-      new TypeInformation()
-      {
-        Type = typeof (ulong),
-        TypeCode = PrimitiveTypeCode.UInt64
-      },
-      new TypeInformation()
-      {
-        Type = typeof (float),
-        TypeCode = PrimitiveTypeCode.Single
-      },
-      new TypeInformation()
-      {
-        Type = typeof (double),
-        TypeCode = PrimitiveTypeCode.Double
-      },
-      new TypeInformation()
-      {
-        Type = typeof (Decimal),
-        TypeCode = PrimitiveTypeCode.Decimal
-      },
-      new TypeInformation()
-      {
-        Type = typeof (DateTime),
-        TypeCode = PrimitiveTypeCode.DateTime
-      },
-      new TypeInformation()
-      {
-        Type = typeof (object),
-        TypeCode = PrimitiveTypeCode.Empty
-      },
-      new TypeInformation()
-      {
-        Type = typeof (string),
-        TypeCode = PrimitiveTypeCode.String
-      }
-    };
-    private static readonly ThreadSafeStore<ConvertUtils.TypeConvertKey, Func<object, object>> CastConverters = new ThreadSafeStore<ConvertUtils.TypeConvertKey, Func<object, object>>(new Func<ConvertUtils.TypeConvertKey, Func<object, object>>(ConvertUtils.CreateCastConverter));
-
-    public static PrimitiveTypeCode GetTypeCode(Type t) => ConvertUtils.GetTypeCode(t, out bool _);
-
-    public static PrimitiveTypeCode GetTypeCode(Type t, out bool isEnum)
-    {
-      PrimitiveTypeCode typeCode;
-      if (ConvertUtils.TypeCodeMap.TryGetValue(t, out typeCode))
-      {
-        isEnum = false;
-        return typeCode;
-      }
-      if (t.IsEnum())
-      {
-        isEnum = true;
-        return ConvertUtils.GetTypeCode(Enum.GetUnderlyingType(t));
-      }
-      if (ReflectionUtils.IsNullableType(t))
-      {
-        Type underlyingType = Nullable.GetUnderlyingType(t);
-        if (underlyingType.IsEnum())
-        {
-          Type t1 = typeof (Nullable<>).MakeGenericType(Enum.GetUnderlyingType(underlyingType));
-          isEnum = true;
-          return ConvertUtils.GetTypeCode(t1);
-        }
-      }
-      isEnum = false;
-      return PrimitiveTypeCode.Object;
-    }
-
-    public static TypeInformation GetTypeInformation(IConvertible convertable)
-    {
-      return ConvertUtils.PrimitiveTypeCodes[(int) convertable.GetTypeCode()];
-    }
-
-    public static bool IsConvertible(Type t) => typeof (IConvertible).IsAssignableFrom(t);
-
-    public static TimeSpan ParseTimeSpan(string input) => TimeSpan.Parse(input);
-
-    private static Func<object, object> CreateCastConverter(ConvertUtils.TypeConvertKey t)
-    {
-      MethodInfo method1 = t.TargetType.GetMethod("op_Implicit", new Type[1]
-      {
-        t.InitialType
-      });
-      if (method1 == null)
-        method1 = t.TargetType.GetMethod("op_Explicit", new Type[1]
-        {
-          t.InitialType
-        });
-      MethodInfo method2 = method1;
-      if (method2 == null)
-        return (Func<object, object>) null;
-      MethodCall<object, object> call = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>((MethodBase) method2);
-      return (Func<object, object>) (o => call((object) null, o));
-    }
-
-    public static object Convert(object initialValue, CultureInfo culture, Type targetType)
-    {
-      object obj;
-      switch (ConvertUtils.TryConvertInternal(initialValue, culture, targetType, out obj))
-      {
-        case ConvertUtils.ConvertResult.Success:
-          return obj;
-        case ConvertUtils.ConvertResult.CannotConvertNull:
-          throw new Exception("Can not convert null {0} into non-nullable {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) initialValue.GetType(), (object) targetType));
-        case ConvertUtils.ConvertResult.NotInstantiableType:
-          throw new ArgumentException("Target type {0} is not a value type or a non-abstract class.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) targetType), nameof (targetType));
-        case ConvertUtils.ConvertResult.NoValidConversion:
-          throw new InvalidOperationException("Can not convert from {0} to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) initialValue.GetType(), (object) targetType));
-        default:
-          throw new InvalidOperationException("Unexpected conversion result.");
-      }
-    }
-
-    private static bool TryConvert(
-      object initialValue,
-      CultureInfo culture,
-      Type targetType,
-      out object value)
-    {
-      try
-      {
-        if (ConvertUtils.TryConvertInternal(initialValue, culture, targetType, out value) == ConvertUtils.ConvertResult.Success)
-          return true;
-        value = (object) null;
-        return false;
-      }
-      catch
-      {
-        value = (object) null;
-        return false;
-      }
-    }
-
-    private static ConvertUtils.ConvertResult TryConvertInternal(
-      object initialValue,
-      CultureInfo culture,
-      Type targetType,
-      out object value)
-    {
-      if (initialValue == null)
-        throw new ArgumentNullException(nameof (initialValue));
-      if (ReflectionUtils.IsNullableType(targetType))
-        targetType = Nullable.GetUnderlyingType(targetType);
-      Type type = initialValue.GetType();
-      if (targetType == type)
-      {
-        value = initialValue;
-        return ConvertUtils.ConvertResult.Success;
-      }
-      if (ConvertUtils.IsConvertible(initialValue.GetType()) && ConvertUtils.IsConvertible(targetType))
-      {
-        if (targetType.IsEnum())
-        {
-          if (initialValue is string)
-          {
-            value = Enum.Parse(targetType, initialValue.ToString(), true);
-            return ConvertUtils.ConvertResult.Success;
-          }
-          if (ConvertUtils.IsInteger(initialValue))
-          {
-            value = Enum.ToObject(targetType, initialValue);
-            return ConvertUtils.ConvertResult.Success;
-          }
-        }
-        value = System.Convert.ChangeType(initialValue, targetType, (IFormatProvider) culture);
-        return ConvertUtils.ConvertResult.Success;
-      }
-      switch (initialValue)
-      {
-        case DateTime dateTime when targetType == typeof (DateTimeOffset):
-          value = (object) new DateTimeOffset(dateTime);
-          return ConvertUtils.ConvertResult.Success;
-        case byte[] b when targetType == typeof (Guid):
-          value = (object) new Guid(b);
-          return ConvertUtils.ConvertResult.Success;
-        case Guid guid when targetType == typeof (byte[]):
-          value = (object) guid.ToByteArray();
-          return ConvertUtils.ConvertResult.Success;
-        case string str:
-          if (targetType == typeof (Guid))
-          {
-            value = (object) new Guid(str);
-            return ConvertUtils.ConvertResult.Success;
-          }
-          if (targetType == typeof (Uri))
-          {
-            value = (object) new Uri(str, UriKind.RelativeOrAbsolute);
-            return ConvertUtils.ConvertResult.Success;
-          }
-          if (targetType == typeof (TimeSpan))
-          {
-            value = (object) ConvertUtils.ParseTimeSpan(str);
-            return ConvertUtils.ConvertResult.Success;
-          }
-          if (targetType == typeof (byte[]))
-          {
-            value = (object) System.Convert.FromBase64String(str);
-            return ConvertUtils.ConvertResult.Success;
-          }
-          if (targetType == typeof (Version))
-          {
-            Version result;
-            if (ConvertUtils.VersionTryParse(str, out result))
-            {
-              value = (object) result;
-              return ConvertUtils.ConvertResult.Success;
-            }
-            value = (object) null;
-            return ConvertUtils.ConvertResult.NoValidConversion;
-          }
-          if (typeof (Type).IsAssignableFrom(targetType))
-          {
-            value = (object) Type.GetType(str, true);
-            return ConvertUtils.ConvertResult.Success;
-          }
-          break;
-      }
-      TypeConverter converter1 = TypeDescriptor.GetConverter(type);
-      if (converter1 != null && converter1.CanConvertTo(targetType))
-      {
-        value = converter1.ConvertTo((ITypeDescriptorContext) null, culture, initialValue, targetType);
-        return ConvertUtils.ConvertResult.Success;
-      }
-      TypeConverter converter2 = TypeDescriptor.GetConverter(targetType);
-      if (converter2 != null && converter2.CanConvertFrom(type))
-      {
-        value = converter2.ConvertFrom((ITypeDescriptorContext) null, culture, initialValue);
-        return ConvertUtils.ConvertResult.Success;
-      }
-      if (initialValue == DBNull.Value)
-      {
-        if (ReflectionUtils.IsNullable(targetType))
-        {
-          value = ConvertUtils.EnsureTypeAssignable((object) null, type, targetType);
-          return ConvertUtils.ConvertResult.Success;
-        }
-        value = (object) null;
-        return ConvertUtils.ConvertResult.CannotConvertNull;
-      }
-      if (targetType.IsInterface() || targetType.IsGenericTypeDefinition() || targetType.IsAbstract())
-      {
-        value = (object) null;
-        return ConvertUtils.ConvertResult.NotInstantiableType;
-      }
-      value = (object) null;
-      return ConvertUtils.ConvertResult.NoValidConversion;
-    }
-
-    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType)
-    {
-      if (targetType == typeof (object))
-        return initialValue;
-      if (initialValue == null && ReflectionUtils.IsNullable(targetType))
-        return (object) null;
-      object obj;
-      return ConvertUtils.TryConvert(initialValue, culture, targetType, out obj) ? obj : ConvertUtils.EnsureTypeAssignable(initialValue, ReflectionUtils.GetObjectType(initialValue), targetType);
-    }
-
-    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType)
-    {
-      Type type = value?.GetType();
-      if (value != null)
-      {
-        if (targetType.IsAssignableFrom(type))
-          return value;
-        Func<object, object> func = ConvertUtils.CastConverters.Get(new ConvertUtils.TypeConvertKey(type, targetType));
-        if (func != null)
-          return func(value);
-      }
-      else if (ReflectionUtils.IsNullable(targetType))
-        return (object) null;
-      throw new ArgumentException("Could not cast or convert from {0} to {1}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) (initialType?.ToString() ?? "{null}"), (object) targetType));
-    }
-
-    public static bool VersionTryParse(string input, out Version result)
-    {
-      try
-      {
-        result = new Version(input);
-        return true;
-      }
-      catch
-      {
-        result = (Version) null;
-        return false;
-      }
-    }
-
-    public static bool IsInteger(object value)
-    {
-      switch (ConvertUtils.GetTypeCode(value.GetType()))
-      {
-        case PrimitiveTypeCode.SByte:
-        case PrimitiveTypeCode.Int16:
-        case PrimitiveTypeCode.UInt16:
-        case PrimitiveTypeCode.Int32:
-        case PrimitiveTypeCode.Byte:
-        case PrimitiveTypeCode.UInt32:
-        case PrimitiveTypeCode.Int64:
-        case PrimitiveTypeCode.UInt64:
-          return true;
-        default:
-          return false;
-      }
-    }
-
-    public static ParseResult Int32TryParse(char[] chars, int start, int length, out int value)
-    {
-      value = 0;
-      if (length == 0)
-        return ParseResult.Invalid;
-      bool flag = chars[start] == '-';
-      if (flag)
-      {
-        if (length == 1)
-          return ParseResult.Invalid;
-        ++start;
-        --length;
-      }
-      int num1 = start + length;
-      if (length > 10 || length == 10 && (int) chars[start] - 48 > 2)
-      {
-        for (int index = start; index < num1; ++index)
-        {
-          int num2 = (int) chars[index] - 48;
-          if (num2 < 0 || num2 > 9)
-            return ParseResult.Invalid;
-        }
-        return ParseResult.Overflow;
-      }
-      for (int index1 = start; index1 < num1; ++index1)
-      {
-        int num3 = (int) chars[index1] - 48;
-        if (num3 < 0 || num3 > 9)
-          return ParseResult.Invalid;
-        int num4 = 10 * value - num3;
-        if (num4 > value)
-        {
-          for (int index2 = index1 + 1; index2 < num1; ++index2)
-          {
-            int num5 = (int) chars[index2] - 48;
-            if (num5 < 0 || num5 > 9)
-              return ParseResult.Invalid;
-          }
-          return ParseResult.Overflow;
-        }
-        value = num4;
-      }
-      if (!flag)
-      {
-        if (value == int.MinValue)
-          return ParseResult.Overflow;
-        value = -value;
-      }
-      return ParseResult.Success;
-    }
-
-    public static ParseResult Int64TryParse(char[] chars, int start, int length, out long value)
-    {
-      value = 0L;
-      if (length == 0)
-        return ParseResult.Invalid;
-      bool flag = chars[start] == '-';
-      if (flag)
-      {
-        if (length == 1)
-          return ParseResult.Invalid;
-        ++start;
-        --length;
-      }
-      int num1 = start + length;
-      if (length > 19)
-      {
-        for (int index = start; index < num1; ++index)
-        {
-          int num2 = (int) chars[index] - 48;
-          if (num2 < 0 || num2 > 9)
-            return ParseResult.Invalid;
-        }
-        return ParseResult.Overflow;
-      }
-      for (int index1 = start; index1 < num1; ++index1)
-      {
-        int num3 = (int) chars[index1] - 48;
-        if (num3 < 0 || num3 > 9)
-          return ParseResult.Invalid;
-        long num4 = 10L * value - (long) num3;
-        if (num4 > value)
-        {
-          for (int index2 = index1 + 1; index2 < num1; ++index2)
-          {
-            int num5 = (int) chars[index2] - 48;
-            if (num5 < 0 || num5 > 9)
-              return ParseResult.Invalid;
-          }
-          return ParseResult.Overflow;
-        }
-        value = num4;
-      }
-      if (!flag)
-      {
-        if (value == long.MinValue)
-          return ParseResult.Overflow;
-        value = -value;
-      }
-      return ParseResult.Success;
-    }
-
-    public static ParseResult DecimalTryParse(
-      char[] chars,
-      int start,
-      int length,
-      out Decimal value)
-    {
-      value = 0M;
-      if (length == 0)
-        return ParseResult.Invalid;
-      bool flag1 = chars[start] == '-';
-      if (flag1)
-      {
-        if (length == 1)
-          return ParseResult.Invalid;
-        ++start;
-        --length;
-      }
-      int index = start;
-      int num1 = start + length;
-      int num2 = num1;
-      int num3 = num1;
-      int num4 = 0;
-      ulong num5 = 0;
-      ulong num6 = 0;
-      int num7 = 0;
-      int num8 = 0;
-      bool? nullable1 = new bool?();
-      bool? nullable2 = new bool?();
-      for (; index < num1; ++index)
-      {
-        char ch1 = chars[index];
-        if (ch1 != '.')
-        {
-          if (ch1 != 'E' && ch1 != 'e')
-            goto label_29;
-label_12:
-          if (index == start || index == num2)
-            return ParseResult.Invalid;
-          ++index;
-          if (index == num1)
-            return ParseResult.Invalid;
-          if (num2 < num1)
-            num3 = index - 1;
-          char ch2 = chars[index];
-          bool flag2 = false;
-          switch (ch2)
-          {
-            case '+':
-              ++index;
-              break;
-            case '-':
-              flag2 = true;
-              ++index;
-              break;
-          }
-          for (; index < num1; ++index)
-          {
-            char ch3 = chars[index];
-            if (ch3 < '0' || ch3 > '9')
-              return ParseResult.Invalid;
-            int num9 = 10 * num4 + ((int) ch3 - 48);
-            if (num4 < num9)
-              num4 = num9;
-          }
-          if (flag2)
-          {
-            num4 = -num4;
-            continue;
-          }
-          continue;
-label_29:
-          if (ch1 < '0' || ch1 > '9')
-            return ParseResult.Invalid;
-          if (index == start && ch1 == '0')
-          {
-            ++index;
-            if (index != num1)
-            {
-              switch (chars[index])
-              {
-                case '.':
-                  goto label_9;
-                case 'E':
-                case 'e':
-                  goto label_12;
-                default:
-                  return ParseResult.Invalid;
-              }
-            }
-          }
-          if (num7 < 29)
-          {
-            if (num7 == 28)
-            {
-              bool? nullable3 = nullable2;
-              int num10;
-              if (!nullable3.HasValue)
-              {
-                nullable2 = new bool?(num5 > 7922816251426433759UL || num5 == 7922816251426433759UL && (num6 > 354395033UL || num6 == 354395033UL && ch1 > '5'));
-                num10 = nullable2.GetValueOrDefault() ? 1 : 0;
-              }
-              else
-                num10 = nullable3.GetValueOrDefault() ? 1 : 0;
-              if (num10 != 0)
-                goto label_45;
-            }
-            if (num7 < 19)
-              num5 = num5 * 10UL + (ulong) ((int) ch1 - 48);
-            else
-              num6 = num6 * 10UL + (ulong) ((int) ch1 - 48);
-            ++num7;
-            continue;
-          }
-label_45:
-          if (!nullable1.HasValue)
-            nullable1 = new bool?(ch1 >= '5');
-          ++num8;
-          continue;
-        }
-label_9:
-        if (index == start || index + 1 == num1 || num2 != num1)
-          return ParseResult.Invalid;
-        num2 = index + 1;
-      }
-      int scale = num4 + num8 - (num3 - num2);
-      value = num7 > 19 ? (Decimal) num5 / new Decimal(1, 0, 0, false, (byte) (num7 - 19)) + (Decimal) num6 : (Decimal) num5;
-      if (scale > 0)
-      {
-        int num11 = num7 + scale;
-        if (num11 > 29)
-          return ParseResult.Overflow;
-        if (num11 == 29)
-        {
-          if (scale > 1)
-          {
-            value /= new Decimal(1, 0, 0, false, (byte) (scale - 1));
-            if (value > 7922816251426433759354395033M)
-              return ParseResult.Overflow;
-          }
-          value *= 10M;
-        }
-        else
-          value /= new Decimal(1, 0, 0, false, (byte) scale);
-      }
-      else
-      {
-        bool? nullable4 = nullable1;
-        bool flag3 = true;
-        if ((nullable4.GetValueOrDefault() == flag3 ? (nullable4.HasValue ? 1 : 0) : 0) != 0 && scale >= -28)
-          ++value;
-        if (scale < 0)
-        {
-          if (num7 + scale + 28 <= 0)
-          {
-            value = flag1 ? 0M : 0M;
-            return ParseResult.Success;
-          }
-          if (scale >= -28)
-          {
-            value *= new Decimal(1, 0, 0, false, (byte) -scale);
-          }
-          else
-          {
-            value /= 10000000000000000000000000000M;
-            value *= new Decimal(1, 0, 0, false, (byte) (-scale - 28));
-          }
-        }
-      }
-      if (flag1)
-        value = -value;
-      return ParseResult.Success;
-    }
-
-    public static bool TryConvertGuid(string s, out Guid g)
-    {
-      if (s == null)
-        throw new ArgumentNullException(nameof (s));
-      if (new Regex("^[A-Fa-f0-9]{8}-([A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}$").Match(s).Success)
-      {
-        g = new Guid(s);
-        return true;
-      }
-      g = Guid.Empty;
-      return false;
-    }
-
-    public static bool TryHexTextToInt(char[] text, int start, int end, out int value)
-    {
-      value = 0;
-      for (int index = start; index < end; ++index)
-      {
-        char ch = text[index];
-        int num;
-        if (ch <= '9' && ch >= '0')
-          num = (int) ch - 48;
-        else if (ch <= 'F' && ch >= 'A')
-          num = (int) ch - 55;
-        else if (ch <= 'f' && ch >= 'a')
-        {
-          num = (int) ch - 87;
-        }
-        else
-        {
-          value = 0;
-          return false;
-        }
-        value += num << (end - 1 - index) * 4;
-      }
-      return true;
-    }
-
-    internal readonly struct TypeConvertKey(Type initialType, Type targetType) : 
-      IEquatable<ConvertUtils.TypeConvertKey>
-    {
-      public Type InitialType { get; } = initialType;
-
-      public Type TargetType { get; } = targetType;
-
-      public override int GetHashCode()
-      {
-        return this.InitialType.GetHashCode() ^ this.TargetType.GetHashCode();
-      }
-
-      public override bool Equals(object obj)
-      {
-        return obj is ConvertUtils.TypeConvertKey other && this.Equals(other);
-      }
-
-      public bool Equals(ConvertUtils.TypeConvertKey other)
-      {
-        return this.InitialType == other.InitialType && this.TargetType == other.TargetType;
-      }
-    }
-
-    internal enum ConvertResult
-    {
-      Success,
-      CannotConvertNull,
-      NotInstantiableType,
-      NoValidConversion,
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/Creator`1.cs b/MSHALTester/Newtonsoft/Json/Utilities/Creator`1.cs
deleted file mode 100644
index 6417ed4..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/Creator`1.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal delegate T Creator<T>();
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/DateTimeParser.cs b/MSHALTester/Newtonsoft/Json/Utilities/DateTimeParser.cs
deleted file mode 100644
index c8f1293..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/DateTimeParser.cs
+++ /dev/null
@@ -1,196 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal struct DateTimeParser
-  {
-    public int Year;
-    public int Month;
-    public int Day;
-    public int Hour;
-    public int Minute;
-    public int Second;
-    public int Fraction;
-    public int ZoneHour;
-    public int ZoneMinute;
-    public ParserTimeZone Zone;
-    private char[] _text;
-    private int _end;
-    private static readonly int[] Power10 = new int[7]
-    {
-      -1,
-      10,
-      100,
-      1000,
-      10000,
-      100000,
-      1000000
-    };
-    private static readonly int Lzyyyy = "yyyy".Length;
-    private static readonly int Lzyyyy_ = "yyyy-".Length;
-    private static readonly int Lzyyyy_MM = "yyyy-MM".Length;
-    private static readonly int Lzyyyy_MM_ = "yyyy-MM-".Length;
-    private static readonly int Lzyyyy_MM_dd = "yyyy-MM-dd".Length;
-    private static readonly int Lzyyyy_MM_ddT = "yyyy-MM-ddT".Length;
-    private static readonly int LzHH = "HH".Length;
-    private static readonly int LzHH_ = "HH:".Length;
-    private static readonly int LzHH_mm = "HH:mm".Length;
-    private static readonly int LzHH_mm_ = "HH:mm:".Length;
-    private static readonly int LzHH_mm_ss = "HH:mm:ss".Length;
-    private static readonly int Lz_ = "-".Length;
-    private static readonly int Lz_zz = "-zz".Length;
-    private const short MaxFractionDigits = 7;
-
-    public bool Parse(char[] text, int startIndex, int length)
-    {
-      this._text = text;
-      this._end = startIndex + length;
-      return this.ParseDate(startIndex) && this.ParseChar(DateTimeParser.Lzyyyy_MM_dd + startIndex, 'T') && this.ParseTimeAndZoneAndWhitespace(DateTimeParser.Lzyyyy_MM_ddT + startIndex);
-    }
-
-    private bool ParseDate(int start)
-    {
-      return this.Parse4Digit(start, out this.Year) && 1 <= this.Year && this.ParseChar(start + DateTimeParser.Lzyyyy, '-') && this.Parse2Digit(start + DateTimeParser.Lzyyyy_, out this.Month) && 1 <= this.Month && this.Month <= 12 && this.ParseChar(start + DateTimeParser.Lzyyyy_MM, '-') && this.Parse2Digit(start + DateTimeParser.Lzyyyy_MM_, out this.Day) && 1 <= this.Day && this.Day <= DateTime.DaysInMonth(this.Year, this.Month);
-    }
-
-    private bool ParseTimeAndZoneAndWhitespace(int start)
-    {
-      return this.ParseTime(ref start) && this.ParseZone(start);
-    }
-
-    private bool ParseTime(ref int start)
-    {
-      if (!this.Parse2Digit(start, out this.Hour) || this.Hour > 24 || !this.ParseChar(start + DateTimeParser.LzHH, ':') || !this.Parse2Digit(start + DateTimeParser.LzHH_, out this.Minute) || this.Minute >= 60 || !this.ParseChar(start + DateTimeParser.LzHH_mm, ':') || !this.Parse2Digit(start + DateTimeParser.LzHH_mm_, out this.Second) || this.Second >= 60 || this.Hour == 24 && (this.Minute != 0 || this.Second != 0))
-        return false;
-      start += DateTimeParser.LzHH_mm_ss;
-      if (this.ParseChar(start, '.'))
-      {
-        this.Fraction = 0;
-        int num1;
-        for (num1 = 0; ++start < this._end && num1 < 7; ++num1)
-        {
-          int num2 = (int) this._text[start] - 48;
-          switch (num2)
-          {
-            case 0:
-            case 1:
-            case 2:
-            case 3:
-            case 4:
-            case 5:
-            case 6:
-            case 7:
-            case 8:
-            case 9:
-              this.Fraction = this.Fraction * 10 + num2;
-              continue;
-            default:
-              goto label_7;
-          }
-        }
-label_7:
-        if (num1 < 7)
-        {
-          if (num1 == 0)
-            return false;
-          this.Fraction *= DateTimeParser.Power10[7 - num1];
-        }
-        if (this.Hour == 24 && this.Fraction != 0)
-          return false;
-      }
-      return true;
-    }
-
-    private bool ParseZone(int start)
-    {
-      if (start < this._end)
-      {
-        char ch = this._text[start];
-        switch (ch)
-        {
-          case 'Z':
-          case 'z':
-            this.Zone = ParserTimeZone.Utc;
-            ++start;
-            break;
-          default:
-            if (start + 2 < this._end && this.Parse2Digit(start + DateTimeParser.Lz_, out this.ZoneHour) && this.ZoneHour <= 99)
-            {
-              switch (ch)
-              {
-                case '+':
-                  this.Zone = ParserTimeZone.LocalEastOfUtc;
-                  start += DateTimeParser.Lz_zz;
-                  break;
-                case '-':
-                  this.Zone = ParserTimeZone.LocalWestOfUtc;
-                  start += DateTimeParser.Lz_zz;
-                  break;
-              }
-            }
-            if (start < this._end)
-            {
-              if (this.ParseChar(start, ':'))
-              {
-                ++start;
-                if (start + 1 < this._end && this.Parse2Digit(start, out this.ZoneMinute) && this.ZoneMinute <= 99)
-                {
-                  start += 2;
-                  break;
-                }
-                break;
-              }
-              if (start + 1 < this._end && this.Parse2Digit(start, out this.ZoneMinute) && this.ZoneMinute <= 99)
-              {
-                start += 2;
-                break;
-              }
-              break;
-            }
-            break;
-        }
-      }
-      return start == this._end;
-    }
-
-    private bool Parse4Digit(int start, out int num)
-    {
-      if (start + 3 < this._end)
-      {
-        int num1 = (int) this._text[start] - 48;
-        int num2 = (int) this._text[start + 1] - 48;
-        int num3 = (int) this._text[start + 2] - 48;
-        int num4 = (int) this._text[start + 3] - 48;
-        if (0 <= num1 && num1 < 10 && 0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10 && 0 <= num4 && num4 < 10)
-        {
-          num = ((num1 * 10 + num2) * 10 + num3) * 10 + num4;
-          return true;
-        }
-      }
-      num = 0;
-      return false;
-    }
-
-    private bool Parse2Digit(int start, out int num)
-    {
-      if (start + 1 < this._end)
-      {
-        int num1 = (int) this._text[start] - 48;
-        int num2 = (int) this._text[start + 1] - 48;
-        if (0 <= num1 && num1 < 10 && 0 <= num2 && num2 < 10)
-        {
-          num = num1 * 10 + num2;
-          return true;
-        }
-      }
-      num = 0;
-      return false;
-    }
-
-    private bool ParseChar(int start, char ch)
-    {
-      return start < this._end && (int) this._text[start] == (int) ch;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/DateTimeUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/DateTimeUtils.cs
deleted file mode 100644
index b46f28c..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/DateTimeUtils.cs
+++ /dev/null
@@ -1,648 +0,0 @@
-using System;
-using System.Globalization;
-using System.IO;
-using System.Xml;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class DateTimeUtils
-  {
-    internal static readonly long InitialJavaScriptDateTicks = 621355968000000000;
-    private const string IsoDateFormat = "yyyy-MM-ddTHH:mm:ss.FFFFFFFK";
-    private const int DaysPer100Years = 36524;
-    private const int DaysPer400Years = 146097;
-    private const int DaysPer4Years = 1461;
-    private const int DaysPerYear = 365;
-    private const long TicksPerDay = 864000000000;
-    private static readonly int[] DaysToMonth365 = new int[13]
-    {
-      0,
-      31,
-      59,
-      90,
-      120,
-      151,
-      181,
-      212,
-      243,
-      273,
-      304,
-      334,
-      365
-    };
-    private static readonly int[] DaysToMonth366 = new int[13]
-    {
-      0,
-      31,
-      60,
-      91,
-      121,
-      152,
-      182,
-      213,
-      244,
-      274,
-      305,
-      335,
-      366
-    };
-
-    public static TimeSpan GetUtcOffset(this DateTime d) => TimeZoneInfo.Local.GetUtcOffset(d);
-
-    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind)
-    {
-      switch (kind)
-      {
-        case DateTimeKind.Unspecified:
-          return XmlDateTimeSerializationMode.Unspecified;
-        case DateTimeKind.Utc:
-          return XmlDateTimeSerializationMode.Utc;
-        case DateTimeKind.Local:
-          return XmlDateTimeSerializationMode.Local;
-        default:
-          throw MiscellaneousUtils.CreateArgumentOutOfRangeException(nameof (kind), (object) kind, "Unexpected DateTimeKind value.");
-      }
-    }
-
-    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone)
-    {
-      switch (timeZone)
-      {
-        case DateTimeZoneHandling.Local:
-          value = DateTimeUtils.SwitchToLocalTime(value);
-          goto case DateTimeZoneHandling.RoundtripKind;
-        case DateTimeZoneHandling.Utc:
-          value = DateTimeUtils.SwitchToUtcTime(value);
-          goto case DateTimeZoneHandling.RoundtripKind;
-        case DateTimeZoneHandling.Unspecified:
-          value = new DateTime(value.Ticks, DateTimeKind.Unspecified);
-          goto case DateTimeZoneHandling.RoundtripKind;
-        case DateTimeZoneHandling.RoundtripKind:
-          return value;
-        default:
-          throw new ArgumentException("Invalid date time handling value.");
-      }
-    }
-
-    private static DateTime SwitchToLocalTime(DateTime value)
-    {
-      switch (value.Kind)
-      {
-        case DateTimeKind.Unspecified:
-          return new DateTime(value.Ticks, DateTimeKind.Local);
-        case DateTimeKind.Utc:
-          return value.ToLocalTime();
-        case DateTimeKind.Local:
-          return value;
-        default:
-          return value;
-      }
-    }
-
-    private static DateTime SwitchToUtcTime(DateTime value)
-    {
-      switch (value.Kind)
-      {
-        case DateTimeKind.Unspecified:
-          return new DateTime(value.Ticks, DateTimeKind.Utc);
-        case DateTimeKind.Utc:
-          return value;
-        case DateTimeKind.Local:
-          return value.ToUniversalTime();
-        default:
-          return value;
-      }
-    }
-
-    private static long ToUniversalTicks(DateTime dateTime)
-    {
-      return dateTime.Kind == DateTimeKind.Utc ? dateTime.Ticks : DateTimeUtils.ToUniversalTicks(dateTime, dateTime.GetUtcOffset());
-    }
-
-    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
-    {
-      if (dateTime.Kind == DateTimeKind.Utc || dateTime == DateTime.MaxValue || dateTime == DateTime.MinValue)
-        return dateTime.Ticks;
-      long num = dateTime.Ticks - offset.Ticks;
-      if (num > 3155378975999999999L)
-        return 3155378975999999999;
-      return num < 0L ? 0L : num;
-    }
-
-    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
-    {
-      return DateTimeUtils.UniversialTicksToJavaScriptTicks(DateTimeUtils.ToUniversalTicks(dateTime, offset));
-    }
-
-    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
-    {
-      return DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime, true);
-    }
-
-    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
-    {
-      return DateTimeUtils.UniversialTicksToJavaScriptTicks(convertToUtc ? DateTimeUtils.ToUniversalTicks(dateTime) : dateTime.Ticks);
-    }
-
-    private static long UniversialTicksToJavaScriptTicks(long universialTicks)
-    {
-      return (universialTicks - DateTimeUtils.InitialJavaScriptDateTicks) / 10000L;
-    }
-
-    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
-    {
-      return new DateTime(javaScriptTicks * 10000L + DateTimeUtils.InitialJavaScriptDateTicks, DateTimeKind.Utc);
-    }
-
-    internal static bool TryParseDateTimeIso(
-      StringReference text,
-      DateTimeZoneHandling dateTimeZoneHandling,
-      out DateTime dt)
-    {
-      DateTimeParser dateTimeParser = new DateTimeParser();
-      if (!dateTimeParser.Parse(text.Chars, text.StartIndex, text.Length))
-      {
-        dt = new DateTime();
-        return false;
-      }
-      DateTime d = DateTimeUtils.CreateDateTime(dateTimeParser);
-      switch (dateTimeParser.Zone)
-      {
-        case ParserTimeZone.Utc:
-          d = new DateTime(d.Ticks, DateTimeKind.Utc);
-          break;
-        case ParserTimeZone.LocalWestOfUtc:
-          TimeSpan timeSpan1 = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
-          long ticks1 = d.Ticks + timeSpan1.Ticks;
-          if (ticks1 <= DateTime.MaxValue.Ticks)
-          {
-            d = new DateTime(ticks1, DateTimeKind.Utc).ToLocalTime();
-            break;
-          }
-          long ticks2 = ticks1 + d.GetUtcOffset().Ticks;
-          if (ticks2 > DateTime.MaxValue.Ticks)
-            ticks2 = DateTime.MaxValue.Ticks;
-          d = new DateTime(ticks2, DateTimeKind.Local);
-          break;
-        case ParserTimeZone.LocalEastOfUtc:
-          TimeSpan timeSpan2 = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
-          long ticks3 = d.Ticks - timeSpan2.Ticks;
-          if (ticks3 >= DateTime.MinValue.Ticks)
-          {
-            d = new DateTime(ticks3, DateTimeKind.Utc).ToLocalTime();
-            break;
-          }
-          long ticks4 = ticks3 + d.GetUtcOffset().Ticks;
-          if (ticks4 < DateTime.MinValue.Ticks)
-            ticks4 = DateTime.MinValue.Ticks;
-          d = new DateTime(ticks4, DateTimeKind.Local);
-          break;
-      }
-      dt = DateTimeUtils.EnsureDateTime(d, dateTimeZoneHandling);
-      return true;
-    }
-
-    internal static bool TryParseDateTimeOffsetIso(StringReference text, out DateTimeOffset dt)
-    {
-      DateTimeParser dateTimeParser = new DateTimeParser();
-      if (!dateTimeParser.Parse(text.Chars, text.StartIndex, text.Length))
-      {
-        dt = new DateTimeOffset();
-        return false;
-      }
-      DateTime dateTime = DateTimeUtils.CreateDateTime(dateTimeParser);
-      TimeSpan offset;
-      switch (dateTimeParser.Zone)
-      {
-        case ParserTimeZone.Utc:
-          offset = new TimeSpan(0L);
-          break;
-        case ParserTimeZone.LocalWestOfUtc:
-          offset = new TimeSpan(-dateTimeParser.ZoneHour, -dateTimeParser.ZoneMinute, 0);
-          break;
-        case ParserTimeZone.LocalEastOfUtc:
-          offset = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
-          break;
-        default:
-          offset = TimeZoneInfo.Local.GetUtcOffset(dateTime);
-          break;
-      }
-      long num = dateTime.Ticks - offset.Ticks;
-      if (num < 0L || num > 3155378975999999999L)
-      {
-        dt = new DateTimeOffset();
-        return false;
-      }
-      dt = new DateTimeOffset(dateTime, offset);
-      return true;
-    }
-
-    private static DateTime CreateDateTime(DateTimeParser dateTimeParser)
-    {
-      bool flag;
-      if (dateTimeParser.Hour == 24)
-      {
-        flag = true;
-        dateTimeParser.Hour = 0;
-      }
-      else
-        flag = false;
-      DateTime dateTime = new DateTime(dateTimeParser.Year, dateTimeParser.Month, dateTimeParser.Day, dateTimeParser.Hour, dateTimeParser.Minute, dateTimeParser.Second);
-      dateTime = dateTime.AddTicks((long) dateTimeParser.Fraction);
-      if (flag)
-        dateTime = dateTime.AddDays(1.0);
-      return dateTime;
-    }
-
-    internal static bool TryParseDateTime(
-      StringReference s,
-      DateTimeZoneHandling dateTimeZoneHandling,
-      string dateFormatString,
-      CultureInfo culture,
-      out DateTime dt)
-    {
-      if (s.Length > 0)
-      {
-        int startIndex = s.StartIndex;
-        if (s[startIndex] == '/')
-        {
-          if (s.Length >= 9 && s.StartsWith("/Date(") && s.EndsWith(")/") && DateTimeUtils.TryParseDateTimeMicrosoft(s, dateTimeZoneHandling, out dt))
-            return true;
-        }
-        else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[startIndex]) && s[startIndex + 10] == 'T' && DateTimeUtils.TryParseDateTimeIso(s, dateTimeZoneHandling, out dt))
-          return true;
-        if (!string.IsNullOrEmpty(dateFormatString) && DateTimeUtils.TryParseDateTimeExact(s.ToString(), dateTimeZoneHandling, dateFormatString, culture, out dt))
-          return true;
-      }
-      dt = new DateTime();
-      return false;
-    }
-
-    internal static bool TryParseDateTime(
-      string s,
-      DateTimeZoneHandling dateTimeZoneHandling,
-      string dateFormatString,
-      CultureInfo culture,
-      out DateTime dt)
-    {
-      if (s.Length > 0)
-      {
-        if (s[0] == '/')
-        {
-          if (s.Length >= 9 && s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && DateTimeUtils.TryParseDateTimeMicrosoft(new StringReference(s.ToCharArray(), 0, s.Length), dateTimeZoneHandling, out dt))
-            return true;
-        }
-        else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && DateTime.TryParseExact(s, "yyyy-MM-ddTHH:mm:ss.FFFFFFFK", (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dt))
-        {
-          dt = DateTimeUtils.EnsureDateTime(dt, dateTimeZoneHandling);
-          return true;
-        }
-        if (!string.IsNullOrEmpty(dateFormatString) && DateTimeUtils.TryParseDateTimeExact(s, dateTimeZoneHandling, dateFormatString, culture, out dt))
-          return true;
-      }
-      dt = new DateTime();
-      return false;
-    }
-
-    internal static bool TryParseDateTimeOffset(
-      StringReference s,
-      string dateFormatString,
-      CultureInfo culture,
-      out DateTimeOffset dt)
-    {
-      if (s.Length > 0)
-      {
-        int startIndex = s.StartIndex;
-        if (s[startIndex] == '/')
-        {
-          if (s.Length >= 9 && s.StartsWith("/Date(") && s.EndsWith(")/") && DateTimeUtils.TryParseDateTimeOffsetMicrosoft(s, out dt))
-            return true;
-        }
-        else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[startIndex]) && s[startIndex + 10] == 'T' && DateTimeUtils.TryParseDateTimeOffsetIso(s, out dt))
-          return true;
-        if (!string.IsNullOrEmpty(dateFormatString) && DateTimeUtils.TryParseDateTimeOffsetExact(s.ToString(), dateFormatString, culture, out dt))
-          return true;
-      }
-      dt = new DateTimeOffset();
-      return false;
-    }
-
-    internal static bool TryParseDateTimeOffset(
-      string s,
-      string dateFormatString,
-      CultureInfo culture,
-      out DateTimeOffset dt)
-    {
-      if (s.Length > 0)
-      {
-        if (s[0] == '/')
-        {
-          if (s.Length >= 9 && s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && DateTimeUtils.TryParseDateTimeOffsetMicrosoft(new StringReference(s.ToCharArray(), 0, s.Length), out dt))
-            return true;
-        }
-        else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && DateTimeOffset.TryParseExact(s, "yyyy-MM-ddTHH:mm:ss.FFFFFFFK", (IFormatProvider) CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dt) && DateTimeUtils.TryParseDateTimeOffsetIso(new StringReference(s.ToCharArray(), 0, s.Length), out dt))
-          return true;
-        if (!string.IsNullOrEmpty(dateFormatString) && DateTimeUtils.TryParseDateTimeOffsetExact(s, dateFormatString, culture, out dt))
-          return true;
-      }
-      dt = new DateTimeOffset();
-      return false;
-    }
-
-    private static bool TryParseMicrosoftDate(
-      StringReference text,
-      out long ticks,
-      out TimeSpan offset,
-      out DateTimeKind kind)
-    {
-      kind = DateTimeKind.Utc;
-      int num = text.IndexOf('+', 7, text.Length - 8);
-      if (num == -1)
-        num = text.IndexOf('-', 7, text.Length - 8);
-      if (num != -1)
-      {
-        kind = DateTimeKind.Local;
-        if (!DateTimeUtils.TryReadOffset(text, num + text.StartIndex, out offset))
-        {
-          ticks = 0L;
-          return false;
-        }
-      }
-      else
-      {
-        offset = TimeSpan.Zero;
-        num = text.Length - 2;
-      }
-      return ConvertUtils.Int64TryParse(text.Chars, 6 + text.StartIndex, num - 6, out ticks) == ParseResult.Success;
-    }
-
-    private static bool TryParseDateTimeMicrosoft(
-      StringReference text,
-      DateTimeZoneHandling dateTimeZoneHandling,
-      out DateTime dt)
-    {
-      long ticks;
-      DateTimeKind kind;
-      if (!DateTimeUtils.TryParseMicrosoftDate(text, out ticks, out TimeSpan _, out kind))
-      {
-        dt = new DateTime();
-        return false;
-      }
-      DateTime dateTime = DateTimeUtils.ConvertJavaScriptTicksToDateTime(ticks);
-      switch (kind)
-      {
-        case DateTimeKind.Unspecified:
-          dt = DateTime.SpecifyKind(dateTime.ToLocalTime(), DateTimeKind.Unspecified);
-          break;
-        case DateTimeKind.Local:
-          dt = dateTime.ToLocalTime();
-          break;
-        default:
-          dt = dateTime;
-          break;
-      }
-      dt = DateTimeUtils.EnsureDateTime(dt, dateTimeZoneHandling);
-      return true;
-    }
-
-    private static bool TryParseDateTimeExact(
-      string text,
-      DateTimeZoneHandling dateTimeZoneHandling,
-      string dateFormatString,
-      CultureInfo culture,
-      out DateTime dt)
-    {
-      DateTime result;
-      if (DateTime.TryParseExact(text, dateFormatString, (IFormatProvider) culture, DateTimeStyles.RoundtripKind, out result))
-      {
-        DateTime dateTime = DateTimeUtils.EnsureDateTime(result, dateTimeZoneHandling);
-        dt = dateTime;
-        return true;
-      }
-      dt = new DateTime();
-      return false;
-    }
-
-    private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, out DateTimeOffset dt)
-    {
-      long ticks;
-      TimeSpan offset;
-      if (!DateTimeUtils.TryParseMicrosoftDate(text, out ticks, out offset, out DateTimeKind _))
-      {
-        dt = (DateTimeOffset) new DateTime();
-        return false;
-      }
-      DateTime dateTime = DateTimeUtils.ConvertJavaScriptTicksToDateTime(ticks);
-      dt = new DateTimeOffset(dateTime.Add(offset).Ticks, offset);
-      return true;
-    }
-
-    private static bool TryParseDateTimeOffsetExact(
-      string text,
-      string dateFormatString,
-      CultureInfo culture,
-      out DateTimeOffset dt)
-    {
-      DateTimeOffset result;
-      if (DateTimeOffset.TryParseExact(text, dateFormatString, (IFormatProvider) culture, DateTimeStyles.RoundtripKind, out result))
-      {
-        dt = result;
-        return true;
-      }
-      dt = new DateTimeOffset();
-      return false;
-    }
-
-    private static bool TryReadOffset(
-      StringReference offsetText,
-      int startIndex,
-      out TimeSpan offset)
-    {
-      bool flag = offsetText[startIndex] == '-';
-      int num1;
-      if (ConvertUtils.Int32TryParse(offsetText.Chars, startIndex + 1, 2, out num1) != ParseResult.Success)
-      {
-        offset = new TimeSpan();
-        return false;
-      }
-      int num2 = 0;
-      if (offsetText.Length - startIndex > 5 && ConvertUtils.Int32TryParse(offsetText.Chars, startIndex + 3, 2, out num2) != ParseResult.Success)
-      {
-        offset = new TimeSpan();
-        return false;
-      }
-      offset = TimeSpan.FromHours((double) num1) + TimeSpan.FromMinutes((double) num2);
-      if (flag)
-        offset = offset.Negate();
-      return true;
-    }
-
-    internal static void WriteDateTimeString(
-      TextWriter writer,
-      DateTime value,
-      DateFormatHandling format,
-      string formatString,
-      CultureInfo culture)
-    {
-      if (string.IsNullOrEmpty(formatString))
-      {
-        char[] chArray = new char[64];
-        int count = DateTimeUtils.WriteDateTimeString(chArray, 0, value, new TimeSpan?(), value.Kind, format);
-        writer.Write(chArray, 0, count);
-      }
-      else
-        writer.Write(value.ToString(formatString, (IFormatProvider) culture));
-    }
-
-    internal static int WriteDateTimeString(
-      char[] chars,
-      int start,
-      DateTime value,
-      TimeSpan? offset,
-      DateTimeKind kind,
-      DateFormatHandling format)
-    {
-      int num1 = start;
-      int start1;
-      if (format == DateFormatHandling.MicrosoftDateFormat)
-      {
-        TimeSpan offset1 = offset ?? value.GetUtcOffset();
-        long javaScriptTicks = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(value, offset1);
-        "\\/Date(".CopyTo(0, chars, num1, 7);
-        int destinationIndex = num1 + 7;
-        string str = javaScriptTicks.ToString((IFormatProvider) CultureInfo.InvariantCulture);
-        str.CopyTo(0, chars, destinationIndex, str.Length);
-        int num2 = destinationIndex + str.Length;
-        switch (kind)
-        {
-          case DateTimeKind.Unspecified:
-            if (value != DateTime.MaxValue && value != DateTime.MinValue)
-            {
-              num2 = DateTimeUtils.WriteDateTimeOffset(chars, num2, offset1, format);
-              break;
-            }
-            break;
-          case DateTimeKind.Local:
-            num2 = DateTimeUtils.WriteDateTimeOffset(chars, num2, offset1, format);
-            break;
-        }
-        ")\\/".CopyTo(0, chars, num2, 3);
-        start1 = num2 + 3;
-      }
-      else
-      {
-        start1 = DateTimeUtils.WriteDefaultIsoDate(chars, num1, value);
-        switch (kind)
-        {
-          case DateTimeKind.Utc:
-            chars[start1++] = 'Z';
-            break;
-          case DateTimeKind.Local:
-            start1 = DateTimeUtils.WriteDateTimeOffset(chars, start1, offset ?? value.GetUtcOffset(), format);
-            break;
-        }
-      }
-      return start1;
-    }
-
-    internal static int WriteDefaultIsoDate(char[] chars, int start, DateTime dt)
-    {
-      int num1 = 19;
-      int year;
-      int month;
-      int day;
-      DateTimeUtils.GetDateValues(dt, out year, out month, out day);
-      DateTimeUtils.CopyIntToCharArray(chars, start, year, 4);
-      chars[start + 4] = '-';
-      DateTimeUtils.CopyIntToCharArray(chars, start + 5, month, 2);
-      chars[start + 7] = '-';
-      DateTimeUtils.CopyIntToCharArray(chars, start + 8, day, 2);
-      chars[start + 10] = 'T';
-      DateTimeUtils.CopyIntToCharArray(chars, start + 11, dt.Hour, 2);
-      chars[start + 13] = ':';
-      DateTimeUtils.CopyIntToCharArray(chars, start + 14, dt.Minute, 2);
-      chars[start + 16] = ':';
-      DateTimeUtils.CopyIntToCharArray(chars, start + 17, dt.Second, 2);
-      int num2 = (int) (dt.Ticks % 10000000L);
-      if (num2 != 0)
-      {
-        int digits = 7;
-        for (; num2 % 10 == 0; num2 /= 10)
-          --digits;
-        chars[start + 19] = '.';
-        DateTimeUtils.CopyIntToCharArray(chars, start + 20, num2, digits);
-        num1 += digits + 1;
-      }
-      return start + num1;
-    }
-
-    private static void CopyIntToCharArray(char[] chars, int start, int value, int digits)
-    {
-      while (digits-- != 0)
-      {
-        chars[start + digits] = (char) (value % 10 + 48);
-        value /= 10;
-      }
-    }
-
-    internal static int WriteDateTimeOffset(
-      char[] chars,
-      int start,
-      TimeSpan offset,
-      DateFormatHandling format)
-    {
-      chars[start++] = offset.Ticks >= 0L ? '+' : '-';
-      int num1 = Math.Abs(offset.Hours);
-      DateTimeUtils.CopyIntToCharArray(chars, start, num1, 2);
-      start += 2;
-      if (format == DateFormatHandling.IsoDateFormat)
-        chars[start++] = ':';
-      int num2 = Math.Abs(offset.Minutes);
-      DateTimeUtils.CopyIntToCharArray(chars, start, num2, 2);
-      start += 2;
-      return start;
-    }
-
-    internal static void WriteDateTimeOffsetString(
-      TextWriter writer,
-      DateTimeOffset value,
-      DateFormatHandling format,
-      string formatString,
-      CultureInfo culture)
-    {
-      if (string.IsNullOrEmpty(formatString))
-      {
-        char[] chArray = new char[64];
-        int count = DateTimeUtils.WriteDateTimeString(chArray, 0, format == DateFormatHandling.IsoDateFormat ? value.DateTime : value.UtcDateTime, new TimeSpan?(value.Offset), DateTimeKind.Local, format);
-        writer.Write(chArray, 0, count);
-      }
-      else
-        writer.Write(value.ToString(formatString, (IFormatProvider) culture));
-    }
-
-    private static void GetDateValues(DateTime td, out int year, out int month, out int day)
-    {
-      int num1 = (int) (td.Ticks / 864000000000L);
-      int num2 = num1 / 146097;
-      int num3 = num1 - num2 * 146097;
-      int num4 = num3 / 36524;
-      if (num4 == 4)
-        num4 = 3;
-      int num5 = num3 - num4 * 36524;
-      int num6 = num5 / 1461;
-      int num7 = num5 - num6 * 1461;
-      int num8 = num7 / 365;
-      if (num8 == 4)
-        num8 = 3;
-      year = num2 * 400 + num4 * 100 + num6 * 4 + num8 + 1;
-      int num9 = num7 - num8 * 365;
-      int[] numArray = (num8 != 3 ? 0 : (num6 != 24 ? 1 : (num4 == 3 ? 1 : 0))) != 0 ? DateTimeUtils.DaysToMonth366 : DateTimeUtils.DaysToMonth365;
-      int index = num9 >> 6;
-      while (num9 >= numArray[index])
-        ++index;
-      month = index;
-      day = num9 - numArray[index - 1] + 1;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/DictionaryWrapper`2.cs b/MSHALTester/Newtonsoft/Json/Utilities/DictionaryWrapper`2.cs
deleted file mode 100644
index 7152401..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/DictionaryWrapper`2.cs
+++ /dev/null
@@ -1,307 +0,0 @@
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Linq;
-using System.Threading;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class DictionaryWrapper<TKey, TValue> : 
-    IDictionary<TKey, TValue>,
-    ICollection<KeyValuePair<TKey, TValue>>,
-    IEnumerable<KeyValuePair<TKey, TValue>>,
-    IEnumerable,
-    IWrappedDictionary,
-    IDictionary,
-    ICollection
-  {
-    private readonly IDictionary _dictionary;
-    private readonly IDictionary<TKey, TValue> _genericDictionary;
-    private object _syncRoot;
-
-    public DictionaryWrapper(IDictionary dictionary)
-    {
-      ValidationUtils.ArgumentNotNull((object) dictionary, nameof (dictionary));
-      this._dictionary = dictionary;
-    }
-
-    public DictionaryWrapper(IDictionary<TKey, TValue> dictionary)
-    {
-      ValidationUtils.ArgumentNotNull((object) dictionary, nameof (dictionary));
-      this._genericDictionary = dictionary;
-    }
-
-    public void Add(TKey key, TValue value)
-    {
-      if (this._dictionary != null)
-      {
-        this._dictionary.Add((object) key, (object) value);
-      }
-      else
-      {
-        if (this._genericDictionary == null)
-          throw new NotSupportedException();
-        this._genericDictionary.Add(key, value);
-      }
-    }
-
-    public bool ContainsKey(TKey key)
-    {
-      return this._dictionary != null ? this._dictionary.Contains((object) key) : this._genericDictionary.ContainsKey(key);
-    }
-
-    public ICollection<TKey> Keys
-    {
-      get
-      {
-        return this._dictionary != null ? (ICollection<TKey>) this._dictionary.Keys.Cast<TKey>().ToList<TKey>() : this._genericDictionary.Keys;
-      }
-    }
-
-    public bool Remove(TKey key)
-    {
-      if (this._dictionary == null)
-        return this._genericDictionary.Remove(key);
-      if (!this._dictionary.Contains((object) key))
-        return false;
-      this._dictionary.Remove((object) key);
-      return true;
-    }
-
-    public bool TryGetValue(TKey key, out TValue value)
-    {
-      if (this._dictionary == null)
-        return this._genericDictionary.TryGetValue(key, out value);
-      if (!this._dictionary.Contains((object) key))
-      {
-        value = default (TValue);
-        return false;
-      }
-      value = (TValue) this._dictionary[(object) key];
-      return true;
-    }
-
-    public ICollection<TValue> Values
-    {
-      get
-      {
-        return this._dictionary != null ? (ICollection<TValue>) this._dictionary.Values.Cast<TValue>().ToList<TValue>() : this._genericDictionary.Values;
-      }
-    }
-
-    public TValue this[TKey key]
-    {
-      get
-      {
-        return this._dictionary != null ? (TValue) this._dictionary[(object) key] : this._genericDictionary[key];
-      }
-      set
-      {
-        if (this._dictionary != null)
-          this._dictionary[(object) key] = (object) value;
-        else
-          this._genericDictionary[key] = value;
-      }
-    }
-
-    public void Add(KeyValuePair<TKey, TValue> item)
-    {
-      if (this._dictionary != null)
-        ((IList) this._dictionary).Add((object) item);
-      else
-        this._genericDictionary?.Add(item);
-    }
-
-    public void Clear()
-    {
-      if (this._dictionary != null)
-        this._dictionary.Clear();
-      else
-        this._genericDictionary.Clear();
-    }
-
-    public bool Contains(KeyValuePair<TKey, TValue> item)
-    {
-      return this._dictionary != null ? ((IList) this._dictionary).Contains((object) item) : this._genericDictionary.Contains(item);
-    }
-
-    public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
-    {
-      if (this._dictionary != null)
-      {
-        IDictionaryEnumerator enumerator = this._dictionary.GetEnumerator();
-        try
-        {
-          while (enumerator.MoveNext())
-          {
-            DictionaryEntry entry = enumerator.Entry;
-            array[arrayIndex++] = new KeyValuePair<TKey, TValue>((TKey) entry.Key, (TValue) entry.Value);
-          }
-        }
-        finally
-        {
-          if (enumerator is IDisposable disposable)
-            disposable.Dispose();
-        }
-      }
-      else
-        this._genericDictionary.CopyTo(array, arrayIndex);
-    }
-
-    public int Count
-    {
-      get => this._dictionary != null ? this._dictionary.Count : this._genericDictionary.Count;
-    }
-
-    public bool IsReadOnly
-    {
-      get
-      {
-        return this._dictionary != null ? this._dictionary.IsReadOnly : this._genericDictionary.IsReadOnly;
-      }
-    }
-
-    public bool Remove(KeyValuePair<TKey, TValue> item)
-    {
-      if (this._dictionary == null)
-        return ((ICollection<KeyValuePair<TKey, TValue>>) this._genericDictionary).Remove(item);
-      if (!this._dictionary.Contains((object) item.Key))
-        return true;
-      if (!object.Equals(this._dictionary[(object) item.Key], (object) item.Value))
-        return false;
-      this._dictionary.Remove((object) item.Key);
-      return true;
-    }
-
-    public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
-    {
-      return this._dictionary != null ? this._dictionary.Cast<DictionaryEntry>().Select<DictionaryEntry, KeyValuePair<TKey, TValue>>((Func<DictionaryEntry, KeyValuePair<TKey, TValue>>) (de => new KeyValuePair<TKey, TValue>((TKey) de.Key, (TValue) de.Value))).GetEnumerator() : this._genericDictionary.GetEnumerator();
-    }
-
-    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-
-    void IDictionary.Add(object key, object value)
-    {
-      if (this._dictionary != null)
-        this._dictionary.Add(key, value);
-      else
-        this._genericDictionary.Add((TKey) key, (TValue) value);
-    }
-
-    object IDictionary.this[object key]
-    {
-      get
-      {
-        return this._dictionary != null ? this._dictionary[key] : (object) this._genericDictionary[(TKey) key];
-      }
-      set
-      {
-        if (this._dictionary != null)
-          this._dictionary[key] = value;
-        else
-          this._genericDictionary[(TKey) key] = (TValue) value;
-      }
-    }
-
-    IDictionaryEnumerator IDictionary.GetEnumerator()
-    {
-      return this._dictionary != null ? this._dictionary.GetEnumerator() : (IDictionaryEnumerator) new DictionaryWrapper<TKey, TValue>.DictionaryEnumerator<TKey, TValue>(this._genericDictionary.GetEnumerator());
-    }
-
-    bool IDictionary.Contains(object key)
-    {
-      return this._genericDictionary != null ? this._genericDictionary.ContainsKey((TKey) key) : this._dictionary.Contains(key);
-    }
-
-    bool IDictionary.IsFixedSize => this._genericDictionary == null && this._dictionary.IsFixedSize;
-
-    ICollection IDictionary.Keys
-    {
-      get
-      {
-        return this._genericDictionary != null ? (ICollection) this._genericDictionary.Keys.ToList<TKey>() : this._dictionary.Keys;
-      }
-    }
-
-    public void Remove(object key)
-    {
-      if (this._dictionary != null)
-        this._dictionary.Remove(key);
-      else
-        this._genericDictionary.Remove((TKey) key);
-    }
-
-    ICollection IDictionary.Values
-    {
-      get
-      {
-        return this._genericDictionary != null ? (ICollection) this._genericDictionary.Values.ToList<TValue>() : this._dictionary.Values;
-      }
-    }
-
-    void ICollection.CopyTo(Array array, int index)
-    {
-      if (this._dictionary != null)
-        this._dictionary.CopyTo(array, index);
-      else
-        this._genericDictionary.CopyTo((KeyValuePair<TKey, TValue>[]) array, index);
-    }
-
-    bool ICollection.IsSynchronized => this._dictionary != null && this._dictionary.IsSynchronized;
-
-    object ICollection.SyncRoot
-    {
-      get
-      {
-        if (this._syncRoot == null)
-          Interlocked.CompareExchange(ref this._syncRoot, new object(), (object) null);
-        return this._syncRoot;
-      }
-    }
-
-    public object UnderlyingDictionary
-    {
-      get
-      {
-        return this._dictionary != null ? (object) this._dictionary : (object) this._genericDictionary;
-      }
-    }
-
-    private readonly struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : 
-      IDictionaryEnumerator,
-      IEnumerator
-    {
-      private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;
-
-      public DictionaryEnumerator(
-        IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
-      {
-        ValidationUtils.ArgumentNotNull((object) e, nameof (e));
-        this._e = e;
-      }
-
-      public DictionaryEntry Entry => (DictionaryEntry) this.Current;
-
-      public object Key => this.Entry.Key;
-
-      public object Value => this.Entry.Value;
-
-      public object Current
-      {
-        get
-        {
-          KeyValuePair<TEnumeratorKey, TEnumeratorValue> current = this._e.Current;
-          __Boxed<TEnumeratorKey> key = (object) current.Key;
-          current = this._e.Current;
-          __Boxed<TEnumeratorValue> local = (object) current.Value;
-          return (object) new DictionaryEntry((object) key, (object) local);
-        }
-      }
-
-      public bool MoveNext() => this._e.MoveNext();
-
-      public void Reset() => this._e.Reset();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/DynamicReflectionDelegateFactory.cs b/MSHALTester/Newtonsoft/Json/Utilities/DynamicReflectionDelegateFactory.cs
deleted file mode 100644
index 720dd47..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/DynamicReflectionDelegateFactory.cs
+++ /dev/null
@@ -1,285 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Globalization;
-using System.Reflection;
-using System.Reflection.Emit;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class DynamicReflectionDelegateFactory : ReflectionDelegateFactory
-  {
-    internal static DynamicReflectionDelegateFactory Instance { get; } = new DynamicReflectionDelegateFactory();
-
-    private static DynamicMethod CreateDynamicMethod(
-      string name,
-      Type returnType,
-      Type[] parameterTypes,
-      Type owner)
-    {
-      return owner.IsInterface() ? new DynamicMethod(name, returnType, parameterTypes, owner.Module, true) : new DynamicMethod(name, returnType, parameterTypes, owner, true);
-    }
-
-    public override ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method)
-    {
-      DynamicMethod dynamicMethod = DynamicReflectionDelegateFactory.CreateDynamicMethod(method.ToString(), typeof (object), new Type[1]
-      {
-        typeof (object[])
-      }, method.DeclaringType);
-      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
-      this.GenerateCreateMethodCallIL(method, ilGenerator, 0);
-      return (ObjectConstructor<object>) dynamicMethod.CreateDelegate(typeof (ObjectConstructor<object>));
-    }
-
-    public override MethodCall<T, object> CreateMethodCall<T>(MethodBase method)
-    {
-      DynamicMethod dynamicMethod = DynamicReflectionDelegateFactory.CreateDynamicMethod(method.ToString(), typeof (object), new Type[2]
-      {
-        typeof (object),
-        typeof (object[])
-      }, method.DeclaringType);
-      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
-      this.GenerateCreateMethodCallIL(method, ilGenerator, 1);
-      return (MethodCall<T, object>) dynamicMethod.CreateDelegate(typeof (MethodCall<T, object>));
-    }
-
-    private void GenerateCreateMethodCallIL(
-      MethodBase method,
-      ILGenerator generator,
-      int argsIndex)
-    {
-      ParameterInfo[] parameters = method.GetParameters();
-      Label label1 = generator.DefineLabel();
-      generator.Emit(OpCodes.Ldarg, argsIndex);
-      generator.Emit(OpCodes.Ldlen);
-      generator.Emit(OpCodes.Ldc_I4, parameters.Length);
-      generator.Emit(OpCodes.Beq, label1);
-      generator.Emit(OpCodes.Newobj, typeof (TargetParameterCountException).GetConstructor(ReflectionUtils.EmptyTypes));
-      generator.Emit(OpCodes.Throw);
-      generator.MarkLabel(label1);
-      if (!method.IsConstructor && !method.IsStatic)
-        generator.PushInstance(method.DeclaringType);
-      LocalBuilder local1 = generator.DeclareLocal(typeof (IConvertible));
-      LocalBuilder local2 = generator.DeclareLocal(typeof (object));
-      for (int arrayIndex = 0; arrayIndex < parameters.Length; ++arrayIndex)
-      {
-        ParameterInfo parameterInfo = parameters[arrayIndex];
-        Type parameterType = parameterInfo.ParameterType;
-        if (parameterType.IsByRef)
-        {
-          Type elementType = parameterType.GetElementType();
-          LocalBuilder local3 = generator.DeclareLocal(elementType);
-          if (!parameterInfo.IsOut)
-          {
-            generator.PushArrayInstance(argsIndex, arrayIndex);
-            if (elementType.IsValueType())
-            {
-              Label label2 = generator.DefineLabel();
-              Label label3 = generator.DefineLabel();
-              generator.Emit(OpCodes.Brtrue_S, label2);
-              generator.Emit(OpCodes.Ldloca_S, local3);
-              generator.Emit(OpCodes.Initobj, elementType);
-              generator.Emit(OpCodes.Br_S, label3);
-              generator.MarkLabel(label2);
-              generator.PushArrayInstance(argsIndex, arrayIndex);
-              generator.UnboxIfNeeded(elementType);
-              generator.Emit(OpCodes.Stloc_S, local3);
-              generator.MarkLabel(label3);
-            }
-            else
-            {
-              generator.UnboxIfNeeded(elementType);
-              generator.Emit(OpCodes.Stloc_S, local3);
-            }
-          }
-          generator.Emit(OpCodes.Ldloca_S, local3);
-        }
-        else if (parameterType.IsValueType())
-        {
-          generator.PushArrayInstance(argsIndex, arrayIndex);
-          generator.Emit(OpCodes.Stloc_S, local2);
-          Label label4 = generator.DefineLabel();
-          Label label5 = generator.DefineLabel();
-          generator.Emit(OpCodes.Ldloc_S, local2);
-          generator.Emit(OpCodes.Brtrue_S, label4);
-          LocalBuilder local4 = generator.DeclareLocal(parameterType);
-          generator.Emit(OpCodes.Ldloca_S, local4);
-          generator.Emit(OpCodes.Initobj, parameterType);
-          generator.Emit(OpCodes.Ldloc_S, local4);
-          generator.Emit(OpCodes.Br_S, label5);
-          generator.MarkLabel(label4);
-          if (parameterType.IsPrimitive())
-          {
-            MethodInfo method1 = typeof (IConvertible).GetMethod("To" + parameterType.Name, new Type[1]
-            {
-              typeof (IFormatProvider)
-            });
-            if (method1 != null)
-            {
-              Label label6 = generator.DefineLabel();
-              generator.Emit(OpCodes.Ldloc_S, local2);
-              generator.Emit(OpCodes.Isinst, parameterType);
-              generator.Emit(OpCodes.Brtrue_S, label6);
-              generator.Emit(OpCodes.Ldloc_S, local2);
-              generator.Emit(OpCodes.Isinst, typeof (IConvertible));
-              generator.Emit(OpCodes.Stloc_S, local1);
-              generator.Emit(OpCodes.Ldloc_S, local1);
-              generator.Emit(OpCodes.Brfalse_S, label6);
-              generator.Emit(OpCodes.Ldloc_S, local1);
-              generator.Emit(OpCodes.Ldnull);
-              generator.Emit(OpCodes.Callvirt, method1);
-              generator.Emit(OpCodes.Br_S, label5);
-              generator.MarkLabel(label6);
-            }
-          }
-          generator.Emit(OpCodes.Ldloc_S, local2);
-          generator.UnboxIfNeeded(parameterType);
-          generator.MarkLabel(label5);
-        }
-        else
-        {
-          generator.PushArrayInstance(argsIndex, arrayIndex);
-          generator.UnboxIfNeeded(parameterType);
-        }
-      }
-      if (method.IsConstructor)
-        generator.Emit(OpCodes.Newobj, (ConstructorInfo) method);
-      else
-        generator.CallMethod((MethodInfo) method);
-      Type type = method.IsConstructor ? method.DeclaringType : ((MethodInfo) method).ReturnType;
-      if (type != typeof (void))
-        generator.BoxIfNeeded(type);
-      else
-        generator.Emit(OpCodes.Ldnull);
-      generator.Return();
-    }
-
-    public override Func<T> CreateDefaultConstructor<T>(Type type)
-    {
-      DynamicMethod dynamicMethod = DynamicReflectionDelegateFactory.CreateDynamicMethod("Create" + type.FullName, typeof (T), ReflectionUtils.EmptyTypes, type);
-      dynamicMethod.InitLocals = true;
-      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
-      this.GenerateCreateDefaultConstructorIL(type, ilGenerator, typeof (T));
-      return (Func<T>) dynamicMethod.CreateDelegate(typeof (Func<T>));
-    }
-
-    private void GenerateCreateDefaultConstructorIL(
-      Type type,
-      ILGenerator generator,
-      Type delegateType)
-    {
-      if (type.IsValueType())
-      {
-        generator.DeclareLocal(type);
-        generator.Emit(OpCodes.Ldloc_0);
-        if (type != delegateType)
-          generator.Emit(OpCodes.Box, type);
-      }
-      else
-        generator.Emit(OpCodes.Newobj, type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, (Binder) null, ReflectionUtils.EmptyTypes, (ParameterModifier[]) null) ?? throw new ArgumentException("Could not get constructor for {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type)));
-      generator.Return();
-    }
-
-    public override Func<T, object> CreateGet<T>(PropertyInfo propertyInfo)
-    {
-      DynamicMethod dynamicMethod = DynamicReflectionDelegateFactory.CreateDynamicMethod("Get" + propertyInfo.Name, typeof (object), new Type[1]
-      {
-        typeof (T)
-      }, propertyInfo.DeclaringType);
-      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
-      this.GenerateCreateGetPropertyIL(propertyInfo, ilGenerator);
-      return (Func<T, object>) dynamicMethod.CreateDelegate(typeof (Func<T, object>));
-    }
-
-    private void GenerateCreateGetPropertyIL(PropertyInfo propertyInfo, ILGenerator generator)
-    {
-      MethodInfo getMethod = propertyInfo.GetGetMethod(true);
-      if (getMethod == null)
-        throw new ArgumentException("Property '{0}' does not have a getter.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) propertyInfo.Name));
-      if (!getMethod.IsStatic)
-        generator.PushInstance(propertyInfo.DeclaringType);
-      generator.CallMethod(getMethod);
-      generator.BoxIfNeeded(propertyInfo.PropertyType);
-      generator.Return();
-    }
-
-    public override Func<T, object> CreateGet<T>(FieldInfo fieldInfo)
-    {
-      if (fieldInfo.IsLiteral)
-      {
-        object constantValue = fieldInfo.GetValue((object) null);
-        return (Func<T, object>) (o => constantValue);
-      }
-      DynamicMethod dynamicMethod = DynamicReflectionDelegateFactory.CreateDynamicMethod("Get" + fieldInfo.Name, typeof (T), new Type[1]
-      {
-        typeof (object)
-      }, fieldInfo.DeclaringType);
-      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
-      this.GenerateCreateGetFieldIL(fieldInfo, ilGenerator);
-      return (Func<T, object>) dynamicMethod.CreateDelegate(typeof (Func<T, object>));
-    }
-
-    private void GenerateCreateGetFieldIL(FieldInfo fieldInfo, ILGenerator generator)
-    {
-      if (!fieldInfo.IsStatic)
-      {
-        generator.PushInstance(fieldInfo.DeclaringType);
-        generator.Emit(OpCodes.Ldfld, fieldInfo);
-      }
-      else
-        generator.Emit(OpCodes.Ldsfld, fieldInfo);
-      generator.BoxIfNeeded(fieldInfo.FieldType);
-      generator.Return();
-    }
-
-    public override Action<T, object> CreateSet<T>(FieldInfo fieldInfo)
-    {
-      DynamicMethod dynamicMethod = DynamicReflectionDelegateFactory.CreateDynamicMethod("Set" + fieldInfo.Name, (Type) null, new Type[2]
-      {
-        typeof (T),
-        typeof (object)
-      }, fieldInfo.DeclaringType);
-      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
-      DynamicReflectionDelegateFactory.GenerateCreateSetFieldIL(fieldInfo, ilGenerator);
-      return (Action<T, object>) dynamicMethod.CreateDelegate(typeof (Action<T, object>));
-    }
-
-    internal static void GenerateCreateSetFieldIL(FieldInfo fieldInfo, ILGenerator generator)
-    {
-      if (!fieldInfo.IsStatic)
-        generator.PushInstance(fieldInfo.DeclaringType);
-      generator.Emit(OpCodes.Ldarg_1);
-      generator.UnboxIfNeeded(fieldInfo.FieldType);
-      if (!fieldInfo.IsStatic)
-        generator.Emit(OpCodes.Stfld, fieldInfo);
-      else
-        generator.Emit(OpCodes.Stsfld, fieldInfo);
-      generator.Return();
-    }
-
-    public override Action<T, object> CreateSet<T>(PropertyInfo propertyInfo)
-    {
-      DynamicMethod dynamicMethod = DynamicReflectionDelegateFactory.CreateDynamicMethod("Set" + propertyInfo.Name, (Type) null, new Type[2]
-      {
-        typeof (T),
-        typeof (object)
-      }, propertyInfo.DeclaringType);
-      ILGenerator ilGenerator = dynamicMethod.GetILGenerator();
-      DynamicReflectionDelegateFactory.GenerateCreateSetPropertyIL(propertyInfo, ilGenerator);
-      return (Action<T, object>) dynamicMethod.CreateDelegate(typeof (Action<T, object>));
-    }
-
-    internal static void GenerateCreateSetPropertyIL(
-      PropertyInfo propertyInfo,
-      ILGenerator generator)
-    {
-      MethodInfo setMethod = propertyInfo.GetSetMethod(true);
-      if (!setMethod.IsStatic)
-        generator.PushInstance(propertyInfo.DeclaringType);
-      generator.Emit(OpCodes.Ldarg_1);
-      generator.UnboxIfNeeded(propertyInfo.PropertyType);
-      generator.CallMethod(setMethod);
-      generator.Return();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/EnumInfo.cs b/MSHALTester/Newtonsoft/Json/Utilities/EnumInfo.cs
deleted file mode 100644
index 8e379aa..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/EnumInfo.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class EnumInfo
-  {
-    public readonly bool IsFlags;
-    public readonly ulong[] Values;
-    public readonly string[] Names;
-    public readonly string[] ResolvedNames;
-
-    public EnumInfo(bool isFlags, ulong[] values, string[] names, string[] resolvedNames)
-    {
-      this.IsFlags = isFlags;
-      this.Values = values;
-      this.Names = names;
-      this.ResolvedNames = resolvedNames;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/EnumUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/EnumUtils.cs
deleted file mode 100644
index 8495841..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/EnumUtils.cs
+++ /dev/null
@@ -1,251 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Linq;
-using System.Reflection;
-using System.Runtime.Serialization;
-using System.Text;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class EnumUtils
-  {
-    private const char EnumSeparatorChar = ',';
-    private const string EnumSeparatorString = ", ";
-    private static readonly ThreadSafeStore<Type, EnumInfo> ValuesAndNamesPerEnum = new ThreadSafeStore<Type, EnumInfo>(new Func<Type, EnumInfo>(EnumUtils.InitializeValuesAndNames));
-
-    private static EnumInfo InitializeValuesAndNames(Type enumType)
-    {
-      string[] names = Enum.GetNames(enumType);
-      string[] strArray = new string[names.Length];
-      ulong[] values = new ulong[names.Length];
-      for (int count = 0; count < names.Length; ++count)
-      {
-        string name = names[count];
-        FieldInfo field = enumType.GetField(name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
-        values[count] = EnumUtils.ToUInt64(field.GetValue((object) null));
-        string str = field.GetCustomAttributes(typeof (EnumMemberAttribute), true).Cast<EnumMemberAttribute>().Select<EnumMemberAttribute, string>((Func<EnumMemberAttribute, string>) (a => a.Value)).SingleOrDefault<string>() ?? field.Name;
-        if (Array.IndexOf<string>(strArray, str, 0, count) != -1)
-          throw new InvalidOperationException("Enum name '{0}' already exists on enum '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) str, (object) enumType.Name));
-        strArray[count] = str;
-      }
-      return new EnumInfo(enumType.IsDefined(typeof (FlagsAttribute), false), values, names, strArray);
-    }
-
-    public static IList<T> GetFlagsValues<T>(T value) where T : struct
-    {
-      Type enumType = typeof (T);
-      if (!enumType.IsDefined(typeof (FlagsAttribute), false))
-        throw new ArgumentException("Enum type {0} is not a set of flags.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) enumType));
-      Type underlyingType = Enum.GetUnderlyingType(value.GetType());
-      ulong uint64 = EnumUtils.ToUInt64((object) value);
-      EnumInfo enumValuesAndNames = EnumUtils.GetEnumValuesAndNames(enumType);
-      IList<T> flagsValues = (IList<T>) new List<T>();
-      for (int index = 0; index < enumValuesAndNames.Values.Length; ++index)
-      {
-        ulong num = enumValuesAndNames.Values[index];
-        if (((long) uint64 & (long) num) == (long) num && num != 0UL)
-          flagsValues.Add((T) Convert.ChangeType((object) num, underlyingType, (IFormatProvider) CultureInfo.CurrentCulture));
-      }
-      if (flagsValues.Count == 0 && ((IEnumerable<ulong>) enumValuesAndNames.Values).Any<ulong>((Func<ulong, bool>) (v => v == 0UL)))
-        flagsValues.Add(default (T));
-      return flagsValues;
-    }
-
-    public static bool TryToString(
-      Type enumType,
-      object value,
-      bool camelCaseText,
-      out string name)
-    {
-      EnumInfo entry = EnumUtils.ValuesAndNamesPerEnum.Get(enumType);
-      ulong uint64 = EnumUtils.ToUInt64(value);
-      if (!entry.IsFlags)
-      {
-        int index = Array.BinarySearch<ulong>(entry.Values, uint64);
-        if (index >= 0)
-        {
-          name = entry.ResolvedNames[index];
-          if (camelCaseText)
-            name = StringUtils.ToCamelCase(name);
-          return true;
-        }
-        name = (string) null;
-        return false;
-      }
-      name = EnumUtils.InternalFlagsFormat(entry, uint64, camelCaseText);
-      return name != null;
-    }
-
-    private static string InternalFlagsFormat(EnumInfo entry, ulong result, bool camelCaseText)
-    {
-      string[] resolvedNames = entry.ResolvedNames;
-      ulong[] values = entry.Values;
-      int index = values.Length - 1;
-      StringBuilder stringBuilder = new StringBuilder();
-      bool flag = true;
-      ulong num = result;
-      for (; index >= 0 && (index != 0 || values[index] != 0UL); --index)
-      {
-        if (((long) result & (long) values[index]) == (long) values[index])
-        {
-          result -= values[index];
-          if (!flag)
-            stringBuilder.Insert(0, ", ");
-          string s = resolvedNames[index];
-          stringBuilder.Insert(0, camelCaseText ? StringUtils.ToCamelCase(s) : s);
-          flag = false;
-        }
-      }
-      string s1;
-      if (result != 0UL)
-        s1 = (string) null;
-      else if (num == 0UL)
-      {
-        if (values.Length != 0 && values[0] == 0UL)
-        {
-          s1 = resolvedNames[0];
-          if (camelCaseText)
-            s1 = StringUtils.ToCamelCase(s1);
-        }
-        else
-          s1 = (string) null;
-      }
-      else
-        s1 = stringBuilder.ToString();
-      return s1;
-    }
-
-    public static EnumInfo GetEnumValuesAndNames(Type enumType)
-    {
-      return EnumUtils.ValuesAndNamesPerEnum.Get(enumType);
-    }
-
-    private static ulong ToUInt64(object value)
-    {
-      switch (ConvertUtils.GetTypeCode(value.GetType(), out bool _))
-      {
-        case PrimitiveTypeCode.Char:
-          return (ulong) (char) value;
-        case PrimitiveTypeCode.Boolean:
-          return (ulong) Convert.ToByte((bool) value);
-        case PrimitiveTypeCode.SByte:
-          return (ulong) (sbyte) value;
-        case PrimitiveTypeCode.Int16:
-          return (ulong) (short) value;
-        case PrimitiveTypeCode.UInt16:
-          return (ulong) (ushort) value;
-        case PrimitiveTypeCode.Int32:
-          return (ulong) (int) value;
-        case PrimitiveTypeCode.Byte:
-          return (ulong) (byte) value;
-        case PrimitiveTypeCode.UInt32:
-          return (ulong) (uint) value;
-        case PrimitiveTypeCode.Int64:
-          return (ulong) (long) value;
-        case PrimitiveTypeCode.UInt64:
-          return (ulong) value;
-        default:
-          throw new InvalidOperationException("Unknown enum type.");
-      }
-    }
-
-    public static object ParseEnum(Type enumType, string value, bool disallowNumber)
-    {
-      ValidationUtils.ArgumentNotNull((object) enumType, nameof (enumType));
-      ValidationUtils.ArgumentNotNull((object) value, nameof (value));
-      EnumInfo enumInfo = enumType.IsEnum() ? EnumUtils.ValuesAndNamesPerEnum.Get(enumType) : throw new ArgumentException("Type provided must be an Enum.", nameof (enumType));
-      string[] names = enumInfo.Names;
-      string[] resolvedNames = enumInfo.ResolvedNames;
-      ulong[] values = enumInfo.Values;
-      int? indexByName = EnumUtils.FindIndexByName(resolvedNames, value, 0, value.Length, StringComparison.Ordinal);
-      if (indexByName.HasValue)
-        return Enum.ToObject(enumType, values[indexByName.Value]);
-      int index1 = -1;
-      for (int index2 = 0; index2 < value.Length; ++index2)
-      {
-        if (!char.IsWhiteSpace(value[index2]))
-        {
-          index1 = index2;
-          break;
-        }
-      }
-      char c = index1 != -1 ? value[index1] : throw new ArgumentException("Must specify valid information for parsing in the string.");
-      if (char.IsDigit(c) || c == '-' || c == '+')
-      {
-        Type underlyingType = Enum.GetUnderlyingType(enumType);
-        value = value.Trim();
-        object obj = (object) null;
-        try
-        {
-          obj = Convert.ChangeType((object) value, underlyingType, (IFormatProvider) CultureInfo.InvariantCulture);
-        }
-        catch (FormatException ex)
-        {
-        }
-        if (obj != null)
-        {
-          if (disallowNumber)
-            throw new FormatException("Integer string '{0}' is not allowed.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value));
-          return Enum.ToObject(enumType, obj);
-        }
-      }
-      ulong num1 = 0;
-      int num2;
-      for (int index3 = index1; index3 <= value.Length; index3 = num2 + 1)
-      {
-        num2 = value.IndexOf(',', index3);
-        if (num2 == -1)
-          num2 = value.Length;
-        int num3 = num2;
-        while (index3 < num2 && char.IsWhiteSpace(value[index3]))
-          ++index3;
-        while (num3 > index3 && char.IsWhiteSpace(value[num3 - 1]))
-          --num3;
-        int valueSubstringLength = num3 - index3;
-        int? nullable = EnumUtils.MatchName(value, names, resolvedNames, index3, valueSubstringLength, StringComparison.Ordinal);
-        if (!nullable.HasValue)
-          nullable = EnumUtils.MatchName(value, names, resolvedNames, index3, valueSubstringLength, StringComparison.OrdinalIgnoreCase);
-        if (!nullable.HasValue)
-        {
-          nullable = EnumUtils.FindIndexByName(resolvedNames, value, 0, value.Length, StringComparison.OrdinalIgnoreCase);
-          if (nullable.HasValue)
-            return Enum.ToObject(enumType, values[nullable.Value]);
-          throw new ArgumentException("Requested value '{0}' was not found.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) value));
-        }
-        num1 |= values[nullable.Value];
-      }
-      return Enum.ToObject(enumType, num1);
-    }
-
-    private static int? MatchName(
-      string value,
-      string[] enumNames,
-      string[] resolvedNames,
-      int valueIndex,
-      int valueSubstringLength,
-      StringComparison comparison)
-    {
-      int? indexByName = EnumUtils.FindIndexByName(resolvedNames, value, valueIndex, valueSubstringLength, comparison);
-      if (!indexByName.HasValue)
-        indexByName = EnumUtils.FindIndexByName(enumNames, value, valueIndex, valueSubstringLength, comparison);
-      return indexByName;
-    }
-
-    private static int? FindIndexByName(
-      string[] enumNames,
-      string value,
-      int valueIndex,
-      int valueSubstringLength,
-      StringComparison comparison)
-    {
-      for (int index = 0; index < enumNames.Length; ++index)
-      {
-        if (enumNames[index].Length == valueSubstringLength && string.Compare(enumNames[index], 0, value, valueIndex, valueSubstringLength, comparison) == 0)
-          return new int?(index);
-      }
-      return new int?();
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ILGeneratorExtensions.cs b/MSHALTester/Newtonsoft/Json/Utilities/ILGeneratorExtensions.cs
deleted file mode 100644
index 0b7f83a..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ILGeneratorExtensions.cs
+++ /dev/null
@@ -1,52 +0,0 @@
-using System;
-using System.Reflection;
-using System.Reflection.Emit;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class ILGeneratorExtensions
-  {
-    public static void PushInstance(this ILGenerator generator, Type type)
-    {
-      generator.Emit(OpCodes.Ldarg_0);
-      if (type.IsValueType())
-        generator.Emit(OpCodes.Unbox, type);
-      else
-        generator.Emit(OpCodes.Castclass, type);
-    }
-
-    public static void PushArrayInstance(this ILGenerator generator, int argsIndex, int arrayIndex)
-    {
-      generator.Emit(OpCodes.Ldarg, argsIndex);
-      generator.Emit(OpCodes.Ldc_I4, arrayIndex);
-      generator.Emit(OpCodes.Ldelem_Ref);
-    }
-
-    public static void BoxIfNeeded(this ILGenerator generator, Type type)
-    {
-      if (type.IsValueType())
-        generator.Emit(OpCodes.Box, type);
-      else
-        generator.Emit(OpCodes.Castclass, type);
-    }
-
-    public static void UnboxIfNeeded(this ILGenerator generator, Type type)
-    {
-      if (type.IsValueType())
-        generator.Emit(OpCodes.Unbox_Any, type);
-      else
-        generator.Emit(OpCodes.Castclass, type);
-    }
-
-    public static void CallMethod(this ILGenerator generator, MethodInfo methodInfo)
-    {
-      if (methodInfo.IsFinal || !methodInfo.IsVirtual)
-        generator.Emit(OpCodes.Call, methodInfo);
-      else
-        generator.Emit(OpCodes.Callvirt, methodInfo);
-    }
-
-    public static void Return(this ILGenerator generator) => generator.Emit(OpCodes.Ret);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/IWrappedCollection.cs b/MSHALTester/Newtonsoft/Json/Utilities/IWrappedCollection.cs
deleted file mode 100644
index 148fa95..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/IWrappedCollection.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System.Collections;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal interface IWrappedCollection : IList, ICollection, IEnumerable
-  {
-    object UnderlyingCollection { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/IWrappedDictionary.cs b/MSHALTester/Newtonsoft/Json/Utilities/IWrappedDictionary.cs
deleted file mode 100644
index 37e972b..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/IWrappedDictionary.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System.Collections;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal interface IWrappedDictionary : IDictionary, ICollection, IEnumerable
-  {
-    object UnderlyingDictionary { get; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ImmutableCollectionsUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/ImmutableCollectionsUtils.cs
deleted file mode 100644
index 96c5d25..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ImmutableCollectionsUtils.cs
+++ /dev/null
@@ -1,143 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Collections.Generic;
-using System.Linq;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class ImmutableCollectionsUtils
-  {
-    private const string ImmutableListGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableList`1";
-    private const string ImmutableQueueGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableQueue`1";
-    private const string ImmutableStackGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableStack`1";
-    private const string ImmutableSetGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableSet`1";
-    private const string ImmutableArrayTypeName = "System.Collections.Immutable.ImmutableArray";
-    private const string ImmutableArrayGenericTypeName = "System.Collections.Immutable.ImmutableArray`1";
-    private const string ImmutableListTypeName = "System.Collections.Immutable.ImmutableList";
-    private const string ImmutableListGenericTypeName = "System.Collections.Immutable.ImmutableList`1";
-    private const string ImmutableQueueTypeName = "System.Collections.Immutable.ImmutableQueue";
-    private const string ImmutableQueueGenericTypeName = "System.Collections.Immutable.ImmutableQueue`1";
-    private const string ImmutableStackTypeName = "System.Collections.Immutable.ImmutableStack";
-    private const string ImmutableStackGenericTypeName = "System.Collections.Immutable.ImmutableStack`1";
-    private const string ImmutableSortedSetTypeName = "System.Collections.Immutable.ImmutableSortedSet";
-    private const string ImmutableSortedSetGenericTypeName = "System.Collections.Immutable.ImmutableSortedSet`1";
-    private const string ImmutableHashSetTypeName = "System.Collections.Immutable.ImmutableHashSet";
-    private const string ImmutableHashSetGenericTypeName = "System.Collections.Immutable.ImmutableHashSet`1";
-    private static readonly IList<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo> ArrayContractImmutableCollectionDefinitions = (IList<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo>) new List<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo>()
-    {
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableList`1", "System.Collections.Immutable.ImmutableList`1", "System.Collections.Immutable.ImmutableList"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableList`1", "System.Collections.Immutable.ImmutableList`1", "System.Collections.Immutable.ImmutableList"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableQueue`1", "System.Collections.Immutable.ImmutableQueue`1", "System.Collections.Immutable.ImmutableQueue"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableQueue`1", "System.Collections.Immutable.ImmutableQueue`1", "System.Collections.Immutable.ImmutableQueue"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableStack`1", "System.Collections.Immutable.ImmutableStack`1", "System.Collections.Immutable.ImmutableStack"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableStack`1", "System.Collections.Immutable.ImmutableStack`1", "System.Collections.Immutable.ImmutableStack"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableSet`1", "System.Collections.Immutable.ImmutableSortedSet`1", "System.Collections.Immutable.ImmutableSortedSet"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableSortedSet`1", "System.Collections.Immutable.ImmutableSortedSet`1", "System.Collections.Immutable.ImmutableSortedSet"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableHashSet`1", "System.Collections.Immutable.ImmutableHashSet`1", "System.Collections.Immutable.ImmutableHashSet"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableArray`1", "System.Collections.Immutable.ImmutableArray`1", "System.Collections.Immutable.ImmutableArray")
-    };
-    private const string ImmutableDictionaryGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableDictionary`2";
-    private const string ImmutableDictionaryTypeName = "System.Collections.Immutable.ImmutableDictionary";
-    private const string ImmutableDictionaryGenericTypeName = "System.Collections.Immutable.ImmutableDictionary`2";
-    private const string ImmutableSortedDictionaryTypeName = "System.Collections.Immutable.ImmutableSortedDictionary";
-    private const string ImmutableSortedDictionaryGenericTypeName = "System.Collections.Immutable.ImmutableSortedDictionary`2";
-    private static readonly IList<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo> DictionaryContractImmutableCollectionDefinitions = (IList<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo>) new List<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo>()
-    {
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.IImmutableDictionary`2", "System.Collections.Immutable.ImmutableSortedDictionary`2", "System.Collections.Immutable.ImmutableSortedDictionary"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableSortedDictionary`2", "System.Collections.Immutable.ImmutableSortedDictionary`2", "System.Collections.Immutable.ImmutableSortedDictionary"),
-      new ImmutableCollectionsUtils.ImmutableCollectionTypeInfo("System.Collections.Immutable.ImmutableDictionary`2", "System.Collections.Immutable.ImmutableDictionary`2", "System.Collections.Immutable.ImmutableDictionary")
-    };
-
-    internal static bool TryBuildImmutableForArrayContract(
-      Type underlyingType,
-      Type collectionItemType,
-      out Type createdType,
-      out ObjectConstructor<object> parameterizedCreator)
-    {
-      if (underlyingType.IsGenericType())
-      {
-        Type genericTypeDefinition = underlyingType.GetGenericTypeDefinition();
-        string name = genericTypeDefinition.FullName;
-        ImmutableCollectionsUtils.ImmutableCollectionTypeInfo collectionTypeInfo = ImmutableCollectionsUtils.ArrayContractImmutableCollectionDefinitions.FirstOrDefault<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo>((Func<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo, bool>) (d => d.ContractTypeName == name));
-        if (collectionTypeInfo != null)
-        {
-          Type type1 = genericTypeDefinition.Assembly().GetType(collectionTypeInfo.CreatedTypeName);
-          Type type2 = genericTypeDefinition.Assembly().GetType(collectionTypeInfo.BuilderTypeName);
-          if (type1 != null && type2 != null)
-          {
-            MethodInfo methodInfo = ((IEnumerable<MethodInfo>) type2.GetMethods()).FirstOrDefault<MethodInfo>((Func<MethodInfo, bool>) (m => m.Name == "CreateRange" && m.GetParameters().Length == 1));
-            if (methodInfo != null)
-            {
-              createdType = type1.MakeGenericType(collectionItemType);
-              MethodInfo method = methodInfo.MakeGenericMethod(collectionItemType);
-              parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) method);
-              return true;
-            }
-          }
-        }
-      }
-      createdType = (Type) null;
-      parameterizedCreator = (ObjectConstructor<object>) null;
-      return false;
-    }
-
-    internal static bool TryBuildImmutableForDictionaryContract(
-      Type underlyingType,
-      Type keyItemType,
-      Type valueItemType,
-      out Type createdType,
-      out ObjectConstructor<object> parameterizedCreator)
-    {
-      if (underlyingType.IsGenericType())
-      {
-        Type genericTypeDefinition = underlyingType.GetGenericTypeDefinition();
-        string name = genericTypeDefinition.FullName;
-        ImmutableCollectionsUtils.ImmutableCollectionTypeInfo collectionTypeInfo = ImmutableCollectionsUtils.DictionaryContractImmutableCollectionDefinitions.FirstOrDefault<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo>((Func<ImmutableCollectionsUtils.ImmutableCollectionTypeInfo, bool>) (d => d.ContractTypeName == name));
-        if (collectionTypeInfo != null)
-        {
-          Type type1 = genericTypeDefinition.Assembly().GetType(collectionTypeInfo.CreatedTypeName);
-          Type type2 = genericTypeDefinition.Assembly().GetType(collectionTypeInfo.BuilderTypeName);
-          if (type1 != null && type2 != null)
-          {
-            MethodInfo methodInfo = ((IEnumerable<MethodInfo>) type2.GetMethods()).FirstOrDefault<MethodInfo>((Func<MethodInfo, bool>) (m =>
-            {
-              ParameterInfo[] parameters = m.GetParameters();
-              return m.Name == "CreateRange" && parameters.Length == 1 && parameters[0].ParameterType.IsGenericType() && parameters[0].ParameterType.GetGenericTypeDefinition() == typeof (IEnumerable<>);
-            }));
-            if (methodInfo != null)
-            {
-              createdType = type1.MakeGenericType(keyItemType, valueItemType);
-              MethodInfo method = methodInfo.MakeGenericMethod(keyItemType, valueItemType);
-              parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor((MethodBase) method);
-              return true;
-            }
-          }
-        }
-      }
-      createdType = (Type) null;
-      parameterizedCreator = (ObjectConstructor<object>) null;
-      return false;
-    }
-
-    internal class ImmutableCollectionTypeInfo
-    {
-      public ImmutableCollectionTypeInfo(
-        string contractTypeName,
-        string createdTypeName,
-        string builderTypeName)
-      {
-        this.ContractTypeName = contractTypeName;
-        this.CreatedTypeName = createdTypeName;
-        this.BuilderTypeName = builderTypeName;
-      }
-
-      public string ContractTypeName { get; set; }
-
-      public string CreatedTypeName { get; set; }
-
-      public string BuilderTypeName { get; set; }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/JavaScriptUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/JavaScriptUtils.cs
deleted file mode 100644
index 7ea5095..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/JavaScriptUtils.cs
+++ /dev/null
@@ -1,233 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.IO;
-using System.Linq;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class JavaScriptUtils
-  {
-    internal static readonly bool[] SingleQuoteCharEscapeFlags = new bool[128];
-    internal static readonly bool[] DoubleQuoteCharEscapeFlags = new bool[128];
-    internal static readonly bool[] HtmlCharEscapeFlags = new bool[128];
-    private const int UnicodeTextLength = 6;
-    private const string EscapedUnicodeText = "!";
-
-    static JavaScriptUtils()
-    {
-      IList<char> first = (IList<char>) new List<char>()
-      {
-        '\n',
-        '\r',
-        '\t',
-        '\\',
-        '\f',
-        '\b'
-      };
-      for (int index = 0; index < 32; ++index)
-        first.Add((char) index);
-      foreach (char index in first.Union<char>((IEnumerable<char>) new char[1]
-      {
-        '\''
-      }))
-        JavaScriptUtils.SingleQuoteCharEscapeFlags[(int) index] = true;
-      foreach (char index in first.Union<char>((IEnumerable<char>) new char[1]
-      {
-        '"'
-      }))
-        JavaScriptUtils.DoubleQuoteCharEscapeFlags[(int) index] = true;
-      foreach (char index in first.Union<char>((IEnumerable<char>) new char[5]
-      {
-        '"',
-        '\'',
-        '<',
-        '>',
-        '&'
-      }))
-        JavaScriptUtils.HtmlCharEscapeFlags[(int) index] = true;
-    }
-
-    public static bool[] GetCharEscapeFlags(
-      StringEscapeHandling stringEscapeHandling,
-      char quoteChar)
-    {
-      if (stringEscapeHandling == StringEscapeHandling.EscapeHtml)
-        return JavaScriptUtils.HtmlCharEscapeFlags;
-      return quoteChar == '"' ? JavaScriptUtils.DoubleQuoteCharEscapeFlags : JavaScriptUtils.SingleQuoteCharEscapeFlags;
-    }
-
-    public static bool ShouldEscapeJavaScriptString(string s, bool[] charEscapeFlags)
-    {
-      if (s == null)
-        return false;
-      foreach (char index in s)
-      {
-        if ((int) index >= charEscapeFlags.Length || charEscapeFlags[(int) index])
-          return true;
-      }
-      return false;
-    }
-
-    public static void WriteEscapedJavaScriptString(
-      TextWriter writer,
-      string s,
-      char delimiter,
-      bool appendDelimiters,
-      bool[] charEscapeFlags,
-      StringEscapeHandling stringEscapeHandling,
-      IArrayPool<char> bufferPool,
-      ref char[] writeBuffer)
-    {
-      if (appendDelimiters)
-        writer.Write(delimiter);
-      if (!string.IsNullOrEmpty(s))
-      {
-        int num1 = JavaScriptUtils.FirstCharToEscape(s, charEscapeFlags, stringEscapeHandling);
-        switch (num1)
-        {
-          case -1:
-            writer.Write(s);
-            break;
-          case 0:
-            for (int index = num1; index < s.Length; ++index)
-            {
-              char c = s[index];
-              if ((int) c >= charEscapeFlags.Length || charEscapeFlags[(int) c])
-              {
-                string a;
-                switch (c)
-                {
-                  case '\b':
-                    a = "\\b";
-                    break;
-                  case '\t':
-                    a = "\\t";
-                    break;
-                  case '\n':
-                    a = "\\n";
-                    break;
-                  case '\f':
-                    a = "\\f";
-                    break;
-                  case '\r':
-                    a = "\\r";
-                    break;
-                  case '\\':
-                    a = "\\\\";
-                    break;
-                  case '\u0085':
-                    a = "\\u0085";
-                    break;
-                  case '\u2028':
-                    a = "\\u2028";
-                    break;
-                  case '\u2029':
-                    a = "\\u2029";
-                    break;
-                  default:
-                    if ((int) c < charEscapeFlags.Length || stringEscapeHandling == StringEscapeHandling.EscapeNonAscii)
-                    {
-                      if (c == '\'' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
-                      {
-                        a = "\\'";
-                        break;
-                      }
-                      if (c == '"' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
-                      {
-                        a = "\\\"";
-                        break;
-                      }
-                      if (writeBuffer == null || writeBuffer.Length < 6)
-                        writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, 6, writeBuffer);
-                      StringUtils.ToCharAsUnicode(c, writeBuffer);
-                      a = "!";
-                      break;
-                    }
-                    a = (string) null;
-                    break;
-                }
-                if (a != null)
-                {
-                  bool flag = string.Equals(a, "!");
-                  if (index > num1)
-                  {
-                    int minSize = index - num1 + (flag ? 6 : 0);
-                    int num2 = flag ? 6 : 0;
-                    if (writeBuffer == null || writeBuffer.Length < minSize)
-                    {
-                      char[] destinationArray = BufferUtils.RentBuffer(bufferPool, minSize);
-                      if (flag)
-                        Array.Copy((Array) writeBuffer, (Array) destinationArray, 6);
-                      BufferUtils.ReturnBuffer(bufferPool, writeBuffer);
-                      writeBuffer = destinationArray;
-                    }
-                    s.CopyTo(num1, writeBuffer, num2, minSize - num2);
-                    writer.Write(writeBuffer, num2, minSize - num2);
-                  }
-                  num1 = index + 1;
-                  if (!flag)
-                    writer.Write(a);
-                  else
-                    writer.Write(writeBuffer, 0, 6);
-                }
-              }
-            }
-            int num3 = s.Length - num1;
-            if (num3 > 0)
-            {
-              if (writeBuffer == null || writeBuffer.Length < num3)
-                writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, num3, writeBuffer);
-              s.CopyTo(num1, writeBuffer, 0, num3);
-              writer.Write(writeBuffer, 0, num3);
-              break;
-            }
-            break;
-          default:
-            if (writeBuffer == null || writeBuffer.Length < num1)
-              writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, num1, writeBuffer);
-            s.CopyTo(0, writeBuffer, 0, num1);
-            writer.Write(writeBuffer, 0, num1);
-            goto case 0;
-        }
-      }
-      if (!appendDelimiters)
-        return;
-      writer.Write(delimiter);
-    }
-
-    public static string ToEscapedJavaScriptString(
-      string value,
-      char delimiter,
-      bool appendDelimiters,
-      StringEscapeHandling stringEscapeHandling)
-    {
-      bool[] charEscapeFlags = JavaScriptUtils.GetCharEscapeFlags(stringEscapeHandling, delimiter);
-      using (StringWriter stringWriter = StringUtils.CreateStringWriter(value != null ? value.Length : 16))
-      {
-        char[] writeBuffer = (char[]) null;
-        JavaScriptUtils.WriteEscapedJavaScriptString((TextWriter) stringWriter, value, delimiter, appendDelimiters, charEscapeFlags, stringEscapeHandling, (IArrayPool<char>) null, ref writeBuffer);
-        return stringWriter.ToString();
-      }
-    }
-
-    private static int FirstCharToEscape(
-      string s,
-      bool[] charEscapeFlags,
-      StringEscapeHandling stringEscapeHandling)
-    {
-      for (int index1 = 0; index1 != s.Length; ++index1)
-      {
-        char index2 = s[index1];
-        if ((int) index2 < charEscapeFlags.Length)
-        {
-          if (charEscapeFlags[(int) index2])
-            return index1;
-        }
-        else if (stringEscapeHandling == StringEscapeHandling.EscapeNonAscii || index2 == '\u0085' || index2 == '\u2028' || index2 == '\u2029')
-          return index1;
-      }
-      return -1;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/JsonTokenUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/JsonTokenUtils.cs
deleted file mode 100644
index 544d6f7..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/JsonTokenUtils.cs
+++ /dev/null
@@ -1,50 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class JsonTokenUtils
-  {
-    internal static bool IsEndToken(JsonToken token)
-    {
-      switch (token)
-      {
-        case JsonToken.EndObject:
-        case JsonToken.EndArray:
-        case JsonToken.EndConstructor:
-          return true;
-        default:
-          return false;
-      }
-    }
-
-    internal static bool IsStartToken(JsonToken token)
-    {
-      switch (token)
-      {
-        case JsonToken.StartObject:
-        case JsonToken.StartArray:
-        case JsonToken.StartConstructor:
-          return true;
-        default:
-          return false;
-      }
-    }
-
-    internal static bool IsPrimitiveToken(JsonToken token)
-    {
-      switch (token)
-      {
-        case JsonToken.Integer:
-        case JsonToken.Float:
-        case JsonToken.String:
-        case JsonToken.Boolean:
-        case JsonToken.Null:
-        case JsonToken.Undefined:
-        case JsonToken.Date:
-        case JsonToken.Bytes:
-          return true;
-        default:
-          return false;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/LateBoundReflectionDelegateFactory.cs b/MSHALTester/Newtonsoft/Json/Utilities/LateBoundReflectionDelegateFactory.cs
deleted file mode 100644
index ba21541..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/LateBoundReflectionDelegateFactory.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class LateBoundReflectionDelegateFactory : ReflectionDelegateFactory
-  {
-    private static readonly LateBoundReflectionDelegateFactory _instance = new LateBoundReflectionDelegateFactory();
-
-    internal static ReflectionDelegateFactory Instance
-    {
-      get => (ReflectionDelegateFactory) LateBoundReflectionDelegateFactory._instance;
-    }
-
-    public override ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method)
-    {
-      ValidationUtils.ArgumentNotNull((object) method, nameof (method));
-      ConstructorInfo c = method as ConstructorInfo;
-      return c != null ? (ObjectConstructor<object>) (a => c.Invoke(a)) : (ObjectConstructor<object>) (a => method.Invoke((object) null, a));
-    }
-
-    public override MethodCall<T, object> CreateMethodCall<T>(MethodBase method)
-    {
-      ValidationUtils.ArgumentNotNull((object) method, nameof (method));
-      ConstructorInfo c = method as ConstructorInfo;
-      return c != null ? (MethodCall<T, object>) ((o, a) => c.Invoke(a)) : (MethodCall<T, object>) ((o, a) => method.Invoke((object) o, a));
-    }
-
-    public override Func<T> CreateDefaultConstructor<T>(Type type)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      if (type.IsValueType())
-        return (Func<T>) (() => (T) Activator.CreateInstance(type));
-      ConstructorInfo constructorInfo = ReflectionUtils.GetDefaultConstructor(type, true);
-      return (Func<T>) (() => (T) constructorInfo.Invoke((object[]) null));
-    }
-
-    public override Func<T, object> CreateGet<T>(PropertyInfo propertyInfo)
-    {
-      ValidationUtils.ArgumentNotNull((object) propertyInfo, nameof (propertyInfo));
-      return (Func<T, object>) (o => propertyInfo.GetValue((object) o, (object[]) null));
-    }
-
-    public override Func<T, object> CreateGet<T>(FieldInfo fieldInfo)
-    {
-      ValidationUtils.ArgumentNotNull((object) fieldInfo, nameof (fieldInfo));
-      return (Func<T, object>) (o => fieldInfo.GetValue((object) o));
-    }
-
-    public override Action<T, object> CreateSet<T>(FieldInfo fieldInfo)
-    {
-      ValidationUtils.ArgumentNotNull((object) fieldInfo, nameof (fieldInfo));
-      return (Action<T, object>) ((o, v) => fieldInfo.SetValue((object) o, v));
-    }
-
-    public override Action<T, object> CreateSet<T>(PropertyInfo propertyInfo)
-    {
-      ValidationUtils.ArgumentNotNull((object) propertyInfo, nameof (propertyInfo));
-      return (Action<T, object>) ((o, v) => propertyInfo.SetValue((object) o, v, (object[]) null));
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/MathUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/MathUtils.cs
deleted file mode 100644
index 5e15e6d..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/MathUtils.cs
+++ /dev/null
@@ -1,81 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class MathUtils
-  {
-    public static int IntLength(ulong i)
-    {
-      if (i < 10000000000UL)
-      {
-        if (i < 10UL)
-          return 1;
-        if (i < 100UL)
-          return 2;
-        if (i < 1000UL)
-          return 3;
-        if (i < 10000UL)
-          return 4;
-        if (i < 100000UL)
-          return 5;
-        if (i < 1000000UL)
-          return 6;
-        if (i < 10000000UL)
-          return 7;
-        if (i < 100000000UL)
-          return 8;
-        return i < 1000000000UL ? 9 : 10;
-      }
-      if (i < 100000000000UL)
-        return 11;
-      if (i < 1000000000000UL)
-        return 12;
-      if (i < 10000000000000UL)
-        return 13;
-      if (i < 100000000000000UL)
-        return 14;
-      if (i < 1000000000000000UL)
-        return 15;
-      if (i < 10000000000000000UL)
-        return 16;
-      if (i < 100000000000000000UL)
-        return 17;
-      if (i < 1000000000000000000UL)
-        return 18;
-      return i < 10000000000000000000UL ? 19 : 20;
-    }
-
-    public static char IntToHex(int n) => n <= 9 ? (char) (n + 48) : (char) (n - 10 + 97);
-
-    public static int? Min(int? val1, int? val2)
-    {
-      if (!val1.HasValue)
-        return val2;
-      return !val2.HasValue ? val1 : new int?(Math.Min(val1.GetValueOrDefault(), val2.GetValueOrDefault()));
-    }
-
-    public static int? Max(int? val1, int? val2)
-    {
-      if (!val1.HasValue)
-        return val2;
-      return !val2.HasValue ? val1 : new int?(Math.Max(val1.GetValueOrDefault(), val2.GetValueOrDefault()));
-    }
-
-    public static double? Max(double? val1, double? val2)
-    {
-      if (!val1.HasValue)
-        return val2;
-      return !val2.HasValue ? val1 : new double?(Math.Max(val1.GetValueOrDefault(), val2.GetValueOrDefault()));
-    }
-
-    public static bool ApproxEquals(double d1, double d2)
-    {
-      if (d1 == d2)
-        return true;
-      double num1 = (Math.Abs(d1) + Math.Abs(d2) + 10.0) * 2.2204460492503131E-16;
-      double num2 = d1 - d2;
-      return -num1 < num2 && num1 > num2;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/MethodCall`2.cs b/MSHALTester/Newtonsoft/Json/Utilities/MethodCall`2.cs
deleted file mode 100644
index f5a90c0..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/MethodCall`2.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal delegate TResult MethodCall<T, TResult>(T target, params object[] args);
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/MiscellaneousUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/MiscellaneousUtils.cs
deleted file mode 100644
index a3137aa..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/MiscellaneousUtils.cs
+++ /dev/null
@@ -1,136 +0,0 @@
-using System;
-using System.Globalization;
-using System.Text.RegularExpressions;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class MiscellaneousUtils
-  {
-    public static bool ValueEquals(object objA, object objB)
-    {
-      if (objA == objB)
-        return true;
-      if (objA == null || objB == null)
-        return false;
-      if (objA.GetType() == objB.GetType())
-        return objA.Equals(objB);
-      if (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB))
-        return Convert.ToDecimal(objA, (IFormatProvider) CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, (IFormatProvider) CultureInfo.CurrentCulture));
-      switch (objA)
-      {
-        case double _:
-        case float _:
-        case Decimal _:
-          switch (objB)
-          {
-            case double _:
-            case float _:
-            case Decimal _:
-              return MathUtils.ApproxEquals(Convert.ToDouble(objA, (IFormatProvider) CultureInfo.CurrentCulture), Convert.ToDouble(objB, (IFormatProvider) CultureInfo.CurrentCulture));
-          }
-          break;
-      }
-      return false;
-    }
-
-    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(
-      string paramName,
-      object actualValue,
-      string message)
-    {
-      string message1 = message + Environment.NewLine + "Actual value was {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, actualValue);
-      return new ArgumentOutOfRangeException(paramName, message1);
-    }
-
-    public static string ToString(object value)
-    {
-      if (value == null)
-        return "{null}";
-      return !(value is string) ? value.ToString() : "\"" + value.ToString() + "\"";
-    }
-
-    public static int ByteArrayCompare(byte[] a1, byte[] a2)
-    {
-      int num1 = a1.Length.CompareTo(a2.Length);
-      if (num1 != 0)
-        return num1;
-      for (int index = 0; index < a1.Length; ++index)
-      {
-        int num2 = a1[index].CompareTo(a2[index]);
-        if (num2 != 0)
-          return num2;
-      }
-      return 0;
-    }
-
-    public static string GetPrefix(string qualifiedName)
-    {
-      string prefix;
-      MiscellaneousUtils.GetQualifiedNameParts(qualifiedName, out prefix, out string _);
-      return prefix;
-    }
-
-    public static string GetLocalName(string qualifiedName)
-    {
-      string localName;
-      MiscellaneousUtils.GetQualifiedNameParts(qualifiedName, out string _, out localName);
-      return localName;
-    }
-
-    public static void GetQualifiedNameParts(
-      string qualifiedName,
-      out string prefix,
-      out string localName)
-    {
-      int length = qualifiedName.IndexOf(':');
-      switch (length)
-      {
-        case -1:
-        case 0:
-          prefix = (string) null;
-          localName = qualifiedName;
-          break;
-        default:
-          if (qualifiedName.Length - 1 != length)
-          {
-            prefix = qualifiedName.Substring(0, length);
-            localName = qualifiedName.Substring(length + 1);
-            break;
-          }
-          goto case -1;
-      }
-    }
-
-    internal static string FormatValueForPrint(object value)
-    {
-      if (value == null)
-        return "{null}";
-      return value is string ? "\"" + value + "\"" : value.ToString();
-    }
-
-    internal static RegexOptions GetRegexOptions(string optionsText)
-    {
-      RegexOptions regexOptions = RegexOptions.None;
-      foreach (char ch in optionsText)
-      {
-        switch (ch)
-        {
-          case 'i':
-            regexOptions |= RegexOptions.IgnoreCase;
-            break;
-          case 'm':
-            regexOptions |= RegexOptions.Multiline;
-            break;
-          case 's':
-            regexOptions |= RegexOptions.Singleline;
-            break;
-          case 'x':
-            regexOptions |= RegexOptions.ExplicitCapture;
-            break;
-        }
-      }
-      return regexOptions;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ParseResult.cs b/MSHALTester/Newtonsoft/Json/Utilities/ParseResult.cs
deleted file mode 100644
index 72b9480..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ParseResult.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal enum ParseResult
-  {
-    None,
-    Success,
-    Overflow,
-    Invalid,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ParserTimeZone.cs b/MSHALTester/Newtonsoft/Json/Utilities/ParserTimeZone.cs
deleted file mode 100644
index 1fcfc01..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ParserTimeZone.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal enum ParserTimeZone
-  {
-    Unspecified,
-    Utc,
-    LocalWestOfUtc,
-    LocalEastOfUtc,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/PrimitiveTypeCode.cs b/MSHALTester/Newtonsoft/Json/Utilities/PrimitiveTypeCode.cs
deleted file mode 100644
index 5b527bf..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/PrimitiveTypeCode.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal enum PrimitiveTypeCode
-  {
-    Empty,
-    Object,
-    Char,
-    CharNullable,
-    Boolean,
-    BooleanNullable,
-    SByte,
-    SByteNullable,
-    Int16,
-    Int16Nullable,
-    UInt16,
-    UInt16Nullable,
-    Int32,
-    Int32Nullable,
-    Byte,
-    ByteNullable,
-    UInt32,
-    UInt32Nullable,
-    Int64,
-    Int64Nullable,
-    UInt64,
-    UInt64Nullable,
-    Single,
-    SingleNullable,
-    Double,
-    DoubleNullable,
-    DateTime,
-    DateTimeNullable,
-    DateTimeOffset,
-    DateTimeOffsetNullable,
-    Decimal,
-    DecimalNullable,
-    Guid,
-    GuidNullable,
-    TimeSpan,
-    TimeSpanNullable,
-    BigInteger,
-    BigIntegerNullable,
-    Uri,
-    String,
-    Bytes,
-    DBNull,
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/PropertyNameTable.cs b/MSHALTester/Newtonsoft/Json/Utilities/PropertyNameTable.cs
deleted file mode 100644
index 49460dd..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/PropertyNameTable.cs
+++ /dev/null
@@ -1,110 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class PropertyNameTable
-  {
-    private static readonly int HashCodeRandomizer = Environment.TickCount;
-    private int _count;
-    private PropertyNameTable.Entry[] _entries;
-    private int _mask = 31;
-
-    public PropertyNameTable() => this._entries = new PropertyNameTable.Entry[this._mask + 1];
-
-    public string Get(char[] key, int start, int length)
-    {
-      if (length == 0)
-        return string.Empty;
-      int num1 = length + PropertyNameTable.HashCodeRandomizer;
-      int num2 = num1 + (num1 << 7 ^ (int) key[start]);
-      int num3 = start + length;
-      for (int index = start + 1; index < num3; ++index)
-        num2 += num2 << 7 ^ (int) key[index];
-      int num4 = num2 - (num2 >> 17);
-      int num5 = num4 - (num4 >> 11);
-      int num6 = num5 - (num5 >> 5);
-      for (PropertyNameTable.Entry entry = this._entries[num6 & this._mask]; entry != null; entry = entry.Next)
-      {
-        if (entry.HashCode == num6 && PropertyNameTable.TextEquals(entry.Value, key, start, length))
-          return entry.Value;
-      }
-      return (string) null;
-    }
-
-    public string Add(string key)
-    {
-      int num1 = key != null ? key.Length : throw new ArgumentNullException(nameof (key));
-      if (num1 == 0)
-        return string.Empty;
-      int num2 = num1 + PropertyNameTable.HashCodeRandomizer;
-      for (int index = 0; index < key.Length; ++index)
-        num2 += num2 << 7 ^ (int) key[index];
-      int num3 = num2 - (num2 >> 17);
-      int num4 = num3 - (num3 >> 11);
-      int hashCode = num4 - (num4 >> 5);
-      for (PropertyNameTable.Entry entry = this._entries[hashCode & this._mask]; entry != null; entry = entry.Next)
-      {
-        if (entry.HashCode == hashCode && entry.Value.Equals(key))
-          return entry.Value;
-      }
-      return this.AddEntry(key, hashCode);
-    }
-
-    private string AddEntry(string str, int hashCode)
-    {
-      int index = hashCode & this._mask;
-      PropertyNameTable.Entry entry = new PropertyNameTable.Entry(str, hashCode, this._entries[index]);
-      this._entries[index] = entry;
-      if (this._count++ == this._mask)
-        this.Grow();
-      return entry.Value;
-    }
-
-    private void Grow()
-    {
-      PropertyNameTable.Entry[] entries = this._entries;
-      int num = this._mask * 2 + 1;
-      PropertyNameTable.Entry[] entryArray = new PropertyNameTable.Entry[num + 1];
-      PropertyNameTable.Entry next;
-      for (int index1 = 0; index1 < entries.Length; ++index1)
-      {
-        for (PropertyNameTable.Entry entry = entries[index1]; entry != null; entry = next)
-        {
-          int index2 = entry.HashCode & num;
-          next = entry.Next;
-          entry.Next = entryArray[index2];
-          entryArray[index2] = entry;
-        }
-      }
-      this._entries = entryArray;
-      this._mask = num;
-    }
-
-    private static bool TextEquals(string str1, char[] str2, int str2Start, int str2Length)
-    {
-      if (str1.Length != str2Length)
-        return false;
-      for (int index = 0; index < str1.Length; ++index)
-      {
-        if ((int) str1[index] != (int) str2[str2Start + index])
-          return false;
-      }
-      return true;
-    }
-
-    private class Entry
-    {
-      internal readonly string Value;
-      internal readonly int HashCode;
-      internal PropertyNameTable.Entry Next;
-
-      internal Entry(string value, int hashCode, PropertyNameTable.Entry next)
-      {
-        this.Value = value;
-        this.HashCode = hashCode;
-        this.Next = next;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ReflectionDelegateFactory.cs b/MSHALTester/Newtonsoft/Json/Utilities/ReflectionDelegateFactory.cs
deleted file mode 100644
index b5f8b77..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ReflectionDelegateFactory.cs
+++ /dev/null
@@ -1,53 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Globalization;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal abstract class ReflectionDelegateFactory
-  {
-    public Func<T, object> CreateGet<T>(MemberInfo memberInfo)
-    {
-      switch (memberInfo)
-      {
-        case PropertyInfo propertyInfo:
-          if (propertyInfo.PropertyType.IsByRef)
-            throw new InvalidOperationException("Could not create getter for {0}. ByRef return values are not supported.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) propertyInfo));
-          return this.CreateGet<T>(propertyInfo);
-        case FieldInfo fieldInfo:
-          return this.CreateGet<T>(fieldInfo);
-        default:
-          throw new Exception("Could not create getter for {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) memberInfo));
-      }
-    }
-
-    public Action<T, object> CreateSet<T>(MemberInfo memberInfo)
-    {
-      switch (memberInfo)
-      {
-        case PropertyInfo propertyInfo:
-          return this.CreateSet<T>(propertyInfo);
-        case FieldInfo fieldInfo:
-          return this.CreateSet<T>(fieldInfo);
-        default:
-          throw new Exception("Could not create setter for {0}.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) memberInfo));
-      }
-    }
-
-    public abstract MethodCall<T, object> CreateMethodCall<T>(MethodBase method);
-
-    public abstract ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method);
-
-    public abstract Func<T> CreateDefaultConstructor<T>(Type type);
-
-    public abstract Func<T, object> CreateGet<T>(PropertyInfo propertyInfo);
-
-    public abstract Func<T, object> CreateGet<T>(FieldInfo fieldInfo);
-
-    public abstract Action<T, object> CreateSet<T>(FieldInfo fieldInfo);
-
-    public abstract Action<T, object> CreateSet<T>(PropertyInfo propertyInfo);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ReflectionMember.cs b/MSHALTester/Newtonsoft/Json/Utilities/ReflectionMember.cs
deleted file mode 100644
index de7c974..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ReflectionMember.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class ReflectionMember
-  {
-    public Type MemberType { get; set; }
-
-    public Func<object, object> Getter { get; set; }
-
-    public Action<object, object> Setter { get; set; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ReflectionObject.cs b/MSHALTester/Newtonsoft/Json/Utilities/ReflectionObject.cs
deleted file mode 100644
index d62d4f7..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ReflectionObject.cs
+++ /dev/null
@@ -1,100 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Linq;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class ReflectionObject
-  {
-    public ObjectConstructor<object> Creator { get; }
-
-    public IDictionary<string, ReflectionMember> Members { get; }
-
-    private ReflectionObject(ObjectConstructor<object> creator)
-    {
-      this.Members = (IDictionary<string, ReflectionMember>) new Dictionary<string, ReflectionMember>();
-      this.Creator = creator;
-    }
-
-    public object GetValue(object target, string member) => this.Members[member].Getter(target);
-
-    public void SetValue(object target, string member, object value)
-    {
-      this.Members[member].Setter(target, value);
-    }
-
-    public Type GetType(string member) => this.Members[member].MemberType;
-
-    public static ReflectionObject Create(Type t, params string[] memberNames)
-    {
-      return ReflectionObject.Create(t, (MethodBase) null, memberNames);
-    }
-
-    public static ReflectionObject Create(Type t, MethodBase creator, params string[] memberNames)
-    {
-      ReflectionDelegateFactory reflectionDelegateFactory = JsonTypeReflector.ReflectionDelegateFactory;
-      ObjectConstructor<object> creator1 = (ObjectConstructor<object>) null;
-      if (creator != null)
-        creator1 = reflectionDelegateFactory.CreateParameterizedConstructor(creator);
-      else if (ReflectionUtils.HasDefaultConstructor(t, false))
-      {
-        Func<object> ctor = reflectionDelegateFactory.CreateDefaultConstructor<object>(t);
-        creator1 = (ObjectConstructor<object>) (args => ctor());
-      }
-      ReflectionObject reflectionObject = new ReflectionObject(creator1);
-      foreach (string memberName in memberNames)
-      {
-        MemberInfo[] member = t.GetMember(memberName, BindingFlags.Instance | BindingFlags.Public);
-        MemberInfo memberInfo = member.Length == 1 ? ((IEnumerable<MemberInfo>) member).Single<MemberInfo>() : throw new ArgumentException("Expected a single member with the name '{0}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) memberName));
-        ReflectionMember reflectionMember = new ReflectionMember();
-        switch (memberInfo.MemberType())
-        {
-          case MemberTypes.Field:
-          case MemberTypes.Property:
-            if (ReflectionUtils.CanReadMemberValue(memberInfo, false))
-              reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
-            if (ReflectionUtils.CanSetMemberValue(memberInfo, false, false))
-            {
-              reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
-              break;
-            }
-            break;
-          case MemberTypes.Method:
-            MethodInfo method = (MethodInfo) memberInfo;
-            if (method.IsPublic)
-            {
-              ParameterInfo[] parameters = method.GetParameters();
-              if (parameters.Length == 0 && method.ReturnType != typeof (void))
-              {
-                MethodCall<object, object> call = reflectionDelegateFactory.CreateMethodCall<object>((MethodBase) method);
-                reflectionMember.Getter = (Func<object, object>) (target => call(target));
-                break;
-              }
-              if (parameters.Length == 1 && method.ReturnType == typeof (void))
-              {
-                MethodCall<object, object> call = reflectionDelegateFactory.CreateMethodCall<object>((MethodBase) method);
-                object obj;
-                reflectionMember.Setter = (Action<object, object>) ((target, arg) => obj = call(target, arg));
-                break;
-              }
-              break;
-            }
-            break;
-          default:
-            throw new ArgumentException("Unexpected member type '{0}' for member '{1}'.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) memberInfo.MemberType(), (object) memberInfo.Name));
-        }
-        if (ReflectionUtils.CanReadMemberValue(memberInfo, false))
-          reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
-        if (ReflectionUtils.CanSetMemberValue(memberInfo, false, false))
-          reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
-        reflectionMember.MemberType = ReflectionUtils.GetMemberUnderlyingType(memberInfo);
-        reflectionObject.Members[memberName] = reflectionMember;
-      }
-      return reflectionObject;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ReflectionUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/ReflectionUtils.cs
deleted file mode 100644
index fcf6b8f..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ReflectionUtils.cs
+++ /dev/null
@@ -1,624 +0,0 @@
-using Newtonsoft.Json.Serialization;
-using System;
-using System.Collections;
-using System.Collections.Generic;
-using System.Globalization;
-using System.Linq;
-using System.Reflection;
-using System.Text;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class ReflectionUtils
-  {
-    public static readonly Type[] EmptyTypes = Type.EmptyTypes;
-
-    public static bool IsVirtual(this PropertyInfo propertyInfo)
-    {
-      ValidationUtils.ArgumentNotNull((object) propertyInfo, nameof (propertyInfo));
-      MethodInfo getMethod = propertyInfo.GetGetMethod(true);
-      if (getMethod != null && getMethod.IsVirtual)
-        return true;
-      MethodInfo setMethod = propertyInfo.GetSetMethod(true);
-      return setMethod != null && setMethod.IsVirtual;
-    }
-
-    public static MethodInfo GetBaseDefinition(this PropertyInfo propertyInfo)
-    {
-      ValidationUtils.ArgumentNotNull((object) propertyInfo, nameof (propertyInfo));
-      MethodInfo getMethod = propertyInfo.GetGetMethod(true);
-      if (getMethod != null)
-        return getMethod.GetBaseDefinition();
-      return propertyInfo.GetSetMethod(true)?.GetBaseDefinition();
-    }
-
-    public static bool IsPublic(PropertyInfo property)
-    {
-      return property.GetGetMethod() != null && property.GetGetMethod().IsPublic || property.GetSetMethod() != null && property.GetSetMethod().IsPublic;
-    }
-
-    public static Type GetObjectType(object v) => v?.GetType();
-
-    public static string GetTypeName(
-      Type t,
-      TypeNameAssemblyFormatHandling assemblyFormat,
-      ISerializationBinder binder)
-    {
-      string qualifiedTypeName = ReflectionUtils.GetFullyQualifiedTypeName(t, binder);
-      if (assemblyFormat == TypeNameAssemblyFormatHandling.Simple)
-        return ReflectionUtils.RemoveAssemblyDetails(qualifiedTypeName);
-      if (assemblyFormat == TypeNameAssemblyFormatHandling.Full)
-        return qualifiedTypeName;
-      throw new ArgumentOutOfRangeException();
-    }
-
-    private static string GetFullyQualifiedTypeName(Type t, ISerializationBinder binder)
-    {
-      if (binder == null)
-        return t.AssemblyQualifiedName;
-      string assemblyName;
-      string typeName;
-      binder.BindToName(t, out assemblyName, out typeName);
-      return assemblyName == null & typeName == null ? t.AssemblyQualifiedName : typeName + (assemblyName == null ? "" : ", " + assemblyName);
-    }
-
-    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName)
-    {
-      StringBuilder stringBuilder = new StringBuilder();
-      bool flag1 = false;
-      bool flag2 = false;
-      for (int index = 0; index < fullyQualifiedTypeName.Length; ++index)
-      {
-        char ch = fullyQualifiedTypeName[index];
-        switch (ch)
-        {
-          case ',':
-            if (!flag1)
-            {
-              flag1 = true;
-              stringBuilder.Append(ch);
-              break;
-            }
-            flag2 = true;
-            break;
-          case '[':
-            flag1 = false;
-            flag2 = false;
-            stringBuilder.Append(ch);
-            break;
-          case ']':
-            flag1 = false;
-            flag2 = false;
-            stringBuilder.Append(ch);
-            break;
-          default:
-            if (!flag2)
-            {
-              stringBuilder.Append(ch);
-              break;
-            }
-            break;
-        }
-      }
-      return stringBuilder.ToString();
-    }
-
-    public static bool HasDefaultConstructor(Type t, bool nonPublic)
-    {
-      ValidationUtils.ArgumentNotNull((object) t, nameof (t));
-      return t.IsValueType() || ReflectionUtils.GetDefaultConstructor(t, nonPublic) != null;
-    }
-
-    public static ConstructorInfo GetDefaultConstructor(Type t)
-    {
-      return ReflectionUtils.GetDefaultConstructor(t, false);
-    }
-
-    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
-    {
-      BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
-      if (nonPublic)
-        bindingAttr |= BindingFlags.NonPublic;
-      return ((IEnumerable<ConstructorInfo>) t.GetConstructors(bindingAttr)).SingleOrDefault<ConstructorInfo>((Func<ConstructorInfo, bool>) (c => !((IEnumerable<ParameterInfo>) c.GetParameters()).Any<ParameterInfo>()));
-    }
-
-    public static bool IsNullable(Type t)
-    {
-      ValidationUtils.ArgumentNotNull((object) t, nameof (t));
-      return !t.IsValueType() || ReflectionUtils.IsNullableType(t);
-    }
-
-    public static bool IsNullableType(Type t)
-    {
-      ValidationUtils.ArgumentNotNull((object) t, nameof (t));
-      return t.IsGenericType() && t.GetGenericTypeDefinition() == typeof (Nullable<>);
-    }
-
-    public static Type EnsureNotNullableType(Type t)
-    {
-      return !ReflectionUtils.IsNullableType(t) ? t : Nullable.GetUnderlyingType(t);
-    }
-
-    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition)
-    {
-      return type.IsGenericType() && type.GetGenericTypeDefinition() == genericInterfaceDefinition;
-    }
-
-    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
-    {
-      return ReflectionUtils.ImplementsGenericDefinition(type, genericInterfaceDefinition, out Type _);
-    }
-
-    public static bool ImplementsGenericDefinition(
-      Type type,
-      Type genericInterfaceDefinition,
-      out Type implementingType)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      ValidationUtils.ArgumentNotNull((object) genericInterfaceDefinition, nameof (genericInterfaceDefinition));
-      if (!genericInterfaceDefinition.IsInterface() || !genericInterfaceDefinition.IsGenericTypeDefinition())
-        throw new ArgumentNullException("'{0}' is not a generic interface definition.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) genericInterfaceDefinition));
-      if (type.IsInterface() && type.IsGenericType())
-      {
-        Type genericTypeDefinition = type.GetGenericTypeDefinition();
-        if (genericInterfaceDefinition == genericTypeDefinition)
-        {
-          implementingType = type;
-          return true;
-        }
-      }
-      foreach (Type type1 in type.GetInterfaces())
-      {
-        if (type1.IsGenericType())
-        {
-          Type genericTypeDefinition = type1.GetGenericTypeDefinition();
-          if (genericInterfaceDefinition == genericTypeDefinition)
-          {
-            implementingType = type1;
-            return true;
-          }
-        }
-      }
-      implementingType = (Type) null;
-      return false;
-    }
-
-    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
-    {
-      return ReflectionUtils.InheritsGenericDefinition(type, genericClassDefinition, out Type _);
-    }
-
-    public static bool InheritsGenericDefinition(
-      Type type,
-      Type genericClassDefinition,
-      out Type implementingType)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      ValidationUtils.ArgumentNotNull((object) genericClassDefinition, nameof (genericClassDefinition));
-      return genericClassDefinition.IsClass() && genericClassDefinition.IsGenericTypeDefinition() ? ReflectionUtils.InheritsGenericDefinitionInternal(type, genericClassDefinition, out implementingType) : throw new ArgumentNullException("'{0}' is not a generic class definition.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) genericClassDefinition));
-    }
-
-    private static bool InheritsGenericDefinitionInternal(
-      Type currentType,
-      Type genericClassDefinition,
-      out Type implementingType)
-    {
-      while (!currentType.IsGenericType() || genericClassDefinition != currentType.GetGenericTypeDefinition())
-      {
-        currentType = currentType.BaseType();
-        if (currentType == null)
-        {
-          implementingType = (Type) null;
-          return false;
-        }
-      }
-      implementingType = currentType;
-      return true;
-    }
-
-    public static Type GetCollectionItemType(Type type)
-    {
-      ValidationUtils.ArgumentNotNull((object) type, nameof (type));
-      if (type.IsArray)
-        return type.GetElementType();
-      Type implementingType;
-      if (ReflectionUtils.ImplementsGenericDefinition(type, typeof (IEnumerable<>), out implementingType))
-        return !implementingType.IsGenericTypeDefinition() ? implementingType.GetGenericArguments()[0] : throw new Exception("Type {0} is not a collection.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type));
-      if (typeof (IEnumerable).IsAssignableFrom(type))
-        return (Type) null;
-      throw new Exception("Type {0} is not a collection.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) type));
-    }
-
-    public static void GetDictionaryKeyValueTypes(
-      Type dictionaryType,
-      out Type keyType,
-      out Type valueType)
-    {
-      ValidationUtils.ArgumentNotNull((object) dictionaryType, nameof (dictionaryType));
-      Type implementingType;
-      if (ReflectionUtils.ImplementsGenericDefinition(dictionaryType, typeof (IDictionary<,>), out implementingType))
-      {
-        Type[] typeArray = !implementingType.IsGenericTypeDefinition() ? implementingType.GetGenericArguments() : throw new Exception("Type {0} is not a dictionary.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) dictionaryType));
-        keyType = typeArray[0];
-        valueType = typeArray[1];
-      }
-      else
-      {
-        if (!typeof (IDictionary).IsAssignableFrom(dictionaryType))
-          throw new Exception("Type {0} is not a dictionary.".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) dictionaryType));
-        keyType = (Type) null;
-        valueType = (Type) null;
-      }
-    }
-
-    public static Type GetMemberUnderlyingType(MemberInfo member)
-    {
-      ValidationUtils.ArgumentNotNull((object) member, nameof (member));
-      switch (member.MemberType())
-      {
-        case MemberTypes.Event:
-          return ((EventInfo) member).EventHandlerType;
-        case MemberTypes.Field:
-          return ((FieldInfo) member).FieldType;
-        case MemberTypes.Method:
-          return ((MethodInfo) member).ReturnType;
-        case MemberTypes.Property:
-          return ((PropertyInfo) member).PropertyType;
-        default:
-          throw new ArgumentException("MemberInfo must be of type FieldInfo, PropertyInfo, EventInfo or MethodInfo", nameof (member));
-      }
-    }
-
-    public static bool IsIndexedProperty(MemberInfo member)
-    {
-      ValidationUtils.ArgumentNotNull((object) member, nameof (member));
-      return member is PropertyInfo property && ReflectionUtils.IsIndexedProperty(property);
-    }
-
-    public static bool IsIndexedProperty(PropertyInfo property)
-    {
-      ValidationUtils.ArgumentNotNull((object) property, nameof (property));
-      return property.GetIndexParameters().Length != 0;
-    }
-
-    public static object GetMemberValue(MemberInfo member, object target)
-    {
-      ValidationUtils.ArgumentNotNull((object) member, nameof (member));
-      ValidationUtils.ArgumentNotNull(target, nameof (target));
-      switch (member.MemberType())
-      {
-        case MemberTypes.Field:
-          return ((FieldInfo) member).GetValue(target);
-        case MemberTypes.Property:
-          try
-          {
-            return ((PropertyInfo) member).GetValue(target, (object[]) null);
-          }
-          catch (TargetParameterCountException ex)
-          {
-            throw new ArgumentException("MemberInfo '{0}' has index parameters".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) member.Name), (Exception) ex);
-          }
-        default:
-          throw new ArgumentException("MemberInfo '{0}' is not of type FieldInfo or PropertyInfo".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) member.Name), nameof (member));
-      }
-    }
-
-    public static void SetMemberValue(MemberInfo member, object target, object value)
-    {
-      ValidationUtils.ArgumentNotNull((object) member, nameof (member));
-      ValidationUtils.ArgumentNotNull(target, nameof (target));
-      switch (member.MemberType())
-      {
-        case MemberTypes.Field:
-          ((FieldInfo) member).SetValue(target, value);
-          break;
-        case MemberTypes.Property:
-          ((PropertyInfo) member).SetValue(target, value, (object[]) null);
-          break;
-        default:
-          throw new ArgumentException("MemberInfo '{0}' must be of type FieldInfo or PropertyInfo".FormatWith((IFormatProvider) CultureInfo.InvariantCulture, (object) member.Name), nameof (member));
-      }
-    }
-
-    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic)
-    {
-      switch (member.MemberType())
-      {
-        case MemberTypes.Field:
-          FieldInfo fieldInfo = (FieldInfo) member;
-          return nonPublic || fieldInfo.IsPublic;
-        case MemberTypes.Property:
-          PropertyInfo propertyInfo = (PropertyInfo) member;
-          if (!propertyInfo.CanRead)
-            return false;
-          return nonPublic || propertyInfo.GetGetMethod(nonPublic) != null;
-        default:
-          return false;
-      }
-    }
-
-    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
-    {
-      switch (member.MemberType())
-      {
-        case MemberTypes.Field:
-          FieldInfo fieldInfo = (FieldInfo) member;
-          return !fieldInfo.IsLiteral && (!fieldInfo.IsInitOnly || canSetReadOnly) && (nonPublic || fieldInfo.IsPublic);
-        case MemberTypes.Property:
-          PropertyInfo propertyInfo = (PropertyInfo) member;
-          if (!propertyInfo.CanWrite)
-            return false;
-          return nonPublic || propertyInfo.GetSetMethod(nonPublic) != null;
-        default:
-          return false;
-      }
-    }
-
-    public static List<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
-    {
-      List<MemberInfo> memberInfoList1 = new List<MemberInfo>();
-      memberInfoList1.AddRange<MemberInfo>((IEnumerable) ReflectionUtils.GetFields(type, bindingAttr));
-      memberInfoList1.AddRange<MemberInfo>((IEnumerable) ReflectionUtils.GetProperties(type, bindingAttr));
-      List<MemberInfo> fieldsAndProperties = new List<MemberInfo>(memberInfoList1.Count);
-      foreach (IGrouping<string, MemberInfo> source in memberInfoList1.GroupBy<MemberInfo, string>((Func<MemberInfo, string>) (m => m.Name)))
-      {
-        if (source.Count<MemberInfo>() == 1)
-        {
-          fieldsAndProperties.Add(source.First<MemberInfo>());
-        }
-        else
-        {
-          List<MemberInfo> memberInfoList2 = new List<MemberInfo>();
-          foreach (MemberInfo memberInfo1 in (IEnumerable<MemberInfo>) source)
-          {
-            MemberInfo memberInfo = memberInfo1;
-            if (memberInfoList2.Count == 0)
-              memberInfoList2.Add(memberInfo);
-            else if ((!ReflectionUtils.IsOverridenGenericMember(memberInfo, bindingAttr) || memberInfo.Name == "Item") && !memberInfoList2.Any<MemberInfo>((Func<MemberInfo, bool>) (m => m.DeclaringType == memberInfo.DeclaringType)))
-              memberInfoList2.Add(memberInfo);
-          }
-          fieldsAndProperties.AddRange((IEnumerable<MemberInfo>) memberInfoList2);
-        }
-      }
-      return fieldsAndProperties;
-    }
-
-    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
-    {
-      if (memberInfo.MemberType() != MemberTypes.Property)
-        return false;
-      PropertyInfo propertyInfo = (PropertyInfo) memberInfo;
-      if (!propertyInfo.IsVirtual())
-        return false;
-      Type declaringType = propertyInfo.DeclaringType;
-      if (!declaringType.IsGenericType())
-        return false;
-      Type genericTypeDefinition = declaringType.GetGenericTypeDefinition();
-      if (genericTypeDefinition == null)
-        return false;
-      MemberInfo[] member = genericTypeDefinition.GetMember(propertyInfo.Name, bindingAttr);
-      return member.Length != 0 && ReflectionUtils.GetMemberUnderlyingType(member[0]).IsGenericParameter;
-    }
-
-    public static T GetAttribute<T>(object attributeProvider) where T : Attribute
-    {
-      return ReflectionUtils.GetAttribute<T>(attributeProvider, true);
-    }
-
-    public static T GetAttribute<T>(object attributeProvider, bool inherit) where T : Attribute
-    {
-      T[] attributes = ReflectionUtils.GetAttributes<T>(attributeProvider, inherit);
-      return attributes == null ? default (T) : ((IEnumerable<T>) attributes).FirstOrDefault<T>();
-    }
-
-    public static T[] GetAttributes<T>(object attributeProvider, bool inherit) where T : Attribute
-    {
-      Attribute[] attributes = ReflectionUtils.GetAttributes(attributeProvider, typeof (T), inherit);
-      return attributes is T[] objArray ? objArray : attributes.Cast<T>().ToArray<T>();
-    }
-
-    public static Attribute[] GetAttributes(
-      object attributeProvider,
-      Type attributeType,
-      bool inherit)
-    {
-      ValidationUtils.ArgumentNotNull(attributeProvider, nameof (attributeProvider));
-      switch (attributeProvider)
-      {
-        case Type type:
-          Attribute[] array = (attributeType != null ? (IEnumerable) type.GetCustomAttributes(attributeType, inherit) : (IEnumerable) type.GetCustomAttributes(inherit)).Cast<Attribute>().ToArray<Attribute>();
-          if (inherit && type.BaseType != null)
-            array = ((IEnumerable<Attribute>) array).Union<Attribute>((IEnumerable<Attribute>) ReflectionUtils.GetAttributes((object) type.BaseType, attributeType, inherit)).ToArray<Attribute>();
-          return array;
-        case Assembly element1:
-          return attributeType == null ? Attribute.GetCustomAttributes(element1) : Attribute.GetCustomAttributes(element1, attributeType);
-        case MemberInfo element2:
-          return attributeType == null ? Attribute.GetCustomAttributes(element2, inherit) : Attribute.GetCustomAttributes(element2, attributeType, inherit);
-        case Module element3:
-          return attributeType == null ? Attribute.GetCustomAttributes(element3, inherit) : Attribute.GetCustomAttributes(element3, attributeType, inherit);
-        case ParameterInfo element4:
-          return attributeType == null ? Attribute.GetCustomAttributes(element4, inherit) : Attribute.GetCustomAttributes(element4, attributeType, inherit);
-        default:
-          ICustomAttributeProvider attributeProvider1 = (ICustomAttributeProvider) attributeProvider;
-          return attributeType != null ? (Attribute[]) attributeProvider1.GetCustomAttributes(attributeType, inherit) : (Attribute[]) attributeProvider1.GetCustomAttributes(inherit);
-      }
-    }
-
-    public static TypeNameKey SplitFullyQualifiedTypeName(string fullyQualifiedTypeName)
-    {
-      int? assemblyDelimiterIndex = ReflectionUtils.GetAssemblyDelimiterIndex(fullyQualifiedTypeName);
-      string typeName;
-      string assemblyName;
-      if (assemblyDelimiterIndex.HasValue)
-      {
-        typeName = fullyQualifiedTypeName.Trim(0, assemblyDelimiterIndex.GetValueOrDefault());
-        assemblyName = fullyQualifiedTypeName.Trim(assemblyDelimiterIndex.GetValueOrDefault() + 1, fullyQualifiedTypeName.Length - assemblyDelimiterIndex.GetValueOrDefault() - 1);
-      }
-      else
-      {
-        typeName = fullyQualifiedTypeName;
-        assemblyName = (string) null;
-      }
-      return new TypeNameKey(assemblyName, typeName);
-    }
-
-    private static int? GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
-    {
-      int num = 0;
-      for (int index = 0; index < fullyQualifiedTypeName.Length; ++index)
-      {
-        switch (fullyQualifiedTypeName[index])
-        {
-          case ',':
-            if (num == 0)
-              return new int?(index);
-            break;
-          case '[':
-            ++num;
-            break;
-          case ']':
-            --num;
-            break;
-        }
-      }
-      return new int?();
-    }
-
-    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
-    {
-      if (memberInfo.MemberType() != MemberTypes.Property)
-        return ((IEnumerable<MemberInfo>) targetType.GetMember(memberInfo.Name, memberInfo.MemberType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)).SingleOrDefault<MemberInfo>();
-      PropertyInfo propertyInfo = (PropertyInfo) memberInfo;
-      Type[] array = ((IEnumerable<ParameterInfo>) propertyInfo.GetIndexParameters()).Select<ParameterInfo, Type>((Func<ParameterInfo, Type>) (p => p.ParameterType)).ToArray<Type>();
-      return (MemberInfo) targetType.GetProperty(propertyInfo.Name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, (Binder) null, propertyInfo.PropertyType, array, (ParameterModifier[]) null);
-    }
-
-    public static IEnumerable<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
-    {
-      ValidationUtils.ArgumentNotNull((object) targetType, nameof (targetType));
-      List<MemberInfo> memberInfoList = new List<MemberInfo>((IEnumerable<MemberInfo>) targetType.GetFields(bindingAttr));
-      ReflectionUtils.GetChildPrivateFields((IList<MemberInfo>) memberInfoList, targetType, bindingAttr);
-      return memberInfoList.Cast<FieldInfo>();
-    }
-
-    private static void GetChildPrivateFields(
-      IList<MemberInfo> initialFields,
-      Type targetType,
-      BindingFlags bindingAttr)
-    {
-      if ((bindingAttr & BindingFlags.NonPublic) == BindingFlags.Default)
-        return;
-      BindingFlags bindingAttr1 = bindingAttr.RemoveFlag(BindingFlags.Public);
-      while ((targetType = targetType.BaseType()) != null)
-      {
-        IEnumerable<FieldInfo> collection = ((IEnumerable<FieldInfo>) targetType.GetFields(bindingAttr1)).Where<FieldInfo>((Func<FieldInfo, bool>) (f => f.IsPrivate));
-        initialFields.AddRange<MemberInfo>((IEnumerable) collection);
-      }
-    }
-
-    public static IEnumerable<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
-    {
-      ValidationUtils.ArgumentNotNull((object) targetType, nameof (targetType));
-      List<PropertyInfo> initialProperties = new List<PropertyInfo>((IEnumerable<PropertyInfo>) targetType.GetProperties(bindingAttr));
-      if (targetType.IsInterface())
-      {
-        foreach (Type type in targetType.GetInterfaces())
-          initialProperties.AddRange((IEnumerable<PropertyInfo>) type.GetProperties(bindingAttr));
-      }
-      ReflectionUtils.GetChildPrivateProperties((IList<PropertyInfo>) initialProperties, targetType, bindingAttr);
-      for (int index = 0; index < initialProperties.Count; ++index)
-      {
-        PropertyInfo propertyInfo = initialProperties[index];
-        if (propertyInfo.DeclaringType != targetType)
-        {
-          PropertyInfo memberInfoFromType = (PropertyInfo) ReflectionUtils.GetMemberInfoFromType(propertyInfo.DeclaringType, (MemberInfo) propertyInfo);
-          initialProperties[index] = memberInfoFromType;
-        }
-      }
-      return (IEnumerable<PropertyInfo>) initialProperties;
-    }
-
-    public static BindingFlags RemoveFlag(this BindingFlags bindingAttr, BindingFlags flag)
-    {
-      return (bindingAttr & flag) != flag ? bindingAttr : bindingAttr ^ flag;
-    }
-
-    private static void GetChildPrivateProperties(
-      IList<PropertyInfo> initialProperties,
-      Type targetType,
-      BindingFlags bindingAttr)
-    {
-      while ((targetType = targetType.BaseType()) != null)
-      {
-        foreach (PropertyInfo property in targetType.GetProperties(bindingAttr))
-        {
-          PropertyInfo subTypeProperty = property;
-          if (!subTypeProperty.IsVirtual())
-          {
-            if (!ReflectionUtils.IsPublic(subTypeProperty))
-            {
-              int index = initialProperties.IndexOf<PropertyInfo>((Func<PropertyInfo, bool>) (p => p.Name == subTypeProperty.Name));
-              if (index == -1)
-                initialProperties.Add(subTypeProperty);
-              else if (!ReflectionUtils.IsPublic(initialProperties[index]))
-                initialProperties[index] = subTypeProperty;
-            }
-            else if (initialProperties.IndexOf<PropertyInfo>((Func<PropertyInfo, bool>) (p => p.Name == subTypeProperty.Name && p.DeclaringType == subTypeProperty.DeclaringType)) == -1)
-              initialProperties.Add(subTypeProperty);
-          }
-          else
-          {
-            Type subTypePropertyDeclaringType = subTypeProperty.GetBaseDefinition()?.DeclaringType ?? subTypeProperty.DeclaringType;
-            if (initialProperties.IndexOf<PropertyInfo>((Func<PropertyInfo, bool>) (p => p.Name == subTypeProperty.Name && p.IsVirtual() && (p.GetBaseDefinition()?.DeclaringType ?? p.DeclaringType).IsAssignableFrom(subTypePropertyDeclaringType))) == -1)
-              initialProperties.Add(subTypeProperty);
-          }
-        }
-      }
-    }
-
-    public static bool IsMethodOverridden(
-      Type currentType,
-      Type methodDeclaringType,
-      string method)
-    {
-      return ((IEnumerable<MethodInfo>) currentType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)).Any<MethodInfo>((Func<MethodInfo, bool>) (info => info.Name == method && info.DeclaringType != methodDeclaringType && info.GetBaseDefinition().DeclaringType == methodDeclaringType));
-    }
-
-    public static object GetDefaultValue(Type type)
-    {
-      if (!type.IsValueType())
-        return (object) null;
-      switch (ConvertUtils.GetTypeCode(type))
-      {
-        case PrimitiveTypeCode.Char:
-        case PrimitiveTypeCode.SByte:
-        case PrimitiveTypeCode.Int16:
-        case PrimitiveTypeCode.UInt16:
-        case PrimitiveTypeCode.Int32:
-        case PrimitiveTypeCode.Byte:
-        case PrimitiveTypeCode.UInt32:
-          return (object) 0;
-        case PrimitiveTypeCode.Boolean:
-          return (object) false;
-        case PrimitiveTypeCode.Int64:
-        case PrimitiveTypeCode.UInt64:
-          return (object) 0L;
-        case PrimitiveTypeCode.Single:
-          return (object) 0.0f;
-        case PrimitiveTypeCode.Double:
-          return (object) 0.0;
-        case PrimitiveTypeCode.DateTime:
-          return (object) new DateTime();
-        case PrimitiveTypeCode.DateTimeOffset:
-          return (object) new DateTimeOffset();
-        case PrimitiveTypeCode.Decimal:
-          return (object) 0M;
-        case PrimitiveTypeCode.Guid:
-          return (object) new Guid();
-        default:
-          return ReflectionUtils.IsNullable(type) ? (object) null : Activator.CreateInstance(type);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/StringBuffer.cs b/MSHALTester/Newtonsoft/Json/Utilities/StringBuffer.cs
deleted file mode 100644
index 4431178..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/StringBuffer.cs
+++ /dev/null
@@ -1,72 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal struct StringBuffer
-  {
-    private char[] _buffer;
-    private int _position;
-
-    public int Position
-    {
-      get => this._position;
-      set => this._position = value;
-    }
-
-    public bool IsEmpty => this._buffer == null;
-
-    public StringBuffer(IArrayPool<char> bufferPool, int initalSize)
-      : this(BufferUtils.RentBuffer(bufferPool, initalSize))
-    {
-    }
-
-    private StringBuffer(char[] buffer)
-    {
-      this._buffer = buffer;
-      this._position = 0;
-    }
-
-    public void Append(IArrayPool<char> bufferPool, char value)
-    {
-      if (this._position == this._buffer.Length)
-        this.EnsureSize(bufferPool, 1);
-      this._buffer[this._position++] = value;
-    }
-
-    public void Append(IArrayPool<char> bufferPool, char[] buffer, int startIndex, int count)
-    {
-      if (this._position + count >= this._buffer.Length)
-        this.EnsureSize(bufferPool, count);
-      Array.Copy((Array) buffer, startIndex, (Array) this._buffer, this._position, count);
-      this._position += count;
-    }
-
-    public void Clear(IArrayPool<char> bufferPool)
-    {
-      if (this._buffer != null)
-      {
-        BufferUtils.ReturnBuffer(bufferPool, this._buffer);
-        this._buffer = (char[]) null;
-      }
-      this._position = 0;
-    }
-
-    private void EnsureSize(IArrayPool<char> bufferPool, int appendLength)
-    {
-      char[] destinationArray = BufferUtils.RentBuffer(bufferPool, (this._position + appendLength) * 2);
-      if (this._buffer != null)
-      {
-        Array.Copy((Array) this._buffer, (Array) destinationArray, this._position);
-        BufferUtils.ReturnBuffer(bufferPool, this._buffer);
-      }
-      this._buffer = destinationArray;
-    }
-
-    public override string ToString() => this.ToString(0, this._position);
-
-    public string ToString(int start, int length) => new string(this._buffer, start, length);
-
-    public char[] InternalBuffer => this._buffer;
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/StringReference.cs b/MSHALTester/Newtonsoft/Json/Utilities/StringReference.cs
deleted file mode 100644
index 6926c16..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/StringReference.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal readonly struct StringReference(char[] chars, int startIndex, int length)
-  {
-    private readonly char[] _chars = chars;
-    private readonly int _startIndex = startIndex;
-    private readonly int _length = length;
-
-    public char this[int i] => this._chars[i];
-
-    public char[] Chars => this._chars;
-
-    public int StartIndex => this._startIndex;
-
-    public int Length => this._length;
-
-    public override string ToString() => new string(this._chars, this._startIndex, this._length);
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/StringReferenceExtensions.cs b/MSHALTester/Newtonsoft/Json/Utilities/StringReferenceExtensions.cs
deleted file mode 100644
index 52d6ae2..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/StringReferenceExtensions.cs
+++ /dev/null
@@ -1,41 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class StringReferenceExtensions
-  {
-    public static int IndexOf(this StringReference s, char c, int startIndex, int length)
-    {
-      int num = Array.IndexOf<char>(s.Chars, c, s.StartIndex + startIndex, length);
-      return num == -1 ? -1 : num - s.StartIndex;
-    }
-
-    public static bool StartsWith(this StringReference s, string text)
-    {
-      if (text.Length > s.Length)
-        return false;
-      char[] chars = s.Chars;
-      for (int index = 0; index < text.Length; ++index)
-      {
-        if ((int) text[index] != (int) chars[index + s.StartIndex])
-          return false;
-      }
-      return true;
-    }
-
-    public static bool EndsWith(this StringReference s, string text)
-    {
-      if (text.Length > s.Length)
-        return false;
-      char[] chars = s.Chars;
-      int num = s.StartIndex + s.Length - text.Length;
-      for (int index = 0; index < text.Length; ++index)
-      {
-        if ((int) text[index] != (int) chars[index + num])
-          return false;
-      }
-      return true;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/StringUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/StringUtils.cs
deleted file mode 100644
index 53073ca..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/StringUtils.cs
+++ /dev/null
@@ -1,250 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Globalization;
-using System.IO;
-using System.Linq;
-using System.Text;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class StringUtils
-  {
-    public const string CarriageReturnLineFeed = "\r\n";
-    public const string Empty = "";
-    public const char CarriageReturn = '\r';
-    public const char LineFeed = '\n';
-    public const char Tab = '\t';
-
-    public static string FormatWith(this string format, IFormatProvider provider, object arg0)
-    {
-      return StringUtils.FormatWith(format, provider, new object[1]
-      {
-        arg0
-      });
-    }
-
-    public static string FormatWith(
-      this string format,
-      IFormatProvider provider,
-      object arg0,
-      object arg1)
-    {
-      return StringUtils.FormatWith(format, provider, new object[2]
-      {
-        arg0,
-        arg1
-      });
-    }
-
-    public static string FormatWith(
-      this string format,
-      IFormatProvider provider,
-      object arg0,
-      object arg1,
-      object arg2)
-    {
-      return StringUtils.FormatWith(format, provider, new object[3]
-      {
-        arg0,
-        arg1,
-        arg2
-      });
-    }
-
-    public static string FormatWith(
-      this string format,
-      IFormatProvider provider,
-      object arg0,
-      object arg1,
-      object arg2,
-      object arg3)
-    {
-      return StringUtils.FormatWith(format, provider, new object[4]
-      {
-        arg0,
-        arg1,
-        arg2,
-        arg3
-      });
-    }
-
-    private static string FormatWith(
-      this string format,
-      IFormatProvider provider,
-      params object[] args)
-    {
-      ValidationUtils.ArgumentNotNull((object) format, nameof (format));
-      return string.Format(provider, format, args);
-    }
-
-    public static bool IsWhiteSpace(string s)
-    {
-      switch (s)
-      {
-        case null:
-          throw new ArgumentNullException(nameof (s));
-        case "":
-          return false;
-        default:
-          for (int index = 0; index < s.Length; ++index)
-          {
-            if (!char.IsWhiteSpace(s[index]))
-              return false;
-          }
-          return true;
-      }
-    }
-
-    public static StringWriter CreateStringWriter(int capacity)
-    {
-      return new StringWriter(new StringBuilder(capacity), (IFormatProvider) CultureInfo.InvariantCulture);
-    }
-
-    public static void ToCharAsUnicode(char c, char[] buffer)
-    {
-      buffer[0] = '\\';
-      buffer[1] = 'u';
-      buffer[2] = MathUtils.IntToHex((int) c >> 12 & 15);
-      buffer[3] = MathUtils.IntToHex((int) c >> 8 & 15);
-      buffer[4] = MathUtils.IntToHex((int) c >> 4 & 15);
-      buffer[5] = MathUtils.IntToHex((int) c & 15);
-    }
-
-    public static TSource ForgivingCaseSensitiveFind<TSource>(
-      this IEnumerable<TSource> source,
-      Func<TSource, string> valueSelector,
-      string testValue)
-    {
-      if (source == null)
-        throw new ArgumentNullException(nameof (source));
-      if (valueSelector == null)
-        throw new ArgumentNullException(nameof (valueSelector));
-      IEnumerable<TSource> source1 = source.Where<TSource>((Func<TSource, bool>) (s => string.Equals(valueSelector(s), testValue, StringComparison.OrdinalIgnoreCase)));
-      return source1.Count<TSource>() <= 1 ? source1.SingleOrDefault<TSource>() : source.Where<TSource>((Func<TSource, bool>) (s => string.Equals(valueSelector(s), testValue, StringComparison.Ordinal))).SingleOrDefault<TSource>();
-    }
-
-    public static string ToCamelCase(string s)
-    {
-      if (string.IsNullOrEmpty(s) || !char.IsUpper(s[0]))
-        return s;
-      char[] charArray = s.ToCharArray();
-      for (int index = 0; index < charArray.Length && (index != 1 || char.IsUpper(charArray[index])); ++index)
-      {
-        bool flag = index + 1 < charArray.Length;
-        if (index > 0 & flag && !char.IsUpper(charArray[index + 1]))
-        {
-          if (char.IsSeparator(charArray[index + 1]))
-          {
-            charArray[index] = StringUtils.ToLower(charArray[index]);
-            break;
-          }
-          break;
-        }
-        charArray[index] = StringUtils.ToLower(charArray[index]);
-      }
-      return new string(charArray);
-    }
-
-    private static char ToLower(char c)
-    {
-      c = char.ToLower(c, CultureInfo.InvariantCulture);
-      return c;
-    }
-
-    public static string ToSnakeCase(string s)
-    {
-      if (string.IsNullOrEmpty(s))
-        return s;
-      StringBuilder stringBuilder = new StringBuilder();
-      StringUtils.SnakeCaseState snakeCaseState = StringUtils.SnakeCaseState.Start;
-      for (int index = 0; index < s.Length; ++index)
-      {
-        if (s[index] == ' ')
-        {
-          if (snakeCaseState != StringUtils.SnakeCaseState.Start)
-            snakeCaseState = StringUtils.SnakeCaseState.NewWord;
-        }
-        else if (char.IsUpper(s[index]))
-        {
-          switch (snakeCaseState)
-          {
-            case StringUtils.SnakeCaseState.Lower:
-            case StringUtils.SnakeCaseState.NewWord:
-              stringBuilder.Append('_');
-              break;
-            case StringUtils.SnakeCaseState.Upper:
-              bool flag = index + 1 < s.Length;
-              if (index > 0 & flag)
-              {
-                char c = s[index + 1];
-                if (!char.IsUpper(c) && c != '_')
-                {
-                  stringBuilder.Append('_');
-                  break;
-                }
-                break;
-              }
-              break;
-          }
-          char lower = char.ToLower(s[index], CultureInfo.InvariantCulture);
-          stringBuilder.Append(lower);
-          snakeCaseState = StringUtils.SnakeCaseState.Upper;
-        }
-        else if (s[index] == '_')
-        {
-          stringBuilder.Append('_');
-          snakeCaseState = StringUtils.SnakeCaseState.Start;
-        }
-        else
-        {
-          if (snakeCaseState == StringUtils.SnakeCaseState.NewWord)
-            stringBuilder.Append('_');
-          stringBuilder.Append(s[index]);
-          snakeCaseState = StringUtils.SnakeCaseState.Lower;
-        }
-      }
-      return stringBuilder.ToString();
-    }
-
-    public static bool IsHighSurrogate(char c) => char.IsHighSurrogate(c);
-
-    public static bool IsLowSurrogate(char c) => char.IsLowSurrogate(c);
-
-    public static bool StartsWith(this string source, char value)
-    {
-      return source.Length > 0 && (int) source[0] == (int) value;
-    }
-
-    public static bool EndsWith(this string source, char value)
-    {
-      return source.Length > 0 && (int) source[source.Length - 1] == (int) value;
-    }
-
-    public static string Trim(this string s, int start, int length)
-    {
-      if (s == null)
-        throw new ArgumentNullException();
-      if (start < 0)
-        throw new ArgumentOutOfRangeException(nameof (start));
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length));
-      int index = start + length - 1;
-      if (index >= s.Length)
-        throw new ArgumentOutOfRangeException(nameof (length));
-      while (start < index && char.IsWhiteSpace(s[start]))
-        ++start;
-      while (index >= start && char.IsWhiteSpace(s[index]))
-        --index;
-      return s.Substring(start, index - start + 1);
-    }
-
-    internal enum SnakeCaseState
-    {
-      Start,
-      Lower,
-      Upper,
-      NewWord,
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ThreadSafeStore`2.cs b/MSHALTester/Newtonsoft/Json/Utilities/ThreadSafeStore`2.cs
deleted file mode 100644
index cc9fc64..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ThreadSafeStore`2.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Threading;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class ThreadSafeStore<TKey, TValue>
-  {
-    private readonly object _lock = new object();
-    private Dictionary<TKey, TValue> _store;
-    private readonly Func<TKey, TValue> _creator;
-
-    public ThreadSafeStore(Func<TKey, TValue> creator)
-    {
-      ValidationUtils.ArgumentNotNull((object) creator, nameof (creator));
-      this._creator = creator;
-      this._store = new Dictionary<TKey, TValue>();
-    }
-
-    public TValue Get(TKey key)
-    {
-      TValue obj;
-      return !this._store.TryGetValue(key, out obj) ? this.AddValue(key) : obj;
-    }
-
-    private TValue AddValue(TKey key)
-    {
-      TValue obj1 = this._creator(key);
-      lock (this._lock)
-      {
-        if (this._store == null)
-        {
-          this._store = new Dictionary<TKey, TValue>();
-          this._store[key] = obj1;
-        }
-        else
-        {
-          TValue obj2;
-          if (this._store.TryGetValue(key, out obj2))
-            return obj2;
-          Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>((IDictionary<TKey, TValue>) this._store);
-          dictionary[key] = obj1;
-          Thread.MemoryBarrier();
-          this._store = dictionary;
-        }
-        return obj1;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/TypeExtensions.cs b/MSHALTester/Newtonsoft/Json/Utilities/TypeExtensions.cs
deleted file mode 100644
index ad801f6..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/TypeExtensions.cs
+++ /dev/null
@@ -1,90 +0,0 @@
-using System;
-using System.Collections.Generic;
-using System.Reflection;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class TypeExtensions
-  {
-    public static MethodInfo Method(this Delegate d) => d.Method;
-
-    public static MemberTypes MemberType(this MemberInfo memberInfo) => memberInfo.MemberType;
-
-    public static bool ContainsGenericParameters(this Type type) => type.ContainsGenericParameters;
-
-    public static bool IsInterface(this Type type) => type.IsInterface;
-
-    public static bool IsGenericType(this Type type) => type.IsGenericType;
-
-    public static bool IsGenericTypeDefinition(this Type type) => type.IsGenericTypeDefinition;
-
-    public static Type BaseType(this Type type) => type.BaseType;
-
-    public static System.Reflection.Assembly Assembly(this Type type) => type.Assembly;
-
-    public static bool IsEnum(this Type type) => type.IsEnum;
-
-    public static bool IsClass(this Type type) => type.IsClass;
-
-    public static bool IsSealed(this Type type) => type.IsSealed;
-
-    public static bool IsAbstract(this Type type) => type.IsAbstract;
-
-    public static bool IsVisible(this Type type) => type.IsVisible;
-
-    public static bool IsValueType(this Type type) => type.IsValueType;
-
-    public static bool IsPrimitive(this Type type) => type.IsPrimitive;
-
-    public static bool AssignableToTypeName(
-      this Type type,
-      string fullTypeName,
-      bool searchInterfaces,
-      out Type match)
-    {
-      for (Type type1 = type; type1 != null; type1 = type1.BaseType())
-      {
-        if (string.Equals(type1.FullName, fullTypeName, StringComparison.Ordinal))
-        {
-          match = type1;
-          return true;
-        }
-      }
-      if (searchInterfaces)
-      {
-        foreach (MemberInfo memberInfo in type.GetInterfaces())
-        {
-          if (string.Equals(memberInfo.Name, fullTypeName, StringComparison.Ordinal))
-          {
-            match = type;
-            return true;
-          }
-        }
-      }
-      match = (Type) null;
-      return false;
-    }
-
-    public static bool AssignableToTypeName(
-      this Type type,
-      string fullTypeName,
-      bool searchInterfaces)
-    {
-      return type.AssignableToTypeName(fullTypeName, searchInterfaces, out Type _);
-    }
-
-    public static bool ImplementInterface(this Type type, Type interfaceType)
-    {
-      for (Type type1 = type; type1 != null; type1 = type1.BaseType())
-      {
-        foreach (Type type2 in (IEnumerable<Type>) type1.GetInterfaces())
-        {
-          if (type2 == interfaceType || type2 != null && type2.ImplementInterface(interfaceType))
-            return true;
-        }
-      }
-      return false;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/TypeInformation.cs b/MSHALTester/Newtonsoft/Json/Utilities/TypeInformation.cs
deleted file mode 100644
index 11fda45..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/TypeInformation.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal class TypeInformation
-  {
-    public Type Type { get; set; }
-
-    public PrimitiveTypeCode TypeCode { get; set; }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/TypeNameKey.cs b/MSHALTester/Newtonsoft/Json/Utilities/TypeNameKey.cs
deleted file mode 100644
index f08029e..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/TypeNameKey.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal readonly struct TypeNameKey(string assemblyName, string typeName) : 
-    IEquatable<TypeNameKey>
-  {
-    internal readonly string AssemblyName = assemblyName;
-    internal readonly string TypeName = typeName;
-
-    public override int GetHashCode()
-    {
-      string assemblyName = this.AssemblyName;
-      int hashCode1 = assemblyName != null ? assemblyName.GetHashCode() : 0;
-      string typeName = this.TypeName;
-      int hashCode2 = typeName != null ? typeName.GetHashCode() : 0;
-      return hashCode1 ^ hashCode2;
-    }
-
-    public override bool Equals(object obj) => obj is TypeNameKey other && this.Equals(other);
-
-    public bool Equals(TypeNameKey other)
-    {
-      return this.AssemblyName == other.AssemblyName && this.TypeName == other.TypeName;
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/Utilities/ValidationUtils.cs b/MSHALTester/Newtonsoft/Json/Utilities/ValidationUtils.cs
deleted file mode 100644
index a9901ff..0000000
--- a/MSHALTester/Newtonsoft/Json/Utilities/ValidationUtils.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System;
-
-#nullable disable
-namespace Newtonsoft.Json.Utilities
-{
-  internal static class ValidationUtils
-  {
-    public static void ArgumentNotNull(object value, string parameterName)
-    {
-      if (value == null)
-        throw new ArgumentNullException(parameterName);
-    }
-  }
-}
diff --git a/MSHALTester/Newtonsoft/Json/WriteState.cs b/MSHALTester/Newtonsoft/Json/WriteState.cs
deleted file mode 100644
index 0ab0b05..0000000
--- a/MSHALTester/Newtonsoft/Json/WriteState.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-#nullable disable
-namespace Newtonsoft.Json
-{
-  public enum WriteState
-  {
-    Error,
-    Closed,
-    Object,
-    Array,
-    Constructor,
-    Property,
-    Start,
-  }
-}
diff --git a/MSHALTester/Redbox/DirectShow/AbstractDirectShowFrameControl.cs b/MSHALTester/Redbox/DirectShow/AbstractDirectShowFrameControl.cs
index f03ddf0..2a41d12 100644
--- a/MSHALTester/Redbox/DirectShow/AbstractDirectShowFrameControl.cs
+++ b/MSHALTester/Redbox/DirectShow/AbstractDirectShowFrameControl.cs
@@ -64,7 +64,7 @@ namespace Redbox.DirectShow
         BitmapData bitmapdata = bitmap.LockBits(new Rectangle(0, 0, this.FrameSize.Width, this.FrameSize.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
         int stride1 = bitmapdata.Stride;
         int stride2 = bitmapdata.Stride;
-        byte* dst = (byte*) ((IntPtr) bitmapdata.Scan0.ToPointer() + stride2 * (this.FrameSize.Height - 1));
+        byte* dst = (byte*) ((byte*) bitmapdata.Scan0.ToPointer() + stride2 * (this.FrameSize.Height - 1));
         byte* pointer = (byte*) buffer.ToPointer();
         for (int index = 0; index < this.FrameSize.Height; ++index)
         {
diff --git a/MSHALTester/Redbox/DirectShow/CameraControlProperty.cs b/MSHALTester/Redbox/DirectShow/CameraControlProperty.cs
index 87db023..5b26c84 100644
--- a/MSHALTester/Redbox/DirectShow/CameraControlProperty.cs
+++ b/MSHALTester/Redbox/DirectShow/CameraControlProperty.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public enum CameraControlProperty
diff --git a/MSHALTester/Redbox/DirectShow/ControlConstants.cs b/MSHALTester/Redbox/DirectShow/ControlConstants.cs
index 67cd182..bab6e89 100644
--- a/MSHALTester/Redbox/DirectShow/ControlConstants.cs
+++ b/MSHALTester/Redbox/DirectShow/ControlConstants.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   internal static class ControlConstants
diff --git a/MSHALTester/Redbox/DirectShow/DirectShowFrameControl.cs b/MSHALTester/Redbox/DirectShow/DirectShowFrameControl.cs
index 5c5adc6..05c65f3 100644
--- a/MSHALTester/Redbox/DirectShow/DirectShowFrameControl.cs
+++ b/MSHALTester/Redbox/DirectShow/DirectShowFrameControl.cs
@@ -68,7 +68,7 @@ namespace Redbox.DirectShow
         BitmapData bitmapdata = bitmap.LockBits(new Rectangle(0, 0, this.FrameSize.Width, this.FrameSize.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
         int stride1 = bitmapdata.Stride;
         int stride2 = bitmapdata.Stride;
-        byte* dst = (byte*) ((IntPtr) bitmapdata.Scan0.ToPointer() + stride2 * (this.FrameSize.Height - 1));
+        byte* dst = (byte*) ((byte*) bitmapdata.Scan0.ToPointer() + stride2 * (this.FrameSize.Height - 1));
         byte* pointer = (byte*) buffer.ToPointer();
         for (int index = 0; index < this.FrameSize.Height; ++index)
         {
diff --git a/MSHALTester/Redbox/DirectShow/DirectShowFrameControl_v2.cs b/MSHALTester/Redbox/DirectShow/DirectShowFrameControl_v2.cs
index 310a11f..8b6dd6d 100644
--- a/MSHALTester/Redbox/DirectShow/DirectShowFrameControl_v2.cs
+++ b/MSHALTester/Redbox/DirectShow/DirectShowFrameControl_v2.cs
@@ -65,7 +65,7 @@ namespace Redbox.DirectShow
         BitmapData bitmapdata = bitmap.LockBits(new Rectangle(0, 0, this.FrameSize.Width, this.FrameSize.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
         int stride1 = bitmapdata.Stride;
         int stride2 = bitmapdata.Stride;
-        byte* dst = (byte*) ((IntPtr) bitmapdata.Scan0.ToPointer() + stride2 * (this.FrameSize.Height - 1));
+        byte* dst = (byte*) ((byte*) bitmapdata.Scan0.ToPointer() + stride2 * (this.FrameSize.Height - 1));
         byte* pointer = (byte*) buffer.ToPointer();
         for (int index = 0; index < this.FrameSize.Height; ++index)
         {
diff --git a/MSHALTester/Redbox/DirectShow/FrameControls.cs b/MSHALTester/Redbox/DirectShow/FrameControls.cs
index 143318a..5a1d7dd 100644
--- a/MSHALTester/Redbox/DirectShow/FrameControls.cs
+++ b/MSHALTester/Redbox/DirectShow/FrameControls.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public enum FrameControls
diff --git a/MSHALTester/Redbox/DirectShow/IVideoSource.cs b/MSHALTester/Redbox/DirectShow/IVideoSource.cs
index 8774273..1771adb 100644
--- a/MSHALTester/Redbox/DirectShow/IVideoSource.cs
+++ b/MSHALTester/Redbox/DirectShow/IVideoSource.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public interface IVideoSource
diff --git a/MSHALTester/Redbox/DirectShow/Interop/DsEvCode.cs b/MSHALTester/Redbox/DirectShow/Interop/DsEvCode.cs
index 27bc6d8..c0d0b8a 100644
--- a/MSHALTester/Redbox/DirectShow/Interop/DsEvCode.cs
+++ b/MSHALTester/Redbox/DirectShow/Interop/DsEvCode.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow.Interop
 {
   internal enum DsEvCode
diff --git a/MSHALTester/Redbox/DirectShow/Interop/FilterState.cs b/MSHALTester/Redbox/DirectShow/Interop/FilterState.cs
index ea24211..a77ec0c 100644
--- a/MSHALTester/Redbox/DirectShow/Interop/FilterState.cs
+++ b/MSHALTester/Redbox/DirectShow/Interop/FilterState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow.Interop
 {
   internal enum FilterState
diff --git a/MSHALTester/Redbox/DirectShow/NewFrameEventHandler.cs b/MSHALTester/Redbox/DirectShow/NewFrameEventHandler.cs
index 8eb11b2..416b89f 100644
--- a/MSHALTester/Redbox/DirectShow/NewFrameEventHandler.cs
+++ b/MSHALTester/Redbox/DirectShow/NewFrameEventHandler.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public delegate void NewFrameEventHandler(object sender, NewFrameEventArgs eventArgs);
diff --git a/MSHALTester/Redbox/DirectShow/PhysicalConnectorType.cs b/MSHALTester/Redbox/DirectShow/PhysicalConnectorType.cs
index 15ba8f5..874bd2d 100644
--- a/MSHALTester/Redbox/DirectShow/PhysicalConnectorType.cs
+++ b/MSHALTester/Redbox/DirectShow/PhysicalConnectorType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public enum PhysicalConnectorType
diff --git a/MSHALTester/Redbox/DirectShow/PlayingFinishedEventHandler.cs b/MSHALTester/Redbox/DirectShow/PlayingFinishedEventHandler.cs
index 6da5bbe..33d4fe3 100644
--- a/MSHALTester/Redbox/DirectShow/PlayingFinishedEventHandler.cs
+++ b/MSHALTester/Redbox/DirectShow/PlayingFinishedEventHandler.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public delegate void PlayingFinishedEventHandler(object sender, ReasonToFinishPlaying reason);
diff --git a/MSHALTester/Redbox/DirectShow/ReasonToFinishPlaying.cs b/MSHALTester/Redbox/DirectShow/ReasonToFinishPlaying.cs
index fced3b1..cf805a7 100644
--- a/MSHALTester/Redbox/DirectShow/ReasonToFinishPlaying.cs
+++ b/MSHALTester/Redbox/DirectShow/ReasonToFinishPlaying.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public enum ReasonToFinishPlaying
diff --git a/MSHALTester/Redbox/DirectShow/SampleGrabber.cs b/MSHALTester/Redbox/DirectShow/SampleGrabber.cs
index 8b2f9b7..e2916fe 100644
--- a/MSHALTester/Redbox/DirectShow/SampleGrabber.cs
+++ b/MSHALTester/Redbox/DirectShow/SampleGrabber.cs
@@ -23,7 +23,7 @@ namespace Redbox.DirectShow
       BitmapData bitmapdata = b.LockBits(new Rectangle(0, 0, this.Size.Width, this.Size.Height), ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);
       int stride1 = bitmapdata.Stride;
       int stride2 = bitmapdata.Stride;
-      byte* dst = (byte*) ((IntPtr) bitmapdata.Scan0.ToPointer() + stride2 * (this.Size.Height - 1));
+      byte* dst = (byte*) ((byte*) bitmapdata.Scan0.ToPointer() + stride2 * (this.Size.Height - 1));
       byte* pointer = (byte*) buffer.ToPointer();
       for (int index = 0; index < this.Size.Height; ++index)
       {
diff --git a/MSHALTester/Redbox/DirectShow/VideoInput.cs b/MSHALTester/Redbox/DirectShow/VideoInput.cs
index 65c6bbb..d11a83d 100644
--- a/MSHALTester/Redbox/DirectShow/VideoInput.cs
+++ b/MSHALTester/Redbox/DirectShow/VideoInput.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public class VideoInput
diff --git a/MSHALTester/Redbox/DirectShow/VideoSourceErrorEventHandler.cs b/MSHALTester/Redbox/DirectShow/VideoSourceErrorEventHandler.cs
index 8fdd569..4c15d78 100644
--- a/MSHALTester/Redbox/DirectShow/VideoSourceErrorEventHandler.cs
+++ b/MSHALTester/Redbox/DirectShow/VideoSourceErrorEventHandler.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.DirectShow
 {
   public delegate void VideoSourceErrorEventHandler(
diff --git a/MSHALTester/Redbox/HAL/Client/Constants.cs b/MSHALTester/Redbox/HAL/Client/Constants.cs
index 5fc2452..e6ba3e9 100644
--- a/MSHALTester/Redbox/HAL/Client/Constants.cs
+++ b/MSHALTester/Redbox/HAL/Client/Constants.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public static class Constants
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/AdjacentBinTest.cs b/MSHALTester/Redbox/HAL/Client/Executors/AdjacentBinTest.cs
index 8eed908..15c5bd4 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/AdjacentBinTest.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/AdjacentBinTest.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class AdjacentBinTest(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/BoardTestJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/BoardTestJob.cs
index ea12c22..9bb4e19 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/BoardTestJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/BoardTestJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class BoardTestJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/ClearImagesFolderExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/ClearImagesFolderExecutor.cs
index adac208..13ae76a 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/ClearImagesFolderExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/ClearImagesFolderExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class ClearImagesFolderExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/FraudSensorPost.cs b/MSHALTester/Redbox/HAL/Client/Executors/FraudSensorPost.cs
index e9330de..68af9d0 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/FraudSensorPost.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/FraudSensorPost.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class FraudSensorPost(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/GetAndCenterResult.cs b/MSHALTester/Redbox/HAL/Client/Executors/GetAndCenterResult.cs
index 2674594..0246561 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/GetAndCenterResult.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/GetAndCenterResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class GetAndCenterResult : JobExecutor
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/GetAndReadExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/GetAndReadExecutor.cs
index b720780..fb2287f 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/GetAndReadExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/GetAndReadExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class GetAndReadExecutor : JobExecutor
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/HardwareStatusExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/HardwareStatusExecutor.cs
index e1992cb..ff143d3 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/HardwareStatusExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/HardwareStatusExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class HardwareStatusExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/IDeckConfig.cs b/MSHALTester/Redbox/HAL/Client/Executors/IDeckConfig.cs
index 350f26e..396e563 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/IDeckConfig.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/IDeckConfig.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public interface IDeckConfig
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/InitJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/InitJob.cs
index 3b2ba2a..bd8704b 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/InitJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/InitJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class InitJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/InventoryStatsJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/InventoryStatsJob.cs
index 893f1b8..e9c91ea 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/InventoryStatsJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/InventoryStatsJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class InventoryStatsJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/MSPullInDvdJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/MSPullInDvdJob.cs
index 9b1c098..f90269d 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/MSPullInDvdJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/MSPullInDvdJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class MSPullInDvdJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/OneDiskQuickTest.cs b/MSHALTester/Redbox/HAL/Client/Executors/OneDiskQuickTest.cs
index 4734077..d7e7577 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/OneDiskQuickTest.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/OneDiskQuickTest.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class OneDiskQuickTest : JobExecutor
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/OneDiskRandomSyncExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/OneDiskRandomSyncExecutor.cs
index c2d10a0..4caab0a 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/OneDiskRandomSyncExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/OneDiskRandomSyncExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class OneDiskRandomSyncExecutor : JobExecutor
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/PowerCycleRouterExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/PowerCycleRouterExecutor.cs
index 218ed58..4079cc4 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/PowerCycleRouterExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/PowerCycleRouterExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class PowerCycleRouterExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/PushInDvdJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/PushInDvdJob.cs
index c264b0e..efd1388 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/PushInDvdJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/PushInDvdJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class PushInDvdJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/PutDiskInPickerInBinJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/PutDiskInPickerInBinJob.cs
index cf2a2e6..8334226 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/PutDiskInPickerInBinJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/PutDiskInPickerInBinJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class PutDiskInPickerInBinJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/PutInEmptySlotResult.cs b/MSHALTester/Redbox/HAL/Client/Executors/PutInEmptySlotResult.cs
index f3f351a..0182bc2 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/PutInEmptySlotResult.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/PutInEmptySlotResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class PutInEmptySlotResult(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/PutInLocationResult.cs b/MSHALTester/Redbox/HAL/Client/Executors/PutInLocationResult.cs
index 0232088..53cda55 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/PutInLocationResult.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/PutInLocationResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class PutInLocationResult : JobExecutor
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/QlmTestSyncJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/QlmTestSyncJob.cs
index a0615af..b6629c5 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/QlmTestSyncJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/QlmTestSyncJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class QlmTestSyncJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/RandomSyncExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/RandomSyncExecutor.cs
index 58d1463..c9ec0ae 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/RandomSyncExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/RandomSyncExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class RandomSyncExecutor : JobExecutor
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/ReadFraudDiskExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/ReadFraudDiskExecutor.cs
index e92bc73..7aa646d 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/ReadFraudDiskExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/ReadFraudDiskExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class ReadFraudDiskExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/RebuildInventoryExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/RebuildInventoryExecutor.cs
index eee334b..c9c7a99 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/RebuildInventoryExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/RebuildInventoryExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class RebuildInventoryExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/ResetControlSystemJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/ResetControlSystemJob.cs
index 94ddbd3..6fe499e 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/ResetControlSystemJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/ResetControlSystemJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class ResetControlSystemJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/ResetFraudSensorJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/ResetFraudSensorJob.cs
index 6fa5cf8..42adfd1 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/ResetFraudSensorJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/ResetFraudSensorJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class ResetFraudSensorJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/ResetMotionControlExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/ResetMotionControlExecutor.cs
index 40166e9..4c38709 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/ResetMotionControlExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/ResetMotionControlExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class ResetMotionControlExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/ReturnExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/ReturnExecutor.cs
index b0a556f..5e2f96a 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/ReturnExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/ReturnExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class ReturnExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/ReturnUnknownExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/ReturnUnknownExecutor.cs
index b1b5ec8..3330005 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/ReturnUnknownExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/ReturnUnknownExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class ReturnUnknownExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/TakeDiskAtDoorJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/TakeDiskAtDoorJob.cs
index 173cc7e..c317ec4 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/TakeDiskAtDoorJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/TakeDiskAtDoorJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class TakeDiskAtDoorJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/TestAndResetCCRExecutor.cs b/MSHALTester/Redbox/HAL/Client/Executors/TestAndResetCCRExecutor.cs
index b4811f2..bbcefb4 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/TestAndResetCCRExecutor.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/TestAndResetCCRExecutor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class TestAndResetCCRExecutor(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/TestRetrofitDeck.cs b/MSHALTester/Redbox/HAL/Client/Executors/TestRetrofitDeck.cs
index 91c888a..21aa539 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/TestRetrofitDeck.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/TestRetrofitDeck.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class TestRetrofitDeck(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/UpdateQREEPROMJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/UpdateQREEPROMJob.cs
index cad4431..e872c14 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/UpdateQREEPROMJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/UpdateQREEPROMJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class UpdateQREEPROMJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/VendDiskInPickerJob.cs b/MSHALTester/Redbox/HAL/Client/Executors/VendDiskInPickerJob.cs
index be34661..348f743 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/VendDiskInPickerJob.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/VendDiskInPickerJob.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class VendDiskInPickerJob(HardwareService service) : JobExecutor(service)
diff --git a/MSHALTester/Redbox/HAL/Client/Executors/VerticalSync.cs b/MSHALTester/Redbox/HAL/Client/Executors/VerticalSync.cs
index 3eff839..049c834 100644
--- a/MSHALTester/Redbox/HAL/Client/Executors/VerticalSync.cs
+++ b/MSHALTester/Redbox/HAL/Client/Executors/VerticalSync.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Executors
 {
   public sealed class VerticalSync : JobExecutor
diff --git a/MSHALTester/Redbox/HAL/Client/HardwareJobConnectionState.cs b/MSHALTester/Redbox/HAL/Client/HardwareJobConnectionState.cs
index 309c16c..8f8d870 100644
--- a/MSHALTester/Redbox/HAL/Client/HardwareJobConnectionState.cs
+++ b/MSHALTester/Redbox/HAL/Client/HardwareJobConnectionState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public enum HardwareJobConnectionState
diff --git a/MSHALTester/Redbox/HAL/Client/HardwareJobPriority.cs b/MSHALTester/Redbox/HAL/Client/HardwareJobPriority.cs
index 2bd4717..1a240b8 100644
--- a/MSHALTester/Redbox/HAL/Client/HardwareJobPriority.cs
+++ b/MSHALTester/Redbox/HAL/Client/HardwareJobPriority.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public enum HardwareJobPriority
diff --git a/MSHALTester/Redbox/HAL/Client/HardwareJobStatus.cs b/MSHALTester/Redbox/HAL/Client/HardwareJobStatus.cs
index d2d8a25..6d7b12d 100644
--- a/MSHALTester/Redbox/HAL/Client/HardwareJobStatus.cs
+++ b/MSHALTester/Redbox/HAL/Client/HardwareJobStatus.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public enum HardwareJobStatus
diff --git a/MSHALTester/Redbox/HAL/Client/HardwareStatusChangeEvent.cs b/MSHALTester/Redbox/HAL/Client/HardwareStatusChangeEvent.cs
index 10d57c4..170bf44 100644
--- a/MSHALTester/Redbox/HAL/Client/HardwareStatusChangeEvent.cs
+++ b/MSHALTester/Redbox/HAL/Client/HardwareStatusChangeEvent.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public delegate void HardwareStatusChangeEvent(HardwareJob job, HardwareJobStatus status);
diff --git a/MSHALTester/Redbox/HAL/Client/IClientOutputSink.cs b/MSHALTester/Redbox/HAL/Client/IClientOutputSink.cs
index 308115d..c6228fb 100644
--- a/MSHALTester/Redbox/HAL/Client/IClientOutputSink.cs
+++ b/MSHALTester/Redbox/HAL/Client/IClientOutputSink.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public interface IClientOutputSink
diff --git a/MSHALTester/Redbox/HAL/Client/Location.cs b/MSHALTester/Redbox/HAL/Client/Location.cs
index 6901af6..d885923 100644
--- a/MSHALTester/Redbox/HAL/Client/Location.cs
+++ b/MSHALTester/Redbox/HAL/Client/Location.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public class Location
diff --git a/MSHALTester/Redbox/HAL/Client/NullSink.cs b/MSHALTester/Redbox/HAL/Client/NullSink.cs
index 0190a92..acb0a02 100644
--- a/MSHALTester/Redbox/HAL/Client/NullSink.cs
+++ b/MSHALTester/Redbox/HAL/Client/NullSink.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   internal class NullSink : IClientOutputSink
diff --git a/MSHALTester/Redbox/HAL/Client/Services/CameraState.cs b/MSHALTester/Redbox/HAL/Client/Services/CameraState.cs
index a1eb284..6a10a6c 100644
--- a/MSHALTester/Redbox/HAL/Client/Services/CameraState.cs
+++ b/MSHALTester/Redbox/HAL/Client/Services/CameraState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Services
 {
   public enum CameraState
diff --git a/MSHALTester/Redbox/HAL/Client/Services/ExecuteServiceCommand.cs b/MSHALTester/Redbox/HAL/Client/Services/ExecuteServiceCommand.cs
index 2b6d68f..be55762 100644
--- a/MSHALTester/Redbox/HAL/Client/Services/ExecuteServiceCommand.cs
+++ b/MSHALTester/Redbox/HAL/Client/Services/ExecuteServiceCommand.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Services
 {
   public class ExecuteServiceCommand : ImmediateCommand
diff --git a/MSHALTester/Redbox/HAL/Client/Services/ExecuteStatementImmediateCommand.cs b/MSHALTester/Redbox/HAL/Client/Services/ExecuteStatementImmediateCommand.cs
index 52a3e4d..912025a 100644
--- a/MSHALTester/Redbox/HAL/Client/Services/ExecuteStatementImmediateCommand.cs
+++ b/MSHALTester/Redbox/HAL/Client/Services/ExecuteStatementImmediateCommand.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Services
 {
   public class ExecuteStatementImmediateCommand : ImmediateCommand
diff --git a/MSHALTester/Redbox/HAL/Client/Services/ImmediateCommandResult.cs b/MSHALTester/Redbox/HAL/Client/Services/ImmediateCommandResult.cs
index 83e2918..c319d5e 100644
--- a/MSHALTester/Redbox/HAL/Client/Services/ImmediateCommandResult.cs
+++ b/MSHALTester/Redbox/HAL/Client/Services/ImmediateCommandResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client.Services
 {
   public class ImmediateCommandResult
diff --git a/MSHALTester/Redbox/HAL/Client/SpeakerState.cs b/MSHALTester/Redbox/HAL/Client/SpeakerState.cs
index df51219..fbbebeb 100644
--- a/MSHALTester/Redbox/HAL/Client/SpeakerState.cs
+++ b/MSHALTester/Redbox/HAL/Client/SpeakerState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public enum SpeakerState
diff --git a/MSHALTester/Redbox/HAL/Client/SyncRange.cs b/MSHALTester/Redbox/HAL/Client/SyncRange.cs
index b77f8c2..aa520a4 100644
--- a/MSHALTester/Redbox/HAL/Client/SyncRange.cs
+++ b/MSHALTester/Redbox/HAL/Client/SyncRange.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Client
 {
   public sealed class SyncRange
diff --git a/MSHALTester/Redbox/HAL/Common/GUI/Functions/ISessionUserService.cs b/MSHALTester/Redbox/HAL/Common/GUI/Functions/ISessionUserService.cs
index 0fe5414..c88085d 100644
--- a/MSHALTester/Redbox/HAL/Common/GUI/Functions/ISessionUserService.cs
+++ b/MSHALTester/Redbox/HAL/Common/GUI/Functions/ISessionUserService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Common.GUI.Functions
 {
   public interface ISessionUserService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/AirExchangerStatus.cs b/MSHALTester/Redbox/HAL/Component/Model/AirExchangerStatus.cs
index 423b320..d82078a 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/AirExchangerStatus.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/AirExchangerStatus.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum AirExchangerStatus
diff --git a/MSHALTester/Redbox/HAL/Component/Model/AudioChannelState.cs b/MSHALTester/Redbox/HAL/Component/Model/AudioChannelState.cs
index 3dc12b9..cd62bfb 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/AudioChannelState.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/AudioChannelState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum AudioChannelState
diff --git a/MSHALTester/Redbox/HAL/Component/Model/AuxInputs.cs b/MSHALTester/Redbox/HAL/Component/Model/AuxInputs.cs
index 2e1f680..53c5f97 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/AuxInputs.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/AuxInputs.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum AuxInputs
diff --git a/MSHALTester/Redbox/HAL/Component/Model/Axis.cs b/MSHALTester/Redbox/HAL/Component/Model/Axis.cs
index 0938b19..3e9774b 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/Axis.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/Axis.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum Axis
diff --git a/MSHALTester/Redbox/HAL/Component/Model/BackupAction.cs b/MSHALTester/Redbox/HAL/Component/Model/BackupAction.cs
index 34db154..1d3f59c 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/BackupAction.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/BackupAction.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum BackupAction
diff --git a/MSHALTester/Redbox/HAL/Component/Model/BarcodeServices.cs b/MSHALTester/Redbox/HAL/Component/Model/BarcodeServices.cs
index ef46346..b588dd3 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/BarcodeServices.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/BarcodeServices.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum BarcodeServices
diff --git a/MSHALTester/Redbox/HAL/Component/Model/CameraGeneration.cs b/MSHALTester/Redbox/HAL/Component/Model/CameraGeneration.cs
index 3e3c6ac..0c1f1af 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/CameraGeneration.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/CameraGeneration.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum CameraGeneration
diff --git a/MSHALTester/Redbox/HAL/Component/Model/CenterDiskMethod.cs b/MSHALTester/Redbox/HAL/Component/Model/CenterDiskMethod.cs
index 4cf6259..1b64dfa 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/CenterDiskMethod.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/CenterDiskMethod.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum CenterDiskMethod
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ChannelType.cs b/MSHALTester/Redbox/HAL/Component/Model/ChannelType.cs
index 4c88447..ce84ec5 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ChannelType.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ChannelType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ChannelType
diff --git a/MSHALTester/Redbox/HAL/Component/Model/CommPortReadModes.cs b/MSHALTester/Redbox/HAL/Component/Model/CommPortReadModes.cs
index acac540..fc56b96 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/CommPortReadModes.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/CommPortReadModes.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum CommPortReadModes
diff --git a/MSHALTester/Redbox/HAL/Component/Model/Compression/CompressionAlgorithmFactory.cs b/MSHALTester/Redbox/HAL/Component/Model/Compression/CompressionAlgorithmFactory.cs
index a99e051..5db6ff6 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/Compression/CompressionAlgorithmFactory.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/Compression/CompressionAlgorithmFactory.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model.Compression
 {
   public static class CompressionAlgorithmFactory
diff --git a/MSHALTester/Redbox/HAL/Component/Model/Compression/NullCompressionAlgorithm.cs b/MSHALTester/Redbox/HAL/Component/Model/Compression/NullCompressionAlgorithm.cs
index 9c0e76f..0c8b662 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/Compression/NullCompressionAlgorithm.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/Compression/NullCompressionAlgorithm.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model.Compression
 {
   internal sealed class NullCompressionAlgorithm : ICompressionAlgorithm
diff --git a/MSHALTester/Redbox/HAL/Component/Model/CompressionType.cs b/MSHALTester/Redbox/HAL/Component/Model/CompressionType.cs
index 3b0537b..448d06a 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/CompressionType.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/CompressionType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum CompressionType
diff --git a/MSHALTester/Redbox/HAL/Component/Model/Configurations.cs b/MSHALTester/Redbox/HAL/Component/Model/Configurations.cs
index 32fe09e..f409226 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/Configurations.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/Configurations.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum Configurations
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ConnectionState.cs b/MSHALTester/Redbox/HAL/Component/Model/ConnectionState.cs
index d259918..7bd40c0 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ConnectionState.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ConnectionState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ConnectionState
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ControlBoards.cs b/MSHALTester/Redbox/HAL/Component/Model/ControlBoards.cs
index 6c83e03..0d36ba6 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ControlBoards.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ControlBoards.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ControlBoards
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ConversionResult.cs b/MSHALTester/Redbox/HAL/Component/Model/ConversionResult.cs
index 8ad3c46..fd420a3 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ConversionResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ConversionResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ConversionResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/DecodeResult.cs b/MSHALTester/Redbox/HAL/Component/Model/DecodeResult.cs
index 1fc0547..44f79bf 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/DecodeResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/DecodeResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public sealed class DecodeResult : IDecodeResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/DeviceClass.cs b/MSHALTester/Redbox/HAL/Component/Model/DeviceClass.cs
index 26232c3..5d5bcbc 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/DeviceClass.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/DeviceClass.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum DeviceClass
diff --git a/MSHALTester/Redbox/HAL/Component/Model/DeviceState.cs b/MSHALTester/Redbox/HAL/Component/Model/DeviceState.cs
index 60c159e..e0e8f67 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/DeviceState.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/DeviceState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum DeviceState
diff --git a/MSHALTester/Redbox/HAL/Component/Model/DoorSensorResult.cs b/MSHALTester/Redbox/HAL/Component/Model/DoorSensorResult.cs
index a1b684f..1c26347 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/DoorSensorResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/DoorSensorResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum DoorSensorResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/DriverMatchType.cs b/MSHALTester/Redbox/HAL/Component/Model/DriverMatchType.cs
index 88bea3a..f4eecdf 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/DriverMatchType.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/DriverMatchType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum DriverMatchType
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ErrorCodes.cs b/MSHALTester/Redbox/HAL/Component/Model/ErrorCodes.cs
index bc40dc7..4ced1a8 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ErrorCodes.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ErrorCodes.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ErrorCodes
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ExchangerFanStatus.cs b/MSHALTester/Redbox/HAL/Component/Model/ExchangerFanStatus.cs
index 5a860c4..222877c 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ExchangerFanStatus.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ExchangerFanStatus.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ExchangerFanStatus
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ExecutionContextStatus.cs b/MSHALTester/Redbox/HAL/Component/Model/ExecutionContextStatus.cs
index ec1565e..2ac9481 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ExecutionContextStatus.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ExecutionContextStatus.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ExecutionContextStatus
diff --git a/MSHALTester/Redbox/HAL/Component/Model/FraudValidationResult.cs b/MSHALTester/Redbox/HAL/Component/Model/FraudValidationResult.cs
index 857c974..773d3dc 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/FraudValidationResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/FraudValidationResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum FraudValidationResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/GripperFingerState.cs b/MSHALTester/Redbox/HAL/Component/Model/GripperFingerState.cs
index 64491bf..a282230 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/GripperFingerState.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/GripperFingerState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum GripperFingerState
diff --git a/MSHALTester/Redbox/HAL/Component/Model/HardwareCorrectionStatistic.cs b/MSHALTester/Redbox/HAL/Component/Model/HardwareCorrectionStatistic.cs
index b3c7598..37a30b1 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/HardwareCorrectionStatistic.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/HardwareCorrectionStatistic.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum HardwareCorrectionStatistic
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IAirExchangerService.cs b/MSHALTester/Redbox/HAL/Component/Model/IAirExchangerService.cs
index 7b7c957..f3dbc8b 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IAirExchangerService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IAirExchangerService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IAirExchangerService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IBarcodeReader.cs b/MSHALTester/Redbox/HAL/Component/Model/IBarcodeReader.cs
index 7548b67..ff5b72e 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IBarcodeReader.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IBarcodeReader.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IBarcodeReader
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IBarcodeReaderFactory.cs b/MSHALTester/Redbox/HAL/Component/Model/IBarcodeReaderFactory.cs
index 0551987..ebc41b2 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IBarcodeReaderFactory.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IBarcodeReaderFactory.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IBarcodeReaderFactory
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IBarcodeValidatorService.cs b/MSHALTester/Redbox/HAL/Component/Model/IBarcodeValidatorService.cs
index 950cacc..e37f5c4 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IBarcodeValidatorService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IBarcodeValidatorService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IBarcodeValidatorService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IBoardVersionResponse.cs b/MSHALTester/Redbox/HAL/Component/Model/IBoardVersionResponse.cs
index 9548616..374f9a2 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IBoardVersionResponse.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IBoardVersionResponse.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IBoardVersionResponse
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ICloneable`1.cs b/MSHALTester/Redbox/HAL/Component/Model/ICloneable`1.cs
index 4072608..9b7bb62 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ICloneable`1.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ICloneable`1.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface ICloneable<T>
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ICommChannelConfiguration.cs b/MSHALTester/Redbox/HAL/Component/Model/ICommChannelConfiguration.cs
index b76ff6b..e5501cb 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ICommChannelConfiguration.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ICommChannelConfiguration.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface ICommChannelConfiguration
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IComponentErrorThreshold.cs b/MSHALTester/Redbox/HAL/Component/Model/IComponentErrorThreshold.cs
index ae64417..024ccd8 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IComponentErrorThreshold.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IComponentErrorThreshold.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IComponentErrorThreshold
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IComponentErrorThresholdService.cs b/MSHALTester/Redbox/HAL/Component/Model/IComponentErrorThresholdService.cs
index 94e7212..c88a2b0 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IComponentErrorThresholdService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IComponentErrorThresholdService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IComponentErrorThresholdService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ICompressionAlgorithm.cs b/MSHALTester/Redbox/HAL/Component/Model/ICompressionAlgorithm.cs
index 9266c0b..5ec3b26 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ICompressionAlgorithm.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ICompressionAlgorithm.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface ICompressionAlgorithm
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IConfigurationFile.cs b/MSHALTester/Redbox/HAL/Component/Model/IConfigurationFile.cs
index 63e11d7..6e208da 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IConfigurationFile.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IConfigurationFile.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IConfigurationFile
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IConfigurationObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IConfigurationObserver.cs
index 6f7630c..b1ee19b 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IConfigurationObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IConfigurationObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IConfigurationObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IConfigurationService.cs b/MSHALTester/Redbox/HAL/Component/Model/IConfigurationService.cs
index 662398f..7e542c7 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IConfigurationService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IConfigurationService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IConfigurationService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IContextSymbol.cs b/MSHALTester/Redbox/HAL/Component/Model/IContextSymbol.cs
index 32aeb8c..d4ff067 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IContextSymbol.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IContextSymbol.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IContextSymbol
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IControlResponse.cs b/MSHALTester/Redbox/HAL/Component/Model/IControlResponse.cs
index 69d65e9..d99caf9 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IControlResponse.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IControlResponse.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IControlResponse
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IControlSystem.cs b/MSHALTester/Redbox/HAL/Component/Model/IControlSystem.cs
index 76994ab..b7dd688 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IControlSystem.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IControlSystem.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IControlSystem
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IControlSystemObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IControlSystemObserver.cs
index ea069bb..994e196 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IControlSystemObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IControlSystemObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IControlSystemObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IControlSystemRevision.cs b/MSHALTester/Redbox/HAL/Component/Model/IControlSystemRevision.cs
index b40f91c..5e30f41 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IControlSystemRevision.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IControlSystemRevision.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IControlSystemRevision
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IControlSystemService.cs b/MSHALTester/Redbox/HAL/Component/Model/IControlSystemService.cs
index 39c71da..65583d6 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IControlSystemService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IControlSystemService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IControlSystemService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IControllerPosition.cs b/MSHALTester/Redbox/HAL/Component/Model/IControllerPosition.cs
index e8b474a..ca8816c 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IControllerPosition.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IControllerPosition.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IControllerPosition
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IDataTableDescriptor.cs b/MSHALTester/Redbox/HAL/Component/Model/IDataTableDescriptor.cs
index 799c297..893ec63 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IDataTableDescriptor.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IDataTableDescriptor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IDataTableDescriptor
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IDataTableService.cs b/MSHALTester/Redbox/HAL/Component/Model/IDataTableService.cs
index 35aef1c..d68ea88 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IDataTableService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IDataTableService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IDataTableService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IDecodeResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IDecodeResult.cs
index 5f1cdff..34716ef 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IDecodeResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IDecodeResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IDecodeResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IDeviceDescriptor.cs b/MSHALTester/Redbox/HAL/Component/Model/IDeviceDescriptor.cs
index d7879a3..543fe92 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IDeviceDescriptor.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IDeviceDescriptor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IDeviceDescriptor
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IDeviceSetupClassFactory.cs b/MSHALTester/Redbox/HAL/Component/Model/IDeviceSetupClassFactory.cs
index d8a7a47..159edb5 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IDeviceSetupClassFactory.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IDeviceSetupClassFactory.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IDeviceSetupClassFactory
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IDoorSensorService.cs b/MSHALTester/Redbox/HAL/Component/Model/IDoorSensorService.cs
index b217fdb..80c1a9a 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IDoorSensorService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IDoorSensorService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IDoorSensorService : IMoveVeto
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IDuplicateSearchResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IDuplicateSearchResult.cs
index e72def7..5653290 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IDuplicateSearchResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IDuplicateSearchResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IDuplicateSearchResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IEmptySearchPatternService.cs b/MSHALTester/Redbox/HAL/Component/Model/IEmptySearchPatternService.cs
index 64e8029..f2bda15 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IEmptySearchPatternService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IEmptySearchPatternService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IEmptySearchPatternService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IExcludeEmptySearchLocationObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IExcludeEmptySearchLocationObserver.cs
index 34529ca..edd71b7 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IExcludeEmptySearchLocationObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IExcludeEmptySearchLocationObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IExcludeEmptySearchLocationObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IFormattedLog.cs b/MSHALTester/Redbox/HAL/Component/Model/IFormattedLog.cs
index 65a118b..f54324c 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IFormattedLog.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IFormattedLog.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IFormattedLog
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IFormattedLogFactoryService.cs b/MSHALTester/Redbox/HAL/Component/Model/IFormattedLogFactoryService.cs
index 54ecff7..ae343a8 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IFormattedLogFactoryService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IFormattedLogFactoryService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IFormattedLogFactoryService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IFraudService.cs b/MSHALTester/Redbox/HAL/Component/Model/IFraudService.cs
index 88096f4..9ccdbc7 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IFraudService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IFraudService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IFraudService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IGetFromObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IGetFromObserver.cs
index fac7ccb..3193294 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IGetFromObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IGetFromObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IGetFromObserver : IGetObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IGetFromResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IGetFromResult.cs
index 679cfe0..2dea212 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IGetFromResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IGetFromResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IGetFromResult : IGetResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IGetObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IGetObserver.cs
index 9611b56..98731c9 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IGetObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IGetObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IGetObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IHardwareCorrectionObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IHardwareCorrectionObserver.cs
index 64b0ce1..f121130 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IHardwareCorrectionObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IHardwareCorrectionObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IHardwareCorrectionObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IHostInfo.cs b/MSHALTester/Redbox/HAL/Component/Model/IHostInfo.cs
index db41915..c0bceee 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IHostInfo.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IHostInfo.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IHostInfo
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IInventoryObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IInventoryObserver.cs
index e1dfd9c..8f025b0 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IInventoryObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IInventoryObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IInventoryObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IIpcProtocol.cs b/MSHALTester/Redbox/HAL/Component/Model/IIpcProtocol.cs
index 98d392c..ec02984 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IIpcProtocol.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IIpcProtocol.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IIpcProtocol
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IIpcProtocolFactory.cs b/MSHALTester/Redbox/HAL/Component/Model/IIpcProtocolFactory.cs
index 92a3e49..6c02242 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IIpcProtocolFactory.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IIpcProtocolFactory.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IIpcProtocolFactory
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IIpcServiceHost.cs b/MSHALTester/Redbox/HAL/Component/Model/IIpcServiceHost.cs
index d4cadb8..bf35fec 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IIpcServiceHost.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IIpcServiceHost.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IIpcServiceHost
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IKioskConfiguration.cs b/MSHALTester/Redbox/HAL/Component/Model/IKioskConfiguration.cs
index 0c185d0..7d7594a 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IKioskConfiguration.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IKioskConfiguration.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IKioskConfiguration
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IMessageSink.cs b/MSHALTester/Redbox/HAL/Component/Model/IMessageSink.cs
index 9ea65a9..3475c3a 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IMessageSink.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IMessageSink.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IMessageSink
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IMotionControlLimit.cs b/MSHALTester/Redbox/HAL/Component/Model/IMotionControlLimit.cs
index 698f46d..7711246 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IMotionControlLimit.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IMotionControlLimit.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IMotionControlLimit
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IMotionControlLimitResponse.cs b/MSHALTester/Redbox/HAL/Component/Model/IMotionControlLimitResponse.cs
index 163ea58..83ab8c2 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IMotionControlLimitResponse.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IMotionControlLimitResponse.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IMotionControlLimitResponse
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IMotionControlService.cs b/MSHALTester/Redbox/HAL/Component/Model/IMotionControlService.cs
index 66082c4..bb5b0a6 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IMotionControlService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IMotionControlService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IMotionControlService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IMoveVeto.cs b/MSHALTester/Redbox/HAL/Component/Model/IMoveVeto.cs
index 686c1f0..735ea46 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IMoveVeto.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IMoveVeto.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IMoveVeto
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPeekResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IPeekResult.cs
index bbe326a..5cfd8cd 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPeekResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPeekResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPeekResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPersistentCounter.cs b/MSHALTester/Redbox/HAL/Component/Model/IPersistentCounter.cs
index 3acb0a4..40ef341 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPersistentCounter.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPersistentCounter.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPersistentCounter
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPersistentCounterService.cs b/MSHALTester/Redbox/HAL/Component/Model/IPersistentCounterService.cs
index 7ecae11..87d5cab 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPersistentCounterService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPersistentCounterService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPersistentCounterService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPersistentMap.cs b/MSHALTester/Redbox/HAL/Component/Model/IPersistentMap.cs
index 0a527a4..d1e0b72 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPersistentMap.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPersistentMap.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPersistentMap
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPersistentMapService.cs b/MSHALTester/Redbox/HAL/Component/Model/IPersistentMapService.cs
index 64a9a16..400dae3 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPersistentMapService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPersistentMapService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPersistentMapService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPersistentOption.cs b/MSHALTester/Redbox/HAL/Component/Model/IPersistentOption.cs
index 0ca54c9..2db6067 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPersistentOption.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPersistentOption.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPersistentOption
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPickerSensorReadResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IPickerSensorReadResult.cs
index 5ec4ddc..50ab2c8 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPickerSensorReadResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPickerSensorReadResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPickerSensorReadResult : IReadInputsResult<PickerInputs>
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPowerCycleDevice.cs b/MSHALTester/Redbox/HAL/Component/Model/IPowerCycleDevice.cs
index cf8d1a4..008344a 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPowerCycleDevice.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPowerCycleDevice.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPowerCycleDevice
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPowerCycleDeviceService.cs b/MSHALTester/Redbox/HAL/Component/Model/IPowerCycleDeviceService.cs
index 5f6c05c..0493f69 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPowerCycleDeviceService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPowerCycleDeviceService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPowerCycleDeviceService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPowerEventObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IPowerEventObserver.cs
index 9a12943..c839c94 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPowerEventObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPowerEventObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPowerEventObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPowerEventService.cs b/MSHALTester/Redbox/HAL/Component/Model/IPowerEventService.cs
index 386e4ce..2e172ff 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPowerEventService.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPowerEventService.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPowerEventService
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPutObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IPutObserver.cs
index 2002947..1f24b8b 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPutObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPutObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPutObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPutResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IPutResult.cs
index a759a81..72afcf1 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPutResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPutResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPutResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPutToObserver.cs b/MSHALTester/Redbox/HAL/Component/Model/IPutToObserver.cs
index 77093dc..12404fc 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPutToObserver.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPutToObserver.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPutToObserver : IPutObserver
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IPutToResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IPutToResult.cs
index 17fe955..b3f844d 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IPutToResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IPutToResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IPutToResult : IPutResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IQuadrant.cs b/MSHALTester/Redbox/HAL/Component/Model/IQuadrant.cs
index fb4757e..e8028ff 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IQuadrant.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IQuadrant.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IQuadrant
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IQueryUsbDeviceResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IQueryUsbDeviceResult.cs
index a4a1373..c9e4546 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IQueryUsbDeviceResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IQueryUsbDeviceResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IQueryUsbDeviceResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IRange`1.cs b/MSHALTester/Redbox/HAL/Component/Model/IRange`1.cs
index 3bca095..63fd326 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IRange`1.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IRange`1.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IRange<T>
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ITouchscreenDescriptor.cs b/MSHALTester/Redbox/HAL/Component/Model/ITouchscreenDescriptor.cs
index 2f42ca6..b309004 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ITouchscreenDescriptor.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ITouchscreenDescriptor.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface ITouchscreenDescriptor : IDeviceDescriptor
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ITransferResult.cs b/MSHALTester/Redbox/HAL/Component/Model/ITransferResult.cs
index fa56dae..b68b8a8 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ITransferResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ITransferResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface ITransferResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IVendItemResult.cs b/MSHALTester/Redbox/HAL/Component/Model/IVendItemResult.cs
index 31f8583..5abd5ff 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IVendItemResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IVendItemResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public interface IVendItemResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/InputState.cs b/MSHALTester/Redbox/HAL/Component/Model/InputState.cs
index 2c70f43..4b807cd 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/InputState.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/InputState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum InputState
diff --git a/MSHALTester/Redbox/HAL/Component/Model/IpcHostVersion.cs b/MSHALTester/Redbox/HAL/Component/Model/IpcHostVersion.cs
index 1daecd8..74c81ad 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/IpcHostVersion.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/IpcHostVersion.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum IpcHostVersion
diff --git a/MSHALTester/Redbox/HAL/Component/Model/KioskConfiguration.cs b/MSHALTester/Redbox/HAL/Component/Model/KioskConfiguration.cs
index eacd0f2..794a8aa 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/KioskConfiguration.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/KioskConfiguration.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum KioskConfiguration
diff --git a/MSHALTester/Redbox/HAL/Component/Model/LogEntryType.cs b/MSHALTester/Redbox/HAL/Component/Model/LogEntryType.cs
index 2335dc2..c3bdaea 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/LogEntryType.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/LogEntryType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum LogEntryType
diff --git a/MSHALTester/Redbox/HAL/Component/Model/MerchFlags.cs b/MSHALTester/Redbox/HAL/Component/Model/MerchFlags.cs
index 538ed5d..b52f7d3 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/MerchFlags.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/MerchFlags.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum MerchFlags : long
diff --git a/MSHALTester/Redbox/HAL/Component/Model/MessageSeverity.cs b/MSHALTester/Redbox/HAL/Component/Model/MessageSeverity.cs
index 85bbd71..86fde8d 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/MessageSeverity.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/MessageSeverity.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum MessageSeverity
diff --git a/MSHALTester/Redbox/HAL/Component/Model/MessageType.cs b/MSHALTester/Redbox/HAL/Component/Model/MessageType.cs
index 9d707d3..d5bf913 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/MessageType.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/MessageType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum MessageType
diff --git a/MSHALTester/Redbox/HAL/Component/Model/MotionControlLimits.cs b/MSHALTester/Redbox/HAL/Component/Model/MotionControlLimits.cs
index 3dce3b9..2c0272c 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/MotionControlLimits.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/MotionControlLimits.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum MotionControlLimits
diff --git a/MSHALTester/Redbox/HAL/Component/Model/MoveMode.cs b/MSHALTester/Redbox/HAL/Component/Model/MoveMode.cs
index e2b0b65..b054cd7 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/MoveMode.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/MoveMode.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum MoveMode
diff --git a/MSHALTester/Redbox/HAL/Component/Model/OffsetMoveData.cs b/MSHALTester/Redbox/HAL/Component/Model/OffsetMoveData.cs
index 6d3b87d..b09e7b4 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/OffsetMoveData.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/OffsetMoveData.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public struct OffsetMoveData
diff --git a/MSHALTester/Redbox/HAL/Component/Model/PickerInputs.cs b/MSHALTester/Redbox/HAL/Component/Model/PickerInputs.cs
index 762bce3..421fff3 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/PickerInputs.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/PickerInputs.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum PickerInputs
diff --git a/MSHALTester/Redbox/HAL/Component/Model/Platform.cs b/MSHALTester/Redbox/HAL/Component/Model/Platform.cs
index 7e18c19..9735d2c 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/Platform.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/Platform.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum Platform
diff --git a/MSHALTester/Redbox/HAL/Component/Model/PowerCycleDevices.cs b/MSHALTester/Redbox/HAL/Component/Model/PowerCycleDevices.cs
index cd913de..9735b39 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/PowerCycleDevices.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/PowerCycleDevices.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum PowerCycleDevices
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ProgramPriority.cs b/MSHALTester/Redbox/HAL/Component/Model/ProgramPriority.cs
index f1e236e..46b52dc 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ProgramPriority.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ProgramPriority.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ProgramPriority
diff --git a/MSHALTester/Redbox/HAL/Component/Model/QlmStatus.cs b/MSHALTester/Redbox/HAL/Component/Model/QlmStatus.cs
index fc86a62..60ba53d 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/QlmStatus.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/QlmStatus.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum QlmStatus
diff --git a/MSHALTester/Redbox/HAL/Component/Model/RedboxHardwareErrorThreshold.cs b/MSHALTester/Redbox/HAL/Component/Model/RedboxHardwareErrorThreshold.cs
index f5bed92..32a2031 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/RedboxHardwareErrorThreshold.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/RedboxHardwareErrorThreshold.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public sealed class RedboxHardwareErrorThreshold
diff --git a/MSHALTester/Redbox/HAL/Component/Model/RollerPosition.cs b/MSHALTester/Redbox/HAL/Component/Model/RollerPosition.cs
index a29496d..efcaa8a 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/RollerPosition.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/RollerPosition.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum RollerPosition
diff --git a/MSHALTester/Redbox/HAL/Component/Model/RollerState.cs b/MSHALTester/Redbox/HAL/Component/Model/RollerState.cs
index 330fe52..613b54b 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/RollerState.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/RollerState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum RollerState
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ScannerServices.cs b/MSHALTester/Redbox/HAL/Component/Model/ScannerServices.cs
index 0de77f9..0b6e9c0 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ScannerServices.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ScannerServices.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum ScannerServices
diff --git a/MSHALTester/Redbox/HAL/Component/Model/StackEnd.cs b/MSHALTester/Redbox/HAL/Component/Model/StackEnd.cs
index 5d12813..025a75c 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/StackEnd.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/StackEnd.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum StackEnd
diff --git a/MSHALTester/Redbox/HAL/Component/Model/SystemConfigurations.cs b/MSHALTester/Redbox/HAL/Component/Model/SystemConfigurations.cs
index d1f6aeb..d7c9362 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/SystemConfigurations.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/SystemConfigurations.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum SystemConfigurations
diff --git a/MSHALTester/Redbox/HAL/Component/Model/TimeoutCounters.cs b/MSHALTester/Redbox/HAL/Component/Model/TimeoutCounters.cs
index 409779b..2569792 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/TimeoutCounters.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/TimeoutCounters.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum TimeoutCounters
diff --git a/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/StateResult.cs b/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/StateResult.cs
index cc2f6b5..1a32a3a 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/StateResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/StateResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model.Tokenizer
 {
   public enum StateResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/TokenType.cs b/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/TokenType.cs
index b82e0f5..b2f045e 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/TokenType.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/TokenType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model.Tokenizer
 {
   public enum TokenType
diff --git a/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/Tokenizer`1.cs b/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/Tokenizer`1.cs
index b37ef38..890287d 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/Tokenizer`1.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/Tokenizer/Tokenizer`1.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model.Tokenizer
 {
   public class Tokenizer<T> : TokenizerBase<T>
diff --git a/MSHALTester/Redbox/HAL/Component/Model/TrackState.cs b/MSHALTester/Redbox/HAL/Component/Model/TrackState.cs
index bd31865..f4e2490 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/TrackState.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/TrackState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum TrackState
diff --git a/MSHALTester/Redbox/HAL/Component/Model/UnzipResult.cs b/MSHALTester/Redbox/HAL/Component/Model/UnzipResult.cs
index aba7938..9a3bb93 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/UnzipResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/UnzipResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public sealed class UnzipResult
diff --git a/MSHALTester/Redbox/HAL/Component/Model/VendDoorState.cs b/MSHALTester/Redbox/HAL/Component/Model/VendDoorState.cs
index 56468d3..5515472 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/VendDoorState.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/VendDoorState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public enum VendDoorState
diff --git a/MSHALTester/Redbox/HAL/Component/Model/ZipResult.cs b/MSHALTester/Redbox/HAL/Component/Model/ZipResult.cs
index 842f53a..13df6ff 100644
--- a/MSHALTester/Redbox/HAL/Component/Model/ZipResult.cs
+++ b/MSHALTester/Redbox/HAL/Component/Model/ZipResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Component.Model
 {
   public sealed class ZipResult
diff --git a/MSHALTester/Redbox/HAL/Configuration/GampBackupResult.cs b/MSHALTester/Redbox/HAL/Configuration/GampBackupResult.cs
index d141c0c..a895891 100644
--- a/MSHALTester/Redbox/HAL/Configuration/GampBackupResult.cs
+++ b/MSHALTester/Redbox/HAL/Configuration/GampBackupResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Configuration
 {
   public sealed class GampBackupResult
diff --git a/MSHALTester/Redbox/HAL/Configuration/PlatterType.cs b/MSHALTester/Redbox/HAL/Configuration/PlatterType.cs
index 80e3157..be631fc 100644
--- a/MSHALTester/Redbox/HAL/Configuration/PlatterType.cs
+++ b/MSHALTester/Redbox/HAL/Configuration/PlatterType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Configuration
 {
   public enum PlatterType
diff --git a/MSHALTester/Redbox/HAL/Core/Descriptors/_3mHardResetCommand.cs b/MSHALTester/Redbox/HAL/Core/Descriptors/_3mHardResetCommand.cs
index 0a2bf87..38ea7d7 100644
--- a/MSHALTester/Redbox/HAL/Core/Descriptors/_3mHardResetCommand.cs
+++ b/MSHALTester/Redbox/HAL/Core/Descriptors/_3mHardResetCommand.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Core.Descriptors
 {
   internal sealed class _3mHardResetCommand : _3MResetCommand
diff --git a/MSHALTester/Redbox/HAL/Core/Descriptors/_3mSoftResetCommand.cs b/MSHALTester/Redbox/HAL/Core/Descriptors/_3mSoftResetCommand.cs
index 6d3d6bf..5389ca4 100644
--- a/MSHALTester/Redbox/HAL/Core/Descriptors/_3mSoftResetCommand.cs
+++ b/MSHALTester/Redbox/HAL/Core/Descriptors/_3mSoftResetCommand.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Core.Descriptors
 {
   internal sealed class _3mSoftResetCommand : _3MResetCommand
diff --git a/MSHALTester/Redbox/HAL/Core/NumberBases.cs b/MSHALTester/Redbox/HAL/Core/NumberBases.cs
index 64764a1..6467607 100644
--- a/MSHALTester/Redbox/HAL/Core/NumberBases.cs
+++ b/MSHALTester/Redbox/HAL/Core/NumberBases.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Core
 {
   public enum NumberBases
diff --git a/MSHALTester/Redbox/HAL/Core/NumberingSchemes.cs b/MSHALTester/Redbox/HAL/Core/NumberingSchemes.cs
index ff846ad..c3acba5 100644
--- a/MSHALTester/Redbox/HAL/Core/NumberingSchemes.cs
+++ b/MSHALTester/Redbox/HAL/Core/NumberingSchemes.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Core
 {
   public enum NumberingSchemes
diff --git a/MSHALTester/Redbox/HAL/Core/StateResult.cs b/MSHALTester/Redbox/HAL/Core/StateResult.cs
index 06cc0c7..116e90c 100644
--- a/MSHALTester/Redbox/HAL/Core/StateResult.cs
+++ b/MSHALTester/Redbox/HAL/Core/StateResult.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Core
 {
   public enum StateResult
diff --git a/MSHALTester/Redbox/HAL/Core/TokenType.cs b/MSHALTester/Redbox/HAL/Core/TokenType.cs
index 8c9d4ac..a4e1d42 100644
--- a/MSHALTester/Redbox/HAL/Core/TokenType.cs
+++ b/MSHALTester/Redbox/HAL/Core/TokenType.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Core
 {
   public enum TokenType
diff --git a/MSHALTester/Redbox/HAL/Core/Tokenizer`1.cs b/MSHALTester/Redbox/HAL/Core/Tokenizer`1.cs
index ba6aedf..bb9fc20 100644
--- a/MSHALTester/Redbox/HAL/Core/Tokenizer`1.cs
+++ b/MSHALTester/Redbox/HAL/Core/Tokenizer`1.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.Core
 {
   public class Tokenizer<T> : TokenizerBase<T>
diff --git a/MSHALTester/Redbox/HAL/IPC/Framework/BinaryEncoding.cs b/MSHALTester/Redbox/HAL/IPC/Framework/BinaryEncoding.cs
index b2e73ea..b40c9a3 100644
--- a/MSHALTester/Redbox/HAL/IPC/Framework/BinaryEncoding.cs
+++ b/MSHALTester/Redbox/HAL/IPC/Framework/BinaryEncoding.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.IPC.Framework
 {
   public enum BinaryEncoding
diff --git a/MSHALTester/Redbox/HAL/IPC/Framework/CommandParserState.cs b/MSHALTester/Redbox/HAL/IPC/Framework/CommandParserState.cs
index 9d289ab..cd7a3e7 100644
--- a/MSHALTester/Redbox/HAL/IPC/Framework/CommandParserState.cs
+++ b/MSHALTester/Redbox/HAL/IPC/Framework/CommandParserState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.IPC.Framework
 {
   public enum CommandParserState
diff --git a/MSHALTester/Redbox/HAL/IPC/Framework/CommunicationsConstants.cs b/MSHALTester/Redbox/HAL/IPC/Framework/CommunicationsConstants.cs
index d5eec62..af37ae0 100644
--- a/MSHALTester/Redbox/HAL/IPC/Framework/CommunicationsConstants.cs
+++ b/MSHALTester/Redbox/HAL/IPC/Framework/CommunicationsConstants.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.IPC.Framework
 {
   internal static class CommunicationsConstants
diff --git a/MSHALTester/Redbox/HAL/IPC/Framework/FormMethodHandler.cs b/MSHALTester/Redbox/HAL/IPC/Framework/FormMethodHandler.cs
index 9cfb8a3..f8cdac8 100644
--- a/MSHALTester/Redbox/HAL/IPC/Framework/FormMethodHandler.cs
+++ b/MSHALTester/Redbox/HAL/IPC/Framework/FormMethodHandler.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.IPC.Framework
 {
   internal delegate void FormMethodHandler(object instance, object[] values);
diff --git a/MSHALTester/Redbox/HAL/IPC/Framework/Pipes/NamedPipeServer.cs b/MSHALTester/Redbox/HAL/IPC/Framework/Pipes/NamedPipeServer.cs
index 071322c..ee7a449 100644
--- a/MSHALTester/Redbox/HAL/IPC/Framework/Pipes/NamedPipeServer.cs
+++ b/MSHALTester/Redbox/HAL/IPC/Framework/Pipes/NamedPipeServer.cs
@@ -32,7 +32,7 @@ namespace Redbox.HAL.IPC.Framework.Pipes
     private const uint NMPWAIT_WAIT_FOREVER = 4294967295;
     private const uint NMPWAIT_NOWAIT = 1;
     private const uint NMPWAIT_USE_DEFAULT_WAIT = 0;
-    private static IntPtr INVALID_HANDLE_VALUE = (IntPtr) -1;
+    private static IntPtr INVALID_HANDLE_VALUE = (IntPtr)(-1);
     private const uint SECURITY_DESCRIPTOR_REVISION = 1;
 
     public static NamedPipeServer Create(string pipeName) => new NamedPipeServer(pipeName);
diff --git a/MSHALTester/Redbox/HAL/IPC/Framework/ServerResponse.cs b/MSHALTester/Redbox/HAL/IPC/Framework/ServerResponse.cs
index f0e80d0..767b24b 100644
--- a/MSHALTester/Redbox/HAL/IPC/Framework/ServerResponse.cs
+++ b/MSHALTester/Redbox/HAL/IPC/Framework/ServerResponse.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.IPC.Framework
 {
   internal sealed class ServerResponse : AbstractIPCResponse
diff --git a/MSHALTester/Redbox/HAL/IPC/Framework/SessionConstants.cs b/MSHALTester/Redbox/HAL/IPC/Framework/SessionConstants.cs
index 0461873..13ea019 100644
--- a/MSHALTester/Redbox/HAL/IPC/Framework/SessionConstants.cs
+++ b/MSHALTester/Redbox/HAL/IPC/Framework/SessionConstants.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.IPC.Framework
 {
   internal static class SessionConstants
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/CommonFunctions.cs b/MSHALTester/Redbox/HAL/MSHALTester/CommonFunctions.cs
index 3346702..bfe5a8f 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/CommonFunctions.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/CommonFunctions.cs
@@ -29,10 +29,9 @@ namespace Redbox.HAL.MSHALTester
         {
           deckNode.ChildNodes[i].SetAttributeValue<int>("Offset", (int) nullable1.Value);
           Decimal? nullable3;
-          ref Decimal? local = ref nullable3;
           Decimal num2 = 0M;
           Decimal num3 = num2;
-          local = new Decimal?(num3);
+          nullable3 = new Decimal?(num3);
           Decimal? nullable4;
           Decimal? nullable5;
           Decimal? nullable6;
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/Configuration.cs b/MSHALTester/Redbox/HAL/MSHALTester/Configuration.cs
index 5e784d6..c8a86a0 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/Configuration.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/Configuration.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.MSHALTester
 {
   public enum Configuration
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/ConfiguredDevicesForm.cs b/MSHALTester/Redbox/HAL/MSHALTester/ConfiguredDevicesForm.cs
index ade0a78..e2c7b6f 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/ConfiguredDevicesForm.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/ConfiguredDevicesForm.cs
@@ -820,8 +820,7 @@ namespace Redbox.HAL.MSHALTester
         HardwareJobSchedule s = new HardwareJobSchedule();
         s.Priority = HardwareJobPriority.High;
         HardwareJob job;
-        ref HardwareJob local = ref job;
-        HardwareCommandResult result = service.PowerCycleRouter(s, out local);
+        HardwareCommandResult result = service.PowerCycleRouter(s, out job);
         if (result.Success)
         {
           using (ClientHelper clientHelper = new ClientHelper(this.Service))
@@ -907,8 +906,7 @@ namespace Redbox.HAL.MSHALTester
         HardwareJobSchedule schedule = new HardwareJobSchedule();
         schedule.Priority = HardwareJobPriority.High;
         HardwareJob job;
-        ref HardwareJob local = ref job;
-        if (!service.ScheduleJob("ms-take-disk-at-door", empty, false, schedule, out local).Success)
+        if (!service.ScheduleJob("ms-take-disk-at-door", empty, false, schedule, out job).Success)
         {
           this.EngineeringOutput.Write("Failed to schedule job");
         }
@@ -964,8 +962,7 @@ namespace Redbox.HAL.MSHALTester
             HardwareJobSchedule schedule = new HardwareJobSchedule();
             schedule.Priority = HardwareJobPriority.Highest;
             HardwareJob hardwareJob;
-            ref HardwareJob local = ref hardwareJob;
-            if (!service.HardSync(range, schedule, out local).Success)
+            if (!service.HardSync(range, schedule, out hardwareJob).Success)
             {
               this.EngineeringOutput.Write("Unable to communicate with HAL.");
             }
@@ -1041,8 +1038,7 @@ namespace Redbox.HAL.MSHALTester
           HardwareJobSchedule schedule = new HardwareJobSchedule();
           schedule.Priority = HardwareJobPriority.Highest;
           HardwareJob hardwareJob;
-          ref HardwareJob local = ref hardwareJob;
-          if (!service.HardSync(locations, "Engineering Location Sync", schedule, out local).Success)
+          if (!service.HardSync(locations, "Engineering Location Sync", schedule, out hardwareJob).Success)
           {
             this.EngineeringOutput.Write("Unable to communicate with HAL.");
           }
@@ -1106,8 +1102,7 @@ namespace Redbox.HAL.MSHALTester
       HardwareJobSchedule s = new HardwareJobSchedule();
       s.Priority = HardwareJobPriority.High;
       HardwareJob job;
-      ref HardwareJob local = ref job;
-      if (service.ResetTouchscreenController(s, out local).Success)
+      if (service.ResetTouchscreenController(s, out job).Success)
       {
         using (ClientHelper clientHelper = new ClientHelper(this.Service))
         {
@@ -1196,8 +1191,7 @@ namespace Redbox.HAL.MSHALTester
         HardwareJobSchedule s = new HardwareJobSchedule();
         s.Priority = HardwareJobPriority.High;
         HardwareJob job;
-        ref HardwareJob local = ref job;
-        HardwareCommandResult result = service.PowerCycleRouter(s, out local);
+        HardwareCommandResult result = service.PowerCycleRouter(s, out job);
         if (result.Success)
         {
           using (ClientHelper clientHelper = new ClientHelper(this.Service))
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/DeckConfigurationColumns.cs b/MSHALTester/Redbox/HAL/MSHALTester/DeckConfigurationColumns.cs
index 34ee302..3fe0202 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/DeckConfigurationColumns.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/DeckConfigurationColumns.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.MSHALTester
 {
   internal enum DeckConfigurationColumns
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/DeckConfigurationDetailColumns.cs b/MSHALTester/Redbox/HAL/MSHALTester/DeckConfigurationDetailColumns.cs
index 08c91db..0def184 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/DeckConfigurationDetailColumns.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/DeckConfigurationDetailColumns.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.MSHALTester
 {
   internal static class DeckConfigurationDetailColumns
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/Form1.cs b/MSHALTester/Redbox/HAL/MSHALTester/Form1.cs
index 20a324f..a19239c 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/Form1.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/Form1.cs
@@ -876,8 +876,7 @@ namespace Redbox.HAL.MSHALTester
           HardwareJobSchedule schedule = new HardwareJobSchedule();
           schedule.Priority = HardwareJobPriority.Highest;
           HardwareJob hardwareJob;
-          ref HardwareJob local = ref hardwareJob;
-          if (!hardwareService.HardSync(locations, "Tester Location Sync", schedule, out local).Success)
+          if (!hardwareService.HardSync(locations, "Tester Location Sync", schedule, out hardwareJob).Success)
           {
             this.OutputBox.Write("Unable to communicate with HAL.");
           }
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/KioskFunctionTest.cs b/MSHALTester/Redbox/HAL/MSHALTester/KioskFunctionTest.cs
index 0099502..86994e3 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/KioskFunctionTest.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/KioskFunctionTest.cs
@@ -77,8 +77,7 @@ namespace Redbox.HAL.MSHALTester
       HardwareJobSchedule schedule = new HardwareJobSchedule();
       schedule.Priority = HardwareJobPriority.Highest;
       HardwareJob job;
-      ref HardwareJob local = ref job;
-      if (!service.HardSync(locations, "KFC Test Sync", schedule, out local).Success)
+      if (!service.HardSync(locations, "KFC Test Sync", schedule, out job).Success)
       {
         this.Box.Write("Unable to communicate with HAL.");
       }
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/TestState.cs b/MSHALTester/Redbox/HAL/MSHALTester/TestState.cs
index 6c0b74e..fddba45 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/TestState.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/TestState.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.MSHALTester
 {
   internal enum TestState
diff --git a/MSHALTester/Redbox/HAL/MSHALTester/TransferLocation.cs b/MSHALTester/Redbox/HAL/MSHALTester/TransferLocation.cs
index 38bf256..b17a458 100644
--- a/MSHALTester/Redbox/HAL/MSHALTester/TransferLocation.cs
+++ b/MSHALTester/Redbox/HAL/MSHALTester/TransferLocation.cs
@@ -1,4 +1,3 @@
-#nullable disable
 namespace Redbox.HAL.MSHALTester
 {
   internal sealed class TransferLocation
diff --git a/MSHALTester/SevenZip/CRC.cs b/MSHALTester/SevenZip/CRC.cs
deleted file mode 100644
index 0830d9b..0000000
--- a/MSHALTester/SevenZip/CRC.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-using System;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public class CRC
-  {
-    public static readonly uint[] Table = new uint[256];
-    private uint _value = uint.MaxValue;
-
-    static CRC()
-    {
-      for (uint index1 = 0; index1 < 256U; ++index1)
-      {
-        uint num = index1;
-        for (int index2 = 0; index2 < 8; ++index2)
-        {
-          if (((int) num & 1) != 0)
-            num = num >> 1 ^ 3988292384U;
-          else
-            num >>= 1;
-        }
-        CRC.Table[(IntPtr) index1] = num;
-      }
-    }
-
-    public void Init() => this._value = uint.MaxValue;
-
-    public void UpdateByte(byte b)
-    {
-      this._value = CRC.Table[(int) (byte) this._value ^ (int) b] ^ this._value >> 8;
-    }
-
-    public void Update(byte[] data, uint offset, uint size)
-    {
-      for (uint index = 0; index < size; ++index)
-        this._value = CRC.Table[(int) (byte) this._value ^ (int) data[(IntPtr) (offset + index)]] ^ this._value >> 8;
-    }
-
-    public uint GetDigest() => this._value ^ uint.MaxValue;
-
-    private static uint CalculateDigest(byte[] data, uint offset, uint size)
-    {
-      CRC crc = new CRC();
-      crc.Update(data, offset, size);
-      return crc.GetDigest();
-    }
-
-    private static bool VerifyDigest(uint digest, byte[] data, uint offset, uint size)
-    {
-      return (int) CRC.CalculateDigest(data, offset, size) == (int) digest;
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/CoderPropID.cs b/MSHALTester/SevenZip/CoderPropID.cs
deleted file mode 100644
index 76b3e1d..0000000
--- a/MSHALTester/SevenZip/CoderPropID.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public enum CoderPropID
-  {
-    DictionarySize = 1024, // 0x00000400
-    UsedMemorySize = 1025, // 0x00000401
-    Order = 1026, // 0x00000402
-    PosStateBits = 1088, // 0x00000440
-    LitContextBits = 1089, // 0x00000441
-    LitPosBits = 1090, // 0x00000442
-    NumFastBytes = 1104, // 0x00000450
-    MatchFinder = 1105, // 0x00000451
-    NumPasses = 1120, // 0x00000460
-    Algorithm = 1136, // 0x00000470
-    MultiThread = 1152, // 0x00000480
-    EndMarker = 1168, // 0x00000490
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZ/BinTree.cs b/MSHALTester/SevenZip/Compression/LZ/BinTree.cs
deleted file mode 100644
index f2df22d..0000000
--- a/MSHALTester/SevenZip/Compression/LZ/BinTree.cs
+++ /dev/null
@@ -1,370 +0,0 @@
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip.Compression.LZ
-{
-  [ComVisible(true)]
-  public class BinTree : InWindow, IMatchFinder, IInWindowStream
-  {
-    private const uint kHash2Size = 1024;
-    private const uint kHash3Size = 65536;
-    private const uint kBT2HashSize = 65536;
-    private const uint kStartMaxLen = 1;
-    private const uint kHash3Offset = 1024;
-    private const uint kEmptyHashValue = 0;
-    private const uint kMaxValForNormalize = 2147483647;
-    private uint _cyclicBufferPos;
-    private uint _cyclicBufferSize;
-    private uint _matchMaxLen;
-    private uint[] _son;
-    private uint[] _hash;
-    private uint _cutValue = (uint) byte.MaxValue;
-    private uint _hashMask;
-    private uint _hashSizeSum;
-    private bool HASH_ARRAY = true;
-    private uint kNumHashDirectBytes;
-    private uint kMinMatchCheck = 4;
-    private uint kFixHashSize = 66560;
-
-    public void SetType(int numHashBytes)
-    {
-      this.HASH_ARRAY = numHashBytes > 2;
-      if (this.HASH_ARRAY)
-      {
-        this.kNumHashDirectBytes = 0U;
-        this.kMinMatchCheck = 4U;
-        this.kFixHashSize = 66560U;
-      }
-      else
-      {
-        this.kNumHashDirectBytes = 2U;
-        this.kMinMatchCheck = 3U;
-        this.kFixHashSize = 0U;
-      }
-    }
-
-    public new void SetStream(Stream stream) => base.SetStream(stream);
-
-    public new void ReleaseStream() => base.ReleaseStream();
-
-    public new void Init()
-    {
-      base.Init();
-      for (uint index = 0; index < this._hashSizeSum; ++index)
-        this._hash[(IntPtr) index] = 0U;
-      this._cyclicBufferPos = 0U;
-      this.ReduceOffsets(-1);
-    }
-
-    public new void MovePos()
-    {
-      if (++this._cyclicBufferPos >= this._cyclicBufferSize)
-        this._cyclicBufferPos = 0U;
-      base.MovePos();
-      if (this._pos != (uint) int.MaxValue)
-        return;
-      this.Normalize();
-    }
-
-    public new byte GetIndexByte(int index) => base.GetIndexByte(index);
-
-    public new uint GetMatchLen(int index, uint distance, uint limit)
-    {
-      return base.GetMatchLen(index, distance, limit);
-    }
-
-    public new uint GetNumAvailableBytes() => base.GetNumAvailableBytes();
-
-    public void Create(
-      uint historySize,
-      uint keepAddBufferBefore,
-      uint matchMaxLen,
-      uint keepAddBufferAfter)
-    {
-      if (historySize > 2147483391U)
-        throw new Exception();
-      this._cutValue = 16U + (matchMaxLen >> 1);
-      uint keepSizeReserv = (historySize + keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2U + 256U;
-      this.Create(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, keepSizeReserv);
-      this._matchMaxLen = matchMaxLen;
-      uint num1 = historySize + 1U;
-      if ((int) this._cyclicBufferSize != (int) num1)
-        this._son = new uint[(IntPtr) ((this._cyclicBufferSize = num1) * 2U)];
-      uint num2 = 65536;
-      if (this.HASH_ARRAY)
-      {
-        uint num3 = historySize - 1U;
-        uint num4 = num3 | num3 >> 1;
-        uint num5 = num4 | num4 >> 2;
-        uint num6 = num5 | num5 >> 4;
-        uint num7 = (num6 | num6 >> 8) >> 1 | (uint) ushort.MaxValue;
-        if (num7 > 16777216U)
-          num7 >>= 1;
-        this._hashMask = num7;
-        num2 = num7 + 1U + this.kFixHashSize;
-      }
-      if ((int) num2 == (int) this._hashSizeSum)
-        return;
-      this._hash = new uint[(IntPtr) (this._hashSizeSum = num2)];
-    }
-
-    public uint GetMatches(uint[] distances)
-    {
-      uint num1;
-      if (this._pos + this._matchMaxLen <= this._streamPos)
-      {
-        num1 = this._matchMaxLen;
-      }
-      else
-      {
-        num1 = this._streamPos - this._pos;
-        if (num1 < this.kMinMatchCheck)
-        {
-          this.MovePos();
-          return 0;
-        }
-      }
-      uint matches = 0;
-      uint num2 = this._pos > this._cyclicBufferSize ? this._pos - this._cyclicBufferSize : 0U;
-      uint index1 = this._bufferOffset + this._pos;
-      uint num3 = 1;
-      uint index2 = 0;
-      uint num4 = 0;
-      uint num5;
-      if (this.HASH_ARRAY)
-      {
-        uint num6 = CRC.Table[(int) this._bufferBase[(IntPtr) index1]] ^ (uint) this._bufferBase[(IntPtr) (index1 + 1U)];
-        index2 = num6 & 1023U;
-        uint num7 = num6 ^ (uint) this._bufferBase[(IntPtr) (index1 + 2U)] << 8;
-        num4 = num7 & (uint) ushort.MaxValue;
-        num5 = (num7 ^ CRC.Table[(int) this._bufferBase[(IntPtr) (index1 + 3U)]] << 5) & this._hashMask;
-      }
-      else
-        num5 = (uint) this._bufferBase[(IntPtr) index1] ^ (uint) this._bufferBase[(IntPtr) (index1 + 1U)] << 8;
-      uint num8 = this._hash[(IntPtr) (this.kFixHashSize + num5)];
-      if (this.HASH_ARRAY)
-      {
-        uint num9 = this._hash[(IntPtr) index2];
-        uint num10 = this._hash[(IntPtr) (1024U + num4)];
-        this._hash[(IntPtr) index2] = this._pos;
-        this._hash[(IntPtr) (1024U + num4)] = this._pos;
-        if (num9 > num2 && (int) this._bufferBase[(IntPtr) (this._bufferOffset + num9)] == (int) this._bufferBase[(IntPtr) index1])
-        {
-          uint[] numArray1 = distances;
-          int num11 = (int) matches;
-          uint num12 = (uint) (num11 + 1);
-          uint index3 = (uint) num11;
-          int num13;
-          num3 = (uint) (num13 = 2);
-          numArray1[(IntPtr) index3] = (uint) num13;
-          uint[] numArray2 = distances;
-          int num14 = (int) num12;
-          matches = (uint) (num14 + 1);
-          uint index4 = (uint) num14;
-          int num15 = (int) this._pos - (int) num9 - 1;
-          numArray2[(IntPtr) index4] = (uint) num15;
-        }
-        if (num10 > num2 && (int) this._bufferBase[(IntPtr) (this._bufferOffset + num10)] == (int) this._bufferBase[(IntPtr) index1])
-        {
-          if ((int) num10 == (int) num9)
-            matches -= 2U;
-          uint[] numArray3 = distances;
-          int num16 = (int) matches;
-          uint num17 = (uint) (num16 + 1);
-          uint index5 = (uint) num16;
-          int num18;
-          num3 = (uint) (num18 = 3);
-          numArray3[(IntPtr) index5] = (uint) num18;
-          uint[] numArray4 = distances;
-          int num19 = (int) num17;
-          matches = (uint) (num19 + 1);
-          uint index6 = (uint) num19;
-          int num20 = (int) this._pos - (int) num10 - 1;
-          numArray4[(IntPtr) index6] = (uint) num20;
-          num9 = num10;
-        }
-        if (matches != 0U && (int) num9 == (int) num8)
-        {
-          matches -= 2U;
-          num3 = 1U;
-        }
-      }
-      this._hash[(IntPtr) (this.kFixHashSize + num5)] = this._pos;
-      uint index7 = (uint) (((int) this._cyclicBufferPos << 1) + 1);
-      uint index8 = this._cyclicBufferPos << 1;
-      uint val2;
-      uint val1 = val2 = this.kNumHashDirectBytes;
-      if (this.kNumHashDirectBytes != 0U && num8 > num2 && (int) this._bufferBase[(IntPtr) (this._bufferOffset + num8 + this.kNumHashDirectBytes)] != (int) this._bufferBase[(IntPtr) (index1 + this.kNumHashDirectBytes)])
-      {
-        uint[] numArray5 = distances;
-        int num21 = (int) matches;
-        uint num22 = (uint) (num21 + 1);
-        uint index9 = (uint) num21;
-        int numHashDirectBytes;
-        num3 = (uint) (numHashDirectBytes = (int) this.kNumHashDirectBytes);
-        numArray5[(IntPtr) index9] = (uint) numHashDirectBytes;
-        uint[] numArray6 = distances;
-        int num23 = (int) num22;
-        matches = (uint) (num23 + 1);
-        uint index10 = (uint) num23;
-        int num24 = (int) this._pos - (int) num8 - 1;
-        numArray6[(IntPtr) index10] = (uint) num24;
-      }
-      uint cutValue = this._cutValue;
-      while (num8 > num2 && cutValue-- != 0U)
-      {
-        uint num25 = this._pos - num8;
-        uint index11 = (uint) ((num25 <= this._cyclicBufferPos ? (int) this._cyclicBufferPos - (int) num25 : (int) this._cyclicBufferPos - (int) num25 + (int) this._cyclicBufferSize) << 1);
-        uint num26 = this._bufferOffset + num8;
-        uint num27 = Math.Min(val1, val2);
-        if ((int) this._bufferBase[(IntPtr) (num26 + num27)] == (int) this._bufferBase[(IntPtr) (index1 + num27)])
-        {
-          do
-            ;
-          while ((int) ++num27 != (int) num1 && (int) this._bufferBase[(IntPtr) (num26 + num27)] == (int) this._bufferBase[(IntPtr) (index1 + num27)]);
-          if (num3 < num27)
-          {
-            uint[] numArray7 = distances;
-            int num28 = (int) matches;
-            uint num29 = (uint) (num28 + 1);
-            uint index12 = (uint) num28;
-            int num30;
-            num3 = (uint) (num30 = (int) num27);
-            numArray7[(IntPtr) index12] = (uint) num30;
-            uint[] numArray8 = distances;
-            int num31 = (int) num29;
-            matches = (uint) (num31 + 1);
-            uint index13 = (uint) num31;
-            int num32 = (int) num25 - 1;
-            numArray8[(IntPtr) index13] = (uint) num32;
-            if ((int) num27 == (int) num1)
-            {
-              this._son[(IntPtr) index8] = this._son[(IntPtr) index11];
-              this._son[(IntPtr) index7] = this._son[(IntPtr) (index11 + 1U)];
-              goto label_29;
-            }
-          }
-        }
-        if ((int) this._bufferBase[(IntPtr) (num26 + num27)] < (int) this._bufferBase[(IntPtr) (index1 + num27)])
-        {
-          this._son[(IntPtr) index8] = num8;
-          index8 = index11 + 1U;
-          num8 = this._son[(IntPtr) index8];
-          val2 = num27;
-        }
-        else
-        {
-          this._son[(IntPtr) index7] = num8;
-          index7 = index11;
-          num8 = this._son[(IntPtr) index7];
-          val1 = num27;
-        }
-      }
-      this._son[(IntPtr) index7] = this._son[(IntPtr) index8] = 0U;
-label_29:
-      this.MovePos();
-      return matches;
-    }
-
-    public void Skip(uint num)
-    {
-      do
-      {
-        uint num1;
-        if (this._pos + this._matchMaxLen <= this._streamPos)
-        {
-          num1 = this._matchMaxLen;
-        }
-        else
-        {
-          num1 = this._streamPos - this._pos;
-          if (num1 < this.kMinMatchCheck)
-          {
-            this.MovePos();
-            goto label_19;
-          }
-        }
-        uint num2 = this._pos > this._cyclicBufferSize ? this._pos - this._cyclicBufferSize : 0U;
-        uint index1 = this._bufferOffset + this._pos;
-        uint num3;
-        if (this.HASH_ARRAY)
-        {
-          uint num4 = CRC.Table[(int) this._bufferBase[(IntPtr) index1]] ^ (uint) this._bufferBase[(IntPtr) (index1 + 1U)];
-          this._hash[(IntPtr) (num4 & 1023U)] = this._pos;
-          uint num5 = num4 ^ (uint) this._bufferBase[(IntPtr) (index1 + 2U)] << 8;
-          this._hash[(IntPtr) (1024U + (num5 & (uint) ushort.MaxValue))] = this._pos;
-          num3 = (num5 ^ CRC.Table[(int) this._bufferBase[(IntPtr) (index1 + 3U)]] << 5) & this._hashMask;
-        }
-        else
-          num3 = (uint) this._bufferBase[(IntPtr) index1] ^ (uint) this._bufferBase[(IntPtr) (index1 + 1U)] << 8;
-        uint num6 = this._hash[(IntPtr) (this.kFixHashSize + num3)];
-        this._hash[(IntPtr) (this.kFixHashSize + num3)] = this._pos;
-        uint index2 = (uint) (((int) this._cyclicBufferPos << 1) + 1);
-        uint index3 = this._cyclicBufferPos << 1;
-        uint val2;
-        uint val1 = val2 = this.kNumHashDirectBytes;
-        uint cutValue = this._cutValue;
-        while (num6 > num2 && cutValue-- != 0U)
-        {
-          uint num7 = this._pos - num6;
-          uint index4 = (uint) ((num7 <= this._cyclicBufferPos ? (int) this._cyclicBufferPos - (int) num7 : (int) this._cyclicBufferPos - (int) num7 + (int) this._cyclicBufferSize) << 1);
-          uint num8 = this._bufferOffset + num6;
-          uint num9 = Math.Min(val1, val2);
-          if ((int) this._bufferBase[(IntPtr) (num8 + num9)] == (int) this._bufferBase[(IntPtr) (index1 + num9)])
-          {
-            do
-              ;
-            while ((int) ++num9 != (int) num1 && (int) this._bufferBase[(IntPtr) (num8 + num9)] == (int) this._bufferBase[(IntPtr) (index1 + num9)]);
-            if ((int) num9 == (int) num1)
-            {
-              this._son[(IntPtr) index3] = this._son[(IntPtr) index4];
-              this._son[(IntPtr) index2] = this._son[(IntPtr) (index4 + 1U)];
-              goto label_18;
-            }
-          }
-          if ((int) this._bufferBase[(IntPtr) (num8 + num9)] < (int) this._bufferBase[(IntPtr) (index1 + num9)])
-          {
-            this._son[(IntPtr) index3] = num6;
-            index3 = index4 + 1U;
-            num6 = this._son[(IntPtr) index3];
-            val2 = num9;
-          }
-          else
-          {
-            this._son[(IntPtr) index2] = num6;
-            index2 = index4;
-            num6 = this._son[(IntPtr) index2];
-            val1 = num9;
-          }
-        }
-        this._son[(IntPtr) index2] = this._son[(IntPtr) index3] = 0U;
-label_18:
-        this.MovePos();
-label_19:;
-      }
-      while (--num != 0U);
-    }
-
-    private void NormalizeLinks(uint[] items, uint numItems, uint subValue)
-    {
-      for (uint index = 0; index < numItems; ++index)
-      {
-        uint num1 = items[(IntPtr) index];
-        uint num2 = num1 > subValue ? num1 - subValue : 0U;
-        items[(IntPtr) index] = num2;
-      }
-    }
-
-    private void Normalize()
-    {
-      uint subValue = this._pos - this._cyclicBufferSize;
-      this.NormalizeLinks(this._son, this._cyclicBufferSize * 2U, subValue);
-      this.NormalizeLinks(this._hash, this._hashSizeSum, subValue);
-      this.ReduceOffsets((int) subValue);
-    }
-
-    public void SetCutValue(uint cutValue) => this._cutValue = cutValue;
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZ/IInWindowStream.cs b/MSHALTester/SevenZip/Compression/LZ/IInWindowStream.cs
deleted file mode 100644
index c340f77..0000000
--- a/MSHALTester/SevenZip/Compression/LZ/IInWindowStream.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace SevenZip.Compression.LZ
-{
-  internal interface IInWindowStream
-  {
-    void SetStream(Stream inStream);
-
-    void Init();
-
-    void ReleaseStream();
-
-    byte GetIndexByte(int index);
-
-    uint GetMatchLen(int index, uint distance, uint limit);
-
-    uint GetNumAvailableBytes();
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZ/IMatchFinder.cs b/MSHALTester/SevenZip/Compression/LZ/IMatchFinder.cs
deleted file mode 100644
index 4446cb4..0000000
--- a/MSHALTester/SevenZip/Compression/LZ/IMatchFinder.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-#nullable disable
-namespace SevenZip.Compression.LZ
-{
-  internal interface IMatchFinder : IInWindowStream
-  {
-    void Create(
-      uint historySize,
-      uint keepAddBufferBefore,
-      uint matchMaxLen,
-      uint keepAddBufferAfter);
-
-    uint GetMatches(uint[] distances);
-
-    void Skip(uint num);
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZ/InWindow.cs b/MSHALTester/SevenZip/Compression/LZ/InWindow.cs
deleted file mode 100644
index d1c3b1c..0000000
--- a/MSHALTester/SevenZip/Compression/LZ/InWindow.cs
+++ /dev/null
@@ -1,127 +0,0 @@
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip.Compression.LZ
-{
-  [ComVisible(true)]
-  public class InWindow
-  {
-    public byte[] _bufferBase;
-    private Stream _stream;
-    private uint _posLimit;
-    private bool _streamEndWasReached;
-    private uint _pointerToLastSafePosition;
-    public uint _bufferOffset;
-    public uint _blockSize;
-    public uint _pos;
-    private uint _keepSizeBefore;
-    private uint _keepSizeAfter;
-    public uint _streamPos;
-
-    public void MoveBlock()
-    {
-      uint num1 = this._bufferOffset + this._pos - this._keepSizeBefore;
-      if (num1 > 0U)
-        --num1;
-      uint num2 = this._bufferOffset + this._streamPos - num1;
-      for (uint index = 0; index < num2; ++index)
-        this._bufferBase[(IntPtr) index] = this._bufferBase[(IntPtr) (num1 + index)];
-      this._bufferOffset -= num1;
-    }
-
-    public virtual void ReadBlock()
-    {
-      if (this._streamEndWasReached)
-        return;
-      while (true)
-      {
-        do
-        {
-          int count = -(int) this._bufferOffset + (int) this._blockSize - (int) this._streamPos;
-          if (count == 0)
-            return;
-          int num = this._stream.Read(this._bufferBase, (int) this._bufferOffset + (int) this._streamPos, count);
-          if (num == 0)
-          {
-            this._posLimit = this._streamPos;
-            if (this._bufferOffset + this._posLimit > this._pointerToLastSafePosition)
-              this._posLimit = this._pointerToLastSafePosition - this._bufferOffset;
-            this._streamEndWasReached = true;
-            return;
-          }
-          this._streamPos += (uint) num;
-        }
-        while (this._streamPos < this._pos + this._keepSizeAfter);
-        this._posLimit = this._streamPos - this._keepSizeAfter;
-      }
-    }
-
-    private void Free() => this._bufferBase = (byte[]) null;
-
-    public void Create(uint keepSizeBefore, uint keepSizeAfter, uint keepSizeReserv)
-    {
-      this._keepSizeBefore = keepSizeBefore;
-      this._keepSizeAfter = keepSizeAfter;
-      uint num = keepSizeBefore + keepSizeAfter + keepSizeReserv;
-      if (this._bufferBase == null || (int) this._blockSize != (int) num)
-      {
-        this.Free();
-        this._blockSize = num;
-        this._bufferBase = new byte[(IntPtr) this._blockSize];
-      }
-      this._pointerToLastSafePosition = this._blockSize - keepSizeAfter;
-    }
-
-    public void SetStream(Stream stream) => this._stream = stream;
-
-    public void ReleaseStream() => this._stream = (Stream) null;
-
-    public void Init()
-    {
-      this._bufferOffset = 0U;
-      this._pos = 0U;
-      this._streamPos = 0U;
-      this._streamEndWasReached = false;
-      this.ReadBlock();
-    }
-
-    public void MovePos()
-    {
-      ++this._pos;
-      if (this._pos <= this._posLimit)
-        return;
-      if (this._bufferOffset + this._pos > this._pointerToLastSafePosition)
-        this.MoveBlock();
-      this.ReadBlock();
-    }
-
-    public byte GetIndexByte(int index)
-    {
-      return this._bufferBase[(long) (this._bufferOffset + this._pos) + (long) index];
-    }
-
-    public uint GetMatchLen(int index, uint distance, uint limit)
-    {
-      if (this._streamEndWasReached && (long) this._pos + (long) index + (long) limit > (long) this._streamPos)
-        limit = this._streamPos - (uint) ((ulong) this._pos + (ulong) index);
-      ++distance;
-      uint num = (uint) ((int) this._bufferOffset + (int) this._pos + index);
-      uint matchLen = 0;
-      while (matchLen < limit && (int) this._bufferBase[(IntPtr) (num + matchLen)] == (int) this._bufferBase[(IntPtr) (num + matchLen - distance)])
-        ++matchLen;
-      return matchLen;
-    }
-
-    public uint GetNumAvailableBytes() => this._streamPos - this._pos;
-
-    public void ReduceOffsets(int subValue)
-    {
-      this._bufferOffset += (uint) subValue;
-      this._posLimit -= (uint) subValue;
-      this._pos -= (uint) subValue;
-      this._streamPos -= (uint) subValue;
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZ/OutWindow.cs b/MSHALTester/SevenZip/Compression/LZ/OutWindow.cs
deleted file mode 100644
index 19063e7..0000000
--- a/MSHALTester/SevenZip/Compression/LZ/OutWindow.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip.Compression.LZ
-{
-  [ComVisible(true)]
-  public class OutWindow
-  {
-    private byte[] _buffer;
-    private uint _pos;
-    private uint _windowSize;
-    private uint _streamPos;
-    private Stream _stream;
-
-    public void Create(uint windowSize)
-    {
-      if ((int) this._windowSize != (int) windowSize)
-        this._buffer = new byte[(IntPtr) windowSize];
-      this._windowSize = windowSize;
-      this._pos = 0U;
-      this._streamPos = 0U;
-    }
-
-    public void Init(Stream stream, bool solid)
-    {
-      this.ReleaseStream();
-      this._stream = stream;
-      if (solid)
-        return;
-      this._streamPos = 0U;
-      this._pos = 0U;
-    }
-
-    public void Init(Stream stream) => this.Init(stream, false);
-
-    public void ReleaseStream()
-    {
-      this.Flush();
-      this._stream = (Stream) null;
-    }
-
-    public void Flush()
-    {
-      uint count = this._pos - this._streamPos;
-      if (count == 0U)
-        return;
-      this._stream.Write(this._buffer, (int) this._streamPos, (int) count);
-      if (this._pos >= this._windowSize)
-        this._pos = 0U;
-      this._streamPos = this._pos;
-    }
-
-    public void CopyBlock(uint distance, uint len)
-    {
-      uint num = (uint) ((int) this._pos - (int) distance - 1);
-      if (num >= this._windowSize)
-        num += this._windowSize;
-      for (; len > 0U; --len)
-      {
-        if (num >= this._windowSize)
-          num = 0U;
-        this._buffer[(IntPtr) this._pos++] = this._buffer[(IntPtr) num++];
-        if (this._pos >= this._windowSize)
-          this.Flush();
-      }
-    }
-
-    public void PutByte(byte b)
-    {
-      this._buffer[(IntPtr) this._pos++] = b;
-      if (this._pos < this._windowSize)
-        return;
-      this.Flush();
-    }
-
-    public byte GetByte(uint distance)
-    {
-      uint index = (uint) ((int) this._pos - (int) distance - 1);
-      if (index >= this._windowSize)
-        index += this._windowSize;
-      return this._buffer[(IntPtr) index];
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZMA/Base.cs b/MSHALTester/SevenZip/Compression/LZMA/Base.cs
deleted file mode 100644
index 8e57b00..0000000
--- a/MSHALTester/SevenZip/Compression/LZMA/Base.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-#nullable disable
-namespace SevenZip.Compression.LZMA
-{
-  internal abstract class Base
-  {
-    public const uint kNumRepDistances = 4;
-    public const uint kNumStates = 12;
-    public const int kNumPosSlotBits = 6;
-    public const int kDicLogSizeMin = 0;
-    public const int kNumLenToPosStatesBits = 2;
-    public const uint kNumLenToPosStates = 4;
-    public const uint kMatchMinLen = 2;
-    public const int kNumAlignBits = 4;
-    public const uint kAlignTableSize = 16;
-    public const uint kAlignMask = 15;
-    public const uint kStartPosModelIndex = 4;
-    public const uint kEndPosModelIndex = 14;
-    public const uint kNumPosModels = 10;
-    public const uint kNumFullDistances = 128;
-    public const uint kNumLitPosStatesBitsEncodingMax = 4;
-    public const uint kNumLitContextBitsMax = 8;
-    public const int kNumPosStatesBitsMax = 4;
-    public const uint kNumPosStatesMax = 16;
-    public const int kNumPosStatesBitsEncodingMax = 4;
-    public const uint kNumPosStatesEncodingMax = 16;
-    public const int kNumLowLenBits = 3;
-    public const int kNumMidLenBits = 3;
-    public const int kNumHighLenBits = 8;
-    public const uint kNumLowLenSymbols = 8;
-    public const uint kNumMidLenSymbols = 8;
-    public const uint kNumLenSymbols = 272;
-    public const uint kMatchMaxLen = 273;
-
-    public static uint GetLenToPosState(uint len)
-    {
-      len -= 2U;
-      return len < 4U ? len : 3U;
-    }
-
-    public struct State
-    {
-      public uint Index;
-
-      public void Init() => this.Index = 0U;
-
-      public void UpdateChar()
-      {
-        if (this.Index < 4U)
-          this.Index = 0U;
-        else if (this.Index < 10U)
-          this.Index -= 3U;
-        else
-          this.Index -= 6U;
-      }
-
-      public void UpdateMatch() => this.Index = this.Index < 7U ? 7U : 10U;
-
-      public void UpdateRep() => this.Index = this.Index < 7U ? 8U : 11U;
-
-      public void UpdateShortRep() => this.Index = this.Index < 7U ? 9U : 11U;
-
-      public bool IsCharState() => this.Index < 7U;
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZMA/Decoder.cs b/MSHALTester/SevenZip/Compression/LZMA/Decoder.cs
deleted file mode 100644
index 0a54ac8..0000000
--- a/MSHALTester/SevenZip/Compression/LZMA/Decoder.cs
+++ /dev/null
@@ -1,349 +0,0 @@
-using SevenZip.Compression.LZ;
-using SevenZip.Compression.RangeCoder;
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip.Compression.LZMA
-{
-  [ComVisible(true)]
-  public class Decoder : ICoder, ISetDecoderProperties
-  {
-    private OutWindow m_OutWindow = new OutWindow();
-    private SevenZip.Compression.RangeCoder.Decoder m_RangeDecoder = new SevenZip.Compression.RangeCoder.Decoder();
-    private BitDecoder[] m_IsMatchDecoders = new BitDecoder[new IntPtr(192)];
-    private BitDecoder[] m_IsRepDecoders = new BitDecoder[new IntPtr(12)];
-    private BitDecoder[] m_IsRepG0Decoders = new BitDecoder[new IntPtr(12)];
-    private BitDecoder[] m_IsRepG1Decoders = new BitDecoder[new IntPtr(12)];
-    private BitDecoder[] m_IsRepG2Decoders = new BitDecoder[new IntPtr(12)];
-    private BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[new IntPtr(192)];
-    private BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[new IntPtr(4)];
-    private BitDecoder[] m_PosDecoders = new BitDecoder[new IntPtr(114)];
-    private BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(4);
-    private Decoder.LenDecoder m_LenDecoder = new Decoder.LenDecoder();
-    private Decoder.LenDecoder m_RepLenDecoder = new Decoder.LenDecoder();
-    private Decoder.LiteralDecoder m_LiteralDecoder = new Decoder.LiteralDecoder();
-    private uint m_DictionarySize;
-    private uint m_DictionarySizeCheck;
-    private uint m_PosStateMask;
-
-    public Decoder()
-    {
-      this.m_DictionarySize = uint.MaxValue;
-      for (int index = 0; index < 4; ++index)
-        this.m_PosSlotDecoder[index] = new BitTreeDecoder(6);
-    }
-
-    private void SetDictionarySize(uint dictionarySize)
-    {
-      if ((int) this.m_DictionarySize == (int) dictionarySize)
-        return;
-      this.m_DictionarySize = dictionarySize;
-      this.m_DictionarySizeCheck = Math.Max(this.m_DictionarySize, 1U);
-      this.m_OutWindow.Create(Math.Max(this.m_DictionarySizeCheck, 4096U));
-    }
-
-    private void SetLiteralProperties(int lp, int lc)
-    {
-      if (lp > 8)
-        throw new InvalidParamException();
-      if (lc > 8)
-        throw new InvalidParamException();
-      this.m_LiteralDecoder.Create(lp, lc);
-    }
-
-    private void SetPosBitsProperties(int pb)
-    {
-      if (pb > 4)
-        throw new InvalidParamException();
-      uint numPosStates = (uint) (1 << pb);
-      this.m_LenDecoder.Create(numPosStates);
-      this.m_RepLenDecoder.Create(numPosStates);
-      this.m_PosStateMask = numPosStates - 1U;
-    }
-
-    private void Init(Stream inStream, Stream outStream)
-    {
-      this.m_RangeDecoder.Init(inStream);
-      this.m_OutWindow.Init(outStream);
-      for (uint index1 = 0; index1 < 12U; ++index1)
-      {
-        for (uint index2 = 0; index2 <= this.m_PosStateMask; ++index2)
-        {
-          uint index3 = (index1 << 4) + index2;
-          this.m_IsMatchDecoders[(IntPtr) index3].Init();
-          this.m_IsRep0LongDecoders[(IntPtr) index3].Init();
-        }
-        this.m_IsRepDecoders[(IntPtr) index1].Init();
-        this.m_IsRepG0Decoders[(IntPtr) index1].Init();
-        this.m_IsRepG1Decoders[(IntPtr) index1].Init();
-        this.m_IsRepG2Decoders[(IntPtr) index1].Init();
-      }
-      this.m_LiteralDecoder.Init();
-      for (uint index = 0; index < 4U; ++index)
-        this.m_PosSlotDecoder[(IntPtr) index].Init();
-      for (uint index = 0; index < 114U; ++index)
-        this.m_PosDecoders[(IntPtr) index].Init();
-      this.m_LenDecoder.Init();
-      this.m_RepLenDecoder.Init();
-      this.m_PosAlignDecoder.Init();
-    }
-
-    public void Code(
-      Stream inStream,
-      Stream outStream,
-      long inSize,
-      long outSize,
-      ICodeProgress progress)
-    {
-      this.Init(inStream, outStream);
-      Base.State state = new Base.State();
-      state.Init();
-      uint distance = 0;
-      uint num1 = 0;
-      uint num2 = 0;
-      uint num3 = 0;
-      ulong pos = 0;
-      ulong num4 = (ulong) outSize;
-      if (pos < num4)
-      {
-        if (this.m_IsMatchDecoders[(IntPtr) (state.Index << 4)].Decode(this.m_RangeDecoder) != 0U)
-          throw new DataErrorException();
-        state.UpdateChar();
-        this.m_OutWindow.PutByte(this.m_LiteralDecoder.DecodeNormal(this.m_RangeDecoder, 0U, (byte) 0));
-        ++pos;
-      }
-      while (pos < num4)
-      {
-        uint posState = (uint) pos & this.m_PosStateMask;
-        if (this.m_IsMatchDecoders[(IntPtr) ((state.Index << 4) + posState)].Decode(this.m_RangeDecoder) == 0U)
-        {
-          byte prevByte = this.m_OutWindow.GetByte(0U);
-          this.m_OutWindow.PutByte(state.IsCharState() ? this.m_LiteralDecoder.DecodeNormal(this.m_RangeDecoder, (uint) pos, prevByte) : this.m_LiteralDecoder.DecodeWithMatchByte(this.m_RangeDecoder, (uint) pos, prevByte, this.m_OutWindow.GetByte(distance)));
-          state.UpdateChar();
-          ++pos;
-        }
-        else
-        {
-          uint len;
-          if (this.m_IsRepDecoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 1U)
-          {
-            if (this.m_IsRepG0Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
-            {
-              if (this.m_IsRep0LongDecoders[(IntPtr) ((state.Index << 4) + posState)].Decode(this.m_RangeDecoder) == 0U)
-              {
-                state.UpdateShortRep();
-                this.m_OutWindow.PutByte(this.m_OutWindow.GetByte(distance));
-                ++pos;
-                continue;
-              }
-            }
-            else
-            {
-              uint num5;
-              if (this.m_IsRepG1Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
-              {
-                num5 = num1;
-              }
-              else
-              {
-                if (this.m_IsRepG2Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
-                {
-                  num5 = num2;
-                }
-                else
-                {
-                  num5 = num3;
-                  num3 = num2;
-                }
-                num2 = num1;
-              }
-              num1 = distance;
-              distance = num5;
-            }
-            len = this.m_RepLenDecoder.Decode(this.m_RangeDecoder, posState) + 2U;
-            state.UpdateRep();
-          }
-          else
-          {
-            num3 = num2;
-            num2 = num1;
-            num1 = distance;
-            len = 2U + this.m_LenDecoder.Decode(this.m_RangeDecoder, posState);
-            state.UpdateMatch();
-            uint num6 = this.m_PosSlotDecoder[(IntPtr) Base.GetLenToPosState(len)].Decode(this.m_RangeDecoder);
-            if (num6 >= 4U)
-            {
-              int NumBitLevels = (int) (num6 >> 1) - 1;
-              uint num7 = (uint) ((2 | (int) num6 & 1) << NumBitLevels);
-              distance = num6 >= 14U ? num7 + (this.m_RangeDecoder.DecodeDirectBits(NumBitLevels - 4) << 4) + this.m_PosAlignDecoder.ReverseDecode(this.m_RangeDecoder) : num7 + BitTreeDecoder.ReverseDecode(this.m_PosDecoders, (uint) ((int) num7 - (int) num6 - 1), this.m_RangeDecoder, NumBitLevels);
-            }
-            else
-              distance = num6;
-          }
-          if ((ulong) distance >= pos || distance >= this.m_DictionarySizeCheck)
-          {
-            if (distance != uint.MaxValue)
-              throw new DataErrorException();
-            break;
-          }
-          this.m_OutWindow.CopyBlock(distance, len);
-          pos += (ulong) len;
-        }
-      }
-      this.m_OutWindow.Flush();
-      this.m_OutWindow.ReleaseStream();
-      this.m_RangeDecoder.ReleaseStream();
-    }
-
-    public void SetDecoderProperties(byte[] properties)
-    {
-      if (properties.Length < 5)
-        throw new InvalidParamException();
-      int lc = (int) properties[0] % 9;
-      int num = (int) properties[0] / 9;
-      int lp = num % 5;
-      int pb = num / 5;
-      if (pb > 4)
-        throw new InvalidParamException();
-      uint dictionarySize = 0;
-      for (int index = 0; index < 4; ++index)
-        dictionarySize += (uint) properties[1 + index] << index * 8;
-      this.SetDictionarySize(dictionarySize);
-      this.SetLiteralProperties(lp, lc);
-      this.SetPosBitsProperties(pb);
-    }
-
-    private class LenDecoder
-    {
-      private BitDecoder m_Choice = new BitDecoder();
-      private BitDecoder m_Choice2 = new BitDecoder();
-      private BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[new IntPtr(16)];
-      private BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[new IntPtr(16)];
-      private BitTreeDecoder m_HighCoder = new BitTreeDecoder(8);
-      private uint m_NumPosStates;
-
-      public void Create(uint numPosStates)
-      {
-        for (uint numPosStates1 = this.m_NumPosStates; numPosStates1 < numPosStates; ++numPosStates1)
-        {
-          this.m_LowCoder[(IntPtr) numPosStates1] = new BitTreeDecoder(3);
-          this.m_MidCoder[(IntPtr) numPosStates1] = new BitTreeDecoder(3);
-        }
-        this.m_NumPosStates = numPosStates;
-      }
-
-      public void Init()
-      {
-        this.m_Choice.Init();
-        for (uint index = 0; index < this.m_NumPosStates; ++index)
-        {
-          this.m_LowCoder[(IntPtr) index].Init();
-          this.m_MidCoder[(IntPtr) index].Init();
-        }
-        this.m_Choice2.Init();
-        this.m_HighCoder.Init();
-      }
-
-      public uint Decode(SevenZip.Compression.RangeCoder.Decoder rangeDecoder, uint posState)
-      {
-        if (this.m_Choice.Decode(rangeDecoder) == 0U)
-          return this.m_LowCoder[(IntPtr) posState].Decode(rangeDecoder);
-        uint num = 8;
-        return this.m_Choice2.Decode(rangeDecoder) != 0U ? num + 8U + this.m_HighCoder.Decode(rangeDecoder) : num + this.m_MidCoder[(IntPtr) posState].Decode(rangeDecoder);
-      }
-    }
-
-    private class LiteralDecoder
-    {
-      private Decoder.LiteralDecoder.Decoder2[] m_Coders;
-      private int m_NumPrevBits;
-      private int m_NumPosBits;
-      private uint m_PosMask;
-
-      public void Create(int numPosBits, int numPrevBits)
-      {
-        if (this.m_Coders != null && this.m_NumPrevBits == numPrevBits && this.m_NumPosBits == numPosBits)
-          return;
-        this.m_NumPosBits = numPosBits;
-        this.m_PosMask = (uint) ((1 << numPosBits) - 1);
-        this.m_NumPrevBits = numPrevBits;
-        uint length = (uint) (1 << this.m_NumPrevBits + this.m_NumPosBits);
-        this.m_Coders = new Decoder.LiteralDecoder.Decoder2[(IntPtr) length];
-        for (uint index = 0; index < length; ++index)
-          this.m_Coders[(IntPtr) index].Create();
-      }
-
-      public void Init()
-      {
-        uint num = (uint) (1 << this.m_NumPrevBits + this.m_NumPosBits);
-        for (uint index = 0; index < num; ++index)
-          this.m_Coders[(IntPtr) index].Init();
-      }
-
-      private uint GetState(uint pos, byte prevByte)
-      {
-        return (uint) ((((int) pos & (int) this.m_PosMask) << this.m_NumPrevBits) + ((int) prevByte >> 8 - this.m_NumPrevBits));
-      }
-
-      public byte DecodeNormal(SevenZip.Compression.RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte)
-      {
-        return this.m_Coders[(IntPtr) this.GetState(pos, prevByte)].DecodeNormal(rangeDecoder);
-      }
-
-      public byte DecodeWithMatchByte(
-        SevenZip.Compression.RangeCoder.Decoder rangeDecoder,
-        uint pos,
-        byte prevByte,
-        byte matchByte)
-      {
-        return this.m_Coders[(IntPtr) this.GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte);
-      }
-
-      private struct Decoder2
-      {
-        private BitDecoder[] m_Decoders;
-
-        public void Create() => this.m_Decoders = new BitDecoder[768];
-
-        public void Init()
-        {
-          for (int index = 0; index < 768; ++index)
-            this.m_Decoders[index].Init();
-        }
-
-        public byte DecodeNormal(SevenZip.Compression.RangeCoder.Decoder rangeDecoder)
-        {
-          uint index = 1;
-          do
-          {
-            index = index << 1 | this.m_Decoders[(IntPtr) index].Decode(rangeDecoder);
-          }
-          while (index < 256U);
-          return (byte) index;
-        }
-
-        public byte DecodeWithMatchByte(SevenZip.Compression.RangeCoder.Decoder rangeDecoder, byte matchByte)
-        {
-          uint index = 1;
-          do
-          {
-            uint num1 = (uint) ((int) matchByte >> 7 & 1);
-            matchByte <<= 1;
-            uint num2 = this.m_Decoders[(IntPtr) ((uint) (1 + (int) num1 << 8) + index)].Decode(rangeDecoder);
-            index = index << 1 | num2;
-            if ((int) num1 != (int) num2)
-            {
-              while (index < 256U)
-                index = index << 1 | this.m_Decoders[(IntPtr) index].Decode(rangeDecoder);
-              break;
-            }
-          }
-          while (index < 256U);
-          return (byte) index;
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZMA/Encoder.cs b/MSHALTester/SevenZip/Compression/LZMA/Encoder.cs
deleted file mode 100644
index 60d2c61..0000000
--- a/MSHALTester/SevenZip/Compression/LZMA/Encoder.cs
+++ /dev/null
@@ -1,1336 +0,0 @@
-using SevenZip.Compression.LZ;
-using SevenZip.Compression.RangeCoder;
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip.Compression.LZMA
-{
-  [ComVisible(true)]
-  public class Encoder : ICoder, ISetCoderProperties, IWriteCoderProperties
-  {
-    private const uint kIfinityPrice = 268435455;
-    private const int kDefaultDictionaryLogSize = 22;
-    private const uint kNumFastBytesDefault = 32;
-    private const uint kNumLenSpecSymbols = 16;
-    private const uint kNumOpts = 4096;
-    private const int kPropSize = 5;
-    private static byte[] g_FastPos = new byte[2048];
-    private Base.State _state = new Base.State();
-    private byte _previousByte;
-    private uint[] _repDistances = new uint[new IntPtr(4)];
-    private Encoder.Optimal[] _optimum = new Encoder.Optimal[new IntPtr(4096)];
-    private IMatchFinder _matchFinder;
-    private SevenZip.Compression.RangeCoder.Encoder _rangeEncoder = new SevenZip.Compression.RangeCoder.Encoder();
-    private BitEncoder[] _isMatch = new BitEncoder[new IntPtr(192)];
-    private BitEncoder[] _isRep = new BitEncoder[new IntPtr(12)];
-    private BitEncoder[] _isRepG0 = new BitEncoder[new IntPtr(12)];
-    private BitEncoder[] _isRepG1 = new BitEncoder[new IntPtr(12)];
-    private BitEncoder[] _isRepG2 = new BitEncoder[new IntPtr(12)];
-    private BitEncoder[] _isRep0Long = new BitEncoder[new IntPtr(192)];
-    private BitTreeEncoder[] _posSlotEncoder = new BitTreeEncoder[new IntPtr(4)];
-    private BitEncoder[] _posEncoders = new BitEncoder[new IntPtr(114)];
-    private BitTreeEncoder _posAlignEncoder = new BitTreeEncoder(4);
-    private Encoder.LenPriceTableEncoder _lenEncoder = new Encoder.LenPriceTableEncoder();
-    private Encoder.LenPriceTableEncoder _repMatchLenEncoder = new Encoder.LenPriceTableEncoder();
-    private Encoder.LiteralEncoder _literalEncoder = new Encoder.LiteralEncoder();
-    private uint[] _matchDistances = new uint[new IntPtr(548)];
-    private uint _numFastBytes = 32;
-    private uint _longestMatchLength;
-    private uint _numDistancePairs;
-    private uint _additionalOffset;
-    private uint _optimumEndIndex;
-    private uint _optimumCurrentIndex;
-    private bool _longestMatchWasFound;
-    private uint[] _posSlotPrices = new uint[256];
-    private uint[] _distancesPrices = new uint[new IntPtr(512)];
-    private uint[] _alignPrices = new uint[new IntPtr(16)];
-    private uint _alignPriceCount;
-    private uint _distTableSize = 44;
-    private int _posStateBits = 2;
-    private uint _posStateMask = 3;
-    private int _numLiteralPosStateBits;
-    private int _numLiteralContextBits = 3;
-    private uint _dictionarySize = 4194304;
-    private uint _dictionarySizePrev = uint.MaxValue;
-    private uint _numFastBytesPrev = uint.MaxValue;
-    private long nowPos64;
-    private bool _finished;
-    private Stream _inStream;
-    private Encoder.EMatchFinderType _matchFinderType = Encoder.EMatchFinderType.BT4;
-    private bool _writeEndMark;
-    private bool _needReleaseMFStream;
-    private uint[] reps = new uint[new IntPtr(4)];
-    private uint[] repLens = new uint[new IntPtr(4)];
-    private byte[] properties = new byte[5];
-    private uint[] tempPrices = new uint[new IntPtr(128)];
-    private uint _matchPriceCount;
-    private static string[] kMatchFinderIDs = new string[2]
-    {
-      "BT2",
-      "BT4"
-    };
-
-    static Encoder()
-    {
-      int index1 = 2;
-      Encoder.g_FastPos[0] = (byte) 0;
-      Encoder.g_FastPos[1] = (byte) 1;
-      for (byte index2 = 2; index2 < (byte) 22; ++index2)
-      {
-        uint num1 = (uint) (1 << ((int) index2 >> 1) - 1);
-        uint num2 = 0;
-        while (num2 < num1)
-        {
-          Encoder.g_FastPos[index1] = index2;
-          ++num2;
-          ++index1;
-        }
-      }
-    }
-
-    private static uint GetPosSlot(uint pos)
-    {
-      if (pos < 2048U)
-        return (uint) Encoder.g_FastPos[(IntPtr) pos];
-      return pos < 2097152U ? (uint) Encoder.g_FastPos[(IntPtr) (pos >> 10)] + 20U : (uint) Encoder.g_FastPos[(IntPtr) (pos >> 20)] + 40U;
-    }
-
-    private static uint GetPosSlot2(uint pos)
-    {
-      if (pos < 131072U)
-        return (uint) Encoder.g_FastPos[(IntPtr) (pos >> 6)] + 12U;
-      return pos < 134217728U ? (uint) Encoder.g_FastPos[(IntPtr) (pos >> 16)] + 32U : (uint) Encoder.g_FastPos[(IntPtr) (pos >> 26)] + 52U;
-    }
-
-    private void BaseInit()
-    {
-      this._state.Init();
-      this._previousByte = (byte) 0;
-      for (uint index = 0; index < 4U; ++index)
-        this._repDistances[(IntPtr) index] = 0U;
-    }
-
-    private void Create()
-    {
-      if (this._matchFinder == null)
-      {
-        BinTree binTree = new BinTree();
-        int numHashBytes = 4;
-        if (this._matchFinderType == Encoder.EMatchFinderType.BT2)
-          numHashBytes = 2;
-        binTree.SetType(numHashBytes);
-        this._matchFinder = (IMatchFinder) binTree;
-      }
-      this._literalEncoder.Create(this._numLiteralPosStateBits, this._numLiteralContextBits);
-      if ((int) this._dictionarySize == (int) this._dictionarySizePrev && (int) this._numFastBytesPrev == (int) this._numFastBytes)
-        return;
-      this._matchFinder.Create(this._dictionarySize, 4096U, this._numFastBytes, 274U);
-      this._dictionarySizePrev = this._dictionarySize;
-      this._numFastBytesPrev = this._numFastBytes;
-    }
-
-    public Encoder()
-    {
-      for (int index = 0; index < 4096; ++index)
-        this._optimum[index] = new Encoder.Optimal();
-      for (int index = 0; index < 4; ++index)
-        this._posSlotEncoder[index] = new BitTreeEncoder(6);
-    }
-
-    private void SetWriteEndMarkerMode(bool writeEndMarker) => this._writeEndMark = writeEndMarker;
-
-    private void Init()
-    {
-      this.BaseInit();
-      this._rangeEncoder.Init();
-      for (uint index1 = 0; index1 < 12U; ++index1)
-      {
-        for (uint index2 = 0; index2 <= this._posStateMask; ++index2)
-        {
-          uint index3 = (index1 << 4) + index2;
-          this._isMatch[(IntPtr) index3].Init();
-          this._isRep0Long[(IntPtr) index3].Init();
-        }
-        this._isRep[(IntPtr) index1].Init();
-        this._isRepG0[(IntPtr) index1].Init();
-        this._isRepG1[(IntPtr) index1].Init();
-        this._isRepG2[(IntPtr) index1].Init();
-      }
-      this._literalEncoder.Init();
-      for (uint index = 0; index < 4U; ++index)
-        this._posSlotEncoder[(IntPtr) index].Init();
-      for (uint index = 0; index < 114U; ++index)
-        this._posEncoders[(IntPtr) index].Init();
-      this._lenEncoder.Init((uint) (1 << this._posStateBits));
-      this._repMatchLenEncoder.Init((uint) (1 << this._posStateBits));
-      this._posAlignEncoder.Init();
-      this._longestMatchWasFound = false;
-      this._optimumEndIndex = 0U;
-      this._optimumCurrentIndex = 0U;
-      this._additionalOffset = 0U;
-    }
-
-    private void ReadMatchDistances(out uint lenRes, out uint numDistancePairs)
-    {
-      lenRes = 0U;
-      numDistancePairs = this._matchFinder.GetMatches(this._matchDistances);
-      if (numDistancePairs > 0U)
-      {
-        lenRes = this._matchDistances[(IntPtr) (numDistancePairs - 2U)];
-        if ((int) lenRes == (int) this._numFastBytes)
-          lenRes += this._matchFinder.GetMatchLen((int) lenRes - 1, this._matchDistances[(IntPtr) (numDistancePairs - 1U)], 273U - lenRes);
-      }
-      ++this._additionalOffset;
-    }
-
-    private void MovePos(uint num)
-    {
-      if (num <= 0U)
-        return;
-      this._matchFinder.Skip(num);
-      this._additionalOffset += num;
-    }
-
-    private uint GetRepLen1Price(Base.State state, uint posState)
-    {
-      return this._isRepG0[(IntPtr) state.Index].GetPrice0() + this._isRep0Long[(IntPtr) ((state.Index << 4) + posState)].GetPrice0();
-    }
-
-    private uint GetPureRepPrice(uint repIndex, Base.State state, uint posState)
-    {
-      uint pureRepPrice;
-      if (repIndex == 0U)
-      {
-        pureRepPrice = this._isRepG0[(IntPtr) state.Index].GetPrice0() + this._isRep0Long[(IntPtr) ((state.Index << 4) + posState)].GetPrice1();
-      }
-      else
-      {
-        uint price1 = this._isRepG0[(IntPtr) state.Index].GetPrice1();
-        pureRepPrice = repIndex != 1U ? price1 + this._isRepG1[(IntPtr) state.Index].GetPrice1() + this._isRepG2[(IntPtr) state.Index].GetPrice(repIndex - 2U) : price1 + this._isRepG1[(IntPtr) state.Index].GetPrice0();
-      }
-      return pureRepPrice;
-    }
-
-    private uint GetRepPrice(uint repIndex, uint len, Base.State state, uint posState)
-    {
-      return this._repMatchLenEncoder.GetPrice(len - 2U, posState) + this.GetPureRepPrice(repIndex, state, posState);
-    }
-
-    private uint GetPosLenPrice(uint pos, uint len, uint posState)
-    {
-      uint lenToPosState = Base.GetLenToPosState(len);
-      return (pos >= 128U ? this._posSlotPrices[(IntPtr) ((lenToPosState << 6) + Encoder.GetPosSlot2(pos))] + this._alignPrices[(IntPtr) (pos & 15U)] : this._distancesPrices[(IntPtr) (lenToPosState * 128U + pos)]) + this._lenEncoder.GetPrice(len - 2U, posState);
-    }
-
-    private uint Backward(out uint backRes, uint cur)
-    {
-      this._optimumEndIndex = cur;
-      uint posPrev = this._optimum[(IntPtr) cur].PosPrev;
-      uint backPrev = this._optimum[(IntPtr) cur].BackPrev;
-      do
-      {
-        if (this._optimum[(IntPtr) cur].Prev1IsChar)
-        {
-          this._optimum[(IntPtr) posPrev].MakeAsChar();
-          this._optimum[(IntPtr) posPrev].PosPrev = posPrev - 1U;
-          if (this._optimum[(IntPtr) cur].Prev2)
-          {
-            this._optimum[(IntPtr) (posPrev - 1U)].Prev1IsChar = false;
-            this._optimum[(IntPtr) (posPrev - 1U)].PosPrev = this._optimum[(IntPtr) cur].PosPrev2;
-            this._optimum[(IntPtr) (posPrev - 1U)].BackPrev = this._optimum[(IntPtr) cur].BackPrev2;
-          }
-        }
-        uint index = posPrev;
-        uint num = backPrev;
-        backPrev = this._optimum[(IntPtr) index].BackPrev;
-        posPrev = this._optimum[(IntPtr) index].PosPrev;
-        this._optimum[(IntPtr) index].BackPrev = num;
-        this._optimum[(IntPtr) index].PosPrev = cur;
-        cur = index;
-      }
-      while (cur > 0U);
-      backRes = this._optimum[0].BackPrev;
-      this._optimumCurrentIndex = this._optimum[0].PosPrev;
-      return this._optimumCurrentIndex;
-    }
-
-    private uint GetOptimum(uint position, out uint backRes)
-    {
-      if ((int) this._optimumEndIndex != (int) this._optimumCurrentIndex)
-      {
-        uint optimum = this._optimum[(IntPtr) this._optimumCurrentIndex].PosPrev - this._optimumCurrentIndex;
-        backRes = this._optimum[(IntPtr) this._optimumCurrentIndex].BackPrev;
-        this._optimumCurrentIndex = this._optimum[(IntPtr) this._optimumCurrentIndex].PosPrev;
-        return optimum;
-      }
-      this._optimumCurrentIndex = this._optimumEndIndex = 0U;
-      uint lenRes1;
-      uint numDistancePairs;
-      if (!this._longestMatchWasFound)
-      {
-        this.ReadMatchDistances(out lenRes1, out numDistancePairs);
-      }
-      else
-      {
-        lenRes1 = this._longestMatchLength;
-        numDistancePairs = this._numDistancePairs;
-        this._longestMatchWasFound = false;
-      }
-      uint num1 = this._matchFinder.GetNumAvailableBytes() + 1U;
-      if (num1 < 2U)
-      {
-        backRes = uint.MaxValue;
-        return 1;
-      }
-      if (num1 > 273U)
-        ;
-      uint index1 = 0;
-      for (uint index2 = 0; index2 < 4U; ++index2)
-      {
-        this.reps[(IntPtr) index2] = this._repDistances[(IntPtr) index2];
-        this.repLens[(IntPtr) index2] = this._matchFinder.GetMatchLen(-1, this.reps[(IntPtr) index2], 273U);
-        if (this.repLens[(IntPtr) index2] > this.repLens[(IntPtr) index1])
-          index1 = index2;
-      }
-      if (this.repLens[(IntPtr) index1] >= this._numFastBytes)
-      {
-        backRes = index1;
-        uint repLen = this.repLens[(IntPtr) index1];
-        this.MovePos(repLen - 1U);
-        return repLen;
-      }
-      if (lenRes1 >= this._numFastBytes)
-      {
-        backRes = this._matchDistances[(IntPtr) (numDistancePairs - 1U)] + 4U;
-        this.MovePos(lenRes1 - 1U);
-        return lenRes1;
-      }
-      byte indexByte1 = this._matchFinder.GetIndexByte(-1);
-      byte indexByte2 = this._matchFinder.GetIndexByte(-(int) this._repDistances[0] - 1 - 1);
-      if (lenRes1 < 2U && (int) indexByte1 != (int) indexByte2 && this.repLens[(IntPtr) index1] < 2U)
-      {
-        backRes = uint.MaxValue;
-        return 1;
-      }
-      this._optimum[0].State = this._state;
-      uint posState1 = position & this._posStateMask;
-      Encoder.Optimal optimal1 = this._optimum[1];
-      int price0 = (int) this._isMatch[(IntPtr) ((this._state.Index << 4) + posState1)].GetPrice0();
-      Encoder.LiteralEncoder.Encoder2 subCoder = this._literalEncoder.GetSubCoder(position, this._previousByte);
-      int price1 = (int) subCoder.GetPrice(!this._state.IsCharState(), indexByte2, indexByte1);
-      int num2 = price0 + price1;
-      optimal1.Price = (uint) num2;
-      this._optimum[1].MakeAsChar();
-      uint price1_1 = this._isMatch[(IntPtr) ((this._state.Index << 4) + posState1)].GetPrice1();
-      uint num3 = price1_1 + this._isRep[(IntPtr) this._state.Index].GetPrice1();
-      if ((int) indexByte2 == (int) indexByte1)
-      {
-        uint num4 = num3 + this.GetRepLen1Price(this._state, posState1);
-        if (num4 < this._optimum[1].Price)
-        {
-          this._optimum[1].Price = num4;
-          this._optimum[1].MakeAsShortRep();
-        }
-      }
-      uint num5 = lenRes1 >= this.repLens[(IntPtr) index1] ? lenRes1 : this.repLens[(IntPtr) index1];
-      if (num5 < 2U)
-      {
-        backRes = this._optimum[1].BackPrev;
-        return 1;
-      }
-      this._optimum[1].PosPrev = 0U;
-      this._optimum[0].Backs0 = this.reps[0];
-      this._optimum[0].Backs1 = this.reps[1];
-      this._optimum[0].Backs2 = this.reps[2];
-      this._optimum[0].Backs3 = this.reps[3];
-      uint num6 = num5;
-      do
-      {
-        this._optimum[(IntPtr) num6--].Price = 268435455U;
-      }
-      while (num6 >= 2U);
-      for (uint repIndex = 0; repIndex < 4U; ++repIndex)
-      {
-        uint repLen = this.repLens[(IntPtr) repIndex];
-        if (repLen >= 2U)
-        {
-          uint num7 = num3 + this.GetPureRepPrice(repIndex, this._state, posState1);
-          do
-          {
-            uint num8 = num7 + this._repMatchLenEncoder.GetPrice(repLen - 2U, posState1);
-            Encoder.Optimal optimal2 = this._optimum[(IntPtr) repLen];
-            if (num8 < optimal2.Price)
-            {
-              optimal2.Price = num8;
-              optimal2.PosPrev = 0U;
-              optimal2.BackPrev = repIndex;
-              optimal2.Prev1IsChar = false;
-            }
-          }
-          while (--repLen >= 2U);
-        }
-      }
-      uint num9 = price1_1 + this._isRep[(IntPtr) this._state.Index].GetPrice0();
-      uint len = this.repLens[0] >= 2U ? this.repLens[0] + 1U : 2U;
-      if (len <= lenRes1)
-      {
-        uint index3 = 0;
-        while (len > this._matchDistances[(IntPtr) index3])
-          index3 += 2U;
-        while (true)
-        {
-          uint matchDistance = this._matchDistances[(IntPtr) (index3 + 1U)];
-          uint num10 = num9 + this.GetPosLenPrice(matchDistance, len, posState1);
-          Encoder.Optimal optimal3 = this._optimum[(IntPtr) len];
-          if (num10 < optimal3.Price)
-          {
-            optimal3.Price = num10;
-            optimal3.PosPrev = 0U;
-            optimal3.BackPrev = matchDistance + 4U;
-            optimal3.Prev1IsChar = false;
-          }
-          if ((int) len == (int) this._matchDistances[(IntPtr) index3])
-          {
-            index3 += 2U;
-            if ((int) index3 == (int) numDistancePairs)
-              break;
-          }
-          ++len;
-        }
-      }
-      uint cur = 0;
-label_45:
-      uint lenRes2;
-      Base.State state1;
-      uint posState2;
-      uint num11;
-      uint num12;
-      uint num13;
-      do
-      {
-        byte indexByte3;
-        byte indexByte4;
-        uint num14;
-        bool flag;
-        uint num15;
-        uint limit1;
-        do
-        {
-          ++cur;
-          if ((int) cur == (int) num5)
-            return this.Backward(out backRes, cur);
-          this.ReadMatchDistances(out lenRes2, out numDistancePairs);
-          if (lenRes2 >= this._numFastBytes)
-          {
-            this._numDistancePairs = numDistancePairs;
-            this._longestMatchLength = lenRes2;
-            this._longestMatchWasFound = true;
-            return this.Backward(out backRes, cur);
-          }
-          ++position;
-          uint index4 = this._optimum[(IntPtr) cur].PosPrev;
-          if (this._optimum[(IntPtr) cur].Prev1IsChar)
-          {
-            --index4;
-            if (this._optimum[(IntPtr) cur].Prev2)
-            {
-              state1 = this._optimum[(IntPtr) this._optimum[(IntPtr) cur].PosPrev2].State;
-              if (this._optimum[(IntPtr) cur].BackPrev2 < 4U)
-                state1.UpdateRep();
-              else
-                state1.UpdateMatch();
-            }
-            else
-              state1 = this._optimum[(IntPtr) index4].State;
-            state1.UpdateChar();
-          }
-          else
-            state1 = this._optimum[(IntPtr) index4].State;
-          if ((int) index4 == (int) cur - 1)
-          {
-            if (this._optimum[(IntPtr) cur].IsShortRep())
-              state1.UpdateShortRep();
-            else
-              state1.UpdateChar();
-          }
-          else
-          {
-            uint num16;
-            if (this._optimum[(IntPtr) cur].Prev1IsChar && this._optimum[(IntPtr) cur].Prev2)
-            {
-              index4 = this._optimum[(IntPtr) cur].PosPrev2;
-              num16 = this._optimum[(IntPtr) cur].BackPrev2;
-              state1.UpdateRep();
-            }
-            else
-            {
-              num16 = this._optimum[(IntPtr) cur].BackPrev;
-              if (num16 < 4U)
-                state1.UpdateRep();
-              else
-                state1.UpdateMatch();
-            }
-            Encoder.Optimal optimal4 = this._optimum[(IntPtr) index4];
-            if (num16 < 4U)
-            {
-              switch (num16)
-              {
-                case 0:
-                  this.reps[0] = optimal4.Backs0;
-                  this.reps[1] = optimal4.Backs1;
-                  this.reps[2] = optimal4.Backs2;
-                  this.reps[3] = optimal4.Backs3;
-                  break;
-                case 1:
-                  this.reps[0] = optimal4.Backs1;
-                  this.reps[1] = optimal4.Backs0;
-                  this.reps[2] = optimal4.Backs2;
-                  this.reps[3] = optimal4.Backs3;
-                  break;
-                case 2:
-                  this.reps[0] = optimal4.Backs2;
-                  this.reps[1] = optimal4.Backs0;
-                  this.reps[2] = optimal4.Backs1;
-                  this.reps[3] = optimal4.Backs3;
-                  break;
-                default:
-                  this.reps[0] = optimal4.Backs3;
-                  this.reps[1] = optimal4.Backs0;
-                  this.reps[2] = optimal4.Backs1;
-                  this.reps[3] = optimal4.Backs2;
-                  break;
-              }
-            }
-            else
-            {
-              this.reps[0] = num16 - 4U;
-              this.reps[1] = optimal4.Backs0;
-              this.reps[2] = optimal4.Backs1;
-              this.reps[3] = optimal4.Backs2;
-            }
-          }
-          this._optimum[(IntPtr) cur].State = state1;
-          this._optimum[(IntPtr) cur].Backs0 = this.reps[0];
-          this._optimum[(IntPtr) cur].Backs1 = this.reps[1];
-          this._optimum[(IntPtr) cur].Backs2 = this.reps[2];
-          this._optimum[(IntPtr) cur].Backs3 = this.reps[3];
-          uint price2 = this._optimum[(IntPtr) cur].Price;
-          indexByte3 = this._matchFinder.GetIndexByte(-1);
-          indexByte4 = this._matchFinder.GetIndexByte(-(int) this.reps[0] - 1 - 1);
-          posState2 = position & this._posStateMask;
-          int num17 = (int) price2 + (int) this._isMatch[(IntPtr) ((state1.Index << 4) + posState2)].GetPrice0();
-          subCoder = this._literalEncoder.GetSubCoder(position, this._matchFinder.GetIndexByte(-2));
-          int price3 = (int) subCoder.GetPrice(!state1.IsCharState(), indexByte4, indexByte3);
-          num14 = (uint) (num17 + price3);
-          Encoder.Optimal optimal5 = this._optimum[(IntPtr) (cur + 1U)];
-          flag = false;
-          if (num14 < optimal5.Price)
-          {
-            optimal5.Price = num14;
-            optimal5.PosPrev = cur;
-            optimal5.MakeAsChar();
-            flag = true;
-          }
-          num11 = price2 + this._isMatch[(IntPtr) ((state1.Index << 4) + posState2)].GetPrice1();
-          num15 = num11 + this._isRep[(IntPtr) state1.Index].GetPrice1();
-          if ((int) indexByte4 == (int) indexByte3 && (optimal5.PosPrev >= cur || optimal5.BackPrev != 0U))
-          {
-            uint num18 = num15 + this.GetRepLen1Price(state1, posState2);
-            if (num18 <= optimal5.Price)
-            {
-              optimal5.Price = num18;
-              optimal5.PosPrev = cur;
-              optimal5.MakeAsShortRep();
-              flag = true;
-            }
-          }
-          uint val2 = this._matchFinder.GetNumAvailableBytes() + 1U;
-          num12 = Math.Min(4095U - cur, val2);
-          limit1 = num12;
-        }
-        while (limit1 < 2U);
-        if (limit1 > this._numFastBytes)
-          limit1 = this._numFastBytes;
-        if (!flag && (int) indexByte4 != (int) indexByte3)
-        {
-          uint matchLen = this._matchFinder.GetMatchLen(0, this.reps[0], Math.Min(num12 - 1U, this._numFastBytes));
-          if (matchLen >= 2U)
-          {
-            Base.State state2 = state1;
-            state2.UpdateChar();
-            uint posState3 = position + 1U & this._posStateMask;
-            uint num19 = num14 + this._isMatch[(IntPtr) ((state2.Index << 4) + posState3)].GetPrice1() + this._isRep[(IntPtr) state2.Index].GetPrice1();
-            uint index5 = cur + 1U + matchLen;
-            while (num5 < index5)
-              this._optimum[(IntPtr) ++num5].Price = 268435455U;
-            uint num20 = num19 + this.GetRepPrice(0U, matchLen, state2, posState3);
-            Encoder.Optimal optimal6 = this._optimum[(IntPtr) index5];
-            if (num20 < optimal6.Price)
-            {
-              optimal6.Price = num20;
-              optimal6.PosPrev = cur + 1U;
-              optimal6.BackPrev = 0U;
-              optimal6.Prev1IsChar = true;
-              optimal6.Prev2 = false;
-            }
-          }
-        }
-        num13 = 2U;
-        for (uint repIndex = 0; repIndex < 4U; ++repIndex)
-        {
-          uint matchLen1 = this._matchFinder.GetMatchLen(-1, this.reps[(IntPtr) repIndex], limit1);
-          if (matchLen1 >= 2U)
-          {
-            uint num21 = matchLen1;
-            do
-            {
-              while (num5 < cur + matchLen1)
-                this._optimum[(IntPtr) ++num5].Price = 268435455U;
-              uint num22 = num15 + this.GetRepPrice(repIndex, matchLen1, state1, posState2);
-              Encoder.Optimal optimal7 = this._optimum[(IntPtr) (cur + matchLen1)];
-              if (num22 < optimal7.Price)
-              {
-                optimal7.Price = num22;
-                optimal7.PosPrev = cur;
-                optimal7.BackPrev = repIndex;
-                optimal7.Prev1IsChar = false;
-              }
-            }
-            while (--matchLen1 >= 2U);
-            uint num23 = num21;
-            if (repIndex == 0U)
-              num13 = num23 + 1U;
-            if (num23 < num12)
-            {
-              uint limit2 = Math.Min(num12 - 1U - num23, this._numFastBytes);
-              uint matchLen2 = this._matchFinder.GetMatchLen((int) num23, this.reps[(IntPtr) repIndex], limit2);
-              if (matchLen2 >= 2U)
-              {
-                Base.State state3 = state1;
-                state3.UpdateRep();
-                uint num24 = position + num23 & this._posStateMask;
-                int num25 = (int) num15 + (int) this.GetRepPrice(repIndex, num23, state1, posState2) + (int) this._isMatch[(IntPtr) ((state3.Index << 4) + num24)].GetPrice0();
-                subCoder = this._literalEncoder.GetSubCoder(position + num23, this._matchFinder.GetIndexByte((int) num23 - 1 - 1));
-                int price4 = (int) subCoder.GetPrice(true, this._matchFinder.GetIndexByte((int) num23 - 1 - ((int) this.reps[(IntPtr) repIndex] + 1)), this._matchFinder.GetIndexByte((int) num23 - 1));
-                uint num26 = (uint) (num25 + price4);
-                state3.UpdateChar();
-                uint posState4 = (uint) ((int) position + (int) num23 + 1) & this._posStateMask;
-                uint num27 = num26 + this._isMatch[(IntPtr) ((state3.Index << 4) + posState4)].GetPrice1() + this._isRep[(IntPtr) state3.Index].GetPrice1();
-                uint num28 = num23 + 1U + matchLen2;
-                while (num5 < cur + num28)
-                  this._optimum[(IntPtr) ++num5].Price = 268435455U;
-                uint num29 = num27 + this.GetRepPrice(0U, matchLen2, state3, posState4);
-                Encoder.Optimal optimal8 = this._optimum[(IntPtr) (cur + num28)];
-                if (num29 < optimal8.Price)
-                {
-                  optimal8.Price = num29;
-                  optimal8.PosPrev = (uint) ((int) cur + (int) num23 + 1);
-                  optimal8.BackPrev = 0U;
-                  optimal8.Prev1IsChar = true;
-                  optimal8.Prev2 = true;
-                  optimal8.PosPrev2 = cur;
-                  optimal8.BackPrev2 = repIndex;
-                }
-              }
-            }
-          }
-        }
-        if (lenRes2 > limit1)
-        {
-          lenRes2 = limit1;
-          uint index6 = 0;
-          while (lenRes2 > this._matchDistances[(IntPtr) index6])
-            index6 += 2U;
-          this._matchDistances[(IntPtr) index6] = lenRes2;
-          numDistancePairs = index6 + 2U;
-        }
-      }
-      while (lenRes2 < num13);
-      uint num30 = num11 + this._isRep[(IntPtr) state1.Index].GetPrice0();
-      while (num5 < cur + lenRes2)
-        this._optimum[(IntPtr) ++num5].Price = 268435455U;
-      uint index7 = 0;
-      while (num13 > this._matchDistances[(IntPtr) index7])
-        index7 += 2U;
-      uint num31 = num13;
-      while (true)
-      {
-        uint matchDistance = this._matchDistances[(IntPtr) (index7 + 1U)];
-        uint num32 = num30 + this.GetPosLenPrice(matchDistance, num31, posState2);
-        Encoder.Optimal optimal9 = this._optimum[(IntPtr) (cur + num31)];
-        if (num32 < optimal9.Price)
-        {
-          optimal9.Price = num32;
-          optimal9.PosPrev = cur;
-          optimal9.BackPrev = matchDistance + 4U;
-          optimal9.Prev1IsChar = false;
-        }
-        if ((int) num31 == (int) this._matchDistances[(IntPtr) index7])
-        {
-          if (num31 < num12)
-          {
-            uint limit = Math.Min(num12 - 1U - num31, this._numFastBytes);
-            uint matchLen = this._matchFinder.GetMatchLen((int) num31, matchDistance, limit);
-            if (matchLen >= 2U)
-            {
-              Base.State state4 = state1;
-              state4.UpdateMatch();
-              uint num33 = position + num31 & this._posStateMask;
-              int num34 = (int) num32 + (int) this._isMatch[(IntPtr) ((state4.Index << 4) + num33)].GetPrice0();
-              subCoder = this._literalEncoder.GetSubCoder(position + num31, this._matchFinder.GetIndexByte((int) num31 - 1 - 1));
-              int price5 = (int) subCoder.GetPrice(true, this._matchFinder.GetIndexByte((int) num31 - ((int) matchDistance + 1) - 1), this._matchFinder.GetIndexByte((int) num31 - 1));
-              uint num35 = (uint) (num34 + price5);
-              state4.UpdateChar();
-              uint posState5 = (uint) ((int) position + (int) num31 + 1) & this._posStateMask;
-              uint num36 = num35 + this._isMatch[(IntPtr) ((state4.Index << 4) + posState5)].GetPrice1() + this._isRep[(IntPtr) state4.Index].GetPrice1();
-              uint num37 = num31 + 1U + matchLen;
-              while (num5 < cur + num37)
-                this._optimum[(IntPtr) ++num5].Price = 268435455U;
-              uint num38 = num36 + this.GetRepPrice(0U, matchLen, state4, posState5);
-              Encoder.Optimal optimal10 = this._optimum[(IntPtr) (cur + num37)];
-              if (num38 < optimal10.Price)
-              {
-                optimal10.Price = num38;
-                optimal10.PosPrev = (uint) ((int) cur + (int) num31 + 1);
-                optimal10.BackPrev = 0U;
-                optimal10.Prev1IsChar = true;
-                optimal10.Prev2 = true;
-                optimal10.PosPrev2 = cur;
-                optimal10.BackPrev2 = matchDistance + 4U;
-              }
-            }
-          }
-          index7 += 2U;
-          if ((int) index7 == (int) numDistancePairs)
-            goto label_45;
-        }
-        ++num31;
-      }
-    }
-
-    private bool ChangePair(uint smallDist, uint bigDist)
-    {
-      return smallDist < 33554432U && bigDist >= smallDist << 7;
-    }
-
-    private void WriteEndMarker(uint posState)
-    {
-      if (!this._writeEndMark)
-        return;
-      this._isMatch[(IntPtr) ((this._state.Index << 4) + posState)].Encode(this._rangeEncoder, 1U);
-      this._isRep[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 0U);
-      this._state.UpdateMatch();
-      uint len = 2;
-      this._lenEncoder.Encode(this._rangeEncoder, len - 2U, posState);
-      uint symbol = 63;
-      this._posSlotEncoder[(IntPtr) Base.GetLenToPosState(len)].Encode(this._rangeEncoder, symbol);
-      int num1 = 30;
-      uint num2 = (uint) ((1 << num1) - 1);
-      this._rangeEncoder.EncodeDirectBits(num2 >> 4, num1 - 4);
-      this._posAlignEncoder.ReverseEncode(this._rangeEncoder, num2 & 15U);
-    }
-
-    private void Flush(uint nowPos)
-    {
-      this.ReleaseMFStream();
-      this.WriteEndMarker(nowPos & this._posStateMask);
-      this._rangeEncoder.FlushData();
-      this._rangeEncoder.FlushStream();
-    }
-
-    public void CodeOneBlock(out long inSize, out long outSize, out bool finished)
-    {
-      inSize = 0L;
-      outSize = 0L;
-      finished = true;
-      if (this._inStream != null)
-      {
-        this._matchFinder.SetStream(this._inStream);
-        this._matchFinder.Init();
-        this._needReleaseMFStream = true;
-        this._inStream = (Stream) null;
-      }
-      if (this._finished)
-        return;
-      this._finished = true;
-      long nowPos64 = this.nowPos64;
-      if (this.nowPos64 == 0L)
-      {
-        if (this._matchFinder.GetNumAvailableBytes() == 0U)
-        {
-          this.Flush((uint) this.nowPos64);
-          return;
-        }
-        this.ReadMatchDistances(out uint _, out uint _);
-        this._isMatch[(IntPtr) ((this._state.Index << 4) + ((uint) this.nowPos64 & this._posStateMask))].Encode(this._rangeEncoder, 0U);
-        this._state.UpdateChar();
-        byte indexByte = this._matchFinder.GetIndexByte(-(int) this._additionalOffset);
-        this._literalEncoder.GetSubCoder((uint) this.nowPos64, this._previousByte).Encode(this._rangeEncoder, indexByte);
-        this._previousByte = indexByte;
-        --this._additionalOffset;
-        ++this.nowPos64;
-      }
-      if (this._matchFinder.GetNumAvailableBytes() == 0U)
-      {
-        this.Flush((uint) this.nowPos64);
-      }
-      else
-      {
-        do
-        {
-          do
-          {
-            uint backRes;
-            uint optimum = this.GetOptimum((uint) this.nowPos64, out backRes);
-            uint posState = (uint) this.nowPos64 & this._posStateMask;
-            uint index1 = (this._state.Index << 4) + posState;
-            if (optimum == 1U && backRes == uint.MaxValue)
-            {
-              this._isMatch[(IntPtr) index1].Encode(this._rangeEncoder, 0U);
-              byte indexByte1 = this._matchFinder.GetIndexByte(-(int) this._additionalOffset);
-              Encoder.LiteralEncoder.Encoder2 subCoder = this._literalEncoder.GetSubCoder((uint) this.nowPos64, this._previousByte);
-              if (!this._state.IsCharState())
-              {
-                byte indexByte2 = this._matchFinder.GetIndexByte(-(int) this._repDistances[0] - 1 - (int) this._additionalOffset);
-                subCoder.EncodeMatched(this._rangeEncoder, indexByte2, indexByte1);
-              }
-              else
-                subCoder.Encode(this._rangeEncoder, indexByte1);
-              this._previousByte = indexByte1;
-              this._state.UpdateChar();
-            }
-            else
-            {
-              this._isMatch[(IntPtr) index1].Encode(this._rangeEncoder, 1U);
-              if (backRes < 4U)
-              {
-                this._isRep[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 1U);
-                if (backRes == 0U)
-                {
-                  this._isRepG0[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 0U);
-                  if (optimum == 1U)
-                    this._isRep0Long[(IntPtr) index1].Encode(this._rangeEncoder, 0U);
-                  else
-                    this._isRep0Long[(IntPtr) index1].Encode(this._rangeEncoder, 1U);
-                }
-                else
-                {
-                  this._isRepG0[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 1U);
-                  if (backRes == 1U)
-                  {
-                    this._isRepG1[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 0U);
-                  }
-                  else
-                  {
-                    this._isRepG1[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 1U);
-                    this._isRepG2[(IntPtr) this._state.Index].Encode(this._rangeEncoder, backRes - 2U);
-                  }
-                }
-                if (optimum == 1U)
-                {
-                  this._state.UpdateShortRep();
-                }
-                else
-                {
-                  this._repMatchLenEncoder.Encode(this._rangeEncoder, optimum - 2U, posState);
-                  this._state.UpdateRep();
-                }
-                uint repDistance = this._repDistances[(IntPtr) backRes];
-                if (backRes != 0U)
-                {
-                  for (uint index2 = backRes; index2 >= 1U; --index2)
-                    this._repDistances[(IntPtr) index2] = this._repDistances[(IntPtr) (index2 - 1U)];
-                  this._repDistances[0] = repDistance;
-                }
-              }
-              else
-              {
-                this._isRep[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 0U);
-                this._state.UpdateMatch();
-                this._lenEncoder.Encode(this._rangeEncoder, optimum - 2U, posState);
-                backRes -= 4U;
-                uint posSlot = Encoder.GetPosSlot(backRes);
-                this._posSlotEncoder[(IntPtr) Base.GetLenToPosState(optimum)].Encode(this._rangeEncoder, posSlot);
-                if (posSlot >= 4U)
-                {
-                  int NumBitLevels = (int) (posSlot >> 1) - 1;
-                  uint num = (uint) ((2 | (int) posSlot & 1) << NumBitLevels);
-                  uint symbol = backRes - num;
-                  if (posSlot < 14U)
-                  {
-                    BitTreeEncoder.ReverseEncode(this._posEncoders, (uint) ((int) num - (int) posSlot - 1), this._rangeEncoder, NumBitLevels, symbol);
-                  }
-                  else
-                  {
-                    this._rangeEncoder.EncodeDirectBits(symbol >> 4, NumBitLevels - 4);
-                    this._posAlignEncoder.ReverseEncode(this._rangeEncoder, symbol & 15U);
-                    ++this._alignPriceCount;
-                  }
-                }
-                uint num1 = backRes;
-                for (uint index3 = 3; index3 >= 1U; --index3)
-                  this._repDistances[(IntPtr) index3] = this._repDistances[(IntPtr) (index3 - 1U)];
-                this._repDistances[0] = num1;
-                ++this._matchPriceCount;
-              }
-              this._previousByte = this._matchFinder.GetIndexByte((int) optimum - 1 - (int) this._additionalOffset);
-            }
-            this._additionalOffset -= optimum;
-            this.nowPos64 += (long) optimum;
-          }
-          while (this._additionalOffset != 0U);
-          if (this._matchPriceCount >= 128U)
-            this.FillDistancesPrices();
-          if (this._alignPriceCount >= 16U)
-            this.FillAlignPrices();
-          inSize = this.nowPos64;
-          outSize = this._rangeEncoder.GetProcessedSizeAdd();
-          if (this._matchFinder.GetNumAvailableBytes() == 0U)
-          {
-            this.Flush((uint) this.nowPos64);
-            return;
-          }
-        }
-        while (this.nowPos64 - nowPos64 < 4096L);
-        this._finished = false;
-        finished = false;
-      }
-    }
-
-    private void ReleaseMFStream()
-    {
-      if (this._matchFinder == null || !this._needReleaseMFStream)
-        return;
-      this._matchFinder.ReleaseStream();
-      this._needReleaseMFStream = false;
-    }
-
-    private void SetOutStream(Stream outStream) => this._rangeEncoder.SetStream(outStream);
-
-    private void ReleaseOutStream() => this._rangeEncoder.ReleaseStream();
-
-    private void ReleaseStreams()
-    {
-      this.ReleaseMFStream();
-      this.ReleaseOutStream();
-    }
-
-    private void SetStreams(Stream inStream, Stream outStream, long inSize, long outSize)
-    {
-      this._inStream = inStream;
-      this._finished = false;
-      this.Create();
-      this.SetOutStream(outStream);
-      this.Init();
-      this.FillDistancesPrices();
-      this.FillAlignPrices();
-      this._lenEncoder.SetTableSize((uint) ((int) this._numFastBytes + 1 - 2));
-      this._lenEncoder.UpdateTables((uint) (1 << this._posStateBits));
-      this._repMatchLenEncoder.SetTableSize((uint) ((int) this._numFastBytes + 1 - 2));
-      this._repMatchLenEncoder.UpdateTables((uint) (1 << this._posStateBits));
-      this.nowPos64 = 0L;
-    }
-
-    public void Code(
-      Stream inStream,
-      Stream outStream,
-      long inSize,
-      long outSize,
-      ICodeProgress progress)
-    {
-      this._needReleaseMFStream = false;
-      try
-      {
-        this.SetStreams(inStream, outStream, inSize, outSize);
-        while (true)
-        {
-          long inSize1;
-          long outSize1;
-          do
-          {
-            bool finished;
-            this.CodeOneBlock(out inSize1, out outSize1, out finished);
-            if (finished)
-              goto label_3;
-          }
-          while (progress == null);
-          progress.SetProgress(inSize1, outSize1);
-        }
-label_3:;
-      }
-      finally
-      {
-        this.ReleaseStreams();
-      }
-    }
-
-    public void WriteCoderProperties(Stream outStream)
-    {
-      this.properties[0] = (byte) ((this._posStateBits * 5 + this._numLiteralPosStateBits) * 9 + this._numLiteralContextBits);
-      for (int index = 0; index < 4; ++index)
-        this.properties[1 + index] = (byte) (this._dictionarySize >> 8 * index);
-      outStream.Write(this.properties, 0, 5);
-    }
-
-    private void FillDistancesPrices()
-    {
-      for (uint pos = 4; pos < 128U; ++pos)
-      {
-        uint posSlot = Encoder.GetPosSlot(pos);
-        int NumBitLevels = (int) (posSlot >> 1) - 1;
-        uint num = (uint) ((2 | (int) posSlot & 1) << NumBitLevels);
-        this.tempPrices[(IntPtr) pos] = BitTreeEncoder.ReverseGetPrice(this._posEncoders, (uint) ((int) num - (int) posSlot - 1), NumBitLevels, pos - num);
-      }
-      for (uint index1 = 0; index1 < 4U; ++index1)
-      {
-        BitTreeEncoder bitTreeEncoder = this._posSlotEncoder[(IntPtr) index1];
-        uint num1 = index1 << 6;
-        for (uint symbol = 0; symbol < this._distTableSize; ++symbol)
-          this._posSlotPrices[(IntPtr) (num1 + symbol)] = bitTreeEncoder.GetPrice(symbol);
-        for (uint index2 = 14; index2 < this._distTableSize; ++index2)
-          this._posSlotPrices[(IntPtr) (num1 + index2)] += (uint) ((int) (index2 >> 1) - 1 - 4 << 6);
-        uint num2 = index1 * 128U;
-        uint pos;
-        for (pos = 0U; pos < 4U; ++pos)
-          this._distancesPrices[(IntPtr) (num2 + pos)] = this._posSlotPrices[(IntPtr) (num1 + pos)];
-        for (; pos < 128U; ++pos)
-          this._distancesPrices[(IntPtr) (num2 + pos)] = this._posSlotPrices[(IntPtr) (num1 + Encoder.GetPosSlot(pos))] + this.tempPrices[(IntPtr) pos];
-      }
-      this._matchPriceCount = 0U;
-    }
-
-    private void FillAlignPrices()
-    {
-      for (uint symbol = 0; symbol < 16U; ++symbol)
-        this._alignPrices[(IntPtr) symbol] = this._posAlignEncoder.ReverseGetPrice(symbol);
-      this._alignPriceCount = 0U;
-    }
-
-    private static int FindMatchFinder(string s)
-    {
-      for (int matchFinder = 0; matchFinder < Encoder.kMatchFinderIDs.Length; ++matchFinder)
-      {
-        if (s == Encoder.kMatchFinderIDs[matchFinder])
-          return matchFinder;
-      }
-      return -1;
-    }
-
-    public void SetCoderProperties(CoderPropID[] propIDs, object[] properties)
-    {
-      for (uint index = 0; (long) index < (long) properties.Length; ++index)
-      {
-        object property = properties[(IntPtr) index];
-        switch (propIDs[(IntPtr) index])
-        {
-          case CoderPropID.DictionarySize:
-            if (!(property is int num1))
-              throw new InvalidParamException();
-            this._dictionarySize = num1 >= 1 && num1 <= 1073741824 ? (uint) num1 : throw new InvalidParamException();
-            int num2 = 0;
-            while (num2 < 30 && (long) num1 > (long) (uint) (1 << num2))
-              ++num2;
-            this._distTableSize = (uint) (num2 * 2);
-            continue;
-          case CoderPropID.PosStateBits:
-            if (!(property is int num3))
-              throw new InvalidParamException();
-            this._posStateBits = num3 >= 0 && num3 <= 4 ? num3 : throw new InvalidParamException();
-            this._posStateMask = (uint) ((1 << this._posStateBits) - 1);
-            continue;
-          case CoderPropID.LitContextBits:
-            if (!(property is int num4))
-              throw new InvalidParamException();
-            this._numLiteralContextBits = num4 >= 0 && num4 <= 8 ? num4 : throw new InvalidParamException();
-            continue;
-          case CoderPropID.LitPosBits:
-            if (!(property is int num5))
-              throw new InvalidParamException();
-            this._numLiteralPosStateBits = num5 >= 0 && num5 <= 4 ? num5 : throw new InvalidParamException();
-            continue;
-          case CoderPropID.NumFastBytes:
-            if (!(property is int num6))
-              throw new InvalidParamException();
-            this._numFastBytes = num6 >= 5 && num6 <= 273 ? (uint) num6 : throw new InvalidParamException();
-            continue;
-          case CoderPropID.MatchFinder:
-            if (!(property is string))
-              throw new InvalidParamException();
-            Encoder.EMatchFinderType matchFinderType = this._matchFinderType;
-            int matchFinder = Encoder.FindMatchFinder(((string) property).ToUpper());
-            this._matchFinderType = matchFinder >= 0 ? (Encoder.EMatchFinderType) matchFinder : throw new InvalidParamException();
-            if (this._matchFinder != null && matchFinderType != this._matchFinderType)
-            {
-              this._dictionarySizePrev = uint.MaxValue;
-              this._matchFinder = (IMatchFinder) null;
-              continue;
-            }
-            continue;
-          case CoderPropID.Algorithm:
-            continue;
-          case CoderPropID.EndMarker:
-            if (!(property is bool writeEndMarker))
-              throw new InvalidParamException();
-            this.SetWriteEndMarkerMode(writeEndMarker);
-            continue;
-          default:
-            throw new InvalidParamException();
-        }
-      }
-    }
-
-    private enum EMatchFinderType
-    {
-      BT2,
-      BT4,
-    }
-
-    private class LiteralEncoder
-    {
-      private Encoder.LiteralEncoder.Encoder2[] m_Coders;
-      private int m_NumPrevBits;
-      private int m_NumPosBits;
-      private uint m_PosMask;
-
-      public void Create(int numPosBits, int numPrevBits)
-      {
-        if (this.m_Coders != null && this.m_NumPrevBits == numPrevBits && this.m_NumPosBits == numPosBits)
-          return;
-        this.m_NumPosBits = numPosBits;
-        this.m_PosMask = (uint) ((1 << numPosBits) - 1);
-        this.m_NumPrevBits = numPrevBits;
-        uint length = (uint) (1 << this.m_NumPrevBits + this.m_NumPosBits);
-        this.m_Coders = new Encoder.LiteralEncoder.Encoder2[(IntPtr) length];
-        for (uint index = 0; index < length; ++index)
-          this.m_Coders[(IntPtr) index].Create();
-      }
-
-      public void Init()
-      {
-        uint num = (uint) (1 << this.m_NumPrevBits + this.m_NumPosBits);
-        for (uint index = 0; index < num; ++index)
-          this.m_Coders[(IntPtr) index].Init();
-      }
-
-      public Encoder.LiteralEncoder.Encoder2 GetSubCoder(uint pos, byte prevByte)
-      {
-        return this.m_Coders[(IntPtr) (uint) ((((int) pos & (int) this.m_PosMask) << this.m_NumPrevBits) + ((int) prevByte >> 8 - this.m_NumPrevBits))];
-      }
-
-      public struct Encoder2
-      {
-        private BitEncoder[] m_Encoders;
-
-        public void Create() => this.m_Encoders = new BitEncoder[768];
-
-        public void Init()
-        {
-          for (int index = 0; index < 768; ++index)
-            this.m_Encoders[index].Init();
-        }
-
-        public void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, byte symbol)
-        {
-          uint index1 = 1;
-          for (int index2 = 7; index2 >= 0; --index2)
-          {
-            uint symbol1 = (uint) ((int) symbol >> index2 & 1);
-            this.m_Encoders[(IntPtr) index1].Encode(rangeEncoder, symbol1);
-            index1 = index1 << 1 | symbol1;
-          }
-        }
-
-        public void EncodeMatched(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, byte matchByte, byte symbol)
-        {
-          uint num1 = 1;
-          bool flag = true;
-          for (int index1 = 7; index1 >= 0; --index1)
-          {
-            uint symbol1 = (uint) ((int) symbol >> index1 & 1);
-            uint index2 = num1;
-            if (flag)
-            {
-              uint num2 = (uint) ((int) matchByte >> index1 & 1);
-              index2 += (uint) (1 + (int) num2 << 8);
-              flag = (int) num2 == (int) symbol1;
-            }
-            this.m_Encoders[(IntPtr) index2].Encode(rangeEncoder, symbol1);
-            num1 = num1 << 1 | symbol1;
-          }
-        }
-
-        public uint GetPrice(bool matchMode, byte matchByte, byte symbol)
-        {
-          uint price = 0;
-          uint index = 1;
-          int num1 = 7;
-          if (matchMode)
-          {
-            for (; num1 >= 0; --num1)
-            {
-              uint num2 = (uint) ((int) matchByte >> num1 & 1);
-              uint symbol1 = (uint) ((int) symbol >> num1 & 1);
-              price += this.m_Encoders[(IntPtr) ((uint) (1 + (int) num2 << 8) + index)].GetPrice(symbol1);
-              index = index << 1 | symbol1;
-              if ((int) num2 != (int) symbol1)
-              {
-                --num1;
-                break;
-              }
-            }
-          }
-          for (; num1 >= 0; --num1)
-          {
-            uint symbol2 = (uint) ((int) symbol >> num1 & 1);
-            price += this.m_Encoders[(IntPtr) index].GetPrice(symbol2);
-            index = index << 1 | symbol2;
-          }
-          return price;
-        }
-      }
-    }
-
-    private class LenEncoder
-    {
-      private BitEncoder _choice = new BitEncoder();
-      private BitEncoder _choice2 = new BitEncoder();
-      private BitTreeEncoder[] _lowCoder = new BitTreeEncoder[new IntPtr(16)];
-      private BitTreeEncoder[] _midCoder = new BitTreeEncoder[new IntPtr(16)];
-      private BitTreeEncoder _highCoder = new BitTreeEncoder(8);
-
-      public LenEncoder()
-      {
-        for (uint index = 0; index < 16U; ++index)
-        {
-          this._lowCoder[(IntPtr) index] = new BitTreeEncoder(3);
-          this._midCoder[(IntPtr) index] = new BitTreeEncoder(3);
-        }
-      }
-
-      public void Init(uint numPosStates)
-      {
-        this._choice.Init();
-        this._choice2.Init();
-        for (uint index = 0; index < numPosStates; ++index)
-        {
-          this._lowCoder[(IntPtr) index].Init();
-          this._midCoder[(IntPtr) index].Init();
-        }
-        this._highCoder.Init();
-      }
-
-      public void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, uint symbol, uint posState)
-      {
-        if (symbol < 8U)
-        {
-          this._choice.Encode(rangeEncoder, 0U);
-          this._lowCoder[(IntPtr) posState].Encode(rangeEncoder, symbol);
-        }
-        else
-        {
-          symbol -= 8U;
-          this._choice.Encode(rangeEncoder, 1U);
-          if (symbol < 8U)
-          {
-            this._choice2.Encode(rangeEncoder, 0U);
-            this._midCoder[(IntPtr) posState].Encode(rangeEncoder, symbol);
-          }
-          else
-          {
-            this._choice2.Encode(rangeEncoder, 1U);
-            this._highCoder.Encode(rangeEncoder, symbol - 8U);
-          }
-        }
-      }
-
-      public void SetPrices(uint posState, uint numSymbols, uint[] prices, uint st)
-      {
-        uint price0 = this._choice.GetPrice0();
-        uint price1 = this._choice.GetPrice1();
-        uint num1 = price1 + this._choice2.GetPrice0();
-        uint num2 = price1 + this._choice2.GetPrice1();
-        uint symbol;
-        for (symbol = 0U; symbol < 8U; ++symbol)
-        {
-          if (symbol >= numSymbols)
-            return;
-          prices[(IntPtr) (st + symbol)] = price0 + this._lowCoder[(IntPtr) posState].GetPrice(symbol);
-        }
-        for (; symbol < 16U; ++symbol)
-        {
-          if (symbol >= numSymbols)
-            return;
-          prices[(IntPtr) (st + symbol)] = num1 + this._midCoder[(IntPtr) posState].GetPrice(symbol - 8U);
-        }
-        for (; symbol < numSymbols; ++symbol)
-          prices[(IntPtr) (st + symbol)] = num2 + this._highCoder.GetPrice((uint) ((int) symbol - 8 - 8));
-      }
-    }
-
-    private class LenPriceTableEncoder : Encoder.LenEncoder
-    {
-      private uint[] _prices = new uint[new IntPtr(4352)];
-      private uint _tableSize;
-      private uint[] _counters = new uint[new IntPtr(16)];
-
-      public void SetTableSize(uint tableSize) => this._tableSize = tableSize;
-
-      public uint GetPrice(uint symbol, uint posState)
-      {
-        return this._prices[(IntPtr) (posState * 272U + symbol)];
-      }
-
-      private void UpdateTable(uint posState)
-      {
-        this.SetPrices(posState, this._tableSize, this._prices, posState * 272U);
-        this._counters[(IntPtr) posState] = this._tableSize;
-      }
-
-      public void UpdateTables(uint numPosStates)
-      {
-        for (uint posState = 0; posState < numPosStates; ++posState)
-          this.UpdateTable(posState);
-      }
-
-      public new void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, uint symbol, uint posState)
-      {
-        base.Encode(rangeEncoder, symbol, posState);
-        if (--this._counters[(IntPtr) posState] != 0U)
-          return;
-        this.UpdateTable(posState);
-      }
-    }
-
-    private class Optimal
-    {
-      public Base.State State;
-      public bool Prev1IsChar;
-      public bool Prev2;
-      public uint PosPrev2;
-      public uint BackPrev2;
-      public uint Price;
-      public uint PosPrev;
-      public uint BackPrev;
-      public uint Backs0;
-      public uint Backs1;
-      public uint Backs2;
-      public uint Backs3;
-
-      public void MakeAsChar()
-      {
-        this.BackPrev = uint.MaxValue;
-        this.Prev1IsChar = false;
-      }
-
-      public void MakeAsShortRep()
-      {
-        this.BackPrev = 0U;
-        this.Prev1IsChar = false;
-      }
-
-      public bool IsShortRep() => this.BackPrev == 0U;
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/LZMA/SevenZipHelper.cs b/MSHALTester/SevenZip/Compression/LZMA/SevenZipHelper.cs
index 1a63d92..e0ed294 100644
--- a/MSHALTester/SevenZip/Compression/LZMA/SevenZipHelper.cs
+++ b/MSHALTester/SevenZip/Compression/LZMA/SevenZipHelper.cs
@@ -2,7 +2,6 @@ using System;
 using System.IO;
 using System.Runtime.InteropServices;
 
-#nullable disable
 namespace SevenZip.Compression.LZMA
 {
   [ComVisible(true)]
diff --git a/MSHALTester/SevenZip/Compression/RangeCoder/BitDecoder.cs b/MSHALTester/SevenZip/Compression/RangeCoder/BitDecoder.cs
deleted file mode 100644
index 9c112d8..0000000
--- a/MSHALTester/SevenZip/Compression/RangeCoder/BitDecoder.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-#nullable disable
-namespace SevenZip.Compression.RangeCoder
-{
-  internal struct BitDecoder
-  {
-    public const int kNumBitModelTotalBits = 11;
-    public const uint kBitModelTotal = 2048;
-    private const int kNumMoveBits = 5;
-    private uint Prob;
-
-    public void UpdateModel(int numMoveBits, uint symbol)
-    {
-      if (symbol == 0U)
-        this.Prob += 2048U - this.Prob >> numMoveBits;
-      else
-        this.Prob -= this.Prob >> numMoveBits;
-    }
-
-    public void Init() => this.Prob = 1024U;
-
-    public uint Decode(Decoder rangeDecoder)
-    {
-      uint num = (rangeDecoder.Range >> 11) * this.Prob;
-      if (rangeDecoder.Code < num)
-      {
-        rangeDecoder.Range = num;
-        this.Prob += 2048U - this.Prob >> 5;
-        if (rangeDecoder.Range < 16777216U)
-        {
-          rangeDecoder.Code = rangeDecoder.Code << 8 | (uint) (byte) rangeDecoder.Stream.ReadByte();
-          rangeDecoder.Range <<= 8;
-        }
-        return 0;
-      }
-      rangeDecoder.Range -= num;
-      rangeDecoder.Code -= num;
-      this.Prob -= this.Prob >> 5;
-      if (rangeDecoder.Range < 16777216U)
-      {
-        rangeDecoder.Code = rangeDecoder.Code << 8 | (uint) (byte) rangeDecoder.Stream.ReadByte();
-        rangeDecoder.Range <<= 8;
-      }
-      return 1;
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/RangeCoder/BitEncoder.cs b/MSHALTester/SevenZip/Compression/RangeCoder/BitEncoder.cs
deleted file mode 100644
index 42e936c..0000000
--- a/MSHALTester/SevenZip/Compression/RangeCoder/BitEncoder.cs
+++ /dev/null
@@ -1,66 +0,0 @@
-using System;
-
-#nullable disable
-namespace SevenZip.Compression.RangeCoder
-{
-  internal struct BitEncoder
-  {
-    public const int kNumBitModelTotalBits = 11;
-    public const uint kBitModelTotal = 2048;
-    private const int kNumMoveBits = 5;
-    private const int kNumMoveReducingBits = 2;
-    public const int kNumBitPriceShiftBits = 6;
-    private uint Prob;
-    private static uint[] ProbPrices = new uint[new IntPtr(512)];
-
-    public void Init() => this.Prob = 1024U;
-
-    public void UpdateModel(uint symbol)
-    {
-      if (symbol == 0U)
-        this.Prob += 2048U - this.Prob >> 5;
-      else
-        this.Prob -= this.Prob >> 5;
-    }
-
-    public void Encode(Encoder encoder, uint symbol)
-    {
-      uint num = (encoder.Range >> 11) * this.Prob;
-      if (symbol == 0U)
-      {
-        encoder.Range = num;
-        this.Prob += 2048U - this.Prob >> 5;
-      }
-      else
-      {
-        encoder.Low += (ulong) num;
-        encoder.Range -= num;
-        this.Prob -= this.Prob >> 5;
-      }
-      if (encoder.Range >= 16777216U)
-        return;
-      encoder.Range <<= 8;
-      encoder.ShiftLow();
-    }
-
-    static BitEncoder()
-    {
-      for (int index1 = 8; index1 >= 0; --index1)
-      {
-        uint num1 = (uint) (1 << 9 - index1 - 1);
-        uint num2 = (uint) (1 << 9 - index1);
-        for (uint index2 = num1; index2 < num2; ++index2)
-          BitEncoder.ProbPrices[(IntPtr) index2] = (uint) ((index1 << 6) + ((int) num2 - (int) index2 << 6 >>> 9 - index1 - 1));
-      }
-    }
-
-    public uint GetPrice(uint symbol)
-    {
-      return BitEncoder.ProbPrices[(((long) (this.Prob - symbol) ^ (long) -(int) symbol) & 2047L) >> 2];
-    }
-
-    public uint GetPrice0() => BitEncoder.ProbPrices[(IntPtr) (this.Prob >> 2)];
-
-    public uint GetPrice1() => BitEncoder.ProbPrices[(IntPtr) (2048U - this.Prob >> 2)];
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/RangeCoder/BitTreeDecoder.cs b/MSHALTester/SevenZip/Compression/RangeCoder/BitTreeDecoder.cs
deleted file mode 100644
index e21da7d..0000000
--- a/MSHALTester/SevenZip/Compression/RangeCoder/BitTreeDecoder.cs
+++ /dev/null
@@ -1,55 +0,0 @@
-using System;
-
-#nullable disable
-namespace SevenZip.Compression.RangeCoder
-{
-  internal struct BitTreeDecoder(int numBitLevels)
-  {
-    private BitDecoder[] Models = new BitDecoder[1 << numBitLevels];
-    private int NumBitLevels = numBitLevels;
-
-    public void Init()
-    {
-      for (uint index = 1; (long) index < (long) (1 << this.NumBitLevels); ++index)
-        this.Models[(IntPtr) index].Init();
-    }
-
-    public uint Decode(Decoder rangeDecoder)
-    {
-      uint index = 1;
-      for (int numBitLevels = this.NumBitLevels; numBitLevels > 0; --numBitLevels)
-        index = (index << 1) + this.Models[(IntPtr) index].Decode(rangeDecoder);
-      return index - (uint) (1 << this.NumBitLevels);
-    }
-
-    public uint ReverseDecode(Decoder rangeDecoder)
-    {
-      uint index1 = 1;
-      uint num1 = 0;
-      for (int index2 = 0; index2 < this.NumBitLevels; ++index2)
-      {
-        uint num2 = this.Models[(IntPtr) index1].Decode(rangeDecoder);
-        index1 = (index1 << 1) + num2;
-        num1 |= num2 << index2;
-      }
-      return num1;
-    }
-
-    public static uint ReverseDecode(
-      BitDecoder[] Models,
-      uint startIndex,
-      Decoder rangeDecoder,
-      int NumBitLevels)
-    {
-      uint num1 = 1;
-      uint num2 = 0;
-      for (int index = 0; index < NumBitLevels; ++index)
-      {
-        uint num3 = Models[(IntPtr) (startIndex + num1)].Decode(rangeDecoder);
-        num1 = (num1 << 1) + num3;
-        num2 |= num3 << index;
-      }
-      return num2;
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/RangeCoder/BitTreeEncoder.cs b/MSHALTester/SevenZip/Compression/RangeCoder/BitTreeEncoder.cs
deleted file mode 100644
index 7158fc5..0000000
--- a/MSHALTester/SevenZip/Compression/RangeCoder/BitTreeEncoder.cs
+++ /dev/null
@@ -1,106 +0,0 @@
-using System;
-
-#nullable disable
-namespace SevenZip.Compression.RangeCoder
-{
-  internal struct BitTreeEncoder(int numBitLevels)
-  {
-    private BitEncoder[] Models = new BitEncoder[1 << numBitLevels];
-    private int NumBitLevels = numBitLevels;
-
-    public void Init()
-    {
-      for (uint index = 1; (long) index < (long) (1 << this.NumBitLevels); ++index)
-        this.Models[(IntPtr) index].Init();
-    }
-
-    public void Encode(Encoder rangeEncoder, uint symbol)
-    {
-      uint index = 1;
-      int numBitLevels = this.NumBitLevels;
-      while (numBitLevels > 0)
-      {
-        --numBitLevels;
-        uint symbol1 = symbol >> numBitLevels & 1U;
-        this.Models[(IntPtr) index].Encode(rangeEncoder, symbol1);
-        index = index << 1 | symbol1;
-      }
-    }
-
-    public void ReverseEncode(Encoder rangeEncoder, uint symbol)
-    {
-      uint index1 = 1;
-      for (uint index2 = 0; (long) index2 < (long) this.NumBitLevels; ++index2)
-      {
-        uint symbol1 = symbol & 1U;
-        this.Models[(IntPtr) index1].Encode(rangeEncoder, symbol1);
-        index1 = index1 << 1 | symbol1;
-        symbol >>= 1;
-      }
-    }
-
-    public uint GetPrice(uint symbol)
-    {
-      uint price = 0;
-      uint index = 1;
-      int numBitLevels = this.NumBitLevels;
-      while (numBitLevels > 0)
-      {
-        --numBitLevels;
-        uint symbol1 = symbol >> numBitLevels & 1U;
-        price += this.Models[(IntPtr) index].GetPrice(symbol1);
-        index = (index << 1) + symbol1;
-      }
-      return price;
-    }
-
-    public uint ReverseGetPrice(uint symbol)
-    {
-      uint price = 0;
-      uint index = 1;
-      for (int numBitLevels = this.NumBitLevels; numBitLevels > 0; --numBitLevels)
-      {
-        uint symbol1 = symbol & 1U;
-        symbol >>= 1;
-        price += this.Models[(IntPtr) index].GetPrice(symbol1);
-        index = index << 1 | symbol1;
-      }
-      return price;
-    }
-
-    public static uint ReverseGetPrice(
-      BitEncoder[] Models,
-      uint startIndex,
-      int NumBitLevels,
-      uint symbol)
-    {
-      uint price = 0;
-      uint num = 1;
-      for (int index = NumBitLevels; index > 0; --index)
-      {
-        uint symbol1 = symbol & 1U;
-        symbol >>= 1;
-        price += Models[(IntPtr) (startIndex + num)].GetPrice(symbol1);
-        num = num << 1 | symbol1;
-      }
-      return price;
-    }
-
-    public static void ReverseEncode(
-      BitEncoder[] Models,
-      uint startIndex,
-      Encoder rangeEncoder,
-      int NumBitLevels,
-      uint symbol)
-    {
-      uint num = 1;
-      for (int index = 0; index < NumBitLevels; ++index)
-      {
-        uint symbol1 = symbol & 1U;
-        Models[(IntPtr) (startIndex + num)].Encode(rangeEncoder, symbol1);
-        num = num << 1 | symbol1;
-        symbol >>= 1;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/RangeCoder/Decoder.cs b/MSHALTester/SevenZip/Compression/RangeCoder/Decoder.cs
deleted file mode 100644
index a211b1d..0000000
--- a/MSHALTester/SevenZip/Compression/RangeCoder/Decoder.cs
+++ /dev/null
@@ -1,90 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace SevenZip.Compression.RangeCoder
-{
-  internal class Decoder
-  {
-    public const uint kTopValue = 16777216;
-    public uint Range;
-    public uint Code;
-    public Stream Stream;
-
-    public void Init(Stream stream)
-    {
-      this.Stream = stream;
-      this.Code = 0U;
-      this.Range = uint.MaxValue;
-      for (int index = 0; index < 5; ++index)
-        this.Code = this.Code << 8 | (uint) (byte) this.Stream.ReadByte();
-    }
-
-    public void ReleaseStream() => this.Stream = (Stream) null;
-
-    public void CloseStream() => this.Stream.Close();
-
-    public void Normalize()
-    {
-      for (; this.Range < 16777216U; this.Range <<= 8)
-        this.Code = this.Code << 8 | (uint) (byte) this.Stream.ReadByte();
-    }
-
-    public void Normalize2()
-    {
-      if (this.Range >= 16777216U)
-        return;
-      this.Code = this.Code << 8 | (uint) (byte) this.Stream.ReadByte();
-      this.Range <<= 8;
-    }
-
-    public uint GetThreshold(uint total) => this.Code / (this.Range /= total);
-
-    public void Decode(uint start, uint size, uint total)
-    {
-      this.Code -= start * this.Range;
-      this.Range *= size;
-      this.Normalize();
-    }
-
-    public uint DecodeDirectBits(int numTotalBits)
-    {
-      uint range = this.Range;
-      uint num1 = this.Code;
-      uint num2 = 0;
-      for (int index = numTotalBits; index > 0; --index)
-      {
-        range >>= 1;
-        uint num3 = num1 - range >> 31;
-        num1 -= range & num3 - 1U;
-        num2 = (uint) ((int) num2 << 1 | 1 - (int) num3);
-        if (range < 16777216U)
-        {
-          num1 = num1 << 8 | (uint) (byte) this.Stream.ReadByte();
-          range <<= 8;
-        }
-      }
-      this.Range = range;
-      this.Code = num1;
-      return num2;
-    }
-
-    public uint DecodeBit(uint size0, int numTotalBits)
-    {
-      uint num1 = (this.Range >> numTotalBits) * size0;
-      uint num2;
-      if (this.Code < num1)
-      {
-        num2 = 0U;
-        this.Range = num1;
-      }
-      else
-      {
-        num2 = 1U;
-        this.Code -= num1;
-        this.Range -= num1;
-      }
-      this.Normalize();
-      return num2;
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/Compression/RangeCoder/Encoder.cs b/MSHALTester/SevenZip/Compression/RangeCoder/Encoder.cs
deleted file mode 100644
index 5805d13..0000000
--- a/MSHALTester/SevenZip/Compression/RangeCoder/Encoder.cs
+++ /dev/null
@@ -1,106 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace SevenZip.Compression.RangeCoder
-{
-  internal class Encoder
-  {
-    public const uint kTopValue = 16777216;
-    private Stream Stream;
-    public ulong Low;
-    public uint Range;
-    private uint _cacheSize;
-    private byte _cache;
-    private long StartPosition;
-
-    public void SetStream(Stream stream) => this.Stream = stream;
-
-    public void ReleaseStream() => this.Stream = (Stream) null;
-
-    public void Init()
-    {
-      this.StartPosition = this.Stream.Position;
-      this.Low = 0UL;
-      this.Range = uint.MaxValue;
-      this._cacheSize = 1U;
-      this._cache = (byte) 0;
-    }
-
-    public void FlushData()
-    {
-      for (int index = 0; index < 5; ++index)
-        this.ShiftLow();
-    }
-
-    public void FlushStream() => this.Stream.Flush();
-
-    public void CloseStream() => this.Stream.Close();
-
-    public void Encode(uint start, uint size, uint total)
-    {
-      this.Low += (ulong) (start * (this.Range /= total));
-      this.Range *= size;
-      while (this.Range < 16777216U)
-      {
-        this.Range <<= 8;
-        this.ShiftLow();
-      }
-    }
-
-    public void ShiftLow()
-    {
-      if ((uint) this.Low < 4278190080U || (uint) (this.Low >> 32) == 1U)
-      {
-        byte num = this._cache;
-        do
-        {
-          this.Stream.WriteByte((byte) ((ulong) num + (this.Low >> 32)));
-          num = byte.MaxValue;
-        }
-        while (--this._cacheSize != 0U);
-        this._cache = (byte) ((uint) this.Low >> 24);
-      }
-      ++this._cacheSize;
-      this.Low = (ulong) ((uint) this.Low << 8);
-    }
-
-    public void EncodeDirectBits(uint v, int numTotalBits)
-    {
-      for (int index = numTotalBits - 1; index >= 0; --index)
-      {
-        this.Range >>= 1;
-        if (((int) (v >> index) & 1) == 1)
-          this.Low += (ulong) this.Range;
-        if (this.Range < 16777216U)
-        {
-          this.Range <<= 8;
-          this.ShiftLow();
-        }
-      }
-    }
-
-    public void EncodeBit(uint size0, int numTotalBits, uint symbol)
-    {
-      uint num = (this.Range >> numTotalBits) * size0;
-      if (symbol == 0U)
-      {
-        this.Range = num;
-      }
-      else
-      {
-        this.Low += (ulong) num;
-        this.Range -= num;
-      }
-      while (this.Range < 16777216U)
-      {
-        this.Range <<= 8;
-        this.ShiftLow();
-      }
-    }
-
-    public long GetProcessedSizeAdd()
-    {
-      return (long) this._cacheSize + this.Stream.Position - this.StartPosition + 4L;
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/DataErrorException.cs b/MSHALTester/SevenZip/DataErrorException.cs
deleted file mode 100644
index 0a4b117..0000000
--- a/MSHALTester/SevenZip/DataErrorException.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using System;
-
-#nullable disable
-namespace SevenZip
-{
-  internal class DataErrorException : ApplicationException
-  {
-    public DataErrorException()
-      : base("Data Error")
-    {
-    }
-  }
-}
diff --git a/MSHALTester/SevenZip/ICodeProgress.cs b/MSHALTester/SevenZip/ICodeProgress.cs
deleted file mode 100644
index 51b047f..0000000
--- a/MSHALTester/SevenZip/ICodeProgress.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface ICodeProgress
-  {
-    void SetProgress(long inSize, long outSize);
-  }
-}
diff --git a/MSHALTester/SevenZip/ICoder.cs b/MSHALTester/SevenZip/ICoder.cs
deleted file mode 100644
index a75e1c1..0000000
--- a/MSHALTester/SevenZip/ICoder.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-using System.IO;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface ICoder
-  {
-    void Code(
-      Stream inStream,
-      Stream outStream,
-      long inSize,
-      long outSize,
-      ICodeProgress progress);
-  }
-}
diff --git a/MSHALTester/SevenZip/ISetCoderProperties.cs b/MSHALTester/SevenZip/ISetCoderProperties.cs
deleted file mode 100644
index ca415ce..0000000
--- a/MSHALTester/SevenZip/ISetCoderProperties.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface ISetCoderProperties
-  {
-    void SetCoderProperties(CoderPropID[] propIDs, object[] properties);
-  }
-}
diff --git a/MSHALTester/SevenZip/ISetDecoderProperties.cs b/MSHALTester/SevenZip/ISetDecoderProperties.cs
deleted file mode 100644
index 19df154..0000000
--- a/MSHALTester/SevenZip/ISetDecoderProperties.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface ISetDecoderProperties
-  {
-    void SetDecoderProperties(byte[] properties);
-  }
-}
diff --git a/MSHALTester/SevenZip/IWriteCoderProperties.cs b/MSHALTester/SevenZip/IWriteCoderProperties.cs
deleted file mode 100644
index 2764a80..0000000
--- a/MSHALTester/SevenZip/IWriteCoderProperties.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System.IO;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface IWriteCoderProperties
-  {
-    void WriteCoderProperties(Stream outStream);
-  }
-}
diff --git a/MSHALTester/SevenZip/InvalidParamException.cs b/MSHALTester/SevenZip/InvalidParamException.cs
deleted file mode 100644
index 89dd3ff..0000000
--- a/MSHALTester/SevenZip/InvalidParamException.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using System;
-
-#nullable disable
-namespace SevenZip
-{
-  internal class InvalidParamException : ApplicationException
-  {
-    public InvalidParamException()
-      : base("Invalid Parameter")
-    {
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/AdoNetAppender.cs b/MSHALTester/log4net/Appender/AdoNetAppender.cs
deleted file mode 100644
index a4bc868..0000000
--- a/MSHALTester/log4net/Appender/AdoNetAppender.cs
+++ /dev/null
@@ -1,299 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Data;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class AdoNetAppender : BufferingAppenderSkeleton
-  {
-    protected bool m_usePreparedCommand;
-    protected ArrayList m_parameters;
-    private SecurityContext m_securityContext;
-    private IDbConnection m_dbConnection;
-    private IDbCommand m_dbCommand;
-    private string m_connectionString;
-    private string m_connectionType;
-    private string m_commandText;
-    private CommandType m_commandType;
-    private bool m_useTransactions;
-    private bool m_reconnectOnError;
-
-    public AdoNetAppender()
-    {
-      this.m_connectionType = "System.Data.OleDb.OleDbConnection, System.Data, Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
-      this.m_useTransactions = true;
-      this.m_commandType = CommandType.Text;
-      this.m_parameters = new ArrayList();
-      this.m_reconnectOnError = false;
-    }
-
-    public string ConnectionString
-    {
-      get => this.m_connectionString;
-      set => this.m_connectionString = value;
-    }
-
-    public string ConnectionType
-    {
-      get => this.m_connectionType;
-      set => this.m_connectionType = value;
-    }
-
-    public string CommandText
-    {
-      get => this.m_commandText;
-      set => this.m_commandText = value;
-    }
-
-    public CommandType CommandType
-    {
-      get => this.m_commandType;
-      set => this.m_commandType = value;
-    }
-
-    public bool UseTransactions
-    {
-      get => this.m_useTransactions;
-      set => this.m_useTransactions = value;
-    }
-
-    public SecurityContext SecurityContext
-    {
-      get => this.m_securityContext;
-      set => this.m_securityContext = value;
-    }
-
-    public bool ReconnectOnError
-    {
-      get => this.m_reconnectOnError;
-      set => this.m_reconnectOnError = value;
-    }
-
-    protected IDbConnection Connection
-    {
-      get => this.m_dbConnection;
-      set => this.m_dbConnection = value;
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      this.m_usePreparedCommand = this.m_commandText != null && this.m_commandText.Length > 0;
-      if (this.m_securityContext == null)
-        this.m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext((object) this);
-      this.InitializeDatabaseConnection();
-      this.InitializeDatabaseCommand();
-    }
-
-    protected override void OnClose()
-    {
-      base.OnClose();
-      if (this.m_dbCommand != null)
-      {
-        this.m_dbCommand.Dispose();
-        this.m_dbCommand = (IDbCommand) null;
-      }
-      if (this.m_dbConnection == null)
-        return;
-      this.m_dbConnection.Close();
-      this.m_dbConnection = (IDbConnection) null;
-    }
-
-    protected override void SendBuffer(LoggingEvent[] events)
-    {
-      if (this.m_reconnectOnError && (this.m_dbConnection == null || this.m_dbConnection.State != ConnectionState.Open))
-      {
-        LogLog.Debug("AdoNetAppender: Attempting to reconnect to database. Current Connection State: " + (this.m_dbConnection == null ? "<null>" : this.m_dbConnection.State.ToString()));
-        this.InitializeDatabaseConnection();
-        this.InitializeDatabaseCommand();
-      }
-      if (this.m_dbConnection == null || this.m_dbConnection.State != ConnectionState.Open)
-        return;
-      if (this.m_useTransactions)
-      {
-        IDbTransaction dbTran = (IDbTransaction) null;
-        try
-        {
-          dbTran = this.m_dbConnection.BeginTransaction();
-          this.SendBuffer(dbTran, events);
-          dbTran.Commit();
-        }
-        catch (Exception ex1)
-        {
-          if (dbTran != null)
-          {
-            try
-            {
-              dbTran.Rollback();
-            }
-            catch (Exception ex2)
-            {
-            }
-          }
-          this.ErrorHandler.Error("Exception while writing to database", ex1);
-        }
-      }
-      else
-        this.SendBuffer((IDbTransaction) null, events);
-    }
-
-    public void AddParameter(AdoNetAppenderParameter parameter)
-    {
-      this.m_parameters.Add((object) parameter);
-    }
-
-    protected virtual void SendBuffer(IDbTransaction dbTran, LoggingEvent[] events)
-    {
-      if (this.m_usePreparedCommand)
-      {
-        if (this.m_dbCommand == null)
-          return;
-        if (dbTran != null)
-          this.m_dbCommand.Transaction = dbTran;
-        foreach (LoggingEvent loggingEvent in events)
-        {
-          foreach (AdoNetAppenderParameter parameter in this.m_parameters)
-            parameter.FormatValue(this.m_dbCommand, loggingEvent);
-          this.m_dbCommand.ExecuteNonQuery();
-        }
-      }
-      else
-      {
-        using (IDbCommand command = this.m_dbConnection.CreateCommand())
-        {
-          if (dbTran != null)
-            command.Transaction = dbTran;
-          foreach (LoggingEvent logEvent in events)
-          {
-            string logStatement = this.GetLogStatement(logEvent);
-            LogLog.Debug("AdoNetAppender: LogStatement [" + logStatement + "]");
-            command.CommandText = logStatement;
-            command.ExecuteNonQuery();
-          }
-        }
-      }
-    }
-
-    protected virtual string GetLogStatement(LoggingEvent logEvent)
-    {
-      if (this.Layout == null)
-      {
-        this.ErrorHandler.Error("ADOAppender: No Layout specified.");
-        return "";
-      }
-      StringWriter writer = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-      this.Layout.Format((TextWriter) writer, logEvent);
-      return writer.ToString();
-    }
-
-    private void InitializeDatabaseConnection()
-    {
-      try
-      {
-        this.m_dbConnection = (IDbConnection) Activator.CreateInstance(this.ResolveConnectionType());
-        this.m_dbConnection.ConnectionString = this.m_connectionString;
-        using (this.SecurityContext.Impersonate((object) this))
-          this.m_dbConnection.Open();
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Could not open database connection [" + this.m_connectionString + "]", ex);
-        this.m_dbConnection = (IDbConnection) null;
-      }
-    }
-
-    protected virtual Type ResolveConnectionType()
-    {
-      try
-      {
-        return SystemInfo.GetTypeFromString(this.m_connectionType, true, false);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Failed to load connection type [" + this.m_connectionType + "]", ex);
-        throw;
-      }
-    }
-
-    private void InitializeDatabaseCommand()
-    {
-      if (this.m_dbConnection == null)
-        return;
-      if (!this.m_usePreparedCommand)
-        return;
-      try
-      {
-        this.m_dbCommand = this.m_dbConnection.CreateCommand();
-        this.m_dbCommand.CommandText = this.m_commandText;
-        this.m_dbCommand.CommandType = this.m_commandType;
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Could not create database command [" + this.m_commandText + "]", ex);
-        if (this.m_dbCommand != null)
-        {
-          try
-          {
-            this.m_dbCommand.Dispose();
-          }
-          catch
-          {
-          }
-          this.m_dbCommand = (IDbCommand) null;
-        }
-      }
-      if (this.m_dbCommand != null)
-      {
-        try
-        {
-          foreach (AdoNetAppenderParameter parameter in this.m_parameters)
-          {
-            try
-            {
-              parameter.Prepare(this.m_dbCommand);
-            }
-            catch (Exception ex)
-            {
-              this.ErrorHandler.Error("Could not add database command parameter [" + parameter.ParameterName + "]", ex);
-              throw;
-            }
-          }
-        }
-        catch
-        {
-          try
-          {
-            this.m_dbCommand.Dispose();
-          }
-          catch
-          {
-          }
-          this.m_dbCommand = (IDbCommand) null;
-        }
-      }
-      if (this.m_dbCommand == null)
-        return;
-      try
-      {
-        this.m_dbCommand.Prepare();
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Could not prepare database command [" + this.m_commandText + "]", ex);
-        try
-        {
-          this.m_dbCommand.Dispose();
-        }
-        catch
-        {
-        }
-        this.m_dbCommand = (IDbCommand) null;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/AdoNetAppenderParameter.cs b/MSHALTester/log4net/Appender/AdoNetAppenderParameter.cs
deleted file mode 100644
index 711ff7f..0000000
--- a/MSHALTester/log4net/Appender/AdoNetAppenderParameter.cs
+++ /dev/null
@@ -1,85 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using System.Data;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class AdoNetAppenderParameter
-  {
-    private string m_parameterName;
-    private DbType m_dbType;
-    private bool m_inferType = true;
-    private byte m_precision;
-    private byte m_scale;
-    private int m_size;
-    private IRawLayout m_layout;
-
-    public AdoNetAppenderParameter()
-    {
-      this.m_precision = (byte) 0;
-      this.m_scale = (byte) 0;
-      this.m_size = 0;
-    }
-
-    public string ParameterName
-    {
-      get => this.m_parameterName;
-      set => this.m_parameterName = value;
-    }
-
-    public DbType DbType
-    {
-      get => this.m_dbType;
-      set
-      {
-        this.m_dbType = value;
-        this.m_inferType = false;
-      }
-    }
-
-    public byte Precision
-    {
-      get => this.m_precision;
-      set => this.m_precision = value;
-    }
-
-    public byte Scale
-    {
-      get => this.m_scale;
-      set => this.m_scale = value;
-    }
-
-    public int Size
-    {
-      get => this.m_size;
-      set => this.m_size = value;
-    }
-
-    public IRawLayout Layout
-    {
-      get => this.m_layout;
-      set => this.m_layout = value;
-    }
-
-    public virtual void Prepare(IDbCommand command)
-    {
-      IDbDataParameter parameter = command.CreateParameter();
-      parameter.ParameterName = this.m_parameterName;
-      if (!this.m_inferType)
-        parameter.DbType = this.m_dbType;
-      if (this.m_precision != (byte) 0)
-        parameter.Precision = this.m_precision;
-      if (this.m_scale != (byte) 0)
-        parameter.Scale = this.m_scale;
-      if (this.m_size != 0)
-        parameter.Size = this.m_size;
-      command.Parameters.Add((object) parameter);
-    }
-
-    public virtual void FormatValue(IDbCommand command, LoggingEvent loggingEvent)
-    {
-      ((IDataParameter) command.Parameters[this.m_parameterName]).Value = this.Layout.Format(loggingEvent);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/AnsiColorTerminalAppender.cs b/MSHALTester/log4net/Appender/AnsiColorTerminalAppender.cs
deleted file mode 100644
index 495cf4e..0000000
--- a/MSHALTester/log4net/Appender/AnsiColorTerminalAppender.cs
+++ /dev/null
@@ -1,133 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Globalization;
-using System.Text;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class AnsiColorTerminalAppender : AppenderSkeleton
-  {
-    public const string ConsoleOut = "Console.Out";
-    public const string ConsoleError = "Console.Error";
-    private const string PostEventCodes = "\u001B[0m";
-    private bool m_writeToErrorStream = false;
-    private LevelMapping m_levelMapping = new LevelMapping();
-
-    public virtual string Target
-    {
-      get => this.m_writeToErrorStream ? "Console.Error" : "Console.Out";
-      set
-      {
-        if (string.Compare("Console.Error", value.Trim(), true, CultureInfo.InvariantCulture) == 0)
-          this.m_writeToErrorStream = true;
-        else
-          this.m_writeToErrorStream = false;
-      }
-    }
-
-    public void AddMapping(AnsiColorTerminalAppender.LevelColors mapping)
-    {
-      this.m_levelMapping.Add((LevelMappingEntry) mapping);
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      string str1 = this.RenderLoggingEvent(loggingEvent);
-      if (this.m_levelMapping.Lookup(loggingEvent.Level) is AnsiColorTerminalAppender.LevelColors levelColors)
-        str1 = levelColors.CombinedColor + str1;
-      string str2 = str1.Length <= 1 ? (str1[0] == '\n' || str1[0] == '\r' ? "\u001B[0m" + str1 : str1 + "\u001B[0m") : (str1.EndsWith("\r\n") || str1.EndsWith("\n\r") ? str1.Insert(str1.Length - 2, "\u001B[0m") : (str1.EndsWith("\n") || str1.EndsWith("\r") ? str1.Insert(str1.Length - 1, "\u001B[0m") : str1 + "\u001B[0m"));
-      if (this.m_writeToErrorStream)
-        Console.Error.Write(str2);
-      else
-        Console.Write(str2);
-    }
-
-    protected override bool RequiresLayout => true;
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      this.m_levelMapping.ActivateOptions();
-    }
-
-    [Flags]
-    public enum AnsiAttributes
-    {
-      Bright = 1,
-      Dim = 2,
-      Underscore = 4,
-      Blink = 8,
-      Reverse = 16, // 0x00000010
-      Hidden = 32, // 0x00000020
-      Strikethrough = 64, // 0x00000040
-    }
-
-    public enum AnsiColor
-    {
-      Black,
-      Red,
-      Green,
-      Yellow,
-      Blue,
-      Magenta,
-      Cyan,
-      White,
-    }
-
-    public class LevelColors : LevelMappingEntry
-    {
-      private AnsiColorTerminalAppender.AnsiColor m_foreColor;
-      private AnsiColorTerminalAppender.AnsiColor m_backColor;
-      private AnsiColorTerminalAppender.AnsiAttributes m_attributes;
-      private string m_combinedColor = "";
-
-      public AnsiColorTerminalAppender.AnsiColor ForeColor
-      {
-        get => this.m_foreColor;
-        set => this.m_foreColor = value;
-      }
-
-      public AnsiColorTerminalAppender.AnsiColor BackColor
-      {
-        get => this.m_backColor;
-        set => this.m_backColor = value;
-      }
-
-      public AnsiColorTerminalAppender.AnsiAttributes Attributes
-      {
-        get => this.m_attributes;
-        set => this.m_attributes = value;
-      }
-
-      public override void ActivateOptions()
-      {
-        base.ActivateOptions();
-        StringBuilder stringBuilder = new StringBuilder();
-        stringBuilder.Append("\u001B[0;");
-        stringBuilder.Append((int) (30 + this.m_foreColor));
-        stringBuilder.Append(';');
-        stringBuilder.Append((int) (40 + this.m_backColor));
-        if ((this.m_attributes & AnsiColorTerminalAppender.AnsiAttributes.Bright) > (AnsiColorTerminalAppender.AnsiAttributes) 0)
-          stringBuilder.Append(";1");
-        if ((this.m_attributes & AnsiColorTerminalAppender.AnsiAttributes.Dim) > (AnsiColorTerminalAppender.AnsiAttributes) 0)
-          stringBuilder.Append(";2");
-        if ((this.m_attributes & AnsiColorTerminalAppender.AnsiAttributes.Underscore) > (AnsiColorTerminalAppender.AnsiAttributes) 0)
-          stringBuilder.Append(";4");
-        if ((this.m_attributes & AnsiColorTerminalAppender.AnsiAttributes.Blink) > (AnsiColorTerminalAppender.AnsiAttributes) 0)
-          stringBuilder.Append(";5");
-        if ((this.m_attributes & AnsiColorTerminalAppender.AnsiAttributes.Reverse) > (AnsiColorTerminalAppender.AnsiAttributes) 0)
-          stringBuilder.Append(";7");
-        if ((this.m_attributes & AnsiColorTerminalAppender.AnsiAttributes.Hidden) > (AnsiColorTerminalAppender.AnsiAttributes) 0)
-          stringBuilder.Append(";8");
-        if ((this.m_attributes & AnsiColorTerminalAppender.AnsiAttributes.Strikethrough) > (AnsiColorTerminalAppender.AnsiAttributes) 0)
-          stringBuilder.Append(";9");
-        stringBuilder.Append('m');
-        this.m_combinedColor = stringBuilder.ToString();
-      }
-
-      internal string CombinedColor => this.m_combinedColor;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/AppenderCollection.cs b/MSHALTester/log4net/Appender/AppenderCollection.cs
deleted file mode 100644
index 63b9f7c..0000000
--- a/MSHALTester/log4net/Appender/AppenderCollection.cs
+++ /dev/null
@@ -1,403 +0,0 @@
-using log4net.Util;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class AppenderCollection : IList, ICollection, IEnumerable, ICloneable
-  {
-    private const int DEFAULT_CAPACITY = 16;
-    private IAppender[] m_array;
-    private int m_count = 0;
-    private int m_version = 0;
-    public static readonly AppenderCollection EmptyCollection = AppenderCollection.ReadOnly(new AppenderCollection(0));
-
-    public static AppenderCollection ReadOnly(AppenderCollection list)
-    {
-      return list != null ? (AppenderCollection) new AppenderCollection.ReadOnlyAppenderCollection(list) : throw new ArgumentNullException(nameof (list));
-    }
-
-    public AppenderCollection() => this.m_array = new IAppender[16];
-
-    public AppenderCollection(int capacity) => this.m_array = new IAppender[capacity];
-
-    public AppenderCollection(AppenderCollection c)
-    {
-      this.m_array = new IAppender[c.Count];
-      this.AddRange(c);
-    }
-
-    public AppenderCollection(IAppender[] a)
-    {
-      this.m_array = new IAppender[a.Length];
-      this.AddRange(a);
-    }
-
-    public AppenderCollection(ICollection col)
-    {
-      this.m_array = new IAppender[col.Count];
-      this.AddRange(col);
-    }
-
-    protected internal AppenderCollection(AppenderCollection.Tag tag)
-    {
-      this.m_array = (IAppender[]) null;
-    }
-
-    public virtual int Count => this.m_count;
-
-    public virtual void CopyTo(IAppender[] array) => this.CopyTo(array, 0);
-
-    public virtual void CopyTo(IAppender[] array, int start)
-    {
-      if (this.m_count > array.GetUpperBound(0) + 1 - start)
-        throw new ArgumentException("Destination array was not long enough.");
-      Array.Copy((Array) this.m_array, 0, (Array) array, start, this.m_count);
-    }
-
-    public virtual bool IsSynchronized => this.m_array.IsSynchronized;
-
-    public virtual object SyncRoot => this.m_array.SyncRoot;
-
-    public virtual IAppender this[int index]
-    {
-      get
-      {
-        this.ValidateIndex(index);
-        return this.m_array[index];
-      }
-      set
-      {
-        this.ValidateIndex(index);
-        ++this.m_version;
-        this.m_array[index] = value;
-      }
-    }
-
-    public virtual int Add(IAppender item)
-    {
-      if (this.m_count == this.m_array.Length)
-        this.EnsureCapacity(this.m_count + 1);
-      this.m_array[this.m_count] = item;
-      ++this.m_version;
-      return this.m_count++;
-    }
-
-    public virtual void Clear()
-    {
-      ++this.m_version;
-      this.m_array = new IAppender[16];
-      this.m_count = 0;
-    }
-
-    public virtual object Clone()
-    {
-      AppenderCollection appenderCollection = new AppenderCollection(this.m_count);
-      Array.Copy((Array) this.m_array, 0, (Array) appenderCollection.m_array, 0, this.m_count);
-      appenderCollection.m_count = this.m_count;
-      appenderCollection.m_version = this.m_version;
-      return (object) appenderCollection;
-    }
-
-    public virtual bool Contains(IAppender item)
-    {
-      for (int index = 0; index != this.m_count; ++index)
-      {
-        if (this.m_array[index].Equals((object) item))
-          return true;
-      }
-      return false;
-    }
-
-    public virtual int IndexOf(IAppender item)
-    {
-      for (int index = 0; index != this.m_count; ++index)
-      {
-        if (this.m_array[index].Equals((object) item))
-          return index;
-      }
-      return -1;
-    }
-
-    public virtual void Insert(int index, IAppender item)
-    {
-      this.ValidateIndex(index, true);
-      if (this.m_count == this.m_array.Length)
-        this.EnsureCapacity(this.m_count + 1);
-      if (index < this.m_count)
-        Array.Copy((Array) this.m_array, index, (Array) this.m_array, index + 1, this.m_count - index);
-      this.m_array[index] = item;
-      ++this.m_count;
-      ++this.m_version;
-    }
-
-    public virtual void Remove(IAppender item)
-    {
-      int index = this.IndexOf(item);
-      if (index < 0)
-        throw new ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
-      ++this.m_version;
-      this.RemoveAt(index);
-    }
-
-    public virtual void RemoveAt(int index)
-    {
-      this.ValidateIndex(index);
-      --this.m_count;
-      if (index < this.m_count)
-        Array.Copy((Array) this.m_array, index + 1, (Array) this.m_array, index, this.m_count - index);
-      Array.Copy((Array) new IAppender[1], 0, (Array) this.m_array, this.m_count, 1);
-      ++this.m_version;
-    }
-
-    public virtual bool IsFixedSize => false;
-
-    public virtual bool IsReadOnly => false;
-
-    public virtual AppenderCollection.IAppenderCollectionEnumerator GetEnumerator()
-    {
-      return (AppenderCollection.IAppenderCollectionEnumerator) new AppenderCollection.Enumerator(this);
-    }
-
-    public virtual int Capacity
-    {
-      get => this.m_array.Length;
-      set
-      {
-        if (value < this.m_count)
-          value = this.m_count;
-        if (value == this.m_array.Length)
-          return;
-        if (value > 0)
-        {
-          IAppender[] destinationArray = new IAppender[value];
-          Array.Copy((Array) this.m_array, 0, (Array) destinationArray, 0, this.m_count);
-          this.m_array = destinationArray;
-        }
-        else
-          this.m_array = new IAppender[16];
-      }
-    }
-
-    public virtual int AddRange(AppenderCollection x)
-    {
-      if (this.m_count + x.Count >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + x.Count);
-      Array.Copy((Array) x.m_array, 0, (Array) this.m_array, this.m_count, x.Count);
-      this.m_count += x.Count;
-      ++this.m_version;
-      return this.m_count;
-    }
-
-    public virtual int AddRange(IAppender[] x)
-    {
-      if (this.m_count + x.Length >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + x.Length);
-      Array.Copy((Array) x, 0, (Array) this.m_array, this.m_count, x.Length);
-      this.m_count += x.Length;
-      ++this.m_version;
-      return this.m_count;
-    }
-
-    public virtual int AddRange(ICollection col)
-    {
-      if (this.m_count + col.Count >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + col.Count);
-      foreach (IAppender appender in (IEnumerable) col)
-        this.Add(appender);
-      return this.m_count;
-    }
-
-    public virtual void TrimToSize() => this.Capacity = this.m_count;
-
-    public virtual IAppender[] ToArray()
-    {
-      IAppender[] destinationArray = new IAppender[this.m_count];
-      if (this.m_count > 0)
-        Array.Copy((Array) this.m_array, 0, (Array) destinationArray, 0, this.m_count);
-      return destinationArray;
-    }
-
-    private void ValidateIndex(int i) => this.ValidateIndex(i, false);
-
-    private void ValidateIndex(int i, bool allowEqualEnd)
-    {
-      int num = allowEqualEnd ? this.m_count : this.m_count - 1;
-      if (i < 0 || i > num)
-        throw SystemInfo.CreateArgumentOutOfRangeException(nameof (i), (object) i, "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object) i + "] Specified argument was out of the range of valid values.");
-    }
-
-    private void EnsureCapacity(int min)
-    {
-      int num = this.m_array.Length == 0 ? 16 : this.m_array.Length * 2;
-      if (num < min)
-        num = min;
-      this.Capacity = num;
-    }
-
-    void ICollection.CopyTo(Array array, int start)
-    {
-      if (this.m_count <= 0)
-        return;
-      Array.Copy((Array) this.m_array, 0, array, start, this.m_count);
-    }
-
-    object IList.this[int i]
-    {
-      get => (object) this[i];
-      set => this[i] = (IAppender) value;
-    }
-
-    int IList.Add(object x) => this.Add((IAppender) x);
-
-    bool IList.Contains(object x) => this.Contains((IAppender) x);
-
-    int IList.IndexOf(object x) => this.IndexOf((IAppender) x);
-
-    void IList.Insert(int pos, object x) => this.Insert(pos, (IAppender) x);
-
-    void IList.Remove(object x) => this.Remove((IAppender) x);
-
-    void IList.RemoveAt(int pos) => this.RemoveAt(pos);
-
-    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-
-    public interface IAppenderCollectionEnumerator
-    {
-      IAppender Current { get; }
-
-      bool MoveNext();
-
-      void Reset();
-    }
-
-    protected internal enum Tag
-    {
-      Default,
-    }
-
-    private sealed class Enumerator : IEnumerator, AppenderCollection.IAppenderCollectionEnumerator
-    {
-      private readonly AppenderCollection m_collection;
-      private int m_index;
-      private int m_version;
-
-      internal Enumerator(AppenderCollection tc)
-      {
-        this.m_collection = tc;
-        this.m_index = -1;
-        this.m_version = tc.m_version;
-      }
-
-      public IAppender Current => this.m_collection[this.m_index];
-
-      public bool MoveNext()
-      {
-        if (this.m_version != this.m_collection.m_version)
-          throw new InvalidOperationException("Collection was modified; enumeration operation may not execute.");
-        ++this.m_index;
-        return this.m_index < this.m_collection.Count;
-      }
-
-      public void Reset() => this.m_index = -1;
-
-      object IEnumerator.Current => (object) this.Current;
-    }
-
-    private sealed class ReadOnlyAppenderCollection : AppenderCollection, ICollection, IEnumerable
-    {
-      private readonly AppenderCollection m_collection;
-
-      internal ReadOnlyAppenderCollection(AppenderCollection list)
-        : base(AppenderCollection.Tag.Default)
-      {
-        this.m_collection = list;
-      }
-
-      public override void CopyTo(IAppender[] array) => this.m_collection.CopyTo(array);
-
-      public override void CopyTo(IAppender[] array, int start)
-      {
-        this.m_collection.CopyTo(array, start);
-      }
-
-      void ICollection.CopyTo(Array array, int start)
-      {
-        ((ICollection) this.m_collection).CopyTo(array, start);
-      }
-
-      public override int Count => this.m_collection.Count;
-
-      public override bool IsSynchronized => this.m_collection.IsSynchronized;
-
-      public override object SyncRoot => this.m_collection.SyncRoot;
-
-      public override IAppender this[int i]
-      {
-        get => this.m_collection[i];
-        set
-        {
-          throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-        }
-      }
-
-      public override int Add(IAppender x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void Clear()
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override bool Contains(IAppender x) => this.m_collection.Contains(x);
-
-      public override int IndexOf(IAppender x) => this.m_collection.IndexOf(x);
-
-      public override void Insert(int pos, IAppender x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void Remove(IAppender x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void RemoveAt(int pos)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override bool IsFixedSize => true;
-
-      public override bool IsReadOnly => true;
-
-      public override AppenderCollection.IAppenderCollectionEnumerator GetEnumerator()
-      {
-        return this.m_collection.GetEnumerator();
-      }
-
-      public override int Capacity
-      {
-        get => this.m_collection.Capacity;
-        set
-        {
-          throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-        }
-      }
-
-      public override int AddRange(AppenderCollection x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override int AddRange(IAppender[] x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/AppenderSkeleton.cs b/MSHALTester/log4net/Appender/AppenderSkeleton.cs
deleted file mode 100644
index e8fcb2a..0000000
--- a/MSHALTester/log4net/Appender/AppenderSkeleton.cs
+++ /dev/null
@@ -1,209 +0,0 @@
-using log4net.Core;
-using log4net.Filter;
-using log4net.Layout;
-using log4net.Util;
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public abstract class AppenderSkeleton : IAppender, IOptionHandler
-  {
-    private const int c_renderBufferSize = 256;
-    private const int c_renderBufferMaxCapacity = 1024;
-    private ILayout m_layout;
-    private string m_name;
-    private Level m_threshold;
-    private IErrorHandler m_errorHandler;
-    private IFilter m_headFilter;
-    private IFilter m_tailFilter;
-    private bool m_closed = false;
-    private bool m_recursiveGuard = false;
-    private ReusableStringWriter m_renderWriter = (ReusableStringWriter) null;
-
-    protected AppenderSkeleton()
-    {
-      this.m_errorHandler = (IErrorHandler) new OnlyOnceErrorHandler(this.GetType().Name);
-    }
-
-    ~AppenderSkeleton()
-    {
-      if (this.m_closed)
-        return;
-      LogLog.Debug("AppenderSkeleton: Finalizing appender named [" + this.m_name + "].");
-      this.Close();
-    }
-
-    public Level Threshold
-    {
-      get => this.m_threshold;
-      set => this.m_threshold = value;
-    }
-
-    public virtual IErrorHandler ErrorHandler
-    {
-      get => this.m_errorHandler;
-      set
-      {
-        lock (this)
-        {
-          if (value == null)
-            LogLog.Warn("AppenderSkeleton: You have tried to set a null error-handler.");
-          else
-            this.m_errorHandler = value;
-        }
-      }
-    }
-
-    public virtual IFilter FilterHead => this.m_headFilter;
-
-    public virtual ILayout Layout
-    {
-      get => this.m_layout;
-      set => this.m_layout = value;
-    }
-
-    public virtual void ActivateOptions()
-    {
-    }
-
-    public string Name
-    {
-      get => this.m_name;
-      set => this.m_name = value;
-    }
-
-    public void Close()
-    {
-      lock (this)
-      {
-        if (this.m_closed)
-          return;
-        this.OnClose();
-        this.m_closed = true;
-      }
-    }
-
-    public void DoAppend(LoggingEvent loggingEvent)
-    {
-      lock (this)
-      {
-        if (this.m_closed)
-        {
-          this.ErrorHandler.Error("Attempted to append to closed appender named [" + this.m_name + "].");
-        }
-        else
-        {
-          if (this.m_recursiveGuard)
-            return;
-          try
-          {
-            this.m_recursiveGuard = true;
-            if (!this.IsAsSevereAsThreshold(loggingEvent.Level))
-              return;
-            IFilter filter = this.FilterHead;
-            while (filter != null)
-            {
-              switch (filter.Decide(loggingEvent))
-              {
-                case FilterDecision.Deny:
-                  return;
-                case FilterDecision.Neutral:
-                  filter = filter.Next;
-                  continue;
-                case FilterDecision.Accept:
-                  filter = (IFilter) null;
-                  continue;
-                default:
-                  continue;
-              }
-            }
-            if (!this.PreAppendCheck())
-              return;
-            this.Append(loggingEvent);
-          }
-          catch (Exception ex)
-          {
-            this.ErrorHandler.Error("Failed in DoAppend", ex);
-          }
-          catch
-          {
-            this.ErrorHandler.Error("Failed in DoAppend (unknown exception)");
-          }
-          finally
-          {
-            this.m_recursiveGuard = false;
-          }
-        }
-      }
-    }
-
-    public virtual void AddFilter(IFilter filter)
-    {
-      if (filter == null)
-        throw new ArgumentNullException("filter param must not be null");
-      if (this.m_headFilter == null)
-      {
-        this.m_headFilter = this.m_tailFilter = filter;
-      }
-      else
-      {
-        this.m_tailFilter.Next = filter;
-        this.m_tailFilter = filter;
-      }
-    }
-
-    public virtual void ClearFilters() => this.m_headFilter = this.m_tailFilter = (IFilter) null;
-
-    protected virtual bool IsAsSevereAsThreshold(Level level)
-    {
-      return this.m_threshold == (Level) null || level >= this.m_threshold;
-    }
-
-    protected virtual void OnClose()
-    {
-    }
-
-    protected abstract void Append(LoggingEvent loggingEvent);
-
-    protected virtual bool PreAppendCheck()
-    {
-      if (this.m_layout != null || !this.RequiresLayout)
-        return true;
-      this.ErrorHandler.Error("AppenderSkeleton: No layout set for the appender named [" + this.m_name + "].");
-      return false;
-    }
-
-    protected string RenderLoggingEvent(LoggingEvent loggingEvent)
-    {
-      if (this.m_renderWriter == null)
-        this.m_renderWriter = new ReusableStringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-      this.m_renderWriter.Reset(1024, 256);
-      this.RenderLoggingEvent((TextWriter) this.m_renderWriter, loggingEvent);
-      return this.m_renderWriter.ToString();
-    }
-
-    protected void RenderLoggingEvent(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      if (this.m_layout == null)
-        throw new InvalidOperationException("A layout must be set");
-      if (this.m_layout.IgnoresException)
-      {
-        string exceptionString = loggingEvent.GetExceptionString();
-        if (exceptionString != null && exceptionString.Length > 0)
-        {
-          this.m_layout.Format(writer, loggingEvent);
-          writer.WriteLine(exceptionString);
-        }
-        else
-          this.m_layout.Format(writer, loggingEvent);
-      }
-      else
-        this.m_layout.Format(writer, loggingEvent);
-    }
-
-    protected virtual bool RequiresLayout => false;
-  }
-}
diff --git a/MSHALTester/log4net/Appender/AspNetTraceAppender.cs b/MSHALTester/log4net/Appender/AspNetTraceAppender.cs
deleted file mode 100644
index 84d0a30..0000000
--- a/MSHALTester/log4net/Appender/AspNetTraceAppender.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-using log4net.Core;
-using System.Web;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class AspNetTraceAppender : AppenderSkeleton
-  {
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      if (HttpContext.Current == null || !HttpContext.Current.Trace.IsEnabled)
-        return;
-      if (loggingEvent.Level >= Level.Warn)
-        HttpContext.Current.Trace.Warn(loggingEvent.LoggerName, this.RenderLoggingEvent(loggingEvent));
-      else
-        HttpContext.Current.Trace.Write(loggingEvent.LoggerName, this.RenderLoggingEvent(loggingEvent));
-    }
-
-    protected override bool RequiresLayout => true;
-  }
-}
diff --git a/MSHALTester/log4net/Appender/BufferingAppenderSkeleton.cs b/MSHALTester/log4net/Appender/BufferingAppenderSkeleton.cs
deleted file mode 100644
index a56945e..0000000
--- a/MSHALTester/log4net/Appender/BufferingAppenderSkeleton.cs
+++ /dev/null
@@ -1,135 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public abstract class BufferingAppenderSkeleton : AppenderSkeleton
-  {
-    private const int DEFAULT_BUFFER_SIZE = 512;
-    private int m_bufferSize = 512;
-    private CyclicBuffer m_cb;
-    private ITriggeringEventEvaluator m_evaluator;
-    private bool m_lossy = false;
-    private ITriggeringEventEvaluator m_lossyEvaluator;
-    private FixFlags m_fixFlags = FixFlags.All;
-    private readonly bool m_eventMustBeFixed;
-
-    protected BufferingAppenderSkeleton()
-      : this(true)
-    {
-    }
-
-    protected BufferingAppenderSkeleton(bool eventMustBeFixed)
-    {
-      this.m_eventMustBeFixed = eventMustBeFixed;
-    }
-
-    public bool Lossy
-    {
-      get => this.m_lossy;
-      set => this.m_lossy = value;
-    }
-
-    public int BufferSize
-    {
-      get => this.m_bufferSize;
-      set => this.m_bufferSize = value;
-    }
-
-    public ITriggeringEventEvaluator Evaluator
-    {
-      get => this.m_evaluator;
-      set => this.m_evaluator = value;
-    }
-
-    public ITriggeringEventEvaluator LossyEvaluator
-    {
-      get => this.m_lossyEvaluator;
-      set => this.m_lossyEvaluator = value;
-    }
-
-    [Obsolete("Use Fix property")]
-    public virtual bool OnlyFixPartialEventData
-    {
-      get => this.Fix == FixFlags.Partial;
-      set
-      {
-        if (value)
-          this.Fix = FixFlags.Partial;
-        else
-          this.Fix = FixFlags.All;
-      }
-    }
-
-    public virtual FixFlags Fix
-    {
-      get => this.m_fixFlags;
-      set => this.m_fixFlags = value;
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      if (this.m_lossy && this.m_evaluator == null)
-        this.ErrorHandler.Error("Appender [" + this.Name + "] is Lossy but has no Evaluator. The buffer will never be sent!");
-      if (this.m_bufferSize > 1)
-        this.m_cb = new CyclicBuffer(this.m_bufferSize);
-      else
-        this.m_cb = (CyclicBuffer) null;
-    }
-
-    protected override void OnClose()
-    {
-      if (this.m_cb == null || this.m_cb.Length <= 0)
-        return;
-      if (this.m_lossy)
-      {
-        if (this.m_lossyEvaluator == null)
-          return;
-        foreach (LoggingEvent loggingEvent in this.m_cb.PopAll())
-        {
-          if (this.m_lossyEvaluator.IsTriggeringEvent(loggingEvent))
-            this.SendBuffer(new LoggingEvent[1]
-            {
-              loggingEvent
-            });
-        }
-      }
-      else
-        this.SendBuffer(this.m_cb);
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      if (this.m_cb == null || this.m_bufferSize <= 1)
-      {
-        if (this.m_lossy && (this.m_evaluator == null || !this.m_evaluator.IsTriggeringEvent(loggingEvent)) && (this.m_lossyEvaluator == null || !this.m_lossyEvaluator.IsTriggeringEvent(loggingEvent)))
-          return;
-        if (this.m_eventMustBeFixed)
-          loggingEvent.Fix = this.Fix;
-        this.SendBuffer(new LoggingEvent[1]{ loggingEvent });
-      }
-      else
-      {
-        loggingEvent.Fix = this.Fix;
-        LoggingEvent loggingEvent1 = this.m_cb.Append(loggingEvent);
-        if (loggingEvent1 != null && this.m_lossyEvaluator != null && this.m_lossyEvaluator.IsTriggeringEvent(loggingEvent1))
-          this.SendBuffer(new LoggingEvent[1]
-          {
-            loggingEvent1
-          });
-        if ((loggingEvent1 == null || this.m_lossy) && (this.m_evaluator == null || !this.m_evaluator.IsTriggeringEvent(loggingEvent)))
-          return;
-        this.SendBuffer(this.m_cb);
-      }
-    }
-
-    protected virtual void SendBuffer(CyclicBuffer buffer) => this.SendBuffer(buffer.PopAll());
-
-    protected virtual void SendBuffer(LoggingEvent[] events)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/BufferingForwardingAppender.cs b/MSHALTester/log4net/Appender/BufferingForwardingAppender.cs
deleted file mode 100644
index 15cea65..0000000
--- a/MSHALTester/log4net/Appender/BufferingForwardingAppender.cs
+++ /dev/null
@@ -1,95 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class BufferingForwardingAppender : BufferingAppenderSkeleton, IAppenderAttachable
-  {
-    private AppenderAttachedImpl m_appenderAttachedImpl;
-
-    protected override void OnClose()
-    {
-      lock (this)
-      {
-        base.OnClose();
-        if (this.m_appenderAttachedImpl == null)
-          return;
-        this.m_appenderAttachedImpl.RemoveAllAppenders();
-      }
-    }
-
-    protected override void SendBuffer(LoggingEvent[] events)
-    {
-      if (this.m_appenderAttachedImpl == null)
-        return;
-      foreach (LoggingEvent loggingEvent in events)
-        this.m_appenderAttachedImpl.AppendLoopOnAppenders(loggingEvent);
-    }
-
-    public virtual void AddAppender(IAppender newAppender)
-    {
-      if (newAppender == null)
-        throw new ArgumentNullException(nameof (newAppender));
-      lock (this)
-      {
-        if (this.m_appenderAttachedImpl == null)
-          this.m_appenderAttachedImpl = new AppenderAttachedImpl();
-        this.m_appenderAttachedImpl.AddAppender(newAppender);
-      }
-    }
-
-    public virtual AppenderCollection Appenders
-    {
-      get
-      {
-        lock (this)
-          return this.m_appenderAttachedImpl == null ? AppenderCollection.EmptyCollection : this.m_appenderAttachedImpl.Appenders;
-      }
-    }
-
-    public virtual IAppender GetAppender(string name)
-    {
-      lock (this)
-        return this.m_appenderAttachedImpl == null || name == null ? (IAppender) null : this.m_appenderAttachedImpl.GetAppender(name);
-    }
-
-    public virtual void RemoveAllAppenders()
-    {
-      lock (this)
-      {
-        if (this.m_appenderAttachedImpl == null)
-          return;
-        this.m_appenderAttachedImpl.RemoveAllAppenders();
-        this.m_appenderAttachedImpl = (AppenderAttachedImpl) null;
-      }
-    }
-
-    public virtual IAppender RemoveAppender(IAppender appender)
-    {
-      lock (this)
-      {
-        if (appender != null)
-        {
-          if (this.m_appenderAttachedImpl != null)
-            return this.m_appenderAttachedImpl.RemoveAppender(appender);
-        }
-      }
-      return (IAppender) null;
-    }
-
-    public virtual IAppender RemoveAppender(string name)
-    {
-      lock (this)
-      {
-        if (name != null)
-        {
-          if (this.m_appenderAttachedImpl != null)
-            return this.m_appenderAttachedImpl.RemoveAppender(name);
-        }
-      }
-      return (IAppender) null;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/ColoredConsoleAppender.cs b/MSHALTester/log4net/Appender/ColoredConsoleAppender.cs
deleted file mode 100644
index 3a4c906..0000000
--- a/MSHALTester/log4net/Appender/ColoredConsoleAppender.cs
+++ /dev/null
@@ -1,178 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using log4net.Util;
-using System;
-using System.Globalization;
-using System.IO;
-using System.Runtime.InteropServices;
-using System.Text;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class ColoredConsoleAppender : AppenderSkeleton
-  {
-    public const string ConsoleOut = "Console.Out";
-    public const string ConsoleError = "Console.Error";
-    private const uint STD_OUTPUT_HANDLE = 4294967285;
-    private const uint STD_ERROR_HANDLE = 4294967284;
-    private static readonly char[] s_windowsNewline = new char[2]
-    {
-      '\r',
-      '\n'
-    };
-    private bool m_writeToErrorStream = false;
-    private LevelMapping m_levelMapping = new LevelMapping();
-    private StreamWriter m_consoleOutputWriter = (StreamWriter) null;
-
-    public ColoredConsoleAppender()
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout property")]
-    public ColoredConsoleAppender(ILayout layout)
-      : this(layout, false)
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout & Target properties")]
-    public ColoredConsoleAppender(ILayout layout, bool writeToErrorStream)
-    {
-      this.Layout = layout;
-      this.m_writeToErrorStream = writeToErrorStream;
-    }
-
-    public virtual string Target
-    {
-      get => this.m_writeToErrorStream ? "Console.Error" : "Console.Out";
-      set
-      {
-        if (string.Compare("Console.Error", value.Trim(), true, CultureInfo.InvariantCulture) == 0)
-          this.m_writeToErrorStream = true;
-        else
-          this.m_writeToErrorStream = false;
-      }
-    }
-
-    public void AddMapping(ColoredConsoleAppender.LevelColors mapping)
-    {
-      this.m_levelMapping.Add((LevelMappingEntry) mapping);
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      if (this.m_consoleOutputWriter == null)
-        return;
-      IntPtr zero = IntPtr.Zero;
-      IntPtr consoleHandle = !this.m_writeToErrorStream ? ColoredConsoleAppender.GetStdHandle(4294967285U) : ColoredConsoleAppender.GetStdHandle(4294967284U);
-      ushort attributes = 7;
-      if (this.m_levelMapping.Lookup(loggingEvent.Level) is ColoredConsoleAppender.LevelColors levelColors)
-        attributes = levelColors.CombinedColor;
-      string str = this.RenderLoggingEvent(loggingEvent);
-      ColoredConsoleAppender.CONSOLE_SCREEN_BUFFER_INFO bufferInfo;
-      ColoredConsoleAppender.GetConsoleScreenBufferInfo(consoleHandle, out bufferInfo);
-      ColoredConsoleAppender.SetConsoleTextAttribute(consoleHandle, attributes);
-      char[] charArray = str.ToCharArray();
-      int length = charArray.Length;
-      bool flag = false;
-      if (length > 1 && charArray[length - 2] == '\r' && charArray[length - 1] == '\n')
-      {
-        length -= 2;
-        flag = true;
-      }
-      this.m_consoleOutputWriter.Write(charArray, 0, length);
-      ColoredConsoleAppender.SetConsoleTextAttribute(consoleHandle, bufferInfo.wAttributes);
-      if (!flag)
-        return;
-      this.m_consoleOutputWriter.Write(ColoredConsoleAppender.s_windowsNewline, 0, 2);
-    }
-
-    protected override bool RequiresLayout => true;
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      this.m_levelMapping.ActivateOptions();
-      this.m_consoleOutputWriter = new StreamWriter(!this.m_writeToErrorStream ? Console.OpenStandardOutput() : Console.OpenStandardError(), Encoding.GetEncoding(ColoredConsoleAppender.GetConsoleOutputCP()), 256);
-      this.m_consoleOutputWriter.AutoFlush = true;
-      GC.SuppressFinalize((object) this.m_consoleOutputWriter);
-    }
-
-    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
-    private static extern int GetConsoleOutputCP();
-
-    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
-    private static extern bool SetConsoleTextAttribute(IntPtr consoleHandle, ushort attributes);
-
-    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
-    private static extern bool GetConsoleScreenBufferInfo(
-      IntPtr consoleHandle,
-      out ColoredConsoleAppender.CONSOLE_SCREEN_BUFFER_INFO bufferInfo);
-
-    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
-    private static extern IntPtr GetStdHandle(uint type);
-
-    [Flags]
-    public enum Colors
-    {
-      Blue = 1,
-      Green = 2,
-      Red = 4,
-      White = Red | Green | Blue, // 0x00000007
-      Yellow = Red | Green, // 0x00000006
-      Purple = Red | Blue, // 0x00000005
-      Cyan = Green | Blue, // 0x00000003
-      HighIntensity = 8,
-    }
-
-    private struct COORD
-    {
-      public ushort x;
-      public ushort y;
-    }
-
-    private struct SMALL_RECT
-    {
-      public ushort Left;
-      public ushort Top;
-      public ushort Right;
-      public ushort Bottom;
-    }
-
-    private struct CONSOLE_SCREEN_BUFFER_INFO
-    {
-      public ColoredConsoleAppender.COORD dwSize;
-      public ColoredConsoleAppender.COORD dwCursorPosition;
-      public ushort wAttributes;
-      public ColoredConsoleAppender.SMALL_RECT srWindow;
-      public ColoredConsoleAppender.COORD dwMaximumWindowSize;
-    }
-
-    public class LevelColors : LevelMappingEntry
-    {
-      private ColoredConsoleAppender.Colors m_foreColor;
-      private ColoredConsoleAppender.Colors m_backColor;
-      private ushort m_combinedColor = 0;
-
-      public ColoredConsoleAppender.Colors ForeColor
-      {
-        get => this.m_foreColor;
-        set => this.m_foreColor = value;
-      }
-
-      public ColoredConsoleAppender.Colors BackColor
-      {
-        get => this.m_backColor;
-        set => this.m_backColor = value;
-      }
-
-      public override void ActivateOptions()
-      {
-        base.ActivateOptions();
-        this.m_combinedColor = (ushort) (this.m_foreColor + ((int) this.m_backColor << 4));
-      }
-
-      internal ushort CombinedColor => this.m_combinedColor;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/ConsoleAppender.cs b/MSHALTester/log4net/Appender/ConsoleAppender.cs
deleted file mode 100644
index 2d951a1..0000000
--- a/MSHALTester/log4net/Appender/ConsoleAppender.cs
+++ /dev/null
@@ -1,54 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class ConsoleAppender : AppenderSkeleton
-  {
-    public const string ConsoleOut = "Console.Out";
-    public const string ConsoleError = "Console.Error";
-    private bool m_writeToErrorStream = false;
-
-    public ConsoleAppender()
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout property")]
-    public ConsoleAppender(ILayout layout)
-      : this(layout, false)
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout & Target properties")]
-    public ConsoleAppender(ILayout layout, bool writeToErrorStream)
-    {
-      this.Layout = layout;
-      this.m_writeToErrorStream = writeToErrorStream;
-    }
-
-    public virtual string Target
-    {
-      get => this.m_writeToErrorStream ? "Console.Error" : "Console.Out";
-      set
-      {
-        if (string.Compare("Console.Error", value.Trim(), true, CultureInfo.InvariantCulture) == 0)
-          this.m_writeToErrorStream = true;
-        else
-          this.m_writeToErrorStream = false;
-      }
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      if (this.m_writeToErrorStream)
-        Console.Error.Write(this.RenderLoggingEvent(loggingEvent));
-      else
-        Console.Write(this.RenderLoggingEvent(loggingEvent));
-    }
-
-    protected override bool RequiresLayout => true;
-  }
-}
diff --git a/MSHALTester/log4net/Appender/DebugAppender.cs b/MSHALTester/log4net/Appender/DebugAppender.cs
deleted file mode 100644
index 10dbd4d..0000000
--- a/MSHALTester/log4net/Appender/DebugAppender.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using System;
-using System.Diagnostics;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class DebugAppender : AppenderSkeleton
-  {
-    private bool m_immediateFlush = true;
-
-    public DebugAppender()
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout property")]
-    public DebugAppender(ILayout layout) => this.Layout = layout;
-
-    public bool ImmediateFlush
-    {
-      get => this.m_immediateFlush;
-      set => this.m_immediateFlush = value;
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      Debug.Write(this.RenderLoggingEvent(loggingEvent), loggingEvent.LoggerName);
-      if (!this.m_immediateFlush)
-        return;
-      Debug.Flush();
-    }
-
-    protected override bool RequiresLayout => true;
-  }
-}
diff --git a/MSHALTester/log4net/Appender/EventLogAppender.cs b/MSHALTester/log4net/Appender/EventLogAppender.cs
deleted file mode 100644
index f2cd00f..0000000
--- a/MSHALTester/log4net/Appender/EventLogAppender.cs
+++ /dev/null
@@ -1,156 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using log4net.Util;
-using System;
-using System.Diagnostics;
-using System.Threading;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class EventLogAppender : AppenderSkeleton
-  {
-    private string m_logName;
-    private string m_applicationName;
-    private string m_machineName;
-    private LevelMapping m_levelMapping = new LevelMapping();
-    private SecurityContext m_securityContext;
-
-    public EventLogAppender()
-    {
-      this.m_applicationName = Thread.GetDomain().FriendlyName;
-      this.m_logName = "Application";
-      this.m_machineName = ".";
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout property")]
-    public EventLogAppender(ILayout layout)
-      : this()
-    {
-      this.Layout = layout;
-    }
-
-    public string LogName
-    {
-      get => this.m_logName;
-      set => this.m_logName = value;
-    }
-
-    public string ApplicationName
-    {
-      get => this.m_applicationName;
-      set => this.m_applicationName = value;
-    }
-
-    public string MachineName
-    {
-      get => this.m_machineName;
-      set
-      {
-      }
-    }
-
-    public void AddMapping(EventLogAppender.Level2EventLogEntryType mapping)
-    {
-      this.m_levelMapping.Add((LevelMappingEntry) mapping);
-    }
-
-    public SecurityContext SecurityContext
-    {
-      get => this.m_securityContext;
-      set => this.m_securityContext = value;
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      if (this.m_securityContext == null)
-        this.m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext((object) this);
-      bool flag = false;
-      string str1 = (string) null;
-      using (this.SecurityContext.Impersonate((object) this))
-      {
-        flag = EventLog.SourceExists(this.m_applicationName);
-        if (flag)
-          str1 = EventLog.LogNameFromSourceName(this.m_applicationName, this.m_machineName);
-      }
-      if (flag && str1 != this.m_logName)
-        LogLog.Debug("EventLogAppender: Changing event source [" + this.m_applicationName + "] from log [" + str1 + "] to log [" + this.m_logName + "]");
-      else if (!flag)
-        LogLog.Debug("EventLogAppender: Creating event source Source [" + this.m_applicationName + "] in log " + this.m_logName + "]");
-      string str2 = (string) null;
-      using (this.SecurityContext.Impersonate((object) this))
-      {
-        if (flag && str1 != this.m_logName)
-        {
-          EventLog.DeleteEventSource(this.m_applicationName, this.m_machineName);
-          EventLog.CreateEventSource(this.m_applicationName, this.m_logName, this.m_machineName);
-          str2 = EventLog.LogNameFromSourceName(this.m_applicationName, this.m_machineName);
-        }
-        else if (!flag)
-        {
-          EventLog.CreateEventSource(this.m_applicationName, this.m_logName, this.m_machineName);
-          str2 = EventLog.LogNameFromSourceName(this.m_applicationName, this.m_machineName);
-        }
-      }
-      this.m_levelMapping.ActivateOptions();
-      LogLog.Debug("EventLogAppender: Source [" + this.m_applicationName + "] is registered to log [" + str2 + "]");
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      pattern_1 = 0;
-      switch (loggingEvent.LookupProperty("EventID"))
-      {
-        case string s:
-          if (s.Length > 0)
-          {
-            int val;
-            if (SystemInfo.TryParse(s, out val))
-            {
-              pattern_1 = val;
-              break;
-            }
-            this.ErrorHandler.Error("Unable to parse event ID property [" + s + "].");
-            break;
-          }
-          break;
-      }
-      try
-      {
-        string message = this.RenderLoggingEvent(loggingEvent);
-        if (message.Length > 32000)
-          message = message.Substring(0, 32000);
-        EventLogEntryType entryType = this.GetEntryType(loggingEvent.Level);
-        using (this.SecurityContext.Impersonate((object) this))
-          EventLog.WriteEntry(this.m_applicationName, message, entryType, pattern_1);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Unable to write to event log [" + this.m_logName + "] using source [" + this.m_applicationName + "]", ex);
-      }
-    }
-
-    protected override bool RequiresLayout => true;
-
-    protected virtual EventLogEntryType GetEntryType(Level level)
-    {
-      if (this.m_levelMapping.Lookup(level) is EventLogAppender.Level2EventLogEntryType eventLogEntryType)
-        return eventLogEntryType.EventLogEntryType;
-      if (level >= Level.Error)
-        return EventLogEntryType.Error;
-      return level == Level.Warn ? EventLogEntryType.Warning : EventLogEntryType.Information;
-    }
-
-    public class Level2EventLogEntryType : LevelMappingEntry
-    {
-      private EventLogEntryType m_entryType;
-
-      public EventLogEntryType EventLogEntryType
-      {
-        get => this.m_entryType;
-        set => this.m_entryType = value;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/FileAppender.cs b/MSHALTester/log4net/Appender/FileAppender.cs
deleted file mode 100644
index 2d3807c..0000000
--- a/MSHALTester/log4net/Appender/FileAppender.cs
+++ /dev/null
@@ -1,497 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using log4net.Util;
-using System;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class FileAppender : TextWriterAppender
-  {
-    private bool m_appendToFile = true;
-    private string m_fileName = (string) null;
-    private Encoding m_encoding = Encoding.Default;
-    private SecurityContext m_securityContext;
-    private FileAppender.LockingStream m_stream = (FileAppender.LockingStream) null;
-    private FileAppender.LockingModelBase m_lockingModel = (FileAppender.LockingModelBase) new FileAppender.ExclusiveLock();
-
-    public FileAppender()
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout, File & AppendToFile properties")]
-    public FileAppender(ILayout layout, string filename, bool append)
-    {
-      this.Layout = layout;
-      this.File = filename;
-      this.AppendToFile = append;
-      this.ActivateOptions();
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout & File properties")]
-    public FileAppender(ILayout layout, string filename)
-      : this(layout, filename, true)
-    {
-    }
-
-    public virtual string File
-    {
-      get => this.m_fileName;
-      set => this.m_fileName = value;
-    }
-
-    public bool AppendToFile
-    {
-      get => this.m_appendToFile;
-      set => this.m_appendToFile = value;
-    }
-
-    public Encoding Encoding
-    {
-      get => this.m_encoding;
-      set => this.m_encoding = value;
-    }
-
-    public SecurityContext SecurityContext
-    {
-      get => this.m_securityContext;
-      set => this.m_securityContext = value;
-    }
-
-    public FileAppender.LockingModelBase LockingModel
-    {
-      get => this.m_lockingModel;
-      set => this.m_lockingModel = value;
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      if (this.m_securityContext == null)
-        this.m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext((object) this);
-      if (this.m_lockingModel == null)
-        this.m_lockingModel = (FileAppender.LockingModelBase) new FileAppender.ExclusiveLock();
-      this.m_lockingModel.CurrentAppender = this;
-      using (this.SecurityContext.Impersonate((object) this))
-        this.m_fileName = FileAppender.ConvertToFullPath(this.m_fileName.Trim());
-      if (this.m_fileName != null)
-      {
-        this.SafeOpenFile(this.m_fileName, this.m_appendToFile);
-      }
-      else
-      {
-        LogLog.Warn("FileAppender: File option not set for appender [" + this.Name + "].");
-        LogLog.Warn("FileAppender: Are you using FileAppender instead of ConsoleAppender?");
-      }
-    }
-
-    protected override void Reset()
-    {
-      base.Reset();
-      this.m_fileName = (string) null;
-    }
-
-    protected override void PrepareWriter()
-    {
-      this.SafeOpenFile(this.m_fileName, this.m_appendToFile);
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      if (!this.m_stream.AcquireLock())
-        return;
-      try
-      {
-        base.Append(loggingEvent);
-      }
-      finally
-      {
-        this.m_stream.ReleaseLock();
-      }
-    }
-
-    protected override void WriteFooter()
-    {
-      if (this.m_stream == null)
-        return;
-      this.m_stream.AcquireLock();
-      try
-      {
-        base.WriteFooter();
-      }
-      finally
-      {
-        this.m_stream.ReleaseLock();
-      }
-    }
-
-    protected override void WriteHeader()
-    {
-      if (this.m_stream == null)
-        return;
-      if (!this.m_stream.AcquireLock())
-        return;
-      try
-      {
-        base.WriteHeader();
-      }
-      finally
-      {
-        this.m_stream.ReleaseLock();
-      }
-    }
-
-    protected override void CloseWriter()
-    {
-      if (this.m_stream == null)
-        return;
-      this.m_stream.AcquireLock();
-      try
-      {
-        base.CloseWriter();
-      }
-      finally
-      {
-        this.m_stream.ReleaseLock();
-      }
-    }
-
-    protected void CloseFile() => this.WriteFooterAndCloseWriter();
-
-    protected virtual void SafeOpenFile(string fileName, bool append)
-    {
-      try
-      {
-        this.OpenFile(fileName, append);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("OpenFile(" + fileName + "," + (object) append + ") call failed.", ex, ErrorCode.FileOpenFailure);
-      }
-    }
-
-    protected virtual void OpenFile(string fileName, bool append)
-    {
-      if (LogLog.IsErrorEnabled)
-      {
-        bool flag = false;
-        using (this.SecurityContext.Impersonate((object) this))
-          flag = Path.IsPathRooted(fileName);
-        if (!flag)
-          LogLog.Error("FileAppender: INTERNAL ERROR. OpenFile(" + fileName + "): File name is not fully qualified.");
-      }
-      lock (this)
-      {
-        this.Reset();
-        LogLog.Debug("FileAppender: Opening file for writing [" + fileName + "] append [" + (object) append + "]");
-        this.m_fileName = fileName;
-        this.m_appendToFile = append;
-        this.LockingModel.CurrentAppender = this;
-        this.LockingModel.OpenFile(fileName, append, this.m_encoding);
-        this.m_stream = new FileAppender.LockingStream(this.LockingModel);
-        if (this.m_stream != null)
-        {
-          this.m_stream.AcquireLock();
-          try
-          {
-            this.SetQWForFiles((TextWriter) new StreamWriter((Stream) this.m_stream, this.m_encoding));
-          }
-          finally
-          {
-            this.m_stream.ReleaseLock();
-          }
-        }
-        this.WriteHeader();
-      }
-    }
-
-    protected virtual void SetQWForFiles(Stream fileStream)
-    {
-      this.SetQWForFiles((TextWriter) new StreamWriter(fileStream, this.m_encoding));
-    }
-
-    protected virtual void SetQWForFiles(TextWriter writer)
-    {
-      this.QuietWriter = new QuietTextWriter(writer, this.ErrorHandler);
-    }
-
-    protected static string ConvertToFullPath(string path) => SystemInfo.ConvertToFullPath(path);
-
-    private sealed class LockingStream : Stream, IDisposable
-    {
-      private Stream m_realStream = (Stream) null;
-      private FileAppender.LockingModelBase m_lockingModel = (FileAppender.LockingModelBase) null;
-      private int m_readTotal = -1;
-      private int m_lockLevel = 0;
-
-      public LockingStream(FileAppender.LockingModelBase locking)
-      {
-        this.m_lockingModel = locking != null ? locking : throw new ArgumentException("Locking model may not be null", nameof (locking));
-      }
-
-      public override IAsyncResult BeginRead(
-        byte[] buffer,
-        int offset,
-        int count,
-        AsyncCallback callback,
-        object state)
-      {
-        this.AssertLocked();
-        IAsyncResult asyncResult = this.m_realStream.BeginRead(buffer, offset, count, callback, state);
-        this.m_readTotal = this.EndRead(asyncResult);
-        return asyncResult;
-      }
-
-      public override IAsyncResult BeginWrite(
-        byte[] buffer,
-        int offset,
-        int count,
-        AsyncCallback callback,
-        object state)
-      {
-        this.AssertLocked();
-        IAsyncResult asyncResult = this.m_realStream.BeginWrite(buffer, offset, count, callback, state);
-        this.EndWrite(asyncResult);
-        return asyncResult;
-      }
-
-      public override void Close() => this.m_lockingModel.CloseFile();
-
-      public override int EndRead(IAsyncResult asyncResult)
-      {
-        this.AssertLocked();
-        return this.m_readTotal;
-      }
-
-      public override void EndWrite(IAsyncResult asyncResult)
-      {
-      }
-
-      public override void Flush()
-      {
-        this.AssertLocked();
-        this.m_realStream.Flush();
-      }
-
-      public override int Read(byte[] buffer, int offset, int count)
-      {
-        return this.m_realStream.Read(buffer, offset, count);
-      }
-
-      public override int ReadByte() => this.m_realStream.ReadByte();
-
-      public override long Seek(long offset, SeekOrigin origin)
-      {
-        this.AssertLocked();
-        return this.m_realStream.Seek(offset, origin);
-      }
-
-      public override void SetLength(long value)
-      {
-        this.AssertLocked();
-        this.m_realStream.SetLength(value);
-      }
-
-      void IDisposable.Dispose() => this.Close();
-
-      public override void Write(byte[] buffer, int offset, int count)
-      {
-        this.AssertLocked();
-        this.m_realStream.Write(buffer, offset, count);
-      }
-
-      public override void WriteByte(byte value)
-      {
-        this.AssertLocked();
-        this.m_realStream.WriteByte(value);
-      }
-
-      public override bool CanRead => false;
-
-      public override bool CanSeek
-      {
-        get
-        {
-          this.AssertLocked();
-          return this.m_realStream.CanSeek;
-        }
-      }
-
-      public override bool CanWrite
-      {
-        get
-        {
-          this.AssertLocked();
-          return this.m_realStream.CanWrite;
-        }
-      }
-
-      public override long Length
-      {
-        get
-        {
-          this.AssertLocked();
-          return this.m_realStream.Length;
-        }
-      }
-
-      public override long Position
-      {
-        get
-        {
-          this.AssertLocked();
-          return this.m_realStream.Position;
-        }
-        set
-        {
-          this.AssertLocked();
-          this.m_realStream.Position = value;
-        }
-      }
-
-      private void AssertLocked()
-      {
-        if (this.m_realStream == null)
-          throw new FileAppender.LockingStream.LockStateException("The file is not currently locked");
-      }
-
-      public bool AcquireLock()
-      {
-        bool flag = false;
-        lock (this)
-        {
-          if (this.m_lockLevel == 0)
-            this.m_realStream = this.m_lockingModel.AcquireLock();
-          if (this.m_realStream != null)
-          {
-            ++this.m_lockLevel;
-            flag = true;
-          }
-        }
-        return flag;
-      }
-
-      public void ReleaseLock()
-      {
-        lock (this)
-        {
-          --this.m_lockLevel;
-          if (this.m_lockLevel != 0)
-            return;
-          this.m_lockingModel.ReleaseLock();
-          this.m_realStream = (Stream) null;
-        }
-      }
-
-      public sealed class LockStateException(string message) : LogException(message)
-      {
-      }
-    }
-
-    public abstract class LockingModelBase
-    {
-      private FileAppender m_appender = (FileAppender) null;
-
-      public abstract void OpenFile(string filename, bool append, Encoding encoding);
-
-      public abstract void CloseFile();
-
-      public abstract Stream AcquireLock();
-
-      public abstract void ReleaseLock();
-
-      public FileAppender CurrentAppender
-      {
-        get => this.m_appender;
-        set => this.m_appender = value;
-      }
-    }
-
-    public class ExclusiveLock : FileAppender.LockingModelBase
-    {
-      private Stream m_stream = (Stream) null;
-
-      public override void OpenFile(string filename, bool append, Encoding encoding)
-      {
-        try
-        {
-          using (this.CurrentAppender.SecurityContext.Impersonate((object) this))
-          {
-            string directoryName = Path.GetDirectoryName(filename);
-            if (!Directory.Exists(directoryName))
-              Directory.CreateDirectory(directoryName);
-            FileMode mode = append ? FileMode.Append : FileMode.Create;
-            this.m_stream = (Stream) new FileStream(filename, mode, FileAccess.Write, FileShare.Read);
-          }
-        }
-        catch (Exception ex)
-        {
-          this.CurrentAppender.ErrorHandler.Error("Unable to acquire lock on file " + filename + ". " + ex.Message);
-        }
-      }
-
-      public override void CloseFile()
-      {
-        using (this.CurrentAppender.SecurityContext.Impersonate((object) this))
-          this.m_stream.Close();
-      }
-
-      public override Stream AcquireLock() => this.m_stream;
-
-      public override void ReleaseLock()
-      {
-      }
-    }
-
-    public class MinimalLock : FileAppender.LockingModelBase
-    {
-      private string m_filename;
-      private bool m_append;
-      private Stream m_stream = (Stream) null;
-
-      public override void OpenFile(string filename, bool append, Encoding encoding)
-      {
-        this.m_filename = filename;
-        this.m_append = append;
-      }
-
-      public override void CloseFile()
-      {
-      }
-
-      public override Stream AcquireLock()
-      {
-        if (this.m_stream == null)
-        {
-          try
-          {
-            using (this.CurrentAppender.SecurityContext.Impersonate((object) this))
-            {
-              string directoryName = Path.GetDirectoryName(this.m_filename);
-              if (!Directory.Exists(directoryName))
-                Directory.CreateDirectory(directoryName);
-              this.m_stream = (Stream) new FileStream(this.m_filename, this.m_append ? FileMode.Append : FileMode.Create, FileAccess.Write, FileShare.Read);
-              this.m_append = true;
-            }
-          }
-          catch (Exception ex)
-          {
-            this.CurrentAppender.ErrorHandler.Error("Unable to acquire lock on file " + this.m_filename + ". " + ex.Message);
-          }
-        }
-        return this.m_stream;
-      }
-
-      public override void ReleaseLock()
-      {
-        using (this.CurrentAppender.SecurityContext.Impersonate((object) this))
-        {
-          this.m_stream.Close();
-          this.m_stream = (Stream) null;
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/ForwardingAppender.cs b/MSHALTester/log4net/Appender/ForwardingAppender.cs
deleted file mode 100644
index 46a38df..0000000
--- a/MSHALTester/log4net/Appender/ForwardingAppender.cs
+++ /dev/null
@@ -1,93 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class ForwardingAppender : AppenderSkeleton, IAppenderAttachable
-  {
-    private AppenderAttachedImpl m_appenderAttachedImpl;
-
-    protected override void OnClose()
-    {
-      lock (this)
-      {
-        if (this.m_appenderAttachedImpl == null)
-          return;
-        this.m_appenderAttachedImpl.RemoveAllAppenders();
-      }
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      if (this.m_appenderAttachedImpl == null)
-        return;
-      this.m_appenderAttachedImpl.AppendLoopOnAppenders(loggingEvent);
-    }
-
-    public virtual void AddAppender(IAppender newAppender)
-    {
-      if (newAppender == null)
-        throw new ArgumentNullException(nameof (newAppender));
-      lock (this)
-      {
-        if (this.m_appenderAttachedImpl == null)
-          this.m_appenderAttachedImpl = new AppenderAttachedImpl();
-        this.m_appenderAttachedImpl.AddAppender(newAppender);
-      }
-    }
-
-    public virtual AppenderCollection Appenders
-    {
-      get
-      {
-        lock (this)
-          return this.m_appenderAttachedImpl == null ? AppenderCollection.EmptyCollection : this.m_appenderAttachedImpl.Appenders;
-      }
-    }
-
-    public virtual IAppender GetAppender(string name)
-    {
-      lock (this)
-        return this.m_appenderAttachedImpl == null || name == null ? (IAppender) null : this.m_appenderAttachedImpl.GetAppender(name);
-    }
-
-    public virtual void RemoveAllAppenders()
-    {
-      lock (this)
-      {
-        if (this.m_appenderAttachedImpl == null)
-          return;
-        this.m_appenderAttachedImpl.RemoveAllAppenders();
-        this.m_appenderAttachedImpl = (AppenderAttachedImpl) null;
-      }
-    }
-
-    public virtual IAppender RemoveAppender(IAppender appender)
-    {
-      lock (this)
-      {
-        if (appender != null)
-        {
-          if (this.m_appenderAttachedImpl != null)
-            return this.m_appenderAttachedImpl.RemoveAppender(appender);
-        }
-      }
-      return (IAppender) null;
-    }
-
-    public virtual IAppender RemoveAppender(string name)
-    {
-      lock (this)
-      {
-        if (name != null)
-        {
-          if (this.m_appenderAttachedImpl != null)
-            return this.m_appenderAttachedImpl.RemoveAppender(name);
-        }
-      }
-      return (IAppender) null;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/IAppender.cs b/MSHALTester/log4net/Appender/IAppender.cs
deleted file mode 100644
index f3fa7af..0000000
--- a/MSHALTester/log4net/Appender/IAppender.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public interface IAppender
-  {
-    void Close();
-
-    void DoAppend(LoggingEvent loggingEvent);
-
-    string Name { get; set; }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/LocalSyslogAppender.cs b/MSHALTester/log4net/Appender/LocalSyslogAppender.cs
deleted file mode 100644
index cc033d2..0000000
--- a/MSHALTester/log4net/Appender/LocalSyslogAppender.cs
+++ /dev/null
@@ -1,150 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class LocalSyslogAppender : AppenderSkeleton
-  {
-    private LocalSyslogAppender.SyslogFacility m_facility = LocalSyslogAppender.SyslogFacility.User;
-    private string m_identity;
-    private IntPtr m_handleToIdentity = IntPtr.Zero;
-    private LevelMapping m_levelMapping = new LevelMapping();
-
-    public string Identity
-    {
-      get => this.m_identity;
-      set => this.m_identity = value;
-    }
-
-    public LocalSyslogAppender.SyslogFacility Facility
-    {
-      get => this.m_facility;
-      set => this.m_facility = value;
-    }
-
-    public void AddMapping(LocalSyslogAppender.LevelSeverity mapping)
-    {
-      this.m_levelMapping.Add((LevelMappingEntry) mapping);
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      this.m_levelMapping.ActivateOptions();
-      this.m_handleToIdentity = Marshal.StringToHGlobalAnsi(this.m_identity ?? SystemInfo.ApplicationFriendlyName);
-      LocalSyslogAppender.openlog(this.m_handleToIdentity, 1, this.m_facility);
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      LocalSyslogAppender.syslog(LocalSyslogAppender.GeneratePriority(this.m_facility, this.GetSeverity(loggingEvent.Level)), this.RenderLoggingEvent(loggingEvent));
-    }
-
-    protected override void OnClose()
-    {
-      base.OnClose();
-      try
-      {
-        LocalSyslogAppender.closelog();
-      }
-      catch (DllNotFoundException ex)
-      {
-      }
-      if (!(this.m_handleToIdentity != IntPtr.Zero))
-        return;
-      Marshal.FreeHGlobal(this.m_handleToIdentity);
-    }
-
-    protected override bool RequiresLayout => true;
-
-    protected virtual LocalSyslogAppender.SyslogSeverity GetSeverity(Level level)
-    {
-      if (this.m_levelMapping.Lookup(level) is LocalSyslogAppender.LevelSeverity levelSeverity)
-        return levelSeverity.Severity;
-      if (level >= Level.Alert)
-        return LocalSyslogAppender.SyslogSeverity.Alert;
-      if (level >= Level.Critical)
-        return LocalSyslogAppender.SyslogSeverity.Critical;
-      if (level >= Level.Error)
-        return LocalSyslogAppender.SyslogSeverity.Error;
-      if (level >= Level.Warn)
-        return LocalSyslogAppender.SyslogSeverity.Warning;
-      if (level >= Level.Notice)
-        return LocalSyslogAppender.SyslogSeverity.Notice;
-      return level >= Level.Info ? LocalSyslogAppender.SyslogSeverity.Informational : LocalSyslogAppender.SyslogSeverity.Debug;
-    }
-
-    private static int GeneratePriority(
-      LocalSyslogAppender.SyslogFacility facility,
-      LocalSyslogAppender.SyslogSeverity severity)
-    {
-      return (int) ((int) facility * 8 + severity);
-    }
-
-    [DllImport("libc")]
-    private static extern void openlog(
-      IntPtr ident,
-      int option,
-      LocalSyslogAppender.SyslogFacility facility);
-
-    [DllImport("libc")]
-    private static extern void syslog(int priority, string message);
-
-    [DllImport("libc")]
-    private static extern void closelog();
-
-    public enum SyslogSeverity
-    {
-      Emergency,
-      Alert,
-      Critical,
-      Error,
-      Warning,
-      Notice,
-      Informational,
-      Debug,
-    }
-
-    public enum SyslogFacility
-    {
-      Kernel,
-      User,
-      Mail,
-      Daemons,
-      Authorization,
-      Syslog,
-      Printer,
-      News,
-      Uucp,
-      Clock,
-      Authorization2,
-      Ftp,
-      Ntp,
-      Audit,
-      Alert,
-      Clock2,
-      Local0,
-      Local1,
-      Local2,
-      Local3,
-      Local4,
-      Local5,
-      Local6,
-      Local7,
-    }
-
-    public class LevelSeverity : LevelMappingEntry
-    {
-      private LocalSyslogAppender.SyslogSeverity m_severity;
-
-      public LocalSyslogAppender.SyslogSeverity Severity
-      {
-        get => this.m_severity;
-        set => this.m_severity = value;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/MemoryAppender.cs b/MSHALTester/log4net/Appender/MemoryAppender.cs
deleted file mode 100644
index 6305d2a..0000000
--- a/MSHALTester/log4net/Appender/MemoryAppender.cs
+++ /dev/null
@@ -1,47 +0,0 @@
-using log4net.Core;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class MemoryAppender : AppenderSkeleton
-  {
-    private ArrayList m_eventsList;
-    private FixFlags m_fixFlags = FixFlags.All;
-
-    public MemoryAppender() => this.m_eventsList = new ArrayList();
-
-    public virtual LoggingEvent[] GetEvents()
-    {
-      return (LoggingEvent[]) this.m_eventsList.ToArray(typeof (LoggingEvent));
-    }
-
-    [Obsolete("Use Fix property")]
-    public virtual bool OnlyFixPartialEventData
-    {
-      get => this.Fix == FixFlags.Partial;
-      set
-      {
-        if (value)
-          this.Fix = FixFlags.Partial;
-        else
-          this.Fix = FixFlags.All;
-      }
-    }
-
-    public virtual FixFlags Fix
-    {
-      get => this.m_fixFlags;
-      set => this.m_fixFlags = value;
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      loggingEvent.Fix = this.Fix;
-      this.m_eventsList.Add((object) loggingEvent);
-    }
-
-    public virtual void Clear() => this.m_eventsList.Clear();
-  }
-}
diff --git a/MSHALTester/log4net/Appender/NetSendAppender.cs b/MSHALTester/log4net/Appender/NetSendAppender.cs
deleted file mode 100644
index 7c95fdf..0000000
--- a/MSHALTester/log4net/Appender/NetSendAppender.cs
+++ /dev/null
@@ -1,75 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class NetSendAppender : AppenderSkeleton
-  {
-    private string m_server;
-    private string m_sender;
-    private string m_recipient;
-    private SecurityContext m_securityContext;
-
-    public string Sender
-    {
-      get => this.m_sender;
-      set => this.m_sender = value;
-    }
-
-    public string Recipient
-    {
-      get => this.m_recipient;
-      set => this.m_recipient = value;
-    }
-
-    public string Server
-    {
-      get => this.m_server;
-      set => this.m_server = value;
-    }
-
-    public SecurityContext SecurityContext
-    {
-      get => this.m_securityContext;
-      set => this.m_securityContext = value;
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      if (this.Recipient == null)
-        throw new ArgumentNullException("Recipient", "The required property 'Recipient' was not specified.");
-      if (this.m_securityContext != null)
-        return;
-      this.m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext((object) this);
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      NativeError nativeError = (NativeError) null;
-      string buffer = this.RenderLoggingEvent(loggingEvent);
-      using (this.m_securityContext.Impersonate((object) this))
-      {
-        int number = NetSendAppender.NetMessageBufferSend(this.Server, this.Recipient, this.Sender, buffer, buffer.Length * Marshal.SystemDefaultCharSize);
-        if (number != 0)
-          nativeError = NativeError.GetError(number);
-      }
-      if (nativeError == null)
-        return;
-      this.ErrorHandler.Error(nativeError.ToString() + " (Params: Server=" + this.Server + ", Recipient=" + this.Recipient + ", Sender=" + this.Sender + ")");
-    }
-
-    protected override bool RequiresLayout => true;
-
-    [DllImport("netapi32.dll", SetLastError = true)]
-    protected static extern int NetMessageBufferSend(
-      [MarshalAs(UnmanagedType.LPWStr)] string serverName,
-      [MarshalAs(UnmanagedType.LPWStr)] string msgName,
-      [MarshalAs(UnmanagedType.LPWStr)] string fromName,
-      [MarshalAs(UnmanagedType.LPWStr)] string buffer,
-      int bufferSize);
-  }
-}
diff --git a/MSHALTester/log4net/Appender/OutputDebugStringAppender.cs b/MSHALTester/log4net/Appender/OutputDebugStringAppender.cs
deleted file mode 100644
index 9df0088..0000000
--- a/MSHALTester/log4net/Appender/OutputDebugStringAppender.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using log4net.Core;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class OutputDebugStringAppender : AppenderSkeleton
-  {
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      OutputDebugStringAppender.OutputDebugString(this.RenderLoggingEvent(loggingEvent));
-    }
-
-    protected override bool RequiresLayout => true;
-
-    [DllImport("kernel32.dll")]
-    protected static extern void OutputDebugString(string message);
-  }
-}
diff --git a/MSHALTester/log4net/Appender/RemoteSyslogAppender.cs b/MSHALTester/log4net/Appender/RemoteSyslogAppender.cs
deleted file mode 100644
index 7bdf967..0000000
--- a/MSHALTester/log4net/Appender/RemoteSyslogAppender.cs
+++ /dev/null
@@ -1,153 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using log4net.Util;
-using System;
-using System.Globalization;
-using System.IO;
-using System.Net;
-using System.Text;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class RemoteSyslogAppender : UdpAppender
-  {
-    private const int DefaultSyslogPort = 514;
-    private RemoteSyslogAppender.SyslogFacility m_facility = RemoteSyslogAppender.SyslogFacility.User;
-    private PatternLayout m_identity;
-    private LevelMapping m_levelMapping = new LevelMapping();
-
-    public RemoteSyslogAppender()
-    {
-      this.RemotePort = 514;
-      this.RemoteAddress = IPAddress.Parse("127.0.0.1");
-      this.Encoding = Encoding.ASCII;
-    }
-
-    public PatternLayout Identity
-    {
-      get => this.m_identity;
-      set => this.m_identity = value;
-    }
-
-    public RemoteSyslogAppender.SyslogFacility Facility
-    {
-      get => this.m_facility;
-      set => this.m_facility = value;
-    }
-
-    public void AddMapping(RemoteSyslogAppender.LevelSeverity mapping)
-    {
-      this.m_levelMapping.Add((LevelMappingEntry) mapping);
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      try
-      {
-        StringWriter writer = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-        int priority = RemoteSyslogAppender.GeneratePriority(this.m_facility, this.GetSeverity(loggingEvent.Level));
-        writer.Write('<');
-        writer.Write(priority);
-        writer.Write('>');
-        if (this.m_identity != null)
-          this.m_identity.Format((TextWriter) writer, loggingEvent);
-        else
-          writer.Write(loggingEvent.Domain);
-        writer.Write(": ");
-        this.RenderLoggingEvent((TextWriter) writer, loggingEvent);
-        byte[] bytes = this.Encoding.GetBytes(writer.ToString().ToCharArray());
-        this.Client.Send(bytes, bytes.Length, this.RemoteEndPoint);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Unable to send logging event to remote syslog " + this.RemoteAddress.ToString() + " on port " + (object) this.RemotePort + ".", ex, ErrorCode.WriteFailure);
-      }
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      this.m_levelMapping.ActivateOptions();
-    }
-
-    protected virtual RemoteSyslogAppender.SyslogSeverity GetSeverity(Level level)
-    {
-      if (this.m_levelMapping.Lookup(level) is RemoteSyslogAppender.LevelSeverity levelSeverity)
-        return levelSeverity.Severity;
-      if (level >= Level.Alert)
-        return RemoteSyslogAppender.SyslogSeverity.Alert;
-      if (level >= Level.Critical)
-        return RemoteSyslogAppender.SyslogSeverity.Critical;
-      if (level >= Level.Error)
-        return RemoteSyslogAppender.SyslogSeverity.Error;
-      if (level >= Level.Warn)
-        return RemoteSyslogAppender.SyslogSeverity.Warning;
-      if (level >= Level.Notice)
-        return RemoteSyslogAppender.SyslogSeverity.Notice;
-      return level >= Level.Info ? RemoteSyslogAppender.SyslogSeverity.Informational : RemoteSyslogAppender.SyslogSeverity.Debug;
-    }
-
-    public static int GeneratePriority(
-      RemoteSyslogAppender.SyslogFacility facility,
-      RemoteSyslogAppender.SyslogSeverity severity)
-    {
-      if (facility < RemoteSyslogAppender.SyslogFacility.Kernel || facility > RemoteSyslogAppender.SyslogFacility.Local7)
-        throw new ArgumentException("SyslogFacility out of range", nameof (facility));
-      if (severity < RemoteSyslogAppender.SyslogSeverity.Emergency || severity > RemoteSyslogAppender.SyslogSeverity.Debug)
-        throw new ArgumentException("SyslogSeverity out of range", nameof (severity));
-      return (int) ((int) facility * 8 + severity);
-    }
-
-    public enum SyslogSeverity
-    {
-      Emergency,
-      Alert,
-      Critical,
-      Error,
-      Warning,
-      Notice,
-      Informational,
-      Debug,
-    }
-
-    public enum SyslogFacility
-    {
-      Kernel,
-      User,
-      Mail,
-      Daemons,
-      Authorization,
-      Syslog,
-      Printer,
-      News,
-      Uucp,
-      Clock,
-      Authorization2,
-      Ftp,
-      Ntp,
-      Audit,
-      Alert,
-      Clock2,
-      Local0,
-      Local1,
-      Local2,
-      Local3,
-      Local4,
-      Local5,
-      Local6,
-      Local7,
-    }
-
-    public class LevelSeverity : LevelMappingEntry
-    {
-      private RemoteSyslogAppender.SyslogSeverity m_severity;
-
-      public RemoteSyslogAppender.SyslogSeverity Severity
-      {
-        get => this.m_severity;
-        set => this.m_severity = value;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/RemotingAppender.cs b/MSHALTester/log4net/Appender/RemotingAppender.cs
deleted file mode 100644
index 6093890..0000000
--- a/MSHALTester/log4net/Appender/RemotingAppender.cs
+++ /dev/null
@@ -1,81 +0,0 @@
-using log4net.Core;
-using System;
-using System.Collections;
-using System.Threading;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class RemotingAppender : BufferingAppenderSkeleton
-  {
-    private string m_sinkUrl;
-    private RemotingAppender.IRemoteLoggingSink m_sinkObj;
-    private int m_queuedCallbackCount = 0;
-    private ManualResetEvent m_workQueueEmptyEvent = new ManualResetEvent(true);
-
-    public string Sink
-    {
-      get => this.m_sinkUrl;
-      set => this.m_sinkUrl = value;
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      IDictionary state = (IDictionary) new Hashtable();
-      state[(object) "typeFilterLevel"] = (object) "Full";
-      this.m_sinkObj = (RemotingAppender.IRemoteLoggingSink) Activator.GetObject(typeof (RemotingAppender.IRemoteLoggingSink), this.m_sinkUrl, (object) state);
-    }
-
-    protected override void SendBuffer(LoggingEvent[] events)
-    {
-      this.BeginAsyncSend();
-      if (ThreadPool.QueueUserWorkItem(new WaitCallback(this.SendBufferCallback), (object) events))
-        return;
-      this.EndAsyncSend();
-      this.ErrorHandler.Error("RemotingAppender [" + this.Name + "] failed to ThreadPool.QueueUserWorkItem logging events in SendBuffer.");
-    }
-
-    protected override void OnClose()
-    {
-      base.OnClose();
-      if (this.m_workQueueEmptyEvent.WaitOne(30000, false))
-        return;
-      this.ErrorHandler.Error("RemotingAppender [" + this.Name + "] failed to send all queued events before close, in OnClose.");
-    }
-
-    private void BeginAsyncSend()
-    {
-      this.m_workQueueEmptyEvent.Reset();
-      Interlocked.Increment(ref this.m_queuedCallbackCount);
-    }
-
-    private void EndAsyncSend()
-    {
-      if (Interlocked.Decrement(ref this.m_queuedCallbackCount) > 0)
-        return;
-      this.m_workQueueEmptyEvent.Set();
-    }
-
-    private void SendBufferCallback(object state)
-    {
-      try
-      {
-        this.m_sinkObj.LogEvents((LoggingEvent[]) state);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Failed in SendBufferCallback", ex);
-      }
-      finally
-      {
-        this.EndAsyncSend();
-      }
-    }
-
-    public interface IRemoteLoggingSink
-    {
-      void LogEvents(LoggingEvent[] events);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/RollingFileAppender.cs b/MSHALTester/log4net/Appender/RollingFileAppender.cs
deleted file mode 100644
index 23181df..0000000
--- a/MSHALTester/log4net/Appender/RollingFileAppender.cs
+++ /dev/null
@@ -1,546 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class RollingFileAppender : FileAppender
-  {
-    private RollingFileAppender.IDateTime m_dateTime = (RollingFileAppender.IDateTime) null;
-    private string m_datePattern = ".yyyy-MM-dd";
-    private string m_scheduledFilename = (string) null;
-    private DateTime m_nextCheck = DateTime.MaxValue;
-    private DateTime m_now;
-    private RollingFileAppender.RollPoint m_rollPoint;
-    private long m_maxFileSize = 10485760;
-    private int m_maxSizeRollBackups = 0;
-    private int m_curSizeRollBackups = 0;
-    private int m_countDirection = -1;
-    private RollingFileAppender.RollingMode m_rollingStyle = RollingFileAppender.RollingMode.Composite;
-    private bool m_rollDate = true;
-    private bool m_rollSize = true;
-    private bool m_staticLogFileName = true;
-    private string m_baseFileName;
-    private static readonly DateTime s_date1970 = new DateTime(1970, 1, 1);
-
-    public RollingFileAppender()
-    {
-      this.m_dateTime = (RollingFileAppender.IDateTime) new RollingFileAppender.DefaultDateTime();
-    }
-
-    public string DatePattern
-    {
-      get => this.m_datePattern;
-      set => this.m_datePattern = value;
-    }
-
-    public int MaxSizeRollBackups
-    {
-      get => this.m_maxSizeRollBackups;
-      set => this.m_maxSizeRollBackups = value;
-    }
-
-    public long MaxFileSize
-    {
-      get => this.m_maxFileSize;
-      set => this.m_maxFileSize = value;
-    }
-
-    public string MaximumFileSize
-    {
-      get => this.m_maxFileSize.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo);
-      set => this.m_maxFileSize = OptionConverter.ToFileSize(value, this.m_maxFileSize + 1L);
-    }
-
-    public int CountDirection
-    {
-      get => this.m_countDirection;
-      set => this.m_countDirection = value;
-    }
-
-    public RollingFileAppender.RollingMode RollingStyle
-    {
-      get => this.m_rollingStyle;
-      set
-      {
-        this.m_rollingStyle = value;
-        switch (this.m_rollingStyle)
-        {
-          case RollingFileAppender.RollingMode.Once:
-            this.m_rollDate = false;
-            this.m_rollSize = false;
-            this.AppendToFile = false;
-            break;
-          case RollingFileAppender.RollingMode.Size:
-            this.m_rollDate = false;
-            this.m_rollSize = true;
-            break;
-          case RollingFileAppender.RollingMode.Date:
-            this.m_rollDate = true;
-            this.m_rollSize = false;
-            break;
-          case RollingFileAppender.RollingMode.Composite:
-            this.m_rollDate = true;
-            this.m_rollSize = true;
-            break;
-        }
-      }
-    }
-
-    public bool StaticLogFileName
-    {
-      get => this.m_staticLogFileName;
-      set => this.m_staticLogFileName = value;
-    }
-
-    protected override void SetQWForFiles(TextWriter writer)
-    {
-      this.QuietWriter = (QuietTextWriter) new CountingQuietTextWriter(writer, this.ErrorHandler);
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      if (this.m_rollDate)
-      {
-        DateTime now = this.m_dateTime.Now;
-        if (now >= this.m_nextCheck)
-        {
-          this.m_now = now;
-          this.m_nextCheck = this.NextCheckDate(this.m_now, this.m_rollPoint);
-          this.RollOverTime(true);
-        }
-      }
-      if (this.m_rollSize && this.File != null && ((CountingQuietTextWriter) this.QuietWriter).Count >= this.m_maxFileSize)
-        this.RollOverSize();
-      base.Append(loggingEvent);
-    }
-
-    protected override void OpenFile(string fileName, bool append)
-    {
-      lock (this)
-      {
-        fileName = this.GetNextOutputFileName(fileName);
-        long num = 0;
-        if (append)
-        {
-          using (this.SecurityContext.Impersonate((object) this))
-          {
-            if (System.IO.File.Exists(fileName))
-              num = new FileInfo(fileName).Length;
-          }
-        }
-        else if (LogLog.IsErrorEnabled && this.m_maxSizeRollBackups != 0 && this.FileExists(fileName))
-          LogLog.Error("RollingFileAppender: INTERNAL ERROR. Append is False but OutputFile [" + fileName + "] already exists.");
-        if (!this.m_staticLogFileName)
-        {
-          this.m_scheduledFilename = fileName;
-          if (this.m_countDirection >= 0)
-            ++this.m_curSizeRollBackups;
-        }
-        base.OpenFile(fileName, append);
-        ((CountingQuietTextWriter) this.QuietWriter).Count = num;
-      }
-    }
-
-    protected string GetNextOutputFileName(string fileName)
-    {
-      if (!this.m_staticLogFileName)
-      {
-        fileName = fileName.Trim();
-        if (this.m_rollDate)
-          fileName += this.m_now.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo);
-        if (this.m_countDirection >= 0)
-          fileName = fileName + (object) '.' + (object) (this.m_curSizeRollBackups + 1);
-      }
-      return fileName;
-    }
-
-    private void DetermineCurSizeRollBackups()
-    {
-      this.m_curSizeRollBackups = 0;
-      string str = (string) null;
-      string baseFile = (string) null;
-      using (this.SecurityContext.Impersonate((object) this))
-      {
-        str = Path.GetFullPath(this.m_baseFileName);
-        baseFile = Path.GetFileName(str);
-      }
-      ArrayList existingFiles = this.GetExistingFiles(str);
-      this.InitializeRollBackups(baseFile, existingFiles);
-      LogLog.Debug("RollingFileAppender: curSizeRollBackups starts at [" + (object) this.m_curSizeRollBackups + "]");
-    }
-
-    private static string GetWildcardPatternForFile(string baseFileName)
-    {
-      return baseFileName + (object) '*';
-    }
-
-    private ArrayList GetExistingFiles(string baseFilePath)
-    {
-      ArrayList existingFiles = new ArrayList();
-      string path = (string) null;
-      using (this.SecurityContext.Impersonate((object) this))
-      {
-        string fullPath = Path.GetFullPath(baseFilePath);
-        path = Path.GetDirectoryName(fullPath);
-        if (Directory.Exists(path))
-        {
-          string fileName1 = Path.GetFileName(fullPath);
-          string[] files = Directory.GetFiles(path, RollingFileAppender.GetWildcardPatternForFile(fileName1));
-          if (files != null)
-          {
-            for (int index = 0; index < files.Length; ++index)
-            {
-              string fileName2 = Path.GetFileName(files[index]);
-              if (fileName2.StartsWith(fileName1))
-                existingFiles.Add((object) fileName2);
-            }
-          }
-        }
-      }
-      LogLog.Debug("RollingFileAppender: Searched for existing files in [" + path + "]");
-      return existingFiles;
-    }
-
-    private void RollOverIfDateBoundaryCrossing()
-    {
-      if (!this.m_staticLogFileName || !this.m_rollDate || !this.FileExists(this.m_baseFileName))
-        return;
-      DateTime lastWriteTime;
-      using (this.SecurityContext.Impersonate((object) this))
-        lastWriteTime = System.IO.File.GetLastWriteTime(this.m_baseFileName);
-      LogLog.Debug("RollingFileAppender: [" + lastWriteTime.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo) + "] vs. [" + this.m_now.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo) + "]");
-      if (lastWriteTime.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo).Equals(this.m_now.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo)))
-        return;
-      this.m_scheduledFilename = this.m_baseFileName + lastWriteTime.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo);
-      LogLog.Debug("RollingFileAppender: Initial roll over to [" + this.m_scheduledFilename + "]");
-      this.RollOverTime(false);
-      LogLog.Debug("RollingFileAppender: curSizeRollBackups after rollOver at [" + (object) this.m_curSizeRollBackups + "]");
-    }
-
-    protected void ExistingInit()
-    {
-      this.DetermineCurSizeRollBackups();
-      this.RollOverIfDateBoundaryCrossing();
-      if (this.AppendToFile)
-        return;
-      bool flag = false;
-      string nextOutputFileName = this.GetNextOutputFileName(this.m_baseFileName);
-      using (this.SecurityContext.Impersonate((object) this))
-        flag = System.IO.File.Exists(nextOutputFileName);
-      if (!flag)
-        return;
-      if (this.m_maxSizeRollBackups == 0)
-      {
-        LogLog.Debug("RollingFileAppender: Output file [" + nextOutputFileName + "] already exists. MaxSizeRollBackups is 0; cannot roll. Overwriting existing file.");
-      }
-      else
-      {
-        LogLog.Debug("RollingFileAppender: Output file [" + nextOutputFileName + "] already exists. Not appending to file. Rolling existing file out of the way.");
-        this.RollOverRenameFiles(nextOutputFileName);
-      }
-    }
-
-    private void InitializeFromOneFile(string baseFile, string curFileName)
-    {
-      if (!curFileName.StartsWith(baseFile) || curFileName.Equals(baseFile))
-        return;
-      int num1 = curFileName.LastIndexOf(".");
-      if (-1 == num1)
-        return;
-      if (this.m_staticLogFileName)
-      {
-        int num2 = curFileName.Length - num1;
-        if (baseFile.Length + num2 != curFileName.Length)
-          return;
-      }
-      if (this.m_rollDate)
-      {
-        if (!this.m_staticLogFileName)
-        {
-          if (!curFileName.StartsWith(baseFile + this.m_dateTime.Now.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo)))
-          {
-            LogLog.Debug("RollingFileAppender: Ignoring file [" + curFileName + "] because it is from a different date period");
-            return;
-          }
-        }
-      }
-      try
-      {
-        int val;
-        if (!SystemInfo.TryParse(curFileName.Substring(num1 + 1), out val) || val <= this.m_curSizeRollBackups)
-          return;
-        if (this.m_maxSizeRollBackups != 0)
-        {
-          if (-1 == this.m_maxSizeRollBackups)
-            this.m_curSizeRollBackups = val;
-          else if (this.m_countDirection >= 0)
-            this.m_curSizeRollBackups = val;
-          else if (val <= this.m_maxSizeRollBackups)
-            this.m_curSizeRollBackups = val;
-        }
-        LogLog.Debug("RollingFileAppender: File name [" + curFileName + "] moves current count to [" + (object) this.m_curSizeRollBackups + "]");
-      }
-      catch (FormatException ex)
-      {
-        LogLog.Debug("RollingFileAppender: Encountered a backup file not ending in .x [" + curFileName + "]");
-      }
-    }
-
-    private void InitializeRollBackups(string baseFile, ArrayList arrayFiles)
-    {
-      if (arrayFiles == null)
-        return;
-      string lower = baseFile.ToLower(CultureInfo.InvariantCulture);
-      foreach (string arrayFile in arrayFiles)
-        this.InitializeFromOneFile(lower, arrayFile.ToLower(CultureInfo.InvariantCulture));
-    }
-
-    private RollingFileAppender.RollPoint ComputeCheckPeriod(string datePattern)
-    {
-      string str1 = RollingFileAppender.s_date1970.ToString(datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo);
-      for (int checkPeriod = 0; checkPeriod <= 5; ++checkPeriod)
-      {
-        string str2 = this.NextCheckDate(RollingFileAppender.s_date1970, (RollingFileAppender.RollPoint) checkPeriod).ToString(datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo);
-        LogLog.Debug("RollingFileAppender: Type = [" + (object) checkPeriod + "], r0 = [" + str1 + "], r1 = [" + str2 + "]");
-        if (str1 != null && str2 != null && !str1.Equals(str2))
-          return (RollingFileAppender.RollPoint) checkPeriod;
-      }
-      return RollingFileAppender.RollPoint.InvalidRollPoint;
-    }
-
-    public override void ActivateOptions()
-    {
-      if (this.m_rollDate && this.m_datePattern != null)
-      {
-        this.m_now = this.m_dateTime.Now;
-        this.m_rollPoint = this.ComputeCheckPeriod(this.m_datePattern);
-        this.m_nextCheck = this.m_rollPoint != RollingFileAppender.RollPoint.InvalidRollPoint ? this.NextCheckDate(this.m_now, this.m_rollPoint) : throw new ArgumentException("Invalid RollPoint, unable to parse [" + this.m_datePattern + "]");
-      }
-      else if (this.m_rollDate)
-        this.ErrorHandler.Error("Either DatePattern or rollingStyle options are not set for [" + this.Name + "].");
-      if (this.m_rollDate && this.File != null && this.m_scheduledFilename == null)
-        this.m_scheduledFilename = this.File + this.m_now.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo);
-      if (this.SecurityContext == null)
-        this.SecurityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext((object) this);
-      using (this.SecurityContext.Impersonate((object) this))
-        this.m_baseFileName = FileAppender.ConvertToFullPath(this.File.Trim());
-      this.ExistingInit();
-      base.ActivateOptions();
-    }
-
-    protected void RollOverTime(bool fileIsOpen)
-    {
-      if (this.m_staticLogFileName)
-      {
-        if (this.m_datePattern == null)
-        {
-          this.ErrorHandler.Error("Missing DatePattern option in rollOver().");
-          return;
-        }
-        string str = this.m_now.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo);
-        if (this.m_scheduledFilename.Equals(this.File + str))
-        {
-          this.ErrorHandler.Error("Compare " + this.m_scheduledFilename + " : " + this.File + str);
-          return;
-        }
-        if (fileIsOpen)
-          this.CloseFile();
-        for (int index = 1; index <= this.m_curSizeRollBackups; ++index)
-          this.RollFile(this.File + (object) '.' + (object) index, this.m_scheduledFilename + (object) '.' + (object) index);
-        this.RollFile(this.File, this.m_scheduledFilename);
-      }
-      this.m_curSizeRollBackups = 0;
-      this.m_scheduledFilename = this.File + this.m_now.ToString(this.m_datePattern, (IFormatProvider) DateTimeFormatInfo.InvariantInfo);
-      if (!fileIsOpen)
-        return;
-      this.SafeOpenFile(this.m_baseFileName, false);
-    }
-
-    protected void RollFile(string fromFile, string toFile)
-    {
-      if (this.FileExists(fromFile))
-      {
-        this.DeleteFile(toFile);
-        try
-        {
-          LogLog.Debug("RollingFileAppender: Moving [" + fromFile + "] -> [" + toFile + "]");
-          using (this.SecurityContext.Impersonate((object) this))
-            System.IO.File.Move(fromFile, toFile);
-        }
-        catch (Exception ex)
-        {
-          this.ErrorHandler.Error("Exception while rolling file [" + fromFile + "] -> [" + toFile + "]", ex, ErrorCode.GenericFailure);
-        }
-      }
-      else
-        LogLog.Warn("RollingFileAppender: Cannot RollFile [" + fromFile + "] -> [" + toFile + "]. Source does not exist");
-    }
-
-    protected bool FileExists(string path)
-    {
-      using (this.SecurityContext.Impersonate((object) this))
-        return System.IO.File.Exists(path);
-    }
-
-    protected void DeleteFile(string fileName)
-    {
-      if (!this.FileExists(fileName))
-        return;
-      string path = fileName;
-      string destFileName = fileName + "." + (object) Environment.TickCount + ".DeletePending";
-      try
-      {
-        using (this.SecurityContext.Impersonate((object) this))
-          System.IO.File.Move(fileName, destFileName);
-        path = destFileName;
-      }
-      catch (Exception ex)
-      {
-        LogLog.Debug("RollingFileAppender: Exception while moving file to be deleted [" + fileName + "] -> [" + destFileName + "]", ex);
-      }
-      try
-      {
-        using (this.SecurityContext.Impersonate((object) this))
-          System.IO.File.Delete(path);
-        LogLog.Debug("RollingFileAppender: Deleted file [" + fileName + "]");
-      }
-      catch (Exception ex)
-      {
-        if (path == fileName)
-          this.ErrorHandler.Error("Exception while deleting file [" + path + "]", ex, ErrorCode.GenericFailure);
-        else
-          LogLog.Debug("RollingFileAppender: Exception while deleting temp file [" + path + "]", ex);
-      }
-    }
-
-    protected void RollOverSize()
-    {
-      this.CloseFile();
-      LogLog.Debug("RollingFileAppender: rolling over count [" + (object) ((CountingQuietTextWriter) this.QuietWriter).Count + "]");
-      LogLog.Debug("RollingFileAppender: maxSizeRollBackups [" + (object) this.m_maxSizeRollBackups + "]");
-      LogLog.Debug("RollingFileAppender: curSizeRollBackups [" + (object) this.m_curSizeRollBackups + "]");
-      LogLog.Debug("RollingFileAppender: countDirection [" + (object) this.m_countDirection + "]");
-      this.RollOverRenameFiles(this.File);
-      this.SafeOpenFile(this.m_baseFileName, false);
-    }
-
-    protected void RollOverRenameFiles(string baseFileName)
-    {
-      if (this.m_maxSizeRollBackups == 0)
-        return;
-      if (this.m_countDirection < 0)
-      {
-        if (this.m_curSizeRollBackups == this.m_maxSizeRollBackups)
-        {
-          this.DeleteFile(baseFileName + (object) '.' + (object) this.m_maxSizeRollBackups);
-          --this.m_curSizeRollBackups;
-        }
-        for (int curSizeRollBackups = this.m_curSizeRollBackups; curSizeRollBackups >= 1; --curSizeRollBackups)
-          this.RollFile(baseFileName + "." + (object) curSizeRollBackups, baseFileName + (object) '.' + (object) (curSizeRollBackups + 1));
-        ++this.m_curSizeRollBackups;
-        this.RollFile(baseFileName, baseFileName + ".1");
-      }
-      else
-      {
-        if (this.m_curSizeRollBackups >= this.m_maxSizeRollBackups && this.m_maxSizeRollBackups > 0)
-        {
-          int num = this.m_curSizeRollBackups - this.m_maxSizeRollBackups + 1;
-          this.DeleteFile(baseFileName + (object) '.' + (object) num);
-        }
-        if (!this.m_staticLogFileName)
-          return;
-        ++this.m_curSizeRollBackups;
-        this.RollFile(baseFileName, baseFileName + (object) '.' + (object) this.m_curSizeRollBackups);
-      }
-    }
-
-    protected DateTime NextCheckDate(
-      DateTime currentDateTime,
-      RollingFileAppender.RollPoint rollPoint)
-    {
-      DateTime dateTime = currentDateTime;
-      switch (rollPoint)
-      {
-        case RollingFileAppender.RollPoint.TopOfMinute:
-          dateTime = dateTime.AddMilliseconds((double) -dateTime.Millisecond);
-          dateTime = dateTime.AddSeconds((double) -dateTime.Second);
-          dateTime = dateTime.AddMinutes(1.0);
-          break;
-        case RollingFileAppender.RollPoint.TopOfHour:
-          dateTime = dateTime.AddMilliseconds((double) -dateTime.Millisecond);
-          dateTime = dateTime.AddSeconds((double) -dateTime.Second);
-          dateTime = dateTime.AddMinutes((double) -dateTime.Minute);
-          dateTime = dateTime.AddHours(1.0);
-          break;
-        case RollingFileAppender.RollPoint.HalfDay:
-          dateTime = dateTime.AddMilliseconds((double) -dateTime.Millisecond);
-          dateTime = dateTime.AddSeconds((double) -dateTime.Second);
-          dateTime = dateTime.AddMinutes((double) -dateTime.Minute);
-          if (dateTime.Hour < 12)
-          {
-            dateTime = dateTime.AddHours((double) (12 - dateTime.Hour));
-            break;
-          }
-          dateTime = dateTime.AddHours((double) -dateTime.Hour);
-          dateTime = dateTime.AddDays(1.0);
-          break;
-        case RollingFileAppender.RollPoint.TopOfDay:
-          dateTime = dateTime.AddMilliseconds((double) -dateTime.Millisecond);
-          dateTime = dateTime.AddSeconds((double) -dateTime.Second);
-          dateTime = dateTime.AddMinutes((double) -dateTime.Minute);
-          dateTime = dateTime.AddHours((double) -dateTime.Hour);
-          dateTime = dateTime.AddDays(1.0);
-          break;
-        case RollingFileAppender.RollPoint.TopOfWeek:
-          dateTime = dateTime.AddMilliseconds((double) -dateTime.Millisecond);
-          dateTime = dateTime.AddSeconds((double) -dateTime.Second);
-          dateTime = dateTime.AddMinutes((double) -dateTime.Minute);
-          dateTime = dateTime.AddHours((double) -dateTime.Hour);
-          dateTime = dateTime.AddDays((double) (7 - dateTime.DayOfWeek));
-          break;
-        case RollingFileAppender.RollPoint.TopOfMonth:
-          dateTime = dateTime.AddMilliseconds((double) -dateTime.Millisecond);
-          dateTime = dateTime.AddSeconds((double) -dateTime.Second);
-          dateTime = dateTime.AddMinutes((double) -dateTime.Minute);
-          dateTime = dateTime.AddHours((double) -dateTime.Hour);
-          dateTime = dateTime.AddMonths(1);
-          break;
-      }
-      return dateTime;
-    }
-
-    public enum RollingMode
-    {
-      Once,
-      Size,
-      Date,
-      Composite,
-    }
-
-    protected enum RollPoint
-    {
-      InvalidRollPoint = -1, // 0xFFFFFFFF
-      TopOfMinute = 0,
-      TopOfHour = 1,
-      HalfDay = 2,
-      TopOfDay = 3,
-      TopOfWeek = 4,
-      TopOfMonth = 5,
-    }
-
-    public interface IDateTime
-    {
-      DateTime Now { get; }
-    }
-
-    private class DefaultDateTime : RollingFileAppender.IDateTime
-    {
-      public DateTime Now => DateTime.Now;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/SmtpAppender.cs b/MSHALTester/log4net/Appender/SmtpAppender.cs
deleted file mode 100644
index c987af3..0000000
--- a/MSHALTester/log4net/Appender/SmtpAppender.cs
+++ /dev/null
@@ -1,132 +0,0 @@
-using log4net.Core;
-using System;
-using System.Globalization;
-using System.IO;
-using System.Web.Mail;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class SmtpAppender : BufferingAppenderSkeleton
-  {
-    private string m_to;
-    private string m_from;
-    private string m_subject;
-    private string m_smtpHost;
-    private SmtpAppender.SmtpAuthentication m_authentication = SmtpAppender.SmtpAuthentication.None;
-    private string m_username;
-    private string m_password;
-    private int m_port = 25;
-
-    public string To
-    {
-      get => this.m_to;
-      set => this.m_to = value;
-    }
-
-    public string From
-    {
-      get => this.m_from;
-      set => this.m_from = value;
-    }
-
-    public string Subject
-    {
-      get => this.m_subject;
-      set => this.m_subject = value;
-    }
-
-    public string SmtpHost
-    {
-      get => this.m_smtpHost;
-      set => this.m_smtpHost = value;
-    }
-
-    [Obsolete("Use the BufferingAppenderSkeleton Fix methods")]
-    public bool LocationInfo
-    {
-      get => false;
-      set
-      {
-      }
-    }
-
-    public SmtpAppender.SmtpAuthentication Authentication
-    {
-      get => this.m_authentication;
-      set => this.m_authentication = value;
-    }
-
-    public string Username
-    {
-      get => this.m_username;
-      set => this.m_username = value;
-    }
-
-    public string Password
-    {
-      get => this.m_password;
-      set => this.m_password = value;
-    }
-
-    public int Port
-    {
-      get => this.m_port;
-      set => this.m_port = value;
-    }
-
-    protected override void SendBuffer(LoggingEvent[] events)
-    {
-      try
-      {
-        StringWriter writer = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-        string header = this.Layout.Header;
-        if (header != null)
-          writer.Write(header);
-        for (int index = 0; index < events.Length; ++index)
-          this.RenderLoggingEvent((TextWriter) writer, events[index]);
-        string footer = this.Layout.Footer;
-        if (footer != null)
-          writer.Write(footer);
-        MailMessage message = new MailMessage();
-        message.Body = writer.ToString();
-        message.From = this.m_from;
-        message.To = this.m_to;
-        message.Subject = this.m_subject;
-        try
-        {
-          if (this.m_authentication == SmtpAppender.SmtpAuthentication.Basic)
-          {
-            message.Fields.Add((object) "http://schemas.microsoft.com/cdo/configuration/smtpauthenticate", (object) 1);
-            message.Fields.Add((object) "http://schemas.microsoft.com/cdo/configuration/sendusername", (object) this.m_username);
-            message.Fields.Add((object) "http://schemas.microsoft.com/cdo/configuration/sendpassword", (object) this.m_password);
-          }
-          else if (this.m_authentication == SmtpAppender.SmtpAuthentication.Ntlm)
-            message.Fields.Add((object) "http://schemas.microsoft.com/cdo/configuration/smtpauthenticate", (object) 2);
-          if (this.m_port != 25)
-            message.Fields.Add((object) "http://schemas.microsoft.com/cdo/configuration/smtpserverport", (object) this.m_port);
-        }
-        catch (MissingMethodException ex)
-        {
-          this.ErrorHandler.Error("SmtpAppender: Authentication and server Port are only supported when running on the MS .NET 1.1 framework", (Exception) ex);
-        }
-        if (this.m_smtpHost != null && this.m_smtpHost.Length > 0)
-          SmtpMail.SmtpServer = this.m_smtpHost;
-        SmtpMail.Send(message);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Error occurred while sending e-mail notification.", ex);
-      }
-    }
-
-    protected override bool RequiresLayout => true;
-
-    public enum SmtpAuthentication
-    {
-      None,
-      Basic,
-      Ntlm,
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/SmtpPickupDirAppender.cs b/MSHALTester/log4net/Appender/SmtpPickupDirAppender.cs
deleted file mode 100644
index 3ac69af..0000000
--- a/MSHALTester/log4net/Appender/SmtpPickupDirAppender.cs
+++ /dev/null
@@ -1,102 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class SmtpPickupDirAppender : BufferingAppenderSkeleton
-  {
-    private string m_to;
-    private string m_from;
-    private string m_subject;
-    private string m_pickupDir;
-    private SecurityContext m_securityContext;
-
-    public string To
-    {
-      get => this.m_to;
-      set => this.m_to = value;
-    }
-
-    public string From
-    {
-      get => this.m_from;
-      set => this.m_from = value;
-    }
-
-    public string Subject
-    {
-      get => this.m_subject;
-      set => this.m_subject = value;
-    }
-
-    public string PickupDir
-    {
-      get => this.m_pickupDir;
-      set => this.m_pickupDir = value;
-    }
-
-    public SecurityContext SecurityContext
-    {
-      get => this.m_securityContext;
-      set => this.m_securityContext = value;
-    }
-
-    protected override void SendBuffer(LoggingEvent[] events)
-    {
-      try
-      {
-        string path = (string) null;
-        StreamWriter writer = (StreamWriter) null;
-        using (this.SecurityContext.Impersonate((object) this))
-        {
-          path = Path.Combine(this.m_pickupDir, SystemInfo.NewGuid().ToString("N"));
-          writer = File.CreateText(path);
-        }
-        if (writer == null)
-        {
-          this.ErrorHandler.Error("Failed to create output file for writing [" + path + "]", (Exception) null, ErrorCode.FileOpenFailure);
-        }
-        else
-        {
-          using (writer)
-          {
-            writer.WriteLine("To: " + this.m_to);
-            writer.WriteLine("From: " + this.m_from);
-            writer.WriteLine("Subject: " + this.m_subject);
-            writer.WriteLine("");
-            string header = this.Layout.Header;
-            if (header != null)
-              writer.Write(header);
-            for (int index = 0; index < events.Length; ++index)
-              this.RenderLoggingEvent((TextWriter) writer, events[index]);
-            string footer = this.Layout.Footer;
-            if (footer != null)
-              writer.Write(footer);
-            writer.WriteLine("");
-            writer.WriteLine(".");
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Error occurred while sending e-mail notification.", ex);
-      }
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      if (this.m_securityContext == null)
-        this.m_securityContext = SecurityContextProvider.DefaultProvider.CreateSecurityContext((object) this);
-      using (this.SecurityContext.Impersonate((object) this))
-        this.m_pickupDir = SmtpPickupDirAppender.ConvertToFullPath(this.m_pickupDir.Trim());
-    }
-
-    protected override bool RequiresLayout => true;
-
-    protected static string ConvertToFullPath(string path) => SystemInfo.ConvertToFullPath(path);
-  }
-}
diff --git a/MSHALTester/log4net/Appender/TelnetAppender.cs b/MSHALTester/log4net/Appender/TelnetAppender.cs
deleted file mode 100644
index b19e008..0000000
--- a/MSHALTester/log4net/Appender/TelnetAppender.cs
+++ /dev/null
@@ -1,237 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Net;
-using System.Net.Sockets;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class TelnetAppender : AppenderSkeleton
-  {
-    private TelnetAppender.SocketHandler m_handler;
-    private int m_listeningPort = 23;
-
-    public int Port
-    {
-      get => this.m_listeningPort;
-      set
-      {
-        this.m_listeningPort = value >= 0 && value <= (int) ushort.MaxValue ? value : throw SystemInfo.CreateArgumentOutOfRangeException(nameof (value), (object) value, "The value specified for Port is less than " + 0.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo) + " or greater than " + ((int) ushort.MaxValue).ToString((IFormatProvider) NumberFormatInfo.InvariantInfo) + ".");
-      }
-    }
-
-    protected override void OnClose()
-    {
-      base.OnClose();
-      if (this.m_handler == null)
-        return;
-      this.m_handler.Dispose();
-      this.m_handler = (TelnetAppender.SocketHandler) null;
-    }
-
-    protected override bool RequiresLayout => true;
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      try
-      {
-        LogLog.Debug("TelnetAppender: Creating SocketHandler to listen on port [" + (object) this.m_listeningPort + "]");
-        this.m_handler = new TelnetAppender.SocketHandler(this.m_listeningPort);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("TelnetAppender: Failed to create SocketHandler", ex);
-        throw;
-      }
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      if (this.m_handler == null || !this.m_handler.HasConnections)
-        return;
-      this.m_handler.Send(this.RenderLoggingEvent(loggingEvent));
-    }
-
-    protected class SocketHandler : IDisposable
-    {
-      private const int MAX_CONNECTIONS = 20;
-      private Socket m_serverSocket;
-      private ArrayList m_clients = new ArrayList();
-
-      public SocketHandler(int port)
-      {
-        this.m_serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
-        this.m_serverSocket.Bind((EndPoint) new IPEndPoint(IPAddress.Any, port));
-        this.m_serverSocket.Listen(5);
-        this.m_serverSocket.BeginAccept(new AsyncCallback(this.OnConnect), (object) null);
-      }
-
-      public void Send(string message)
-      {
-        foreach (TelnetAppender.SocketHandler.SocketClient client in this.m_clients)
-        {
-          try
-          {
-            client.Send(message);
-          }
-          catch (Exception ex)
-          {
-            client.Dispose();
-            this.RemoveClient(client);
-          }
-        }
-      }
-
-      private void AddClient(TelnetAppender.SocketHandler.SocketClient client)
-      {
-        lock (this)
-        {
-          ArrayList arrayList = (ArrayList) this.m_clients.Clone();
-          arrayList.Add((object) client);
-          this.m_clients = arrayList;
-        }
-      }
-
-      private void RemoveClient(TelnetAppender.SocketHandler.SocketClient client)
-      {
-        lock (this)
-        {
-          ArrayList arrayList = (ArrayList) this.m_clients.Clone();
-          arrayList.Remove((object) client);
-          this.m_clients = arrayList;
-        }
-      }
-
-      public bool HasConnections
-      {
-        get
-        {
-          ArrayList clients = this.m_clients;
-          return clients != null && clients.Count > 0;
-        }
-      }
-
-      private void OnConnect(IAsyncResult asyncResult)
-      {
-        try
-        {
-          Socket socket = this.m_serverSocket.EndAccept(asyncResult);
-          LogLog.Debug("TelnetAppender: Accepting connection from [" + socket.RemoteEndPoint.ToString() + "]");
-          TelnetAppender.SocketHandler.SocketClient client = new TelnetAppender.SocketHandler.SocketClient(socket);
-          int count = this.m_clients.Count;
-          if (count < 20)
-          {
-            try
-            {
-              client.Send("TelnetAppender v1.0 (" + (object) (count + 1) + " active connections)\r\n\r\n");
-              this.AddClient(client);
-            }
-            catch
-            {
-              client.Dispose();
-            }
-          }
-          else
-          {
-            client.Send("Sorry - Too many connections.\r\n");
-            client.Dispose();
-          }
-        }
-        catch
-        {
-        }
-        finally
-        {
-          if (this.m_serverSocket != null)
-            this.m_serverSocket.BeginAccept(new AsyncCallback(this.OnConnect), (object) null);
-        }
-      }
-
-      public void Dispose()
-      {
-        foreach (TelnetAppender.SocketHandler.SocketClient client in this.m_clients)
-          client.Dispose();
-        this.m_clients.Clear();
-        Socket serverSocket = this.m_serverSocket;
-        this.m_serverSocket = (Socket) null;
-        try
-        {
-          serverSocket.Shutdown(SocketShutdown.Both);
-        }
-        catch
-        {
-        }
-        try
-        {
-          serverSocket.Close();
-        }
-        catch
-        {
-        }
-      }
-
-      protected class SocketClient : IDisposable
-      {
-        private Socket m_socket;
-        private StreamWriter m_writer;
-
-        public SocketClient(Socket socket)
-        {
-          this.m_socket = socket;
-          try
-          {
-            this.m_writer = new StreamWriter((Stream) new NetworkStream(socket));
-          }
-          catch
-          {
-            this.Dispose();
-            throw;
-          }
-        }
-
-        public void Send(string message)
-        {
-          this.m_writer.Write(message);
-          this.m_writer.Flush();
-        }
-
-        public void Dispose()
-        {
-          try
-          {
-            if (this.m_writer != null)
-            {
-              this.m_writer.Close();
-              this.m_writer = (StreamWriter) null;
-            }
-          }
-          catch
-          {
-          }
-          if (this.m_socket == null)
-            return;
-          try
-          {
-            this.m_socket.Shutdown(SocketShutdown.Both);
-          }
-          catch
-          {
-          }
-          try
-          {
-            this.m_socket.Close();
-          }
-          catch
-          {
-          }
-          this.m_socket = (Socket) null;
-        }
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/TextWriterAppender.cs b/MSHALTester/log4net/Appender/TextWriterAppender.cs
deleted file mode 100644
index e0a8d17..0000000
--- a/MSHALTester/log4net/Appender/TextWriterAppender.cs
+++ /dev/null
@@ -1,167 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using log4net.Util;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class TextWriterAppender : AppenderSkeleton
-  {
-    private QuietTextWriter m_qtw;
-    private bool m_immediateFlush = true;
-
-    public TextWriterAppender()
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout & Writer properties")]
-    public TextWriterAppender(ILayout layout, Stream os)
-      : this(layout, (TextWriter) new StreamWriter(os))
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout & Writer properties")]
-    public TextWriterAppender(ILayout layout, TextWriter writer)
-    {
-      this.Layout = layout;
-      this.Writer = writer;
-    }
-
-    public bool ImmediateFlush
-    {
-      get => this.m_immediateFlush;
-      set => this.m_immediateFlush = value;
-    }
-
-    public virtual TextWriter Writer
-    {
-      get => (TextWriter) this.m_qtw;
-      set
-      {
-        lock (this)
-        {
-          this.Reset();
-          if (value == null)
-            return;
-          this.m_qtw = new QuietTextWriter(value, this.ErrorHandler);
-          this.WriteHeader();
-        }
-      }
-    }
-
-    protected override bool PreAppendCheck()
-    {
-      if (!base.PreAppendCheck())
-        return false;
-      if (this.m_qtw == null)
-      {
-        this.PrepareWriter();
-        if (this.m_qtw == null)
-        {
-          this.ErrorHandler.Error("No output stream or file set for the appender named [" + this.Name + "].");
-          return false;
-        }
-      }
-      if (!this.m_qtw.Closed)
-        return true;
-      this.ErrorHandler.Error("Output stream for appender named [" + this.Name + "] has been closed.");
-      return false;
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      this.RenderLoggingEvent((TextWriter) this.m_qtw, loggingEvent);
-      if (!this.m_immediateFlush)
-        return;
-      this.m_qtw.Flush();
-    }
-
-    protected override void OnClose()
-    {
-      lock (this)
-        this.Reset();
-    }
-
-    public override IErrorHandler ErrorHandler
-    {
-      get => base.ErrorHandler;
-      set
-      {
-        lock (this)
-        {
-          if (value == null)
-          {
-            LogLog.Warn("TextWriterAppender: You have tried to set a null error-handler.");
-          }
-          else
-          {
-            base.ErrorHandler = value;
-            if (this.m_qtw == null)
-              return;
-            this.m_qtw.ErrorHandler = value;
-          }
-        }
-      }
-    }
-
-    protected override bool RequiresLayout => true;
-
-    protected virtual void WriteFooterAndCloseWriter()
-    {
-      this.WriteFooter();
-      this.CloseWriter();
-    }
-
-    protected virtual void CloseWriter()
-    {
-      if (this.m_qtw == null)
-        return;
-      try
-      {
-        this.m_qtw.Close();
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Could not close writer [" + (object) this.m_qtw + "]", ex);
-      }
-    }
-
-    protected virtual void Reset()
-    {
-      this.WriteFooterAndCloseWriter();
-      this.m_qtw = (QuietTextWriter) null;
-    }
-
-    protected virtual void WriteFooter()
-    {
-      if (this.Layout == null || this.m_qtw == null || this.m_qtw.Closed)
-        return;
-      string footer = this.Layout.Footer;
-      if (footer == null)
-        return;
-      this.m_qtw.Write(footer);
-    }
-
-    protected virtual void WriteHeader()
-    {
-      if (this.Layout == null || this.m_qtw == null || this.m_qtw.Closed)
-        return;
-      string header = this.Layout.Header;
-      if (header == null)
-        return;
-      this.m_qtw.Write(header);
-    }
-
-    protected virtual void PrepareWriter()
-    {
-    }
-
-    protected QuietTextWriter QuietWriter
-    {
-      get => this.m_qtw;
-      set => this.m_qtw = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Appender/TraceAppender.cs b/MSHALTester/log4net/Appender/TraceAppender.cs
deleted file mode 100644
index f7aeb85..0000000
--- a/MSHALTester/log4net/Appender/TraceAppender.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-using log4net.Core;
-using log4net.Layout;
-using System;
-using System.Diagnostics;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class TraceAppender : AppenderSkeleton
-  {
-    private bool m_immediateFlush = true;
-
-    public TraceAppender()
-    {
-    }
-
-    [Obsolete("Instead use the default constructor and set the Layout property")]
-    public TraceAppender(ILayout layout) => this.Layout = layout;
-
-    public bool ImmediateFlush
-    {
-      get => this.m_immediateFlush;
-      set => this.m_immediateFlush = value;
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      Trace.Write(this.RenderLoggingEvent(loggingEvent), loggingEvent.LoggerName);
-      if (!this.m_immediateFlush)
-        return;
-      Trace.Flush();
-    }
-
-    protected override bool RequiresLayout => true;
-  }
-}
diff --git a/MSHALTester/log4net/Appender/UdpAppender.cs b/MSHALTester/log4net/Appender/UdpAppender.cs
deleted file mode 100644
index 4830161..0000000
--- a/MSHALTester/log4net/Appender/UdpAppender.cs
+++ /dev/null
@@ -1,162 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Globalization;
-using System.Net;
-using System.Net.Sockets;
-using System.Text;
-
-#nullable disable
-namespace log4net.Appender
-{
-  public class UdpAppender : AppenderSkeleton
-  {
-    private IPAddress m_remoteAddress;
-    private int m_remotePort;
-    private IPEndPoint m_remoteEndPoint;
-    private int m_localPort;
-    private UdpClient m_client;
-    private Encoding m_encoding = Encoding.Default;
-
-    public IPAddress RemoteAddress
-    {
-      get => this.m_remoteAddress;
-      set => this.m_remoteAddress = value;
-    }
-
-    public int RemotePort
-    {
-      get => this.m_remotePort;
-      set
-      {
-        this.m_remotePort = value >= 0 && value <= (int) ushort.MaxValue ? value : throw SystemInfo.CreateArgumentOutOfRangeException(nameof (value), (object) value, "The value specified is less than " + 0.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo) + " or greater than " + ((int) ushort.MaxValue).ToString((IFormatProvider) NumberFormatInfo.InvariantInfo) + ".");
-      }
-    }
-
-    public int LocalPort
-    {
-      get => this.m_localPort;
-      set
-      {
-        this.m_localPort = value == 0 || value >= 0 && value <= (int) ushort.MaxValue ? value : throw SystemInfo.CreateArgumentOutOfRangeException(nameof (value), (object) value, "The value specified is less than " + 0.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo) + " or greater than " + ((int) ushort.MaxValue).ToString((IFormatProvider) NumberFormatInfo.InvariantInfo) + ".");
-      }
-    }
-
-    public Encoding Encoding
-    {
-      get => this.m_encoding;
-      set => this.m_encoding = value;
-    }
-
-    protected UdpClient Client
-    {
-      get => this.m_client;
-      set => this.m_client = value;
-    }
-
-    protected IPEndPoint RemoteEndPoint
-    {
-      get => this.m_remoteEndPoint;
-      set => this.m_remoteEndPoint = value;
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      if (this.RemoteAddress == null)
-        throw new ArgumentNullException("The required property 'Address' was not specified.");
-      if (this.RemotePort < 0 || this.RemotePort > (int) ushort.MaxValue)
-      {
-        // ISSUE: variable of a boxed type
-        __Boxed<int> remotePort = (ValueType) this.RemotePort;
-        string[] strArray1 = new string[5]
-        {
-          "The RemotePort is less than ",
-          null,
-          null,
-          null,
-          null
-        };
-        string[] strArray2 = strArray1;
-        int num = 0;
-        string str1 = num.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo);
-        strArray2[1] = str1;
-        strArray1[2] = " or greater than ";
-        string[] strArray3 = strArray1;
-        num = (int) ushort.MaxValue;
-        string str2 = num.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo);
-        strArray3[3] = str2;
-        strArray1[4] = ".";
-        string message = string.Concat(strArray1);
-        throw SystemInfo.CreateArgumentOutOfRangeException("this.RemotePort", (object) remotePort, message);
-      }
-      if (this.LocalPort != 0 && (this.LocalPort < 0 || this.LocalPort > (int) ushort.MaxValue))
-      {
-        // ISSUE: variable of a boxed type
-        __Boxed<int> localPort = (ValueType) this.LocalPort;
-        string[] strArray4 = new string[5]
-        {
-          "The LocalPort is less than ",
-          null,
-          null,
-          null,
-          null
-        };
-        string[] strArray5 = strArray4;
-        int num = 0;
-        string str3 = num.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo);
-        strArray5[1] = str3;
-        strArray4[2] = " or greater than ";
-        string[] strArray6 = strArray4;
-        num = (int) ushort.MaxValue;
-        string str4 = num.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo);
-        strArray6[3] = str4;
-        strArray4[4] = ".";
-        string message = string.Concat(strArray4);
-        throw SystemInfo.CreateArgumentOutOfRangeException("this.LocalPort", (object) localPort, message);
-      }
-      this.RemoteEndPoint = new IPEndPoint(this.RemoteAddress, this.RemotePort);
-      this.InitializeClientConnection();
-    }
-
-    protected override void Append(LoggingEvent loggingEvent)
-    {
-      try
-      {
-        byte[] bytes = this.m_encoding.GetBytes(this.RenderLoggingEvent(loggingEvent).ToCharArray());
-        this.Client.Send(bytes, bytes.Length, this.RemoteEndPoint);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Unable to send logging event to remote host " + this.RemoteAddress.ToString() + " on port " + (object) this.RemotePort + ".", ex, ErrorCode.WriteFailure);
-      }
-    }
-
-    protected override bool RequiresLayout => true;
-
-    protected override void OnClose()
-    {
-      base.OnClose();
-      if (this.Client == null)
-        return;
-      this.Client.Close();
-      this.Client = (UdpClient) null;
-    }
-
-    protected virtual void InitializeClientConnection()
-    {
-      try
-      {
-        if (this.LocalPort == 0)
-          this.Client = new UdpClient();
-        else
-          this.Client = new UdpClient(this.LocalPort);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Could not initialize the UdpClient connection on port " + this.LocalPort.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo) + ".", ex, ErrorCode.GenericFailure);
-        this.Client = (UdpClient) null;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/AliasDomainAttribute.cs b/MSHALTester/log4net/Config/AliasDomainAttribute.cs
deleted file mode 100644
index fc451e5..0000000
--- a/MSHALTester/log4net/Config/AliasDomainAttribute.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Config
-{
-  [Obsolete("Use AliasRepositoryAttribute instead of AliasDomainAttribute")]
-  [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
-  [Serializable]
-  public sealed class AliasDomainAttribute(string name) : AliasRepositoryAttribute(name)
-  {
-  }
-}
diff --git a/MSHALTester/log4net/Config/AliasRepositoryAttribute.cs b/MSHALTester/log4net/Config/AliasRepositoryAttribute.cs
deleted file mode 100644
index 63e463b..0000000
--- a/MSHALTester/log4net/Config/AliasRepositoryAttribute.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Config
-{
-  [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
-  [Serializable]
-  public class AliasRepositoryAttribute : Attribute
-  {
-    private string m_name = (string) null;
-
-    public AliasRepositoryAttribute(string name) => this.Name = name;
-
-    public string Name
-    {
-      get => this.m_name;
-      set => this.m_name = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/BasicConfigurator.cs b/MSHALTester/log4net/Config/BasicConfigurator.cs
deleted file mode 100644
index 123be51..0000000
--- a/MSHALTester/log4net/Config/BasicConfigurator.cs
+++ /dev/null
@@ -1,45 +0,0 @@
-using log4net.Appender;
-using log4net.Layout;
-using log4net.Repository;
-using log4net.Util;
-using System.Reflection;
-
-#nullable disable
-namespace log4net.Config
-{
-  public sealed class BasicConfigurator
-  {
-    private BasicConfigurator()
-    {
-    }
-
-    public static void Configure()
-    {
-      BasicConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()));
-    }
-
-    public static void Configure(IAppender appender)
-    {
-      BasicConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), appender);
-    }
-
-    public static void Configure(ILoggerRepository repository)
-    {
-      PatternLayout patternLayout = new PatternLayout();
-      patternLayout.ConversionPattern = "%timestamp [%thread] %level %logger %ndc - %message%newline";
-      patternLayout.ActivateOptions();
-      ConsoleAppender consoleAppender = new ConsoleAppender();
-      consoleAppender.Layout = (ILayout) patternLayout;
-      consoleAppender.ActivateOptions();
-      BasicConfigurator.Configure(repository, (IAppender) consoleAppender);
-    }
-
-    public static void Configure(ILoggerRepository repository, IAppender appender)
-    {
-      if (repository is IBasicRepositoryConfigurator repositoryConfigurator)
-        repositoryConfigurator.Configure(appender);
-      else
-        LogLog.Warn("BasicConfigurator: Repository [" + (object) repository + "] does not support the BasicConfigurator");
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/ConfiguratorAttribute.cs b/MSHALTester/log4net/Config/ConfiguratorAttribute.cs
deleted file mode 100644
index b53830f..0000000
--- a/MSHALTester/log4net/Config/ConfiguratorAttribute.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-using log4net.Repository;
-using System;
-using System.Reflection;
-
-#nullable disable
-namespace log4net.Config
-{
-  [AttributeUsage(AttributeTargets.Assembly)]
-  public abstract class ConfiguratorAttribute : Attribute, IComparable
-  {
-    private int m_priority = 0;
-
-    protected ConfiguratorAttribute(int priority) => this.m_priority = priority;
-
-    public abstract void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository);
-
-    public int CompareTo(object obj)
-    {
-      if (this == obj)
-        return 0;
-      int num = -1;
-      if (obj is ConfiguratorAttribute configuratorAttribute)
-      {
-        num = configuratorAttribute.m_priority.CompareTo((object) this.m_priority);
-        if (num == 0)
-          num = -1;
-      }
-      return num;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/DOMConfigurator.cs b/MSHALTester/log4net/Config/DOMConfigurator.cs
deleted file mode 100644
index 3894c70..0000000
--- a/MSHALTester/log4net/Config/DOMConfigurator.cs
+++ /dev/null
@@ -1,77 +0,0 @@
-using log4net.Repository;
-using System;
-using System.IO;
-using System.Reflection;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Config
-{
-  [Obsolete("Use XmlConfigurator instead of DOMConfigurator")]
-  public sealed class DOMConfigurator
-  {
-    private DOMConfigurator()
-    {
-    }
-
-    [Obsolete("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
-    public static void Configure()
-    {
-      XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()));
-    }
-
-    [Obsolete("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
-    public static void Configure(ILoggerRepository repository)
-    {
-      XmlConfigurator.Configure(repository);
-    }
-
-    [Obsolete("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
-    public static void Configure(XmlElement element)
-    {
-      XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), element);
-    }
-
-    [Obsolete("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
-    public static void Configure(ILoggerRepository repository, XmlElement element)
-    {
-      XmlConfigurator.Configure(repository, element);
-    }
-
-    [Obsolete("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
-    public static void Configure(FileInfo configFile)
-    {
-      XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), configFile);
-    }
-
-    [Obsolete("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
-    public static void Configure(Stream configStream)
-    {
-      XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), configStream);
-    }
-
-    [Obsolete("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
-    public static void Configure(ILoggerRepository repository, FileInfo configFile)
-    {
-      XmlConfigurator.Configure(repository, configFile);
-    }
-
-    [Obsolete("Use XmlConfigurator.Configure instead of DOMConfigurator.Configure")]
-    public static void Configure(ILoggerRepository repository, Stream configStream)
-    {
-      XmlConfigurator.Configure(repository, configStream);
-    }
-
-    [Obsolete("Use XmlConfigurator.ConfigureAndWatch instead of DOMConfigurator.ConfigureAndWatch")]
-    public static void ConfigureAndWatch(FileInfo configFile)
-    {
-      XmlConfigurator.ConfigureAndWatch(LogManager.GetRepository(Assembly.GetCallingAssembly()), configFile);
-    }
-
-    [Obsolete("Use XmlConfigurator.ConfigureAndWatch instead of DOMConfigurator.ConfigureAndWatch")]
-    public static void ConfigureAndWatch(ILoggerRepository repository, FileInfo configFile)
-    {
-      XmlConfigurator.ConfigureAndWatch(repository, configFile);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/DOMConfiguratorAttribute.cs b/MSHALTester/log4net/Config/DOMConfiguratorAttribute.cs
deleted file mode 100644
index c961e12..0000000
--- a/MSHALTester/log4net/Config/DOMConfiguratorAttribute.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Config
-{
-  [Obsolete("Use XmlConfiguratorAttribute instead of DOMConfiguratorAttribute")]
-  [AttributeUsage(AttributeTargets.Assembly)]
-  [Serializable]
-  public sealed class DOMConfiguratorAttribute : XmlConfiguratorAttribute
-  {
-  }
-}
diff --git a/MSHALTester/log4net/Config/DomainAttribute.cs b/MSHALTester/log4net/Config/DomainAttribute.cs
deleted file mode 100644
index 13587ab..0000000
--- a/MSHALTester/log4net/Config/DomainAttribute.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Config
-{
-  [AttributeUsage(AttributeTargets.Assembly)]
-  [Obsolete("Use RepositoryAttribute instead of DomainAttribute")]
-  [Serializable]
-  public sealed class DomainAttribute : RepositoryAttribute
-  {
-    public DomainAttribute()
-    {
-    }
-
-    public DomainAttribute(string name)
-      : base(name)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/Log4NetConfigurationSectionHandler.cs b/MSHALTester/log4net/Config/Log4NetConfigurationSectionHandler.cs
deleted file mode 100644
index 3343c2f..0000000
--- a/MSHALTester/log4net/Config/Log4NetConfigurationSectionHandler.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-using System.Configuration;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Config
-{
-  public class Log4NetConfigurationSectionHandler : IConfigurationSectionHandler
-  {
-    public object Create(object parent, object configContext, XmlNode section) => (object) section;
-  }
-}
diff --git a/MSHALTester/log4net/Config/PluginAttribute.cs b/MSHALTester/log4net/Config/PluginAttribute.cs
deleted file mode 100644
index 194ab3e..0000000
--- a/MSHALTester/log4net/Config/PluginAttribute.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-using log4net.Core;
-using log4net.Plugin;
-using log4net.Util;
-using System;
-
-#nullable disable
-namespace log4net.Config
-{
-  [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
-  [Serializable]
-  public sealed class PluginAttribute : Attribute, IPluginFactory
-  {
-    private string m_type = (string) null;
-
-    public PluginAttribute(string type) => this.m_type = type;
-
-    public string Type
-    {
-      get => this.m_type;
-      set => this.m_type = value;
-    }
-
-    public IPlugin CreatePlugin()
-    {
-      System.Type typeFromString = SystemInfo.GetTypeFromString(this.Type, true, true);
-      return typeof (IPlugin).IsAssignableFrom(typeFromString) ? (IPlugin) Activator.CreateInstance(typeFromString) : throw new LogException("Plugin type [" + this.Type + "] does not implement log4net.IPlugin interface");
-    }
-
-    public override string ToString() => "PluginAttribute[Type=" + this.Type + "]";
-  }
-}
diff --git a/MSHALTester/log4net/Config/RepositoryAttribute.cs b/MSHALTester/log4net/Config/RepositoryAttribute.cs
deleted file mode 100644
index 505648d..0000000
--- a/MSHALTester/log4net/Config/RepositoryAttribute.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Config
-{
-  [AttributeUsage(AttributeTargets.Assembly)]
-  [Serializable]
-  public class RepositoryAttribute : Attribute
-  {
-    private string m_name = (string) null;
-    private Type m_repositoryType = (Type) null;
-
-    public RepositoryAttribute()
-    {
-    }
-
-    public RepositoryAttribute(string name) => this.m_name = name;
-
-    public string Name
-    {
-      get => this.m_name;
-      set => this.m_name = value;
-    }
-
-    public Type RepositoryType
-    {
-      get => this.m_repositoryType;
-      set => this.m_repositoryType = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/SecurityContextProviderAttribute.cs b/MSHALTester/log4net/Config/SecurityContextProviderAttribute.cs
deleted file mode 100644
index 3623a16..0000000
--- a/MSHALTester/log4net/Config/SecurityContextProviderAttribute.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-using log4net.Core;
-using log4net.Repository;
-using log4net.Util;
-using System;
-using System.Reflection;
-
-#nullable disable
-namespace log4net.Config
-{
-  [AttributeUsage(AttributeTargets.Assembly)]
-  [Serializable]
-  public sealed class SecurityContextProviderAttribute : ConfiguratorAttribute
-  {
-    private Type m_providerType = (Type) null;
-
-    public SecurityContextProviderAttribute(Type providerType)
-      : base(100)
-    {
-      this.m_providerType = providerType;
-    }
-
-    public Type ProviderType
-    {
-      get => this.m_providerType;
-      set => this.m_providerType = value;
-    }
-
-    public override void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository)
-    {
-      if (this.m_providerType == null)
-      {
-        LogLog.Error("SecurityContextProviderAttribute: Attribute specified on assembly [" + sourceAssembly.FullName + "] with null ProviderType.");
-      }
-      else
-      {
-        LogLog.Debug("SecurityContextProviderAttribute: Creating provider of type [" + this.m_providerType.FullName + "]");
-        if (!(Activator.CreateInstance(this.m_providerType) is SecurityContextProvider instance))
-          LogLog.Error("SecurityContextProviderAttribute: Failed to create SecurityContextProvider instance of type [" + this.m_providerType.Name + "].");
-        else
-          SecurityContextProvider.DefaultProvider = instance;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/XmlConfigurator.cs b/MSHALTester/log4net/Config/XmlConfigurator.cs
deleted file mode 100644
index ee0c005..0000000
--- a/MSHALTester/log4net/Config/XmlConfigurator.cs
+++ /dev/null
@@ -1,302 +0,0 @@
-using log4net.Repository;
-using log4net.Util;
-using System;
-using System.Configuration;
-using System.IO;
-using System.Net;
-using System.Reflection;
-using System.Threading;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Config
-{
-  public sealed class XmlConfigurator
-  {
-    private XmlConfigurator()
-    {
-    }
-
-    public static void Configure()
-    {
-      XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()));
-    }
-
-    public static void Configure(ILoggerRepository repository)
-    {
-      LogLog.Debug("XmlConfigurator: configuring repository [" + repository.Name + "] using .config file section");
-      try
-      {
-        LogLog.Debug("XmlConfigurator: Application config file is [" + SystemInfo.ConfigurationFileLocation + "]");
-      }
-      catch
-      {
-        LogLog.Debug("XmlConfigurator: Application config file location unknown");
-      }
-      try
-      {
-        if (!(ConfigurationSettings.GetConfig("log4net") is XmlElement config))
-          LogLog.Error("XmlConfigurator: Failed to find configuration section 'log4net' in the application's .config file. Check your .config file for the <log4net> and <configSections> elements. The configuration section should look like: <section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler,log4net\" />");
-        else
-          XmlConfigurator.ConfigureFromXml(repository, config);
-      }
-      catch (ConfigurationException ex)
-      {
-        if (ex.BareMessage.IndexOf("Unrecognized element") >= 0)
-          LogLog.Error("XmlConfigurator: Failed to parse config file. Check your .config file is well formed XML.", (Exception) ex);
-        else
-          LogLog.Error("XmlConfigurator: Failed to parse config file. Is the <configSections> specified as: " + ("<section name=\"log4net\" type=\"log4net.Config.Log4NetConfigurationSectionHandler," + Assembly.GetExecutingAssembly().FullName + "\" />"), (Exception) ex);
-      }
-    }
-
-    public static void Configure(XmlElement element)
-    {
-      XmlConfigurator.ConfigureFromXml(LogManager.GetRepository(Assembly.GetCallingAssembly()), element);
-    }
-
-    public static void Configure(ILoggerRepository repository, XmlElement element)
-    {
-      LogLog.Debug("XmlConfigurator: configuring repository [" + repository.Name + "] using XML element");
-      XmlConfigurator.ConfigureFromXml(repository, element);
-    }
-
-    public static void Configure(FileInfo configFile)
-    {
-      XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), configFile);
-    }
-
-    public static void Configure(Uri configUri)
-    {
-      XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), configUri);
-    }
-
-    public static void Configure(Stream configStream)
-    {
-      XmlConfigurator.Configure(LogManager.GetRepository(Assembly.GetCallingAssembly()), configStream);
-    }
-
-    public static void Configure(ILoggerRepository repository, FileInfo configFile)
-    {
-      LogLog.Debug("XmlConfigurator: configuring repository [" + repository.Name + "] using file [" + (object) configFile + "]");
-      if (configFile == null)
-        LogLog.Error("XmlConfigurator: Configure called with null 'configFile' parameter");
-      else if (System.IO.File.Exists(configFile.FullName))
-      {
-        FileStream configStream = (FileStream) null;
-        int num = 5;
-        while (--num >= 0)
-        {
-          try
-          {
-            configStream = configFile.Open(FileMode.Open, FileAccess.Read, FileShare.Read);
-            break;
-          }
-          catch (IOException ex)
-          {
-            if (num == 0)
-            {
-              LogLog.Error("XmlConfigurator: Failed to open XML config file [" + configFile.Name + "]", (Exception) ex);
-              configStream = (FileStream) null;
-            }
-            Thread.Sleep(250);
-          }
-        }
-        if (configStream == null)
-          return;
-        try
-        {
-          XmlConfigurator.Configure(repository, (Stream) configStream);
-        }
-        finally
-        {
-          configStream.Close();
-        }
-      }
-      else
-        LogLog.Debug("XmlConfigurator: config file [" + configFile.FullName + "] not found. Configuration unchanged.");
-    }
-
-    public static void Configure(ILoggerRepository repository, Uri configUri)
-    {
-      LogLog.Debug("XmlConfigurator: configuring repository [" + repository.Name + "] using URI [" + (object) configUri + "]");
-      if ((object) configUri == null)
-        LogLog.Error("XmlConfigurator: Configure called with null 'configUri' parameter");
-      else if (configUri.IsFile)
-      {
-        XmlConfigurator.Configure(repository, new FileInfo(configUri.LocalPath));
-      }
-      else
-      {
-        WebRequest webRequest = (WebRequest) null;
-        try
-        {
-          webRequest = WebRequest.Create(configUri);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("XmlConfigurator: Failed to create WebRequest for URI [" + (object) configUri + "]", ex);
-        }
-        if (webRequest == null)
-          return;
-        try
-        {
-          webRequest.Credentials = CredentialCache.DefaultCredentials;
-        }
-        catch
-        {
-        }
-        try
-        {
-          WebResponse response = webRequest.GetResponse();
-          if (response == null)
-            return;
-          try
-          {
-            using (Stream responseStream = response.GetResponseStream())
-              XmlConfigurator.Configure(repository, responseStream);
-          }
-          finally
-          {
-            response.Close();
-          }
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("XmlConfigurator: Failed to request config from URI [" + (object) configUri + "]", ex);
-        }
-      }
-    }
-
-    public static void Configure(ILoggerRepository repository, Stream configStream)
-    {
-      LogLog.Debug("XmlConfigurator: configuring repository [" + repository.Name + "] using stream");
-      if (configStream == null)
-      {
-        LogLog.Error("XmlConfigurator: Configure called with null 'configStream' parameter");
-      }
-      else
-      {
-        XmlDocument xmlDocument = new XmlDocument();
-        try
-        {
-          xmlDocument.Load((XmlReader) new XmlValidatingReader((XmlReader) new XmlTextReader(configStream))
-          {
-            ValidationType = ValidationType.None,
-            EntityHandling = EntityHandling.ExpandEntities
-          });
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("XmlConfigurator: Error while loading XML configuration", ex);
-          xmlDocument = (XmlDocument) null;
-        }
-        if (xmlDocument == null)
-          return;
-        LogLog.Debug("XmlConfigurator: loading XML configuration");
-        XmlNodeList elementsByTagName = xmlDocument.GetElementsByTagName("log4net");
-        if (elementsByTagName.Count == 0)
-          LogLog.Debug("XmlConfigurator: XML configuration does not contain a <log4net> element. Configuration Aborted.");
-        else if (elementsByTagName.Count > 1)
-          LogLog.Error("XmlConfigurator: XML configuration contains [" + (object) elementsByTagName.Count + "] <log4net> elements. Only one is allowed. Configuration Aborted.");
-        else
-          XmlConfigurator.ConfigureFromXml(repository, elementsByTagName[0] as XmlElement);
-      }
-    }
-
-    public static void ConfigureAndWatch(FileInfo configFile)
-    {
-      XmlConfigurator.ConfigureAndWatch(LogManager.GetRepository(Assembly.GetCallingAssembly()), configFile);
-    }
-
-    public static void ConfigureAndWatch(ILoggerRepository repository, FileInfo configFile)
-    {
-      LogLog.Debug("XmlConfigurator: configuring repository [" + repository.Name + "] using file [" + (object) configFile + "] watching for file updates");
-      if (configFile == null)
-      {
-        LogLog.Error("XmlConfigurator: ConfigureAndWatch called with null 'configFile' parameter");
-      }
-      else
-      {
-        XmlConfigurator.Configure(repository, configFile);
-        try
-        {
-          XmlConfigurator.ConfigureAndWatchHandler.StartWatching(repository, configFile);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("XmlConfigurator: Failed to initialize configuration file watcher for file [" + configFile.FullName + "]", ex);
-        }
-      }
-    }
-
-    private static void ConfigureFromXml(ILoggerRepository repository, XmlElement element)
-    {
-      if (element == null)
-        LogLog.Error("XmlConfigurator: ConfigureFromXml called with null 'element' parameter");
-      else if (repository == null)
-      {
-        LogLog.Error("XmlConfigurator: ConfigureFromXml called with null 'repository' parameter");
-      }
-      else
-      {
-        LogLog.Debug("XmlConfigurator: Configuring Repository [" + repository.Name + "]");
-        if (!(repository is IXmlRepositoryConfigurator repositoryConfigurator))
-        {
-          LogLog.Warn("XmlConfigurator: Repository [" + (object) repository + "] does not support the XmlConfigurator");
-        }
-        else
-        {
-          XmlDocument xmlDocument = new XmlDocument();
-          XmlElement element1 = (XmlElement) xmlDocument.AppendChild(xmlDocument.ImportNode((XmlNode) element, true));
-          repositoryConfigurator.Configure(element1);
-        }
-      }
-    }
-
-    private sealed class ConfigureAndWatchHandler
-    {
-      private const int TimeoutMillis = 500;
-      private FileInfo m_configFile;
-      private ILoggerRepository m_repository;
-      private System.Threading.Timer m_timer;
-
-      internal static void StartWatching(ILoggerRepository repository, FileInfo configFile)
-      {
-        XmlConfigurator.ConfigureAndWatchHandler configureAndWatchHandler = new XmlConfigurator.ConfigureAndWatchHandler(repository, configFile);
-      }
-
-      private ConfigureAndWatchHandler(ILoggerRepository repository, FileInfo configFile)
-      {
-        this.m_repository = repository;
-        this.m_configFile = configFile;
-        FileSystemWatcher fileSystemWatcher = new FileSystemWatcher();
-        fileSystemWatcher.Path = this.m_configFile.DirectoryName;
-        fileSystemWatcher.Filter = this.m_configFile.Name;
-        fileSystemWatcher.NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite | NotifyFilters.CreationTime;
-        fileSystemWatcher.Changed += new FileSystemEventHandler(this.ConfigureAndWatchHandler_OnChanged);
-        fileSystemWatcher.Created += new FileSystemEventHandler(this.ConfigureAndWatchHandler_OnChanged);
-        fileSystemWatcher.Deleted += new FileSystemEventHandler(this.ConfigureAndWatchHandler_OnChanged);
-        fileSystemWatcher.Renamed += new RenamedEventHandler(this.ConfigureAndWatchHandler_OnRenamed);
-        fileSystemWatcher.EnableRaisingEvents = true;
-        this.m_timer = new System.Threading.Timer(new TimerCallback(this.OnWatchedFileChange), (object) null, -1, -1);
-      }
-
-      private void ConfigureAndWatchHandler_OnChanged(object source, FileSystemEventArgs e)
-      {
-        LogLog.Debug("ConfigureAndWatchHandler: " + (object) e.ChangeType + " [" + this.m_configFile.FullName + "]");
-        this.m_timer.Change(500, -1);
-      }
-
-      private void ConfigureAndWatchHandler_OnRenamed(object source, RenamedEventArgs e)
-      {
-        LogLog.Debug("ConfigureAndWatchHandler: " + (object) e.ChangeType + " [" + this.m_configFile.FullName + "]");
-        this.m_timer.Change(500, -1);
-      }
-
-      private void OnWatchedFileChange(object state)
-      {
-        XmlConfigurator.Configure(this.m_repository, this.m_configFile);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Config/XmlConfiguratorAttribute.cs b/MSHALTester/log4net/Config/XmlConfiguratorAttribute.cs
deleted file mode 100644
index e56483f..0000000
--- a/MSHALTester/log4net/Config/XmlConfiguratorAttribute.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-using log4net.Repository;
-using log4net.Util;
-using System;
-using System.IO;
-using System.Reflection;
-
-#nullable disable
-namespace log4net.Config
-{
-  [AttributeUsage(AttributeTargets.Assembly)]
-  [Serializable]
-  public class XmlConfiguratorAttribute : ConfiguratorAttribute
-  {
-    private string m_configFile = (string) null;
-    private string m_configFileExtension = (string) null;
-    private bool m_configureAndWatch = false;
-
-    public XmlConfiguratorAttribute()
-      : base(0)
-    {
-    }
-
-    public string ConfigFile
-    {
-      get => this.m_configFile;
-      set => this.m_configFile = value;
-    }
-
-    public string ConfigFileExtension
-    {
-      get => this.m_configFileExtension;
-      set => this.m_configFileExtension = value;
-    }
-
-    public bool Watch
-    {
-      get => this.m_configureAndWatch;
-      set => this.m_configureAndWatch = value;
-    }
-
-    public override void Configure(Assembly sourceAssembly, ILoggerRepository targetRepository)
-    {
-      if (new Uri(SystemInfo.ApplicationBaseDirectory).IsFile)
-        this.ConfigureFromFile(sourceAssembly, targetRepository);
-      else
-        this.ConfigureFromUri(sourceAssembly, targetRepository);
-    }
-
-    private void ConfigureFromFile(Assembly sourceAssembly, ILoggerRepository targetRepository)
-    {
-      string fileName;
-      if (this.m_configFile == null || this.m_configFile.Length == 0)
-      {
-        if (this.m_configFileExtension == null || this.m_configFileExtension.Length == 0)
-        {
-          fileName = SystemInfo.ConfigurationFileLocation;
-        }
-        else
-        {
-          if (this.m_configFileExtension[0] != '.')
-            this.m_configFileExtension = "." + this.m_configFileExtension;
-          fileName = Path.Combine(SystemInfo.ApplicationBaseDirectory, SystemInfo.AssemblyFileName(sourceAssembly) + this.m_configFileExtension);
-        }
-      }
-      else
-        fileName = Path.Combine(SystemInfo.ApplicationBaseDirectory, this.m_configFile);
-      this.ConfigureFromFile(targetRepository, new FileInfo(fileName));
-    }
-
-    private void ConfigureFromFile(ILoggerRepository targetRepository, FileInfo configFile)
-    {
-      if (this.m_configureAndWatch)
-        XmlConfigurator.ConfigureAndWatch(targetRepository, configFile);
-      else
-        XmlConfigurator.Configure(targetRepository, configFile);
-    }
-
-    private void ConfigureFromUri(Assembly sourceAssembly, ILoggerRepository targetRepository)
-    {
-      Uri baseUri = new Uri(SystemInfo.ApplicationBaseDirectory);
-      Uri uri = new Uri(SystemInfo.ConfigurationFileLocation);
-      Uri configUri;
-      if (this.m_configFile == null || this.m_configFile.Length == 0)
-      {
-        if (this.m_configFileExtension == null || this.m_configFileExtension.Length == 0)
-        {
-          configUri = uri;
-        }
-        else
-        {
-          if (this.m_configFileExtension[0] != '.')
-            this.m_configFileExtension = "." + this.m_configFileExtension;
-          UriBuilder uriBuilder = new UriBuilder(uri);
-          string str1 = uriBuilder.Path;
-          int length = str1.LastIndexOf(".");
-          if (length >= 0)
-            str1 = str1.Substring(0, length);
-          string str2 = str1 + this.m_configFileExtension;
-          uriBuilder.Path = str2;
-          configUri = uriBuilder.Uri;
-        }
-      }
-      else
-        configUri = new Uri(baseUri, this.m_configFile);
-      if (configUri.IsFile)
-      {
-        this.ConfigureFromFile(targetRepository, new FileInfo(configUri.LocalPath));
-      }
-      else
-      {
-        if (this.m_configureAndWatch)
-          LogLog.Warn("XmlConfiguratorAttribute: Unable to watch config file loaded from a URI");
-        XmlConfigurator.Configure(targetRepository, configUri);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/CompactRepositorySelector.cs b/MSHALTester/log4net/Core/CompactRepositorySelector.cs
deleted file mode 100644
index 7254987..0000000
--- a/MSHALTester/log4net/Core/CompactRepositorySelector.cs
+++ /dev/null
@@ -1,105 +0,0 @@
-using log4net.Repository;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Reflection;
-
-#nullable disable
-namespace log4net.Core
-{
-  public class CompactRepositorySelector : IRepositorySelector
-  {
-    private const string DefaultRepositoryName = "log4net-default-repository";
-    private readonly Hashtable m_name2repositoryMap = new Hashtable();
-    private readonly Type m_defaultRepositoryType;
-
-    private event LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;
-
-    public CompactRepositorySelector(Type defaultRepositoryType)
-    {
-      if (defaultRepositoryType == null)
-        throw new ArgumentNullException(nameof (defaultRepositoryType));
-      this.m_defaultRepositoryType = typeof (ILoggerRepository).IsAssignableFrom(defaultRepositoryType) ? defaultRepositoryType : throw SystemInfo.CreateArgumentOutOfRangeException(nameof (defaultRepositoryType), (object) defaultRepositoryType, "Parameter: defaultRepositoryType, Value: [" + (object) defaultRepositoryType + "] out of range. Argument must implement the ILoggerRepository interface");
-      LogLog.Debug("CompactRepositorySelector: defaultRepositoryType [" + (object) this.m_defaultRepositoryType + "]");
-    }
-
-    public ILoggerRepository GetRepository(Assembly assembly)
-    {
-      return this.CreateRepository(assembly, this.m_defaultRepositoryType);
-    }
-
-    public ILoggerRepository GetRepository(string repositoryName)
-    {
-      if (repositoryName == null)
-        throw new ArgumentNullException(nameof (repositoryName));
-      lock (this)
-      {
-        if (!(this.m_name2repositoryMap[(object) repositoryName] is ILoggerRepository name2repository))
-          throw new LogException("Repository [" + repositoryName + "] is NOT defined.");
-        return name2repository;
-      }
-    }
-
-    public ILoggerRepository CreateRepository(Assembly assembly, Type repositoryType)
-    {
-      if (repositoryType == null)
-        repositoryType = this.m_defaultRepositoryType;
-      lock (this)
-      {
-        if (!(this.m_name2repositoryMap[(object) "log4net-default-repository"] is ILoggerRepository repository))
-          repository = this.CreateRepository("log4net-default-repository", repositoryType);
-        return repository;
-      }
-    }
-
-    public ILoggerRepository CreateRepository(string repositoryName, Type repositoryType)
-    {
-      if (repositoryName == null)
-        throw new ArgumentNullException(nameof (repositoryName));
-      if (repositoryType == null)
-        repositoryType = this.m_defaultRepositoryType;
-      lock (this)
-      {
-        if (this.m_name2repositoryMap[(object) repositoryName] is ILoggerRepository)
-          throw new LogException("Repository [" + repositoryName + "] is already defined. Repositories cannot be redefined.");
-        LogLog.Debug("DefaultRepositorySelector: Creating repository [" + repositoryName + "] using type [" + (object) repositoryType + "]");
-        ILoggerRepository instance = (ILoggerRepository) Activator.CreateInstance(repositoryType);
-        instance.Name = repositoryName;
-        this.m_name2repositoryMap[(object) repositoryName] = (object) instance;
-        this.OnLoggerRepositoryCreatedEvent(instance);
-        return instance;
-      }
-    }
-
-    public bool ExistsRepository(string repositoryName)
-    {
-      lock (this)
-        return this.m_name2repositoryMap.ContainsKey((object) repositoryName);
-    }
-
-    public ILoggerRepository[] GetAllRepositories()
-    {
-      lock (this)
-      {
-        ICollection values = this.m_name2repositoryMap.Values;
-        ILoggerRepository[] allRepositories = new ILoggerRepository[values.Count];
-        values.CopyTo((Array) allRepositories, 0);
-        return allRepositories;
-      }
-    }
-
-    public event LoggerRepositoryCreationEventHandler LoggerRepositoryCreatedEvent
-    {
-      add => this.m_loggerRepositoryCreatedEvent += value;
-      remove => this.m_loggerRepositoryCreatedEvent -= value;
-    }
-
-    protected virtual void OnLoggerRepositoryCreatedEvent(ILoggerRepository repository)
-    {
-      LoggerRepositoryCreationEventHandler repositoryCreatedEvent = this.m_loggerRepositoryCreatedEvent;
-      if (repositoryCreatedEvent == null)
-        return;
-      repositoryCreatedEvent((object) this, new LoggerRepositoryCreationEventArgs(repository));
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/DefaultRepositorySelector.cs b/MSHALTester/log4net/Core/DefaultRepositorySelector.cs
deleted file mode 100644
index 43bcaac..0000000
--- a/MSHALTester/log4net/Core/DefaultRepositorySelector.cs
+++ /dev/null
@@ -1,274 +0,0 @@
-using log4net.Config;
-using log4net.Plugin;
-using log4net.Repository;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Reflection;
-
-#nullable disable
-namespace log4net.Core
-{
-  public class DefaultRepositorySelector : IRepositorySelector
-  {
-    private const string DefaultRepositoryName = "log4net-default-repository";
-    private readonly Hashtable m_name2repositoryMap = new Hashtable();
-    private readonly Hashtable m_assembly2repositoryMap = new Hashtable();
-    private readonly Hashtable m_alias2repositoryMap = new Hashtable();
-    private readonly Type m_defaultRepositoryType;
-
-    public event LoggerRepositoryCreationEventHandler LoggerRepositoryCreatedEvent
-    {
-      add => this.m_loggerRepositoryCreatedEvent += value;
-      remove => this.m_loggerRepositoryCreatedEvent -= value;
-    }
-
-    public DefaultRepositorySelector(Type defaultRepositoryType)
-    {
-      if (defaultRepositoryType == null)
-        throw new ArgumentNullException(nameof (defaultRepositoryType));
-      this.m_defaultRepositoryType = typeof (ILoggerRepository).IsAssignableFrom(defaultRepositoryType) ? defaultRepositoryType : throw SystemInfo.CreateArgumentOutOfRangeException(nameof (defaultRepositoryType), (object) defaultRepositoryType, "Parameter: defaultRepositoryType, Value: [" + (object) defaultRepositoryType + "] out of range. Argument must implement the ILoggerRepository interface");
-      LogLog.Debug("DefaultRepositorySelector: defaultRepositoryType [" + (object) this.m_defaultRepositoryType + "]");
-    }
-
-    public ILoggerRepository GetRepository(Assembly repositoryAssembly)
-    {
-      return repositoryAssembly != null ? this.CreateRepository(repositoryAssembly, this.m_defaultRepositoryType) : throw new ArgumentNullException(nameof (repositoryAssembly));
-    }
-
-    public ILoggerRepository GetRepository(string repositoryName)
-    {
-      if (repositoryName == null)
-        throw new ArgumentNullException(nameof (repositoryName));
-      lock (this)
-      {
-        if (!(this.m_name2repositoryMap[(object) repositoryName] is ILoggerRepository name2repository))
-          throw new LogException("Repository [" + repositoryName + "] is NOT defined.");
-        return name2repository;
-      }
-    }
-
-    public ILoggerRepository CreateRepository(Assembly repositoryAssembly, Type repositoryType)
-    {
-      return this.CreateRepository(repositoryAssembly, repositoryType, "log4net-default-repository", true);
-    }
-
-    public ILoggerRepository CreateRepository(
-      Assembly repositoryAssembly,
-      Type repositoryType,
-      string repositoryName,
-      bool readAssemblyAttributes)
-    {
-      if (repositoryAssembly == null)
-        throw new ArgumentNullException(nameof (repositoryAssembly));
-      if (repositoryType == null)
-        repositoryType = this.m_defaultRepositoryType;
-      lock (this)
-      {
-        if (!(this.m_assembly2repositoryMap[(object) repositoryAssembly] is ILoggerRepository repository1))
-        {
-          LogLog.Debug("DefaultRepositorySelector: Creating repository for assembly [" + (object) repositoryAssembly + "]");
-          string repositoryName1 = repositoryName;
-          Type repositoryType1 = repositoryType;
-          if (readAssemblyAttributes)
-            this.GetInfoForAssembly(repositoryAssembly, ref repositoryName1, ref repositoryType1);
-          LogLog.Debug("DefaultRepositorySelector: Assembly [" + (object) repositoryAssembly + "] using repository [" + repositoryName1 + "] and repository type [" + (object) repositoryType1 + "]");
-          if (!(this.m_name2repositoryMap[(object) repositoryName1] is ILoggerRepository repository1))
-          {
-            repository1 = this.CreateRepository(repositoryName1, repositoryType1);
-            if (readAssemblyAttributes)
-            {
-              this.LoadAliases(repositoryAssembly, repository1);
-              this.LoadPlugins(repositoryAssembly, repository1);
-              this.ConfigureRepository(repositoryAssembly, repository1);
-            }
-          }
-          else
-          {
-            LogLog.Debug("DefaultRepositorySelector: repository [" + repositoryName1 + "] already exists, using repository type [" + repository1.GetType().FullName + "]");
-            if (readAssemblyAttributes)
-              this.LoadPlugins(repositoryAssembly, repository1);
-          }
-          this.m_assembly2repositoryMap[(object) repositoryAssembly] = (object) repository1;
-        }
-        return repository1;
-      }
-    }
-
-    public ILoggerRepository CreateRepository(string repositoryName, Type repositoryType)
-    {
-      if (repositoryName == null)
-        throw new ArgumentNullException(nameof (repositoryName));
-      if (repositoryType == null)
-        repositoryType = this.m_defaultRepositoryType;
-      lock (this)
-      {
-        if (this.m_name2repositoryMap[(object) repositoryName] is ILoggerRepository repository)
-          throw new LogException("Repository [" + repositoryName + "] is already defined. Repositories cannot be redefined.");
-        if (this.m_alias2repositoryMap[(object) repositoryName] is ILoggerRepository alias2repository)
-        {
-          if (alias2repository.GetType() == repositoryType)
-          {
-            LogLog.Debug("DefaultRepositorySelector: Aliasing repository [" + repositoryName + "] to existing repository [" + alias2repository.Name + "]");
-            repository = alias2repository;
-            this.m_name2repositoryMap[(object) repositoryName] = (object) repository;
-          }
-          else
-            LogLog.Error("DefaultRepositorySelector: Failed to alias repository [" + repositoryName + "] to existing repository [" + alias2repository.Name + "]. Requested repository type [" + repositoryType.FullName + "] is not compatible with existing type [" + alias2repository.GetType().FullName + "]");
-        }
-        if (repository == null)
-        {
-          LogLog.Debug("DefaultRepositorySelector: Creating repository [" + repositoryName + "] using type [" + (object) repositoryType + "]");
-          repository = (ILoggerRepository) Activator.CreateInstance(repositoryType);
-          repository.Name = repositoryName;
-          this.m_name2repositoryMap[(object) repositoryName] = (object) repository;
-          this.OnLoggerRepositoryCreatedEvent(repository);
-        }
-        return repository;
-      }
-    }
-
-    public bool ExistsRepository(string repositoryName)
-    {
-      lock (this)
-        return this.m_name2repositoryMap.ContainsKey((object) repositoryName);
-    }
-
-    public ILoggerRepository[] GetAllRepositories()
-    {
-      lock (this)
-      {
-        ICollection values = this.m_name2repositoryMap.Values;
-        ILoggerRepository[] allRepositories = new ILoggerRepository[values.Count];
-        values.CopyTo((Array) allRepositories, 0);
-        return allRepositories;
-      }
-    }
-
-    public void AliasRepository(string repositoryAlias, ILoggerRepository repositoryTarget)
-    {
-      if (repositoryAlias == null)
-        throw new ArgumentNullException(nameof (repositoryAlias));
-      if (repositoryTarget == null)
-        throw new ArgumentNullException(nameof (repositoryTarget));
-      lock (this)
-      {
-        if (this.m_alias2repositoryMap.Contains((object) repositoryAlias))
-        {
-          if (repositoryTarget != (ILoggerRepository) this.m_alias2repositoryMap[(object) repositoryAlias])
-            throw new InvalidOperationException("Repository [" + repositoryAlias + "] is already aliased to repository [" + ((ILoggerRepository) this.m_alias2repositoryMap[(object) repositoryAlias]).Name + "]. Aliases cannot be redefined.");
-        }
-        else if (this.m_name2repositoryMap.Contains((object) repositoryAlias))
-        {
-          if (repositoryTarget != (ILoggerRepository) this.m_name2repositoryMap[(object) repositoryAlias])
-            throw new InvalidOperationException("Repository [" + repositoryAlias + "] already exists and cannot be aliased to repository [" + repositoryTarget.Name + "].");
-        }
-        else
-          this.m_alias2repositoryMap[(object) repositoryAlias] = (object) repositoryTarget;
-      }
-    }
-
-    protected virtual void OnLoggerRepositoryCreatedEvent(ILoggerRepository repository)
-    {
-      LoggerRepositoryCreationEventHandler repositoryCreatedEvent = this.m_loggerRepositoryCreatedEvent;
-      if (repositoryCreatedEvent == null)
-        return;
-      repositoryCreatedEvent((object) this, new LoggerRepositoryCreationEventArgs(repository));
-    }
-
-    private void GetInfoForAssembly(
-      Assembly assembly,
-      ref string repositoryName,
-      ref Type repositoryType)
-    {
-      if (assembly == null)
-        throw new ArgumentNullException(nameof (assembly));
-      LogLog.Debug("DefaultRepositorySelector: Assembly [" + assembly.FullName + "] Loaded From [" + SystemInfo.AssemblyLocationInfo(assembly) + "]");
-      object[] customAttributes = (object[]) Attribute.GetCustomAttributes(assembly, typeof (RepositoryAttribute), false);
-      if (customAttributes == null || customAttributes.Length == 0)
-      {
-        LogLog.Debug("DefaultRepositorySelector: Assembly [" + (object) assembly + "] does not have a RepositoryAttribute specified.");
-      }
-      else
-      {
-        if (customAttributes.Length > 1)
-          LogLog.Error("DefaultRepositorySelector: Assembly [" + (object) assembly + "] has multiple log4net.Config.RepositoryAttribute assembly attributes. Only using first occurrence.");
-        if (!(customAttributes[0] is RepositoryAttribute repositoryAttribute))
-        {
-          LogLog.Error("DefaultRepositorySelector: Assembly [" + (object) assembly + "] has a RepositoryAttribute but it does not!.");
-        }
-        else
-        {
-          if (repositoryAttribute.Name != null)
-            repositoryName = repositoryAttribute.Name;
-          if (repositoryAttribute.RepositoryType == null)
-            return;
-          if (typeof (ILoggerRepository).IsAssignableFrom(repositoryAttribute.RepositoryType))
-            repositoryType = repositoryAttribute.RepositoryType;
-          else
-            LogLog.Error("DefaultRepositorySelector: Repository Type [" + (object) repositoryAttribute.RepositoryType + "] must implement the ILoggerRepository interface.");
-        }
-      }
-    }
-
-    private void ConfigureRepository(Assembly assembly, ILoggerRepository repository)
-    {
-      if (assembly == null)
-        throw new ArgumentNullException(nameof (assembly));
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      object[] customAttributes = (object[]) Attribute.GetCustomAttributes(assembly, typeof (ConfiguratorAttribute), false);
-      if (customAttributes == null || customAttributes.Length <= 0)
-        return;
-      Array.Sort((Array) customAttributes);
-      foreach (ConfiguratorAttribute configuratorAttribute in customAttributes)
-        configuratorAttribute.Configure(assembly, repository);
-    }
-
-    private void LoadPlugins(Assembly assembly, ILoggerRepository repository)
-    {
-      if (assembly == null)
-        throw new ArgumentNullException(nameof (assembly));
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      object[] customAttributes = (object[]) Attribute.GetCustomAttributes(assembly, typeof (PluginAttribute), false);
-      if (customAttributes == null || customAttributes.Length <= 0)
-        return;
-      foreach (IPluginFactory pluginFactory in customAttributes)
-      {
-        try
-        {
-          repository.PluginMap.Add(pluginFactory.CreatePlugin());
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("DefaultRepositorySelector: Failed to create plugin. Attribute [" + pluginFactory.ToString() + "]", ex);
-        }
-      }
-    }
-
-    private void LoadAliases(Assembly assembly, ILoggerRepository repository)
-    {
-      if (assembly == null)
-        throw new ArgumentNullException(nameof (assembly));
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      object[] customAttributes = (object[]) Attribute.GetCustomAttributes(assembly, typeof (AliasRepositoryAttribute), false);
-      if (customAttributes == null || customAttributes.Length <= 0)
-        return;
-      foreach (AliasRepositoryAttribute repositoryAttribute in customAttributes)
-      {
-        try
-        {
-          this.AliasRepository(repositoryAttribute.Name, repository);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("DefaultRepositorySelector: Failed to alias repository [" + repositoryAttribute.Name + "]", ex);
-        }
-      }
-    }
-
-    private event LoggerRepositoryCreationEventHandler m_loggerRepositoryCreatedEvent;
-  }
-}
diff --git a/MSHALTester/log4net/Core/ErrorCode.cs b/MSHALTester/log4net/Core/ErrorCode.cs
deleted file mode 100644
index 7b2e235..0000000
--- a/MSHALTester/log4net/Core/ErrorCode.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-#nullable disable
-namespace log4net.Core
-{
-  public enum ErrorCode
-  {
-    GenericFailure,
-    WriteFailure,
-    FlushFailure,
-    CloseFailure,
-    FileOpenFailure,
-    MissingLayout,
-    AddressParseFailure,
-  }
-}
diff --git a/MSHALTester/log4net/Core/FixFlags.cs b/MSHALTester/log4net/Core/FixFlags.cs
deleted file mode 100644
index 0e6e4e8..0000000
--- a/MSHALTester/log4net/Core/FixFlags.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Core
-{
-  [Flags]
-  public enum FixFlags
-  {
-    [Obsolete("Replaced by composite Properties")] Mdc = 1,
-    Ndc = 2,
-    Message = 4,
-    ThreadName = 8,
-    LocationInfo = 16, // 0x00000010
-    UserName = 32, // 0x00000020
-    Domain = 64, // 0x00000040
-    Identity = 128, // 0x00000080
-    Exception = 256, // 0x00000100
-    Properties = 512, // 0x00000200
-    None = 0,
-    All = 268435455, // 0x0FFFFFFF
-    Partial = Properties | Exception | Domain | ThreadName | Message, // 0x0000034C
-  }
-}
diff --git a/MSHALTester/log4net/Core/IAppenderAttachable.cs b/MSHALTester/log4net/Core/IAppenderAttachable.cs
deleted file mode 100644
index 8333839..0000000
--- a/MSHALTester/log4net/Core/IAppenderAttachable.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using log4net.Appender;
-
-#nullable disable
-namespace log4net.Core
-{
-  public interface IAppenderAttachable
-  {
-    void AddAppender(IAppender appender);
-
-    AppenderCollection Appenders { get; }
-
-    IAppender GetAppender(string name);
-
-    void RemoveAllAppenders();
-
-    IAppender RemoveAppender(IAppender appender);
-
-    IAppender RemoveAppender(string name);
-  }
-}
diff --git a/MSHALTester/log4net/Core/IErrorHandler.cs b/MSHALTester/log4net/Core/IErrorHandler.cs
deleted file mode 100644
index a847c9d..0000000
--- a/MSHALTester/log4net/Core/IErrorHandler.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Core
-{
-  public interface IErrorHandler
-  {
-    void Error(string message, Exception e, ErrorCode errorCode);
-
-    void Error(string message, Exception e);
-
-    void Error(string message);
-  }
-}
diff --git a/MSHALTester/log4net/Core/IFixingRequired.cs b/MSHALTester/log4net/Core/IFixingRequired.cs
deleted file mode 100644
index ec3b096..0000000
--- a/MSHALTester/log4net/Core/IFixingRequired.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace log4net.Core
-{
-  public interface IFixingRequired
-  {
-    object GetFixedObject();
-  }
-}
diff --git a/MSHALTester/log4net/Core/ILogger.cs b/MSHALTester/log4net/Core/ILogger.cs
deleted file mode 100644
index 4693a70..0000000
--- a/MSHALTester/log4net/Core/ILogger.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-using log4net.Repository;
-using System;
-
-#nullable disable
-namespace log4net.Core
-{
-  public interface ILogger
-  {
-    string Name { get; }
-
-    void Log(
-      Type callerStackBoundaryDeclaringType,
-      Level level,
-      object message,
-      Exception exception);
-
-    void Log(LoggingEvent logEvent);
-
-    bool IsEnabledFor(Level level);
-
-    ILoggerRepository Repository { get; }
-  }
-}
diff --git a/MSHALTester/log4net/Core/ILoggerWrapper.cs b/MSHALTester/log4net/Core/ILoggerWrapper.cs
deleted file mode 100644
index 3c7370f..0000000
--- a/MSHALTester/log4net/Core/ILoggerWrapper.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace log4net.Core
-{
-  public interface ILoggerWrapper
-  {
-    ILogger Logger { get; }
-  }
-}
diff --git a/MSHALTester/log4net/Core/IOptionHandler.cs b/MSHALTester/log4net/Core/IOptionHandler.cs
deleted file mode 100644
index d05eca8..0000000
--- a/MSHALTester/log4net/Core/IOptionHandler.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace log4net.Core
-{
-  public interface IOptionHandler
-  {
-    void ActivateOptions();
-  }
-}
diff --git a/MSHALTester/log4net/Core/IRepositorySelector.cs b/MSHALTester/log4net/Core/IRepositorySelector.cs
deleted file mode 100644
index 7b130d8..0000000
--- a/MSHALTester/log4net/Core/IRepositorySelector.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-using log4net.Repository;
-using System;
-using System.Reflection;
-
-#nullable disable
-namespace log4net.Core
-{
-  public interface IRepositorySelector
-  {
-    ILoggerRepository GetRepository(Assembly assembly);
-
-    ILoggerRepository GetRepository(string repositoryName);
-
-    ILoggerRepository CreateRepository(Assembly assembly, Type repositoryType);
-
-    ILoggerRepository CreateRepository(string repositoryName, Type repositoryType);
-
-    bool ExistsRepository(string repositoryName);
-
-    ILoggerRepository[] GetAllRepositories();
-
-    event LoggerRepositoryCreationEventHandler LoggerRepositoryCreatedEvent;
-  }
-}
diff --git a/MSHALTester/log4net/Core/ITriggeringEventEvaluator.cs b/MSHALTester/log4net/Core/ITriggeringEventEvaluator.cs
deleted file mode 100644
index 62a0c71..0000000
--- a/MSHALTester/log4net/Core/ITriggeringEventEvaluator.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace log4net.Core
-{
-  public interface ITriggeringEventEvaluator
-  {
-    bool IsTriggeringEvent(LoggingEvent loggingEvent);
-  }
-}
diff --git a/MSHALTester/log4net/Core/Level.cs b/MSHALTester/log4net/Core/Level.cs
deleted file mode 100644
index fb61542..0000000
--- a/MSHALTester/log4net/Core/Level.cs
+++ /dev/null
@@ -1,92 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Core
-{
-  [Serializable]
-  public sealed class Level : IComparable
-  {
-    public static readonly Level Off = new Level(int.MaxValue, "OFF");
-    public static readonly Level Emergency = new Level(120000, "EMERGENCY");
-    public static readonly Level Fatal = new Level(110000, "FATAL");
-    public static readonly Level Alert = new Level(100000, "ALERT");
-    public static readonly Level Critical = new Level(90000, "CRITICAL");
-    public static readonly Level Severe = new Level(80000, "SEVERE");
-    public static readonly Level Error = new Level(70000, "ERROR");
-    public static readonly Level Warn = new Level(60000, "WARN");
-    public static readonly Level Notice = new Level(50000, "NOTICE");
-    public static readonly Level Info = new Level(40000, "INFO");
-    public static readonly Level Debug = new Level(30000, "DEBUG");
-    public static readonly Level Fine = new Level(30000, "FINE");
-    public static readonly Level Trace = new Level(20000, "TRACE");
-    public static readonly Level Finer = new Level(20000, "FINER");
-    public static readonly Level Verbose = new Level(10000, "VERBOSE");
-    public static readonly Level Finest = new Level(10000, "FINEST");
-    public static readonly Level All = new Level(int.MinValue, "ALL");
-    private readonly int m_levelValue;
-    private readonly string m_levelName;
-    private readonly string m_levelDisplayName;
-
-    public Level(int level, string levelName, string displayName)
-    {
-      if (levelName == null)
-        throw new ArgumentNullException(nameof (levelName));
-      if (displayName == null)
-        throw new ArgumentNullException(nameof (displayName));
-      this.m_levelValue = level;
-      this.m_levelName = string.Intern(levelName);
-      this.m_levelDisplayName = displayName;
-    }
-
-    public Level(int level, string levelName)
-      : this(level, levelName, levelName)
-    {
-    }
-
-    public string Name => this.m_levelName;
-
-    public int Value => this.m_levelValue;
-
-    public string DisplayName => this.m_levelDisplayName;
-
-    public override string ToString() => this.m_levelName;
-
-    public override bool Equals(object o)
-    {
-      Level level = o as Level;
-      return level != (Level) null ? this.m_levelValue == level.m_levelValue : base.Equals(o);
-    }
-
-    public override int GetHashCode() => this.m_levelValue;
-
-    public int CompareTo(object r)
-    {
-      Level r1 = r as Level;
-      return r1 != (Level) null ? Level.Compare(this, r1) : throw new ArgumentException("Parameter: r, Value: [" + r + "] is not an instance of Level");
-    }
-
-    public static bool operator >(Level l, Level r) => l.m_levelValue > r.m_levelValue;
-
-    public static bool operator <(Level l, Level r) => l.m_levelValue < r.m_levelValue;
-
-    public static bool operator >=(Level l, Level r) => l.m_levelValue >= r.m_levelValue;
-
-    public static bool operator <=(Level l, Level r) => l.m_levelValue <= r.m_levelValue;
-
-    public static bool operator ==(Level l, Level r)
-    {
-      return (object) l != null && (object) r != null ? l.m_levelValue == r.m_levelValue : (object) l == (object) r;
-    }
-
-    public static bool operator !=(Level l, Level r) => !(l == r);
-
-    public static int Compare(Level l, Level r)
-    {
-      if ((object) l == (object) r || l == (Level) null && r == (Level) null)
-        return 0;
-      if (l == (Level) null)
-        return -1;
-      return r == (Level) null ? 1 : l.m_levelValue - r.m_levelValue;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/LevelCollection.cs b/MSHALTester/log4net/Core/LevelCollection.cs
deleted file mode 100644
index c8202d6..0000000
--- a/MSHALTester/log4net/Core/LevelCollection.cs
+++ /dev/null
@@ -1,384 +0,0 @@
-using log4net.Util;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Core
-{
-  public class LevelCollection : IList, ICollection, IEnumerable, ICloneable
-  {
-    private const int DEFAULT_CAPACITY = 16;
-    private Level[] m_array;
-    private int m_count = 0;
-    private int m_version = 0;
-
-    public static LevelCollection ReadOnly(LevelCollection list)
-    {
-      return list != null ? (LevelCollection) new LevelCollection.ReadOnlyLevelCollection(list) : throw new ArgumentNullException(nameof (list));
-    }
-
-    public LevelCollection() => this.m_array = new Level[16];
-
-    public LevelCollection(int capacity) => this.m_array = new Level[capacity];
-
-    public LevelCollection(LevelCollection c)
-    {
-      this.m_array = new Level[c.Count];
-      this.AddRange(c);
-    }
-
-    public LevelCollection(Level[] a)
-    {
-      this.m_array = new Level[a.Length];
-      this.AddRange(a);
-    }
-
-    public LevelCollection(ICollection col)
-    {
-      this.m_array = new Level[col.Count];
-      this.AddRange(col);
-    }
-
-    protected internal LevelCollection(LevelCollection.Tag tag) => this.m_array = (Level[]) null;
-
-    public virtual int Count => this.m_count;
-
-    public virtual void CopyTo(Level[] array) => this.CopyTo(array, 0);
-
-    public virtual void CopyTo(Level[] array, int start)
-    {
-      if (this.m_count > array.GetUpperBound(0) + 1 - start)
-        throw new ArgumentException("Destination array was not long enough.");
-      Array.Copy((Array) this.m_array, 0, (Array) array, start, this.m_count);
-    }
-
-    public virtual bool IsSynchronized => this.m_array.IsSynchronized;
-
-    public virtual object SyncRoot => this.m_array.SyncRoot;
-
-    public virtual Level this[int index]
-    {
-      get
-      {
-        this.ValidateIndex(index);
-        return this.m_array[index];
-      }
-      set
-      {
-        this.ValidateIndex(index);
-        ++this.m_version;
-        this.m_array[index] = value;
-      }
-    }
-
-    public virtual int Add(Level item)
-    {
-      if (this.m_count == this.m_array.Length)
-        this.EnsureCapacity(this.m_count + 1);
-      this.m_array[this.m_count] = item;
-      ++this.m_version;
-      return this.m_count++;
-    }
-
-    public virtual void Clear()
-    {
-      ++this.m_version;
-      this.m_array = new Level[16];
-      this.m_count = 0;
-    }
-
-    public virtual object Clone()
-    {
-      LevelCollection levelCollection = new LevelCollection(this.m_count);
-      Array.Copy((Array) this.m_array, 0, (Array) levelCollection.m_array, 0, this.m_count);
-      levelCollection.m_count = this.m_count;
-      levelCollection.m_version = this.m_version;
-      return (object) levelCollection;
-    }
-
-    public virtual bool Contains(Level item)
-    {
-      for (int index = 0; index != this.m_count; ++index)
-      {
-        if (this.m_array[index].Equals((object) item))
-          return true;
-      }
-      return false;
-    }
-
-    public virtual int IndexOf(Level item)
-    {
-      for (int index = 0; index != this.m_count; ++index)
-      {
-        if (this.m_array[index].Equals((object) item))
-          return index;
-      }
-      return -1;
-    }
-
-    public virtual void Insert(int index, Level item)
-    {
-      this.ValidateIndex(index, true);
-      if (this.m_count == this.m_array.Length)
-        this.EnsureCapacity(this.m_count + 1);
-      if (index < this.m_count)
-        Array.Copy((Array) this.m_array, index, (Array) this.m_array, index + 1, this.m_count - index);
-      this.m_array[index] = item;
-      ++this.m_count;
-      ++this.m_version;
-    }
-
-    public virtual void Remove(Level item)
-    {
-      int index = this.IndexOf(item);
-      if (index < 0)
-        throw new ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
-      ++this.m_version;
-      this.RemoveAt(index);
-    }
-
-    public virtual void RemoveAt(int index)
-    {
-      this.ValidateIndex(index);
-      --this.m_count;
-      if (index < this.m_count)
-        Array.Copy((Array) this.m_array, index + 1, (Array) this.m_array, index, this.m_count - index);
-      Array.Copy((Array) new Level[1], 0, (Array) this.m_array, this.m_count, 1);
-      ++this.m_version;
-    }
-
-    public virtual bool IsFixedSize => false;
-
-    public virtual bool IsReadOnly => false;
-
-    public virtual LevelCollection.ILevelCollectionEnumerator GetEnumerator()
-    {
-      return (LevelCollection.ILevelCollectionEnumerator) new LevelCollection.Enumerator(this);
-    }
-
-    public virtual int Capacity
-    {
-      get => this.m_array.Length;
-      set
-      {
-        if (value < this.m_count)
-          value = this.m_count;
-        if (value == this.m_array.Length)
-          return;
-        if (value > 0)
-        {
-          Level[] destinationArray = new Level[value];
-          Array.Copy((Array) this.m_array, 0, (Array) destinationArray, 0, this.m_count);
-          this.m_array = destinationArray;
-        }
-        else
-          this.m_array = new Level[16];
-      }
-    }
-
-    public virtual int AddRange(LevelCollection x)
-    {
-      if (this.m_count + x.Count >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + x.Count);
-      Array.Copy((Array) x.m_array, 0, (Array) this.m_array, this.m_count, x.Count);
-      this.m_count += x.Count;
-      ++this.m_version;
-      return this.m_count;
-    }
-
-    public virtual int AddRange(Level[] x)
-    {
-      if (this.m_count + x.Length >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + x.Length);
-      Array.Copy((Array) x, 0, (Array) this.m_array, this.m_count, x.Length);
-      this.m_count += x.Length;
-      ++this.m_version;
-      return this.m_count;
-    }
-
-    public virtual int AddRange(ICollection col)
-    {
-      if (this.m_count + col.Count >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + col.Count);
-      foreach (Level level in (IEnumerable) col)
-        this.Add(level);
-      return this.m_count;
-    }
-
-    public virtual void TrimToSize() => this.Capacity = this.m_count;
-
-    private void ValidateIndex(int i) => this.ValidateIndex(i, false);
-
-    private void ValidateIndex(int i, bool allowEqualEnd)
-    {
-      int num = allowEqualEnd ? this.m_count : this.m_count - 1;
-      if (i < 0 || i > num)
-        throw SystemInfo.CreateArgumentOutOfRangeException(nameof (i), (object) i, "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object) i + "] Specified argument was out of the range of valid values.");
-    }
-
-    private void EnsureCapacity(int min)
-    {
-      int num = this.m_array.Length == 0 ? 16 : this.m_array.Length * 2;
-      if (num < min)
-        num = min;
-      this.Capacity = num;
-    }
-
-    void ICollection.CopyTo(Array array, int start)
-    {
-      Array.Copy((Array) this.m_array, 0, array, start, this.m_count);
-    }
-
-    object IList.this[int i]
-    {
-      get => (object) this[i];
-      set => this[i] = (Level) value;
-    }
-
-    int IList.Add(object x) => this.Add((Level) x);
-
-    bool IList.Contains(object x) => this.Contains((Level) x);
-
-    int IList.IndexOf(object x) => this.IndexOf((Level) x);
-
-    void IList.Insert(int pos, object x) => this.Insert(pos, (Level) x);
-
-    void IList.Remove(object x) => this.Remove((Level) x);
-
-    void IList.RemoveAt(int pos) => this.RemoveAt(pos);
-
-    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-
-    public interface ILevelCollectionEnumerator
-    {
-      Level Current { get; }
-
-      bool MoveNext();
-
-      void Reset();
-    }
-
-    protected internal enum Tag
-    {
-      Default,
-    }
-
-    private sealed class Enumerator : IEnumerator, LevelCollection.ILevelCollectionEnumerator
-    {
-      private readonly LevelCollection m_collection;
-      private int m_index;
-      private int m_version;
-
-      internal Enumerator(LevelCollection tc)
-      {
-        this.m_collection = tc;
-        this.m_index = -1;
-        this.m_version = tc.m_version;
-      }
-
-      public Level Current => this.m_collection[this.m_index];
-
-      public bool MoveNext()
-      {
-        if (this.m_version != this.m_collection.m_version)
-          throw new InvalidOperationException("Collection was modified; enumeration operation may not execute.");
-        ++this.m_index;
-        return this.m_index < this.m_collection.Count;
-      }
-
-      public void Reset() => this.m_index = -1;
-
-      object IEnumerator.Current => (object) this.Current;
-    }
-
-    private sealed class ReadOnlyLevelCollection : LevelCollection
-    {
-      private readonly LevelCollection m_collection;
-
-      internal ReadOnlyLevelCollection(LevelCollection list)
-        : base(LevelCollection.Tag.Default)
-      {
-        this.m_collection = list;
-      }
-
-      public override void CopyTo(Level[] array) => this.m_collection.CopyTo(array);
-
-      public override void CopyTo(Level[] array, int start)
-      {
-        this.m_collection.CopyTo(array, start);
-      }
-
-      public override int Count => this.m_collection.Count;
-
-      public override bool IsSynchronized => this.m_collection.IsSynchronized;
-
-      public override object SyncRoot => this.m_collection.SyncRoot;
-
-      public override Level this[int i]
-      {
-        get => this.m_collection[i];
-        set
-        {
-          throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-        }
-      }
-
-      public override int Add(Level x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void Clear()
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override bool Contains(Level x) => this.m_collection.Contains(x);
-
-      public override int IndexOf(Level x) => this.m_collection.IndexOf(x);
-
-      public override void Insert(int pos, Level x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void Remove(Level x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void RemoveAt(int pos)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override bool IsFixedSize => true;
-
-      public override bool IsReadOnly => true;
-
-      public override LevelCollection.ILevelCollectionEnumerator GetEnumerator()
-      {
-        return this.m_collection.GetEnumerator();
-      }
-
-      public override int Capacity
-      {
-        get => this.m_collection.Capacity;
-        set
-        {
-          throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-        }
-      }
-
-      public override int AddRange(LevelCollection x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override int AddRange(Level[] x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/LevelEvaluator.cs b/MSHALTester/log4net/Core/LevelEvaluator.cs
deleted file mode 100644
index a79d156..0000000
--- a/MSHALTester/log4net/Core/LevelEvaluator.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Core
-{
-  public class LevelEvaluator : ITriggeringEventEvaluator
-  {
-    private Level m_threshold;
-
-    public LevelEvaluator()
-      : this(Level.Off)
-    {
-    }
-
-    public LevelEvaluator(Level threshold)
-    {
-      this.m_threshold = !(threshold == (Level) null) ? threshold : throw new ArgumentNullException(nameof (threshold));
-    }
-
-    public Level Threshold
-    {
-      get => this.m_threshold;
-      set => this.m_threshold = value;
-    }
-
-    public bool IsTriggeringEvent(LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      return loggingEvent.Level >= this.m_threshold;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/LevelMap.cs b/MSHALTester/log4net/Core/LevelMap.cs
deleted file mode 100644
index de5c0e4..0000000
--- a/MSHALTester/log4net/Core/LevelMap.cs
+++ /dev/null
@@ -1,74 +0,0 @@
-using log4net.Util;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Core
-{
-  public sealed class LevelMap
-  {
-    private Hashtable m_mapName2Level = new Hashtable((IHashCodeProvider) CaseInsensitiveHashCodeProvider.Default, (IComparer) CaseInsensitiveComparer.Default);
-
-    public void Clear() => this.m_mapName2Level.Clear();
-
-    public Level this[string name]
-    {
-      get
-      {
-        if (name == null)
-          throw new ArgumentNullException(nameof (name));
-        lock (this)
-          return (Level) this.m_mapName2Level[(object) name];
-      }
-    }
-
-    public void Add(string name, int value) => this.Add(name, value, (string) null);
-
-    public void Add(string name, int value, string displayName)
-    {
-      switch (name)
-      {
-        case null:
-          throw new ArgumentNullException(nameof (name));
-        case "":
-          throw SystemInfo.CreateArgumentOutOfRangeException(nameof (name), (object) name, "Parameter: name, Value: [" + name + "] out of range. Level name must not be empty");
-        default:
-          if (displayName == null || displayName.Length == 0)
-            displayName = name;
-          this.Add(new Level(value, name, displayName));
-          break;
-      }
-    }
-
-    public void Add(Level level)
-    {
-      if (level == (Level) null)
-        throw new ArgumentNullException(nameof (level));
-      lock (this)
-        this.m_mapName2Level[(object) level.Name] = (object) level;
-    }
-
-    public LevelCollection AllLevels
-    {
-      get
-      {
-        lock (this)
-          return new LevelCollection(this.m_mapName2Level.Values);
-      }
-    }
-
-    public Level LookupWithDefault(Level defaultLevel)
-    {
-      if (defaultLevel == (Level) null)
-        throw new ArgumentNullException(nameof (defaultLevel));
-      lock (this)
-      {
-        Level level = (Level) this.m_mapName2Level[(object) defaultLevel.Name];
-        if (!(level == (Level) null))
-          return level;
-        this.m_mapName2Level[(object) defaultLevel.Name] = (object) defaultLevel;
-        return defaultLevel;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/LocationInfo.cs b/MSHALTester/log4net/Core/LocationInfo.cs
deleted file mode 100644
index 40cb329..0000000
--- a/MSHALTester/log4net/Core/LocationInfo.cs
+++ /dev/null
@@ -1,87 +0,0 @@
-using log4net.Util;
-using System;
-using System.Diagnostics;
-using System.Globalization;
-using System.Reflection;
-using System.Security;
-
-#nullable disable
-namespace log4net.Core
-{
-  [Serializable]
-  public class LocationInfo
-  {
-    private const string NA = "?";
-    private readonly string m_className;
-    private readonly string m_fileName;
-    private readonly string m_lineNumber;
-    private readonly string m_methodName;
-    private readonly string m_fullInfo;
-
-    public LocationInfo(Type callerStackBoundaryDeclaringType)
-    {
-      this.m_className = "?";
-      this.m_fileName = "?";
-      this.m_lineNumber = "?";
-      this.m_methodName = "?";
-      this.m_fullInfo = "?";
-      if (callerStackBoundaryDeclaringType == null)
-        return;
-      try
-      {
-        StackTrace stackTrace = new StackTrace(true);
-        int index;
-        for (index = 0; index < stackTrace.FrameCount; ++index)
-        {
-          System.Diagnostics.StackFrame frame = stackTrace.GetFrame(index);
-          if (frame != null && frame.GetMethod().DeclaringType == callerStackBoundaryDeclaringType)
-            break;
-        }
-        for (; index < stackTrace.FrameCount; ++index)
-        {
-          System.Diagnostics.StackFrame frame = stackTrace.GetFrame(index);
-          if (frame != null && frame.GetMethod().DeclaringType != callerStackBoundaryDeclaringType)
-            break;
-        }
-        if (index >= stackTrace.FrameCount)
-          return;
-        System.Diagnostics.StackFrame frame1 = stackTrace.GetFrame(index);
-        if (frame1 == null)
-          return;
-        MethodBase method = frame1.GetMethod();
-        if (method != null)
-        {
-          this.m_methodName = method.Name;
-          if (method.DeclaringType != null)
-            this.m_className = method.DeclaringType.FullName;
-        }
-        this.m_fileName = frame1.GetFileName();
-        this.m_lineNumber = frame1.GetFileLineNumber().ToString((IFormatProvider) NumberFormatInfo.InvariantInfo);
-        this.m_fullInfo = this.m_className + (object) '.' + this.m_methodName + (object) '(' + this.m_fileName + (object) ':' + this.m_lineNumber + (object) ')';
-      }
-      catch (SecurityException ex)
-      {
-        LogLog.Debug("LocationInfo: Security exception while trying to get caller stack frame. Error Ignored. Location Information Not Available.");
-      }
-    }
-
-    public LocationInfo(string className, string methodName, string fileName, string lineNumber)
-    {
-      this.m_className = className;
-      this.m_fileName = fileName;
-      this.m_lineNumber = lineNumber;
-      this.m_methodName = methodName;
-      this.m_fullInfo = this.m_className + (object) '.' + this.m_methodName + (object) '(' + this.m_fileName + (object) ':' + this.m_lineNumber + (object) ')';
-    }
-
-    public string ClassName => this.m_className;
-
-    public string FileName => this.m_fileName;
-
-    public string LineNumber => this.m_lineNumber;
-
-    public string MethodName => this.m_methodName;
-
-    public string FullInfo => this.m_fullInfo;
-  }
-}
diff --git a/MSHALTester/log4net/Core/LogException.cs b/MSHALTester/log4net/Core/LogException.cs
deleted file mode 100644
index 189ac92..0000000
--- a/MSHALTester/log4net/Core/LogException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace log4net.Core
-{
-  [Serializable]
-  public class LogException : ApplicationException
-  {
-    public LogException()
-    {
-    }
-
-    public LogException(string message)
-      : base(message)
-    {
-    }
-
-    public LogException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-
-    protected LogException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/LogImpl.cs b/MSHALTester/log4net/Core/LogImpl.cs
deleted file mode 100644
index d78b15a..0000000
--- a/MSHALTester/log4net/Core/LogImpl.cs
+++ /dev/null
@@ -1,151 +0,0 @@
-using log4net.Repository;
-using System;
-using System.Globalization;
-
-#nullable disable
-namespace log4net.Core
-{
-  public class LogImpl : LoggerWrapperImpl, ILog, ILoggerWrapper
-  {
-    private static readonly Type ThisDeclaringType = typeof (LogImpl);
-    private Level m_levelDebug;
-    private Level m_levelInfo;
-    private Level m_levelWarn;
-    private Level m_levelError;
-    private Level m_levelFatal;
-
-    public LogImpl(ILogger logger)
-      : base(logger)
-    {
-      logger.Repository.ConfigurationChanged += new LoggerRepositoryConfigurationChangedEventHandler(this.LoggerRepositoryConfigurationChanged);
-      this.ReloadLevels(logger.Repository);
-    }
-
-    protected virtual void ReloadLevels(ILoggerRepository repository)
-    {
-      LevelMap levelMap = repository.LevelMap;
-      this.m_levelDebug = levelMap.LookupWithDefault(Level.Debug);
-      this.m_levelInfo = levelMap.LookupWithDefault(Level.Info);
-      this.m_levelWarn = levelMap.LookupWithDefault(Level.Warn);
-      this.m_levelError = levelMap.LookupWithDefault(Level.Error);
-      this.m_levelFatal = levelMap.LookupWithDefault(Level.Fatal);
-    }
-
-    public virtual void Debug(object message)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelDebug, message, (Exception) null);
-    }
-
-    public virtual void Debug(object message, Exception exception)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelDebug, message, exception);
-    }
-
-    public virtual void DebugFormat(string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelDebug, (object) string.Format((IFormatProvider) CultureInfo.InvariantCulture, format, args), (Exception) null);
-    }
-
-    public virtual void DebugFormat(IFormatProvider provider, string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelDebug, (object) string.Format(provider, format, args), (Exception) null);
-    }
-
-    public virtual void Info(object message)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelInfo, message, (Exception) null);
-    }
-
-    public virtual void Info(object message, Exception exception)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelInfo, message, exception);
-    }
-
-    public virtual void InfoFormat(string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelInfo, (object) string.Format((IFormatProvider) CultureInfo.InvariantCulture, format, args), (Exception) null);
-    }
-
-    public virtual void InfoFormat(IFormatProvider provider, string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelInfo, (object) string.Format(provider, format, args), (Exception) null);
-    }
-
-    public virtual void Warn(object message)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelWarn, message, (Exception) null);
-    }
-
-    public virtual void Warn(object message, Exception exception)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelWarn, message, exception);
-    }
-
-    public virtual void WarnFormat(string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelWarn, (object) string.Format((IFormatProvider) CultureInfo.InvariantCulture, format, args), (Exception) null);
-    }
-
-    public virtual void WarnFormat(IFormatProvider provider, string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelWarn, (object) string.Format(provider, format, args), (Exception) null);
-    }
-
-    public virtual void Error(object message)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelError, message, (Exception) null);
-    }
-
-    public virtual void Error(object message, Exception exception)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelError, message, exception);
-    }
-
-    public virtual void ErrorFormat(string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelError, (object) string.Format((IFormatProvider) CultureInfo.InvariantCulture, format, args), (Exception) null);
-    }
-
-    public virtual void ErrorFormat(IFormatProvider provider, string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelError, (object) string.Format(provider, format, args), (Exception) null);
-    }
-
-    public virtual void Fatal(object message)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelFatal, message, (Exception) null);
-    }
-
-    public virtual void Fatal(object message, Exception exception)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelFatal, message, exception);
-    }
-
-    public virtual void FatalFormat(string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelFatal, (object) string.Format((IFormatProvider) CultureInfo.InvariantCulture, format, args), (Exception) null);
-    }
-
-    public virtual void FatalFormat(IFormatProvider provider, string format, params object[] args)
-    {
-      this.Logger.Log(LogImpl.ThisDeclaringType, this.m_levelFatal, (object) string.Format(provider, format, args), (Exception) null);
-    }
-
-    public virtual bool IsDebugEnabled => this.Logger.IsEnabledFor(this.m_levelDebug);
-
-    public virtual bool IsInfoEnabled => this.Logger.IsEnabledFor(this.m_levelInfo);
-
-    public virtual bool IsWarnEnabled => this.Logger.IsEnabledFor(this.m_levelWarn);
-
-    public virtual bool IsErrorEnabled => this.Logger.IsEnabledFor(this.m_levelError);
-
-    public virtual bool IsFatalEnabled => this.Logger.IsEnabledFor(this.m_levelFatal);
-
-    private void LoggerRepositoryConfigurationChanged(object sender, EventArgs e)
-    {
-      if (!(sender is ILoggerRepository repository))
-        return;
-      this.ReloadLevels(repository);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/LoggerManager.cs b/MSHALTester/log4net/Core/LoggerManager.cs
deleted file mode 100644
index 7b6b5a2..0000000
--- a/MSHALTester/log4net/Core/LoggerManager.cs
+++ /dev/null
@@ -1,229 +0,0 @@
-using log4net.Repository;
-using log4net.Util;
-using System;
-using System.Reflection;
-using System.Security;
-using System.Text;
-
-#nullable disable
-namespace log4net.Core
-{
-  public sealed class LoggerManager
-  {
-    private static IRepositorySelector s_repositorySelector;
-
-    private LoggerManager()
-    {
-    }
-
-    static LoggerManager()
-    {
-      try
-      {
-        LoggerManager.RegisterAppDomainEvents();
-      }
-      catch (SecurityException ex)
-      {
-        LogLog.Debug("LoggerMAnager: Security Exception (ControlAppDomain LinkDemand) while trying to register Shutdown handler with the AppDomain. LoggerManager.Shutdown() will not be called automatically when the AppDomain exits. It must be called programmatically.");
-      }
-      LogLog.Debug(LoggerManager.GetVersionInfo());
-      LoggerManager.s_repositorySelector = (IRepositorySelector) new DefaultRepositorySelector(typeof (log4net.Repository.Hierarchy.Hierarchy));
-    }
-
-    private static void RegisterAppDomainEvents()
-    {
-      AppDomain.CurrentDomain.ProcessExit += new EventHandler(LoggerManager.OnProcessExit);
-      AppDomain.CurrentDomain.DomainUnload += new EventHandler(LoggerManager.OnDomainUnload);
-    }
-
-    [Obsolete("Use GetRepository instead of GetLoggerRepository")]
-    public static ILoggerRepository GetLoggerRepository(string repository)
-    {
-      return LoggerManager.GetRepository(repository);
-    }
-
-    [Obsolete("Use GetRepository instead of GetLoggerRepository")]
-    public static ILoggerRepository GetLoggerRepository(Assembly repositoryAssembly)
-    {
-      return LoggerManager.GetRepository(repositoryAssembly);
-    }
-
-    public static ILoggerRepository GetRepository(string repository)
-    {
-      return repository != null ? LoggerManager.RepositorySelector.GetRepository(repository) : throw new ArgumentNullException(nameof (repository));
-    }
-
-    public static ILoggerRepository GetRepository(Assembly repositoryAssembly)
-    {
-      return repositoryAssembly != null ? LoggerManager.RepositorySelector.GetRepository(repositoryAssembly) : throw new ArgumentNullException(nameof (repositoryAssembly));
-    }
-
-    public static ILogger Exists(string repository, string name)
-    {
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      return LoggerManager.RepositorySelector.GetRepository(repository).Exists(name);
-    }
-
-    public static ILogger Exists(Assembly repositoryAssembly, string name)
-    {
-      if (repositoryAssembly == null)
-        throw new ArgumentNullException(nameof (repositoryAssembly));
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      return LoggerManager.RepositorySelector.GetRepository(repositoryAssembly).Exists(name);
-    }
-
-    public static ILogger[] GetCurrentLoggers(string repository)
-    {
-      return repository != null ? LoggerManager.RepositorySelector.GetRepository(repository).GetCurrentLoggers() : throw new ArgumentNullException(nameof (repository));
-    }
-
-    public static ILogger[] GetCurrentLoggers(Assembly repositoryAssembly)
-    {
-      return repositoryAssembly != null ? LoggerManager.RepositorySelector.GetRepository(repositoryAssembly).GetCurrentLoggers() : throw new ArgumentNullException(nameof (repositoryAssembly));
-    }
-
-    public static ILogger GetLogger(string repository, string name)
-    {
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      return LoggerManager.RepositorySelector.GetRepository(repository).GetLogger(name);
-    }
-
-    public static ILogger GetLogger(Assembly repositoryAssembly, string name)
-    {
-      if (repositoryAssembly == null)
-        throw new ArgumentNullException(nameof (repositoryAssembly));
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      return LoggerManager.RepositorySelector.GetRepository(repositoryAssembly).GetLogger(name);
-    }
-
-    public static ILogger GetLogger(string repository, Type type)
-    {
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      if (type == null)
-        throw new ArgumentNullException(nameof (type));
-      return LoggerManager.RepositorySelector.GetRepository(repository).GetLogger(type.FullName);
-    }
-
-    public static ILogger GetLogger(Assembly repositoryAssembly, Type type)
-    {
-      if (repositoryAssembly == null)
-        throw new ArgumentNullException(nameof (repositoryAssembly));
-      if (type == null)
-        throw new ArgumentNullException(nameof (type));
-      return LoggerManager.RepositorySelector.GetRepository(repositoryAssembly).GetLogger(type.FullName);
-    }
-
-    public static void Shutdown()
-    {
-      foreach (ILoggerRepository allRepository in LoggerManager.GetAllRepositories())
-        allRepository.Shutdown();
-    }
-
-    public static void ShutdownRepository(string repository)
-    {
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      LoggerManager.RepositorySelector.GetRepository(repository).Shutdown();
-    }
-
-    public static void ShutdownRepository(Assembly repositoryAssembly)
-    {
-      if (repositoryAssembly == null)
-        throw new ArgumentNullException(nameof (repositoryAssembly));
-      LoggerManager.RepositorySelector.GetRepository(repositoryAssembly).Shutdown();
-    }
-
-    public static void ResetConfiguration(string repository)
-    {
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      LoggerManager.RepositorySelector.GetRepository(repository).ResetConfiguration();
-    }
-
-    public static void ResetConfiguration(Assembly repositoryAssembly)
-    {
-      if (repositoryAssembly == null)
-        throw new ArgumentNullException(nameof (repositoryAssembly));
-      LoggerManager.RepositorySelector.GetRepository(repositoryAssembly).ResetConfiguration();
-    }
-
-    [Obsolete("Use CreateRepository instead of CreateDomain")]
-    public static ILoggerRepository CreateDomain(string repository)
-    {
-      return LoggerManager.CreateRepository(repository);
-    }
-
-    public static ILoggerRepository CreateRepository(string repository)
-    {
-      return repository != null ? LoggerManager.RepositorySelector.CreateRepository(repository, (Type) null) : throw new ArgumentNullException(nameof (repository));
-    }
-
-    [Obsolete("Use CreateRepository instead of CreateDomain")]
-    public static ILoggerRepository CreateDomain(string repository, Type repositoryType)
-    {
-      return LoggerManager.CreateRepository(repository, repositoryType);
-    }
-
-    public static ILoggerRepository CreateRepository(string repository, Type repositoryType)
-    {
-      if (repository == null)
-        throw new ArgumentNullException(nameof (repository));
-      if (repositoryType == null)
-        throw new ArgumentNullException(nameof (repositoryType));
-      return LoggerManager.RepositorySelector.CreateRepository(repository, repositoryType);
-    }
-
-    [Obsolete("Use CreateRepository instead of CreateDomain")]
-    public static ILoggerRepository CreateDomain(Assembly repositoryAssembly, Type repositoryType)
-    {
-      return LoggerManager.CreateRepository(repositoryAssembly, repositoryType);
-    }
-
-    public static ILoggerRepository CreateRepository(
-      Assembly repositoryAssembly,
-      Type repositoryType)
-    {
-      if (repositoryAssembly == null)
-        throw new ArgumentNullException(nameof (repositoryAssembly));
-      if (repositoryType == null)
-        throw new ArgumentNullException(nameof (repositoryType));
-      return LoggerManager.RepositorySelector.CreateRepository(repositoryAssembly, repositoryType);
-    }
-
-    public static ILoggerRepository[] GetAllRepositories()
-    {
-      return LoggerManager.RepositorySelector.GetAllRepositories();
-    }
-
-    public static IRepositorySelector RepositorySelector
-    {
-      get => LoggerManager.s_repositorySelector;
-      set => LoggerManager.s_repositorySelector = value;
-    }
-
-    private static string GetVersionInfo()
-    {
-      StringBuilder stringBuilder = new StringBuilder();
-      Assembly executingAssembly = Assembly.GetExecutingAssembly();
-      stringBuilder.Append("log4net assembly [").Append(executingAssembly.FullName).Append("]. ");
-      stringBuilder.Append("Loaded from [").Append(SystemInfo.AssemblyLocationInfo(executingAssembly)).Append("]. ");
-      stringBuilder.Append("(.NET Runtime [").Append(Environment.Version.ToString()).Append("]");
-      stringBuilder.Append(" on ").Append(Environment.OSVersion.ToString());
-      stringBuilder.Append(")");
-      return stringBuilder.ToString();
-    }
-
-    private static void OnDomainUnload(object sender, EventArgs e) => LoggerManager.Shutdown();
-
-    private static void OnProcessExit(object sender, EventArgs e) => LoggerManager.Shutdown();
-  }
-}
diff --git a/MSHALTester/log4net/Core/LoggerRepositoryCreationEventArgs.cs b/MSHALTester/log4net/Core/LoggerRepositoryCreationEventArgs.cs
deleted file mode 100644
index 8e21898..0000000
--- a/MSHALTester/log4net/Core/LoggerRepositoryCreationEventArgs.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-using log4net.Repository;
-using System;
-
-#nullable disable
-namespace log4net.Core
-{
-  public class LoggerRepositoryCreationEventArgs : EventArgs
-  {
-    private ILoggerRepository m_repository;
-
-    public LoggerRepositoryCreationEventArgs(ILoggerRepository repository)
-    {
-      this.m_repository = repository;
-    }
-
-    public ILoggerRepository LoggerRepository => this.m_repository;
-  }
-}
diff --git a/MSHALTester/log4net/Core/LoggerRepositoryCreationEventHandler.cs b/MSHALTester/log4net/Core/LoggerRepositoryCreationEventHandler.cs
deleted file mode 100644
index 7bd9aa8..0000000
--- a/MSHALTester/log4net/Core/LoggerRepositoryCreationEventHandler.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-#nullable disable
-namespace log4net.Core
-{
-  public delegate void LoggerRepositoryCreationEventHandler(
-    object sender,
-    LoggerRepositoryCreationEventArgs e);
-}
diff --git a/MSHALTester/log4net/Core/LoggerWrapperImpl.cs b/MSHALTester/log4net/Core/LoggerWrapperImpl.cs
deleted file mode 100644
index cfd9830..0000000
--- a/MSHALTester/log4net/Core/LoggerWrapperImpl.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-#nullable disable
-namespace log4net.Core
-{
-  public abstract class LoggerWrapperImpl : ILoggerWrapper
-  {
-    private readonly ILogger m_logger;
-
-    protected LoggerWrapperImpl(ILogger logger) => this.m_logger = logger;
-
-    public virtual ILogger Logger => this.m_logger;
-  }
-}
diff --git a/MSHALTester/log4net/Core/LoggingEvent.cs b/MSHALTester/log4net/Core/LoggingEvent.cs
deleted file mode 100644
index a7208fc..0000000
--- a/MSHALTester/log4net/Core/LoggingEvent.cs
+++ /dev/null
@@ -1,382 +0,0 @@
-using log4net.Repository;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Runtime.Serialization;
-using System.Security;
-using System.Security.Permissions;
-using System.Security.Principal;
-using System.Threading;
-
-#nullable disable
-namespace log4net.Core
-{
-  [Serializable]
-  public class LoggingEvent : ISerializable
-  {
-    public const string HostNameProperty = "log4net:HostName";
-    public const string IdentityProperty = "log4net:Identity";
-    public const string UserNameProperty = "log4net:UserName";
-    private LoggingEventData m_data;
-    private CompositeProperties m_compositeProperties;
-    private PropertiesDictionary m_eventProperties;
-    private readonly Type m_callerStackBoundaryDeclaringType;
-    private readonly object m_message;
-    private readonly Exception m_thrownException;
-    private ILoggerRepository m_repository = (ILoggerRepository) null;
-    private FixFlags m_fixFlags = FixFlags.None;
-
-    public LoggingEvent(
-      Type callerStackBoundaryDeclaringType,
-      ILoggerRepository repository,
-      string loggerName,
-      Level level,
-      object message,
-      Exception exception)
-    {
-      this.m_callerStackBoundaryDeclaringType = callerStackBoundaryDeclaringType;
-      this.m_message = message;
-      this.m_repository = repository;
-      this.m_thrownException = exception;
-      this.m_data.LoggerName = loggerName;
-      this.m_data.Level = level;
-      this.m_data.TimeStamp = DateTime.Now;
-    }
-
-    public LoggingEvent(
-      Type callerStackBoundaryDeclaringType,
-      ILoggerRepository repository,
-      LoggingEventData data)
-    {
-      this.m_callerStackBoundaryDeclaringType = callerStackBoundaryDeclaringType;
-      this.m_repository = repository;
-      this.m_data = data;
-    }
-
-    public LoggingEvent(LoggingEventData data)
-      : this((Type) null, (ILoggerRepository) null, data)
-    {
-    }
-
-    protected LoggingEvent(SerializationInfo info, StreamingContext context)
-    {
-      this.m_data.LoggerName = info.GetString(nameof (LoggerName));
-      this.m_data.Level = (Level) info.GetValue(nameof (Level), typeof (Level));
-      this.m_data.Message = info.GetString("Message");
-      this.m_data.ThreadName = info.GetString(nameof (ThreadName));
-      this.m_data.TimeStamp = info.GetDateTime(nameof (TimeStamp));
-      this.m_data.LocationInfo = (LocationInfo) info.GetValue("LocationInfo", typeof (LocationInfo));
-      this.m_data.UserName = info.GetString(nameof (UserName));
-      this.m_data.ExceptionString = info.GetString("ExceptionString");
-      this.m_data.Properties = (PropertiesDictionary) info.GetValue(nameof (Properties), typeof (PropertiesDictionary));
-      this.m_data.Domain = info.GetString(nameof (Domain));
-      this.m_data.Identity = info.GetString(nameof (Identity));
-    }
-
-    public static DateTime StartTime => SystemInfo.ProcessStartTime;
-
-    public Level Level => this.m_data.Level;
-
-    public DateTime TimeStamp => this.m_data.TimeStamp;
-
-    public string LoggerName => this.m_data.LoggerName;
-
-    public LocationInfo LocationInformation
-    {
-      get
-      {
-        if (this.m_data.LocationInfo == null)
-          this.m_data.LocationInfo = new LocationInfo(this.m_callerStackBoundaryDeclaringType);
-        return this.m_data.LocationInfo;
-      }
-    }
-
-    public object MessageObject => this.m_message;
-
-    public Exception ExceptionObject => this.m_thrownException;
-
-    public ILoggerRepository Repository => this.m_repository;
-
-    internal void EnsureRepository(ILoggerRepository repository)
-    {
-      if (repository == null)
-        return;
-      this.m_repository = repository;
-    }
-
-    public string RenderedMessage
-    {
-      get
-      {
-        if (this.m_data.Message == null)
-          this.m_data.Message = this.m_message != null ? (!(this.m_message is string) ? (this.m_repository == null ? this.m_message.ToString() : this.m_repository.RendererMap.FindAndRender(this.m_message)) : this.m_message as string) : "";
-        return this.m_data.Message;
-      }
-    }
-
-    public void WriteRenderedMessage(TextWriter writer)
-    {
-      if (this.m_data.Message != null)
-      {
-        writer.Write(this.m_data.Message);
-      }
-      else
-      {
-        if (this.m_message == null)
-          return;
-        if (this.m_message is string)
-          writer.Write(this.m_message as string);
-        else if (this.m_repository != null)
-          this.m_repository.RendererMap.FindAndRender(this.m_message, writer);
-        else
-          writer.Write(this.m_message.ToString());
-      }
-    }
-
-    public string ThreadName
-    {
-      get
-      {
-        if (this.m_data.ThreadName == null)
-        {
-          this.m_data.ThreadName = Thread.CurrentThread.Name;
-          if (this.m_data.ThreadName != null)
-          {
-            if (this.m_data.ThreadName.Length != 0)
-              goto label_5;
-          }
-          try
-          {
-            this.m_data.ThreadName = SystemInfo.CurrentThreadId.ToString((IFormatProvider) NumberFormatInfo.InvariantInfo);
-          }
-          catch (SecurityException ex)
-          {
-            LogLog.Debug("LoggingEvent: Security exception while trying to get current thread ID. Error Ignored. Empty thread name.");
-            this.m_data.ThreadName = Thread.CurrentThread.GetHashCode().ToString((IFormatProvider) CultureInfo.InvariantCulture);
-          }
-        }
-label_5:
-        return this.m_data.ThreadName;
-      }
-    }
-
-    public string UserName
-    {
-      get
-      {
-        if (this.m_data.UserName == null)
-        {
-          try
-          {
-            WindowsIdentity current = WindowsIdentity.GetCurrent();
-            this.m_data.UserName = current == null || current.Name == null ? "" : current.Name;
-          }
-          catch (SecurityException ex)
-          {
-            LogLog.Debug("LoggingEvent: Security exception while trying to get current windows identity. Error Ignored. Empty user name.");
-            this.m_data.UserName = "";
-          }
-        }
-        return this.m_data.UserName;
-      }
-    }
-
-    public string Identity
-    {
-      get
-      {
-        if (this.m_data.Identity == null)
-        {
-          try
-          {
-            this.m_data.Identity = Thread.CurrentPrincipal == null || Thread.CurrentPrincipal.Identity == null || Thread.CurrentPrincipal.Identity.Name == null ? "" : Thread.CurrentPrincipal.Identity.Name;
-          }
-          catch (SecurityException ex)
-          {
-            LogLog.Debug("LoggingEvent: Security exception while trying to get current thread principal. Error Ignored. Empty identity name.");
-            this.m_data.Identity = "";
-          }
-        }
-        return this.m_data.Identity;
-      }
-    }
-
-    public string Domain
-    {
-      get
-      {
-        if (this.m_data.Domain == null)
-          this.m_data.Domain = SystemInfo.ApplicationFriendlyName;
-        return this.m_data.Domain;
-      }
-    }
-
-    public PropertiesDictionary Properties
-    {
-      get
-      {
-        if (this.m_data.Properties != null)
-          return this.m_data.Properties;
-        if (this.m_eventProperties == null)
-          this.m_eventProperties = new PropertiesDictionary();
-        return this.m_eventProperties;
-      }
-    }
-
-    public FixFlags Fix
-    {
-      get => this.m_fixFlags;
-      set => this.FixVolatileData(value);
-    }
-
-    [PermissionSet(SecurityAction.Demand, XML = "<PermissionSet class=\"System.Security.PermissionSet\"\r\n               version=\"1\">\r\n   <IPermission class=\"System.Security.Permissions.SecurityPermission, mscorlib, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\"\r\n                version=\"1\"\r\n                Flags=\"SerializationFormatter\"/>\r\n</PermissionSet>\r\n")]
-    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
-    {
-      info.AddValue("LoggerName", (object) this.m_data.LoggerName);
-      info.AddValue("Level", (object) this.m_data.Level);
-      info.AddValue("Message", (object) this.m_data.Message);
-      info.AddValue("ThreadName", (object) this.m_data.ThreadName);
-      info.AddValue("TimeStamp", this.m_data.TimeStamp);
-      info.AddValue("LocationInfo", (object) this.m_data.LocationInfo);
-      info.AddValue("UserName", (object) this.m_data.UserName);
-      info.AddValue("ExceptionString", (object) this.m_data.ExceptionString);
-      info.AddValue("Properties", (object) this.m_data.Properties);
-      info.AddValue("Domain", (object) this.m_data.Domain);
-      info.AddValue("Identity", (object) this.m_data.Identity);
-    }
-
-    public LoggingEventData GetLoggingEventData() => this.GetLoggingEventData(FixFlags.Partial);
-
-    public LoggingEventData GetLoggingEventData(FixFlags fixFlags)
-    {
-      this.Fix = fixFlags;
-      return this.m_data;
-    }
-
-    [Obsolete("Use GetExceptionString instead")]
-    public string GetExceptionStrRep() => this.GetExceptionString();
-
-    public string GetExceptionString()
-    {
-      if (this.m_data.ExceptionString == null)
-        this.m_data.ExceptionString = this.m_thrownException == null ? "" : (this.m_repository == null ? this.m_thrownException.ToString() : this.m_repository.RendererMap.FindAndRender((object) this.m_thrownException));
-      return this.m_data.ExceptionString;
-    }
-
-    [Obsolete("Use Fix property")]
-    public void FixVolatileData() => this.Fix = FixFlags.All;
-
-    [Obsolete("Use Fix property")]
-    public void FixVolatileData(bool fastButLoose)
-    {
-      if (fastButLoose)
-        this.Fix = FixFlags.Partial;
-      else
-        this.Fix = FixFlags.All;
-    }
-
-    protected void FixVolatileData(FixFlags flags)
-    {
-      FixFlags fixFlags = (flags ^ this.m_fixFlags) & flags;
-      if (fixFlags <= FixFlags.None)
-        return;
-      if ((fixFlags & FixFlags.Message) != FixFlags.None)
-      {
-        string renderedMessage = this.RenderedMessage;
-        this.m_fixFlags |= FixFlags.Message;
-      }
-      if ((fixFlags & FixFlags.Message) != FixFlags.None)
-      {
-        string renderedMessage = this.RenderedMessage;
-        this.m_fixFlags |= FixFlags.Message;
-      }
-      if ((fixFlags & FixFlags.ThreadName) != FixFlags.None)
-      {
-        string threadName = this.ThreadName;
-        this.m_fixFlags |= FixFlags.ThreadName;
-      }
-      if ((fixFlags & FixFlags.LocationInfo) != FixFlags.None)
-      {
-        LocationInfo locationInformation = this.LocationInformation;
-        this.m_fixFlags |= FixFlags.LocationInfo;
-      }
-      if ((fixFlags & FixFlags.UserName) != FixFlags.None)
-      {
-        string userName = this.UserName;
-        this.m_fixFlags |= FixFlags.UserName;
-      }
-      if ((fixFlags & FixFlags.Domain) != FixFlags.None)
-      {
-        string domain = this.Domain;
-        this.m_fixFlags |= FixFlags.Domain;
-      }
-      if ((fixFlags & FixFlags.Identity) != FixFlags.None)
-      {
-        string identity = this.Identity;
-        this.m_fixFlags |= FixFlags.Identity;
-      }
-      if ((fixFlags & FixFlags.Exception) != FixFlags.None)
-      {
-        this.GetExceptionString();
-        this.m_fixFlags |= FixFlags.Exception;
-      }
-      if ((fixFlags & FixFlags.Properties) == FixFlags.None)
-        return;
-      this.CacheProperties();
-      this.m_fixFlags |= FixFlags.Properties;
-    }
-
-    private void CreateCompositeProperties()
-    {
-      this.m_compositeProperties = new CompositeProperties();
-      if (this.m_eventProperties != null)
-        this.m_compositeProperties.Add((ReadOnlyPropertiesDictionary) this.m_eventProperties);
-      PropertiesDictionary properties1 = LogicalThreadContext.Properties.GetProperties(false);
-      if (properties1 != null)
-        this.m_compositeProperties.Add((ReadOnlyPropertiesDictionary) properties1);
-      PropertiesDictionary properties2 = ThreadContext.Properties.GetProperties(false);
-      if (properties2 != null)
-        this.m_compositeProperties.Add((ReadOnlyPropertiesDictionary) properties2);
-      this.m_compositeProperties.Add(GlobalContext.Properties.GetReadOnlyProperties());
-    }
-
-    private void CacheProperties()
-    {
-      if (this.m_data.Properties != null)
-        return;
-      if (this.m_compositeProperties == null)
-        this.CreateCompositeProperties();
-      PropertiesDictionary propertiesDictionary1 = this.m_compositeProperties.Flatten();
-      PropertiesDictionary propertiesDictionary2 = new PropertiesDictionary();
-      foreach (DictionaryEntry dictionaryEntry in (IEnumerable) propertiesDictionary1)
-      {
-        string key = (string) dictionaryEntry.Key;
-        object fixedObject = dictionaryEntry.Value;
-        if (fixedObject is IFixingRequired fixingRequired)
-          fixedObject = fixingRequired.GetFixedObject();
-        propertiesDictionary2[key] = fixedObject;
-      }
-      this.m_data.Properties = propertiesDictionary2;
-    }
-
-    public object LookupProperty(string key)
-    {
-      if (this.m_data.Properties != null)
-        return this.m_data.Properties[key];
-      if (this.m_compositeProperties == null)
-        this.CreateCompositeProperties();
-      return this.m_compositeProperties[key];
-    }
-
-    public PropertiesDictionary GetProperties()
-    {
-      if (this.m_data.Properties != null)
-        return this.m_data.Properties;
-      if (this.m_compositeProperties == null)
-        this.CreateCompositeProperties();
-      return this.m_compositeProperties.Flatten();
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/LoggingEventData.cs b/MSHALTester/log4net/Core/LoggingEventData.cs
deleted file mode 100644
index 4340468..0000000
--- a/MSHALTester/log4net/Core/LoggingEventData.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-using log4net.Util;
-using System;
-
-#nullable disable
-namespace log4net.Core
-{
-  public struct LoggingEventData
-  {
-    public string LoggerName;
-    public Level Level;
-    public string Message;
-    public string ThreadName;
-    public DateTime TimeStamp;
-    public LocationInfo LocationInfo;
-    public string UserName;
-    public string Identity;
-    public string ExceptionString;
-    public string Domain;
-    public PropertiesDictionary Properties;
-  }
-}
diff --git a/MSHALTester/log4net/Core/SecurityContext.cs b/MSHALTester/log4net/Core/SecurityContext.cs
deleted file mode 100644
index 0f60889..0000000
--- a/MSHALTester/log4net/Core/SecurityContext.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Core
-{
-  public abstract class SecurityContext
-  {
-    public abstract IDisposable Impersonate(object state);
-  }
-}
diff --git a/MSHALTester/log4net/Core/SecurityContextProvider.cs b/MSHALTester/log4net/Core/SecurityContextProvider.cs
deleted file mode 100644
index d5d5a65..0000000
--- a/MSHALTester/log4net/Core/SecurityContextProvider.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-using log4net.Util;
-
-#nullable disable
-namespace log4net.Core
-{
-  public class SecurityContextProvider
-  {
-    private static SecurityContextProvider s_defaultProvider = new SecurityContextProvider();
-
-    public static SecurityContextProvider DefaultProvider
-    {
-      get => SecurityContextProvider.s_defaultProvider;
-      set => SecurityContextProvider.s_defaultProvider = value;
-    }
-
-    protected SecurityContextProvider()
-    {
-    }
-
-    public virtual SecurityContext CreateSecurityContext(object consumer)
-    {
-      return (SecurityContext) NullSecurityContext.Instance;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Core/WrapperCreationHandler.cs b/MSHALTester/log4net/Core/WrapperCreationHandler.cs
deleted file mode 100644
index d535c48..0000000
--- a/MSHALTester/log4net/Core/WrapperCreationHandler.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace log4net.Core
-{
-  public delegate ILoggerWrapper WrapperCreationHandler(ILogger logger);
-}
diff --git a/MSHALTester/log4net/Core/WrapperMap.cs b/MSHALTester/log4net/Core/WrapperMap.cs
deleted file mode 100644
index 78f2f22..0000000
--- a/MSHALTester/log4net/Core/WrapperMap.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-using log4net.Repository;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Core
-{
-  public class WrapperMap
-  {
-    private readonly Hashtable m_repositories = new Hashtable();
-    private readonly WrapperCreationHandler m_createWrapperHandler;
-    private readonly LoggerRepositoryShutdownEventHandler m_shutdownHandler;
-
-    public WrapperMap(WrapperCreationHandler createWrapperHandler)
-    {
-      this.m_createWrapperHandler = createWrapperHandler;
-      this.m_shutdownHandler = new LoggerRepositoryShutdownEventHandler(this.ILoggerRepository_Shutdown);
-    }
-
-    public virtual ILoggerWrapper GetWrapper(ILogger logger)
-    {
-      if (logger == null)
-        return (ILoggerWrapper) null;
-      lock (this)
-      {
-        Hashtable hashtable = (Hashtable) this.m_repositories[(object) logger.Repository];
-        if (hashtable == null)
-        {
-          hashtable = new Hashtable();
-          this.m_repositories[(object) logger.Repository] = (object) hashtable;
-          logger.Repository.ShutdownEvent += this.m_shutdownHandler;
-        }
-        if (!(hashtable[(object) logger] is ILoggerWrapper newWrapperObject))
-        {
-          newWrapperObject = this.CreateNewWrapperObject(logger);
-          hashtable[(object) logger] = (object) newWrapperObject;
-        }
-        return newWrapperObject;
-      }
-    }
-
-    protected Hashtable Repositories => this.m_repositories;
-
-    protected virtual ILoggerWrapper CreateNewWrapperObject(ILogger logger)
-    {
-      return this.m_createWrapperHandler != null ? this.m_createWrapperHandler(logger) : (ILoggerWrapper) null;
-    }
-
-    protected virtual void RepositoryShutdown(ILoggerRepository repository)
-    {
-      lock (this)
-      {
-        this.m_repositories.Remove((object) repository);
-        repository.ShutdownEvent -= this.m_shutdownHandler;
-      }
-    }
-
-    private void ILoggerRepository_Shutdown(object sender, EventArgs e)
-    {
-      if (!(sender is ILoggerRepository repository))
-        return;
-      this.RepositoryShutdown(repository);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/DateFormatter/AbsoluteTimeDateFormatter.cs b/MSHALTester/log4net/DateFormatter/AbsoluteTimeDateFormatter.cs
deleted file mode 100644
index 5e176d8..0000000
--- a/MSHALTester/log4net/DateFormatter/AbsoluteTimeDateFormatter.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-using System;
-using System.IO;
-using System.Text;
-using System.Threading;
-
-#nullable disable
-namespace log4net.DateFormatter
-{
-  public class AbsoluteTimeDateFormatter : IDateFormatter
-  {
-    public const string AbsoluteTimeDateFormat = "ABSOLUTE";
-    public const string DateAndTimeDateFormat = "DATE";
-    public const string Iso8601TimeDateFormat = "ISO8601";
-    private static long s_lastTimeToTheSecond = 0;
-    private static StringBuilder s_lastTimeBuf = new StringBuilder();
-    private static string s_lastTimeString;
-
-    protected virtual void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer)
-    {
-      int hour = dateToFormat.Hour;
-      if (hour < 10)
-        buffer.Append('0');
-      buffer.Append(hour);
-      buffer.Append(':');
-      int minute = dateToFormat.Minute;
-      if (minute < 10)
-        buffer.Append('0');
-      buffer.Append(minute);
-      buffer.Append(':');
-      int second = dateToFormat.Second;
-      if (second < 10)
-        buffer.Append('0');
-      buffer.Append(second);
-    }
-
-    public virtual void FormatDate(DateTime dateToFormat, TextWriter writer)
-    {
-      long num = dateToFormat.Ticks - dateToFormat.Ticks % 10000000L;
-      if (AbsoluteTimeDateFormatter.s_lastTimeToTheSecond != num)
-      {
-        lock (AbsoluteTimeDateFormatter.s_lastTimeBuf)
-        {
-          if (AbsoluteTimeDateFormatter.s_lastTimeToTheSecond != num)
-          {
-            AbsoluteTimeDateFormatter.s_lastTimeBuf.Length = 0;
-            this.FormatDateWithoutMillis(dateToFormat, AbsoluteTimeDateFormatter.s_lastTimeBuf);
-            string str = AbsoluteTimeDateFormatter.s_lastTimeBuf.ToString();
-            Thread.MemoryBarrier();
-            AbsoluteTimeDateFormatter.s_lastTimeString = str;
-            AbsoluteTimeDateFormatter.s_lastTimeToTheSecond = num;
-          }
-        }
-      }
-      writer.Write(AbsoluteTimeDateFormatter.s_lastTimeString);
-      writer.Write(',');
-      int millisecond = dateToFormat.Millisecond;
-      if (millisecond < 100)
-        writer.Write('0');
-      if (millisecond < 10)
-        writer.Write('0');
-      writer.Write(millisecond);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/DateFormatter/DateTimeDateFormatter.cs b/MSHALTester/log4net/DateFormatter/DateTimeDateFormatter.cs
deleted file mode 100644
index b127e45..0000000
--- a/MSHALTester/log4net/DateFormatter/DateTimeDateFormatter.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using System;
-using System.Globalization;
-using System.Text;
-
-#nullable disable
-namespace log4net.DateFormatter
-{
-  public class DateTimeDateFormatter : AbsoluteTimeDateFormatter
-  {
-    private readonly DateTimeFormatInfo m_dateTimeFormatInfo;
-
-    public DateTimeDateFormatter() => this.m_dateTimeFormatInfo = DateTimeFormatInfo.InvariantInfo;
-
-    protected override void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer)
-    {
-      int day = dateToFormat.Day;
-      if (day < 10)
-        buffer.Append('0');
-      buffer.Append(day);
-      buffer.Append(' ');
-      buffer.Append(this.m_dateTimeFormatInfo.GetAbbreviatedMonthName(dateToFormat.Month));
-      buffer.Append(' ');
-      buffer.Append(dateToFormat.Year);
-      buffer.Append(' ');
-      base.FormatDateWithoutMillis(dateToFormat, buffer);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/DateFormatter/IDateFormatter.cs b/MSHALTester/log4net/DateFormatter/IDateFormatter.cs
deleted file mode 100644
index 2517a85..0000000
--- a/MSHALTester/log4net/DateFormatter/IDateFormatter.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.DateFormatter
-{
-  public interface IDateFormatter
-  {
-    void FormatDate(DateTime dateToFormat, TextWriter writer);
-  }
-}
diff --git a/MSHALTester/log4net/DateFormatter/Iso8601DateFormatter.cs b/MSHALTester/log4net/DateFormatter/Iso8601DateFormatter.cs
deleted file mode 100644
index e6907f2..0000000
--- a/MSHALTester/log4net/DateFormatter/Iso8601DateFormatter.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using System;
-using System.Text;
-
-#nullable disable
-namespace log4net.DateFormatter
-{
-  public class Iso8601DateFormatter : AbsoluteTimeDateFormatter
-  {
-    protected override void FormatDateWithoutMillis(DateTime dateToFormat, StringBuilder buffer)
-    {
-      buffer.Append(dateToFormat.Year);
-      buffer.Append('-');
-      int month = dateToFormat.Month;
-      if (month < 10)
-        buffer.Append('0');
-      buffer.Append(month);
-      buffer.Append('-');
-      int day = dateToFormat.Day;
-      if (day < 10)
-        buffer.Append('0');
-      buffer.Append(day);
-      buffer.Append(' ');
-      base.FormatDateWithoutMillis(dateToFormat, buffer);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/DateFormatter/SimpleDateFormatter.cs b/MSHALTester/log4net/DateFormatter/SimpleDateFormatter.cs
deleted file mode 100644
index 52dc330..0000000
--- a/MSHALTester/log4net/DateFormatter/SimpleDateFormatter.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.DateFormatter
-{
-  public class SimpleDateFormatter : IDateFormatter
-  {
-    private readonly string m_formatString;
-
-    public SimpleDateFormatter(string format) => this.m_formatString = format;
-
-    public virtual void FormatDate(DateTime dateToFormat, TextWriter writer)
-    {
-      writer.Write(dateToFormat.ToString(this.m_formatString, (IFormatProvider) DateTimeFormatInfo.InvariantInfo));
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Filter/DenyAllFilter.cs b/MSHALTester/log4net/Filter/DenyAllFilter.cs
deleted file mode 100644
index 3bfc253..0000000
--- a/MSHALTester/log4net/Filter/DenyAllFilter.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Filter
-{
-  public sealed class DenyAllFilter : FilterSkeleton
-  {
-    public override FilterDecision Decide(LoggingEvent loggingEvent) => FilterDecision.Deny;
-  }
-}
diff --git a/MSHALTester/log4net/Filter/FilterDecision.cs b/MSHALTester/log4net/Filter/FilterDecision.cs
deleted file mode 100644
index 58f29d1..0000000
--- a/MSHALTester/log4net/Filter/FilterDecision.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-#nullable disable
-namespace log4net.Filter
-{
-  public enum FilterDecision
-  {
-    Deny = -1, // 0xFFFFFFFF
-    Neutral = 0,
-    Accept = 1,
-  }
-}
diff --git a/MSHALTester/log4net/Filter/FilterSkeleton.cs b/MSHALTester/log4net/Filter/FilterSkeleton.cs
deleted file mode 100644
index ca99c13..0000000
--- a/MSHALTester/log4net/Filter/FilterSkeleton.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Filter
-{
-  public abstract class FilterSkeleton : IFilter, IOptionHandler
-  {
-    private IFilter m_next;
-
-    public virtual void ActivateOptions()
-    {
-    }
-
-    public abstract FilterDecision Decide(LoggingEvent loggingEvent);
-
-    public IFilter Next
-    {
-      get => this.m_next;
-      set => this.m_next = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Filter/IFilter.cs b/MSHALTester/log4net/Filter/IFilter.cs
deleted file mode 100644
index e365a7d..0000000
--- a/MSHALTester/log4net/Filter/IFilter.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Filter
-{
-  public interface IFilter : IOptionHandler
-  {
-    FilterDecision Decide(LoggingEvent loggingEvent);
-
-    IFilter Next { get; set; }
-  }
-}
diff --git a/MSHALTester/log4net/Filter/LevelMatchFilter.cs b/MSHALTester/log4net/Filter/LevelMatchFilter.cs
deleted file mode 100644
index d70cf61..0000000
--- a/MSHALTester/log4net/Filter/LevelMatchFilter.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net.Filter
-{
-  public class LevelMatchFilter : FilterSkeleton
-  {
-    private bool m_acceptOnMatch = true;
-    private Level m_levelToMatch;
-
-    public bool AcceptOnMatch
-    {
-      get => this.m_acceptOnMatch;
-      set => this.m_acceptOnMatch = value;
-    }
-
-    public Level LevelToMatch
-    {
-      get => this.m_levelToMatch;
-      set => this.m_levelToMatch = value;
-    }
-
-    public override FilterDecision Decide(LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      if (this.m_levelToMatch == (Level) null)
-        return FilterDecision.Neutral;
-      bool flag = false;
-      if (this.m_levelToMatch == loggingEvent.Level)
-        flag = true;
-      return this.m_acceptOnMatch ^ flag ? FilterDecision.Deny : FilterDecision.Accept;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Filter/LevelRangeFilter.cs b/MSHALTester/log4net/Filter/LevelRangeFilter.cs
deleted file mode 100644
index acb28e1..0000000
--- a/MSHALTester/log4net/Filter/LevelRangeFilter.cs
+++ /dev/null
@@ -1,40 +0,0 @@
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net.Filter
-{
-  public class LevelRangeFilter : FilterSkeleton
-  {
-    private bool m_acceptOnMatch = true;
-    private Level m_levelMin;
-    private Level m_levelMax;
-
-    public bool AcceptOnMatch
-    {
-      get => this.m_acceptOnMatch;
-      set => this.m_acceptOnMatch = value;
-    }
-
-    public Level LevelMin
-    {
-      get => this.m_levelMin;
-      set => this.m_levelMin = value;
-    }
-
-    public Level LevelMax
-    {
-      get => this.m_levelMax;
-      set => this.m_levelMax = value;
-    }
-
-    public override FilterDecision Decide(LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      if (this.m_levelMin != (Level) null && loggingEvent.Level < this.m_levelMin || this.m_levelMax != (Level) null && loggingEvent.Level > this.m_levelMax)
-        return FilterDecision.Deny;
-      return this.m_acceptOnMatch ? FilterDecision.Accept : FilterDecision.Neutral;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Filter/LoggerMatchFilter.cs b/MSHALTester/log4net/Filter/LoggerMatchFilter.cs
deleted file mode 100644
index e1218ff..0000000
--- a/MSHALTester/log4net/Filter/LoggerMatchFilter.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net.Filter
-{
-  public class LoggerMatchFilter : FilterSkeleton
-  {
-    private bool m_acceptOnMatch = true;
-    private string m_loggerToMatch;
-
-    public bool AcceptOnMatch
-    {
-      get => this.m_acceptOnMatch;
-      set => this.m_acceptOnMatch = value;
-    }
-
-    public string LoggerToMatch
-    {
-      get => this.m_loggerToMatch;
-      set => this.m_loggerToMatch = value;
-    }
-
-    public override FilterDecision Decide(LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      if (this.m_loggerToMatch == null || this.m_loggerToMatch.Length == 0 || !loggingEvent.LoggerName.StartsWith(this.m_loggerToMatch))
-        return FilterDecision.Neutral;
-      return this.m_acceptOnMatch ? FilterDecision.Accept : FilterDecision.Deny;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Filter/MdcFilter.cs b/MSHALTester/log4net/Filter/MdcFilter.cs
deleted file mode 100644
index 467b13b..0000000
--- a/MSHALTester/log4net/Filter/MdcFilter.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-#nullable disable
-namespace log4net.Filter
-{
-  public class MdcFilter : PropertyFilter
-  {
-  }
-}
diff --git a/MSHALTester/log4net/Filter/NdcFilter.cs b/MSHALTester/log4net/Filter/NdcFilter.cs
deleted file mode 100644
index e0e22d4..0000000
--- a/MSHALTester/log4net/Filter/NdcFilter.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace log4net.Filter
-{
-  public class NdcFilter : PropertyFilter
-  {
-    public NdcFilter() => this.Key = "NDC";
-  }
-}
diff --git a/MSHALTester/log4net/Filter/PropertyFilter.cs b/MSHALTester/log4net/Filter/PropertyFilter.cs
deleted file mode 100644
index 13650f4..0000000
--- a/MSHALTester/log4net/Filter/PropertyFilter.cs
+++ /dev/null
@@ -1,38 +0,0 @@
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net.Filter
-{
-  public class PropertyFilter : StringMatchFilter
-  {
-    private string m_key;
-
-    public string Key
-    {
-      get => this.m_key;
-      set => this.m_key = value;
-    }
-
-    public override FilterDecision Decide(LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      if (this.m_key == null)
-        return FilterDecision.Neutral;
-      object obj = loggingEvent.LookupProperty(this.m_key);
-      string andRender = loggingEvent.Repository.RendererMap.FindAndRender(obj);
-      if (andRender == null || this.m_stringToMatch == null && this.m_regexToMatch == null)
-        return FilterDecision.Neutral;
-      if (this.m_regexToMatch != null)
-      {
-        if (!this.m_regexToMatch.Match(andRender).Success)
-          return FilterDecision.Neutral;
-        return this.m_acceptOnMatch ? FilterDecision.Accept : FilterDecision.Deny;
-      }
-      if (this.m_stringToMatch == null || andRender.IndexOf(this.m_stringToMatch) == -1)
-        return FilterDecision.Neutral;
-      return this.m_acceptOnMatch ? FilterDecision.Accept : FilterDecision.Deny;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Filter/StringMatchFilter.cs b/MSHALTester/log4net/Filter/StringMatchFilter.cs
deleted file mode 100644
index 0c12d5d..0000000
--- a/MSHALTester/log4net/Filter/StringMatchFilter.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-using log4net.Core;
-using System;
-using System.Text.RegularExpressions;
-
-#nullable disable
-namespace log4net.Filter
-{
-  public class StringMatchFilter : FilterSkeleton
-  {
-    protected bool m_acceptOnMatch = true;
-    protected string m_stringToMatch;
-    protected string m_stringRegexToMatch;
-    protected Regex m_regexToMatch;
-
-    public override void ActivateOptions()
-    {
-      if (this.m_stringRegexToMatch == null)
-        return;
-      this.m_regexToMatch = new Regex(this.m_stringRegexToMatch, RegexOptions.Compiled);
-    }
-
-    public bool AcceptOnMatch
-    {
-      get => this.m_acceptOnMatch;
-      set => this.m_acceptOnMatch = value;
-    }
-
-    public string StringToMatch
-    {
-      get => this.m_stringToMatch;
-      set => this.m_stringToMatch = value;
-    }
-
-    public string RegexToMatch
-    {
-      get => this.m_stringRegexToMatch;
-      set => this.m_stringRegexToMatch = value;
-    }
-
-    public override FilterDecision Decide(LoggingEvent loggingEvent)
-    {
-      string input = loggingEvent != null ? loggingEvent.RenderedMessage : throw new ArgumentNullException(nameof (loggingEvent));
-      if (input == null || this.m_stringToMatch == null && this.m_regexToMatch == null)
-        return FilterDecision.Neutral;
-      if (this.m_regexToMatch != null)
-      {
-        if (!this.m_regexToMatch.Match(input).Success)
-          return FilterDecision.Neutral;
-        return this.m_acceptOnMatch ? FilterDecision.Accept : FilterDecision.Deny;
-      }
-      if (this.m_stringToMatch == null || input.IndexOf(this.m_stringToMatch) == -1)
-        return FilterDecision.Neutral;
-      return this.m_acceptOnMatch ? FilterDecision.Accept : FilterDecision.Deny;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/GlobalContext.cs b/MSHALTester/log4net/GlobalContext.cs
deleted file mode 100644
index 5ae1b4e..0000000
--- a/MSHALTester/log4net/GlobalContext.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-using log4net.Util;
-
-#nullable disable
-namespace log4net
-{
-  public sealed class GlobalContext
-  {
-    private static readonly GlobalContextProperties s_properties = new GlobalContextProperties();
-
-    private GlobalContext()
-    {
-    }
-
-    static GlobalContext()
-    {
-      GlobalContext.Properties["log4net:HostName"] = (object) SystemInfo.HostName;
-    }
-
-    public static GlobalContextProperties Properties => GlobalContext.s_properties;
-  }
-}
diff --git a/MSHALTester/log4net/ILog.cs b/MSHALTester/log4net/ILog.cs
deleted file mode 100644
index 6ffc808..0000000
--- a/MSHALTester/log4net/ILog.cs
+++ /dev/null
@@ -1,59 +0,0 @@
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net
-{
-  public interface ILog : ILoggerWrapper
-  {
-    void Debug(object message);
-
-    void Debug(object message, Exception exception);
-
-    void DebugFormat(string format, params object[] args);
-
-    void DebugFormat(IFormatProvider provider, string format, params object[] args);
-
-    void Info(object message);
-
-    void Info(object message, Exception exception);
-
-    void InfoFormat(string format, params object[] args);
-
-    void InfoFormat(IFormatProvider provider, string format, params object[] args);
-
-    void Warn(object message);
-
-    void Warn(object message, Exception exception);
-
-    void WarnFormat(string format, params object[] args);
-
-    void WarnFormat(IFormatProvider provider, string format, params object[] args);
-
-    void Error(object message);
-
-    void Error(object message, Exception exception);
-
-    void ErrorFormat(string format, params object[] args);
-
-    void ErrorFormat(IFormatProvider provider, string format, params object[] args);
-
-    void Fatal(object message);
-
-    void Fatal(object message, Exception exception);
-
-    void FatalFormat(string format, params object[] args);
-
-    void FatalFormat(IFormatProvider provider, string format, params object[] args);
-
-    bool IsDebugEnabled { get; }
-
-    bool IsInfoEnabled { get; }
-
-    bool IsWarnEnabled { get; }
-
-    bool IsErrorEnabled { get; }
-
-    bool IsFatalEnabled { get; }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/ExceptionLayout.cs b/MSHALTester/log4net/Layout/ExceptionLayout.cs
deleted file mode 100644
index fa7a236..0000000
--- a/MSHALTester/log4net/Layout/ExceptionLayout.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-using log4net.Core;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class ExceptionLayout : LayoutSkeleton
-  {
-    public ExceptionLayout() => this.IgnoresException = false;
-
-    public override void ActivateOptions()
-    {
-    }
-
-    public override void Format(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      writer.Write(loggingEvent.GetExceptionString());
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/ILayout.cs b/MSHALTester/log4net/Layout/ILayout.cs
deleted file mode 100644
index 588df8e..0000000
--- a/MSHALTester/log4net/Layout/ILayout.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public interface ILayout
-  {
-    void Format(TextWriter writer, LoggingEvent loggingEvent);
-
-    string ContentType { get; }
-
-    string Header { get; }
-
-    string Footer { get; }
-
-    bool IgnoresException { get; }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/IRawLayout.cs b/MSHALTester/log4net/Layout/IRawLayout.cs
deleted file mode 100644
index 3dc743c..0000000
--- a/MSHALTester/log4net/Layout/IRawLayout.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using log4net.Core;
-using log4net.Util.TypeConverters;
-
-#nullable disable
-namespace log4net.Layout
-{
-  [TypeConverter(typeof (RawLayoutConverter))]
-  public interface IRawLayout
-  {
-    object Format(LoggingEvent loggingEvent);
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Layout2RawLayoutAdapter.cs b/MSHALTester/log4net/Layout/Layout2RawLayoutAdapter.cs
deleted file mode 100644
index 7cb8369..0000000
--- a/MSHALTester/log4net/Layout/Layout2RawLayoutAdapter.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-using log4net.Core;
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class Layout2RawLayoutAdapter : IRawLayout
-  {
-    private ILayout m_layout;
-
-    public Layout2RawLayoutAdapter(ILayout layout) => this.m_layout = layout;
-
-    public virtual object Format(LoggingEvent loggingEvent)
-    {
-      StringWriter writer = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-      this.m_layout.Format((TextWriter) writer, loggingEvent);
-      return (object) writer.ToString();
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/LayoutSkeleton.cs b/MSHALTester/log4net/Layout/LayoutSkeleton.cs
deleted file mode 100644
index a9a1675..0000000
--- a/MSHALTester/log4net/Layout/LayoutSkeleton.cs
+++ /dev/null
@@ -1,37 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public abstract class LayoutSkeleton : ILayout, IOptionHandler
-  {
-    private string m_header = (string) null;
-    private string m_footer = (string) null;
-    private bool m_ignoresException = true;
-
-    public abstract void ActivateOptions();
-
-    public abstract void Format(TextWriter writer, LoggingEvent loggingEvent);
-
-    public virtual string ContentType => "text/plain";
-
-    public virtual string Header
-    {
-      get => this.m_header;
-      set => this.m_header = value;
-    }
-
-    public virtual string Footer
-    {
-      get => this.m_footer;
-      set => this.m_footer = value;
-    }
-
-    public virtual bool IgnoresException
-    {
-      get => this.m_ignoresException;
-      set => this.m_ignoresException = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/AppDomainPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/AppDomainPatternConverter.cs
deleted file mode 100644
index 386a94c..0000000
--- a/MSHALTester/log4net/Layout/Pattern/AppDomainPatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class AppDomainPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.Domain);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/DatePatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/DatePatternConverter.cs
deleted file mode 100644
index 216c7c2..0000000
--- a/MSHALTester/log4net/Layout/Pattern/DatePatternConverter.cs
+++ /dev/null
@@ -1,52 +0,0 @@
-using log4net.Core;
-using log4net.DateFormatter;
-using log4net.Util;
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal class DatePatternConverter : PatternLayoutConverter, IOptionHandler
-  {
-    protected IDateFormatter m_dateFormatter;
-
-    public void ActivateOptions()
-    {
-      string str = this.Option ?? "ISO8601";
-      if (string.Compare(str, "ISO8601", true, CultureInfo.InvariantCulture) == 0)
-        this.m_dateFormatter = (IDateFormatter) new Iso8601DateFormatter();
-      else if (string.Compare(str, "ABSOLUTE", true, CultureInfo.InvariantCulture) == 0)
-        this.m_dateFormatter = (IDateFormatter) new AbsoluteTimeDateFormatter();
-      else if (string.Compare(str, "DATE", true, CultureInfo.InvariantCulture) == 0)
-      {
-        this.m_dateFormatter = (IDateFormatter) new DateTimeDateFormatter();
-      }
-      else
-      {
-        try
-        {
-          this.m_dateFormatter = (IDateFormatter) new SimpleDateFormatter(str);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("DatePatternConverter: Could not instantiate SimpleDateFormatter with [" + str + "]", ex);
-          this.m_dateFormatter = (IDateFormatter) new Iso8601DateFormatter();
-        }
-      }
-    }
-
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      try
-      {
-        this.m_dateFormatter.FormatDate(loggingEvent.TimeStamp, writer);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("DatePatternConverter: Error occurred while converting date.", ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/ExceptionPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/ExceptionPatternConverter.cs
deleted file mode 100644
index 80ae0b2..0000000
--- a/MSHALTester/log4net/Layout/Pattern/ExceptionPatternConverter.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class ExceptionPatternConverter : PatternLayoutConverter
-  {
-    public ExceptionPatternConverter() => this.IgnoresException = false;
-
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      string exceptionString = loggingEvent.GetExceptionString();
-      if (exceptionString == null || exceptionString.Length <= 0)
-        return;
-      writer.WriteLine(exceptionString);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/FileLocationPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/FileLocationPatternConverter.cs
deleted file mode 100644
index 869766b..0000000
--- a/MSHALTester/log4net/Layout/Pattern/FileLocationPatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class FileLocationPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.LocationInformation.FileName);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/FullLocationPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/FullLocationPatternConverter.cs
deleted file mode 100644
index ad5885c..0000000
--- a/MSHALTester/log4net/Layout/Pattern/FullLocationPatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class FullLocationPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.LocationInformation.FullInfo);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/IdentityPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/IdentityPatternConverter.cs
deleted file mode 100644
index 95c4ae6..0000000
--- a/MSHALTester/log4net/Layout/Pattern/IdentityPatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class IdentityPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.Identity);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/LevelPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/LevelPatternConverter.cs
deleted file mode 100644
index beb095f..0000000
--- a/MSHALTester/log4net/Layout/Pattern/LevelPatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class LevelPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.Level.DisplayName);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/LineLocationPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/LineLocationPatternConverter.cs
deleted file mode 100644
index a9bab48..0000000
--- a/MSHALTester/log4net/Layout/Pattern/LineLocationPatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class LineLocationPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.LocationInformation.LineNumber);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/LoggerPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/LoggerPatternConverter.cs
deleted file mode 100644
index 27c3d65..0000000
--- a/MSHALTester/log4net/Layout/Pattern/LoggerPatternConverter.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class LoggerPatternConverter : NamedPatternConverter
-  {
-    protected override string GetFullyQualifiedName(LoggingEvent loggingEvent)
-    {
-      return loggingEvent.LoggerName;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/MessagePatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/MessagePatternConverter.cs
deleted file mode 100644
index e6f0f9b..0000000
--- a/MSHALTester/log4net/Layout/Pattern/MessagePatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class MessagePatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      loggingEvent.WriteRenderedMessage(writer);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/MethodLocationPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/MethodLocationPatternConverter.cs
deleted file mode 100644
index 3f2ec1c..0000000
--- a/MSHALTester/log4net/Layout/Pattern/MethodLocationPatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class MethodLocationPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.LocationInformation.MethodName);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/NamedPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/NamedPatternConverter.cs
deleted file mode 100644
index 93c262b..0000000
--- a/MSHALTester/log4net/Layout/Pattern/NamedPatternConverter.cs
+++ /dev/null
@@ -1,58 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal abstract class NamedPatternConverter : PatternLayoutConverter, IOptionHandler
-  {
-    protected int m_precision = 0;
-
-    public void ActivateOptions()
-    {
-      this.m_precision = 0;
-      if (this.Option == null)
-        return;
-      string s = this.Option.Trim();
-      if (s.Length <= 0)
-        return;
-      int val;
-      if (SystemInfo.TryParse(s, out val))
-      {
-        if (val <= 0)
-          LogLog.Error("NamedPatternConverter: Precision option (" + s + ") isn't a positive integer.");
-        else
-          this.m_precision = val;
-      }
-      else
-        LogLog.Error("NamedPatternConverter: Precision option \"" + s + "\" not a decimal integer.");
-    }
-
-    protected abstract string GetFullyQualifiedName(LoggingEvent loggingEvent);
-
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      string fullyQualifiedName = this.GetFullyQualifiedName(loggingEvent);
-      if (this.m_precision <= 0)
-      {
-        writer.Write(fullyQualifiedName);
-      }
-      else
-      {
-        int length = fullyQualifiedName.Length;
-        int num = length - 1;
-        for (int precision = this.m_precision; precision > 0; --precision)
-        {
-          num = fullyQualifiedName.LastIndexOf('.', num - 1);
-          if (num == -1)
-          {
-            writer.Write(fullyQualifiedName);
-            return;
-          }
-        }
-        writer.Write(fullyQualifiedName.Substring(num + 1, length - num - 1));
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/NdcPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/NdcPatternConverter.cs
deleted file mode 100644
index e87c130..0000000
--- a/MSHALTester/log4net/Layout/Pattern/NdcPatternConverter.cs
+++ /dev/null
@@ -1,15 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class NdcPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      PatternConverter.WriteObject(writer, loggingEvent.Repository, loggingEvent.LookupProperty("NDC"));
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/PatternLayoutConverter.cs b/MSHALTester/log4net/Layout/Pattern/PatternLayoutConverter.cs
deleted file mode 100644
index d336110..0000000
--- a/MSHALTester/log4net/Layout/Pattern/PatternLayoutConverter.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  public abstract class PatternLayoutConverter : PatternConverter
-  {
-    private bool m_ignoresException = true;
-
-    public virtual bool IgnoresException
-    {
-      get => this.m_ignoresException;
-      set => this.m_ignoresException = value;
-    }
-
-    protected abstract void Convert(TextWriter writer, LoggingEvent loggingEvent);
-
-    protected override void Convert(TextWriter writer, object state)
-    {
-      if (!(state is LoggingEvent loggingEvent))
-        throw new ArgumentException("state must be of type [" + typeof (LoggingEvent).FullName + "]", nameof (state));
-      this.Convert(writer, loggingEvent);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/PropertyPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/PropertyPatternConverter.cs
deleted file mode 100644
index bae62d6..0000000
--- a/MSHALTester/log4net/Layout/Pattern/PropertyPatternConverter.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System.Collections;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class PropertyPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      if (this.Option != null)
-        PatternConverter.WriteObject(writer, loggingEvent.Repository, loggingEvent.LookupProperty(this.Option));
-      else
-        PatternConverter.WriteDictionary(writer, loggingEvent.Repository, (IDictionary) loggingEvent.GetProperties());
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/RelativeTimePatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/RelativeTimePatternConverter.cs
deleted file mode 100644
index 291eb6b..0000000
--- a/MSHALTester/log4net/Layout/Pattern/RelativeTimePatternConverter.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-using log4net.Core;
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class RelativeTimePatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(RelativeTimePatternConverter.TimeDifferenceInMillis(LoggingEvent.StartTime, loggingEvent.TimeStamp).ToString((IFormatProvider) NumberFormatInfo.InvariantInfo));
-    }
-
-    private static long TimeDifferenceInMillis(DateTime start, DateTime end)
-    {
-      return (long) (end.ToUniversalTime() - start.ToUniversalTime()).TotalMilliseconds;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/ThreadPatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/ThreadPatternConverter.cs
deleted file mode 100644
index 6b6d9a1..0000000
--- a/MSHALTester/log4net/Layout/Pattern/ThreadPatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class ThreadPatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.ThreadName);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/TypeNamePatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/TypeNamePatternConverter.cs
deleted file mode 100644
index 56832e2..0000000
--- a/MSHALTester/log4net/Layout/Pattern/TypeNamePatternConverter.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class TypeNamePatternConverter : NamedPatternConverter
-  {
-    protected override string GetFullyQualifiedName(LoggingEvent loggingEvent)
-    {
-      return loggingEvent.LocationInformation.ClassName;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/UserNamePatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/UserNamePatternConverter.cs
deleted file mode 100644
index 3b1d175..0000000
--- a/MSHALTester/log4net/Layout/Pattern/UserNamePatternConverter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Core;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal sealed class UserNamePatternConverter : PatternLayoutConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.Write(loggingEvent.UserName);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/Pattern/UtcDatePatternConverter.cs b/MSHALTester/log4net/Layout/Pattern/UtcDatePatternConverter.cs
deleted file mode 100644
index 1754178..0000000
--- a/MSHALTester/log4net/Layout/Pattern/UtcDatePatternConverter.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout.Pattern
-{
-  internal class UtcDatePatternConverter : DatePatternConverter
-  {
-    protected override void Convert(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      try
-      {
-        this.m_dateFormatter.FormatDate(loggingEvent.TimeStamp.ToUniversalTime(), writer);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("UtcDatePatternConverter: Error occurred while converting date.", ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/PatternLayout.cs b/MSHALTester/log4net/Layout/PatternLayout.cs
deleted file mode 100644
index 5785899..0000000
--- a/MSHALTester/log4net/Layout/PatternLayout.cs
+++ /dev/null
@@ -1,153 +0,0 @@
-using log4net.Core;
-using log4net.Layout.Pattern;
-using log4net.Util;
-using log4net.Util.PatternStringConverters;
-using System;
-using System.Collections;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class PatternLayout : LayoutSkeleton
-  {
-    public const string DefaultConversionPattern = "%message%newline";
-    public const string DetailConversionPattern = "%timestamp [%thread] %level %logger %ndc - %message%newline";
-    private static Hashtable s_globalRulesRegistry = new Hashtable(35);
-    private string m_pattern;
-    private PatternConverter m_head;
-    private Hashtable m_instanceRulesRegistry = new Hashtable();
-
-    static PatternLayout()
-    {
-      PatternLayout.s_globalRulesRegistry.Add((object) "literal", (object) typeof (LiteralPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "newline", (object) typeof (NewLinePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "n", (object) typeof (NewLinePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "c", (object) typeof (LoggerPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "logger", (object) typeof (LoggerPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "C", (object) typeof (TypeNamePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "class", (object) typeof (TypeNamePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "type", (object) typeof (TypeNamePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "d", (object) typeof (log4net.Layout.Pattern.DatePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "date", (object) typeof (log4net.Layout.Pattern.DatePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "exception", (object) typeof (ExceptionPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "F", (object) typeof (FileLocationPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "file", (object) typeof (FileLocationPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "l", (object) typeof (FullLocationPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "location", (object) typeof (FullLocationPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "L", (object) typeof (LineLocationPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "line", (object) typeof (LineLocationPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "m", (object) typeof (MessagePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "message", (object) typeof (MessagePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "M", (object) typeof (MethodLocationPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "method", (object) typeof (MethodLocationPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "p", (object) typeof (LevelPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "level", (object) typeof (LevelPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "P", (object) typeof (log4net.Layout.Pattern.PropertyPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "property", (object) typeof (log4net.Layout.Pattern.PropertyPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "properties", (object) typeof (log4net.Layout.Pattern.PropertyPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "r", (object) typeof (RelativeTimePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "timestamp", (object) typeof (RelativeTimePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "t", (object) typeof (ThreadPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "thread", (object) typeof (ThreadPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "x", (object) typeof (NdcPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "ndc", (object) typeof (NdcPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "X", (object) typeof (log4net.Layout.Pattern.PropertyPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "mdc", (object) typeof (log4net.Layout.Pattern.PropertyPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "a", (object) typeof (log4net.Layout.Pattern.AppDomainPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "appdomain", (object) typeof (log4net.Layout.Pattern.AppDomainPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "u", (object) typeof (log4net.Layout.Pattern.IdentityPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "identity", (object) typeof (log4net.Layout.Pattern.IdentityPatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "utcdate", (object) typeof (log4net.Layout.Pattern.UtcDatePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "utcDate", (object) typeof (log4net.Layout.Pattern.UtcDatePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "UtcDate", (object) typeof (log4net.Layout.Pattern.UtcDatePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "w", (object) typeof (log4net.Layout.Pattern.UserNamePatternConverter));
-      PatternLayout.s_globalRulesRegistry.Add((object) "username", (object) typeof (log4net.Layout.Pattern.UserNamePatternConverter));
-    }
-
-    public PatternLayout()
-      : this("%message%newline")
-    {
-    }
-
-    public PatternLayout(string pattern)
-    {
-      this.IgnoresException = true;
-      this.m_pattern = pattern;
-      if (this.m_pattern == null)
-        this.m_pattern = "%message%newline";
-      this.ActivateOptions();
-    }
-
-    public string ConversionPattern
-    {
-      get => this.m_pattern;
-      set => this.m_pattern = value;
-    }
-
-    protected virtual PatternParser CreatePatternParser(string pattern)
-    {
-      PatternParser patternParser = new PatternParser(pattern);
-      foreach (DictionaryEntry dictionaryEntry in PatternLayout.s_globalRulesRegistry)
-        patternParser.PatternConverters[dictionaryEntry.Key] = dictionaryEntry.Value;
-      foreach (DictionaryEntry dictionaryEntry in this.m_instanceRulesRegistry)
-        patternParser.PatternConverters[dictionaryEntry.Key] = dictionaryEntry.Value;
-      return patternParser;
-    }
-
-    public override void ActivateOptions()
-    {
-      this.m_head = this.CreatePatternParser(this.m_pattern).Parse();
-      for (PatternConverter patternConverter = this.m_head; patternConverter != null; patternConverter = patternConverter.Next)
-      {
-        if (patternConverter is PatternLayoutConverter patternLayoutConverter && !patternLayoutConverter.IgnoresException)
-        {
-          this.IgnoresException = false;
-          break;
-        }
-      }
-    }
-
-    public override void Format(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      if (writer == null)
-        throw new ArgumentNullException(nameof (writer));
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      for (PatternConverter patternConverter = this.m_head; patternConverter != null; patternConverter = patternConverter.Next)
-        patternConverter.Format(writer, (object) loggingEvent);
-    }
-
-    public void AddConverter(PatternLayout.ConverterInfo converterInfo)
-    {
-      this.AddConverter(converterInfo.Name, converterInfo.Type);
-    }
-
-    public void AddConverter(string name, Type type)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (type == null)
-        throw new ArgumentNullException(nameof (type));
-      this.m_instanceRulesRegistry[(object) name] = typeof (PatternConverter).IsAssignableFrom(type) ? (object) type : throw new ArgumentException("The converter type specified [" + (object) type + "] must be a subclass of log4net.Util.PatternConverter", nameof (type));
-    }
-
-    public sealed class ConverterInfo
-    {
-      private string m_name;
-      private Type m_type;
-
-      public string Name
-      {
-        get => this.m_name;
-        set => this.m_name = value;
-      }
-
-      public Type Type
-      {
-        get => this.m_type;
-        set => this.m_type = value;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/RawLayoutConverter.cs b/MSHALTester/log4net/Layout/RawLayoutConverter.cs
deleted file mode 100644
index 9ac017c..0000000
--- a/MSHALTester/log4net/Layout/RawLayoutConverter.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-using log4net.Util.TypeConverters;
-using System;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class RawLayoutConverter : IConvertFrom
-  {
-    public bool CanConvertFrom(Type sourceType) => typeof (ILayout).IsAssignableFrom(sourceType);
-
-    public object ConvertFrom(object source)
-    {
-      return source is ILayout layout ? (object) new Layout2RawLayoutAdapter(layout) : throw ConversionNotSupportedException.Create(typeof (IRawLayout), source);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/RawPropertyLayout.cs b/MSHALTester/log4net/Layout/RawPropertyLayout.cs
deleted file mode 100644
index ba9c1e6..0000000
--- a/MSHALTester/log4net/Layout/RawPropertyLayout.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class RawPropertyLayout : IRawLayout
-  {
-    private string m_key;
-
-    public string Key
-    {
-      get => this.m_key;
-      set => this.m_key = value;
-    }
-
-    public virtual object Format(LoggingEvent loggingEvent)
-    {
-      return loggingEvent.LookupProperty(this.m_key);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/RawTimeStampLayout.cs b/MSHALTester/log4net/Layout/RawTimeStampLayout.cs
deleted file mode 100644
index 4f10b59..0000000
--- a/MSHALTester/log4net/Layout/RawTimeStampLayout.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class RawTimeStampLayout : IRawLayout
-  {
-    public virtual object Format(LoggingEvent loggingEvent) => (object) loggingEvent.TimeStamp;
-  }
-}
diff --git a/MSHALTester/log4net/Layout/RawUtcTimeStampLayout.cs b/MSHALTester/log4net/Layout/RawUtcTimeStampLayout.cs
deleted file mode 100644
index 5ddad34..0000000
--- a/MSHALTester/log4net/Layout/RawUtcTimeStampLayout.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class RawUtcTimeStampLayout : IRawLayout
-  {
-    public virtual object Format(LoggingEvent loggingEvent)
-    {
-      return (object) loggingEvent.TimeStamp.ToUniversalTime();
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/SimpleLayout.cs b/MSHALTester/log4net/Layout/SimpleLayout.cs
deleted file mode 100644
index ffea254..0000000
--- a/MSHALTester/log4net/Layout/SimpleLayout.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using log4net.Core;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class SimpleLayout : LayoutSkeleton
-  {
-    public SimpleLayout() => this.IgnoresException = true;
-
-    public override void ActivateOptions()
-    {
-    }
-
-    public override void Format(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      writer.Write(loggingEvent.Level.DisplayName);
-      writer.Write(" - ");
-      loggingEvent.WriteRenderedMessage(writer);
-      writer.WriteLine();
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/XmlLayout.cs b/MSHALTester/log4net/Layout/XmlLayout.cs
deleted file mode 100644
index 8036344..0000000
--- a/MSHALTester/log4net/Layout/XmlLayout.cs
+++ /dev/null
@@ -1,120 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System.Collections;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class XmlLayout : XmlLayoutBase
-  {
-    private const string PREFIX = "log4net";
-    private const string ELM_EVENT = "event";
-    private const string ELM_MESSAGE = "message";
-    private const string ELM_PROPERTIES = "properties";
-    private const string ELM_GLOBAL_PROPERTIES = "global-properties";
-    private const string ELM_DATA = "data";
-    private const string ELM_EXCEPTION = "exception";
-    private const string ELM_LOCATION = "locationInfo";
-    private const string ATTR_LOGGER = "logger";
-    private const string ATTR_TIMESTAMP = "timestamp";
-    private const string ATTR_LEVEL = "level";
-    private const string ATTR_THREAD = "thread";
-    private const string ATTR_DOMAIN = "domain";
-    private const string ATTR_IDENTITY = "identity";
-    private const string ATTR_USERNAME = "username";
-    private const string ATTR_CLASS = "class";
-    private const string ATTR_METHOD = "method";
-    private const string ATTR_FILE = "file";
-    private const string ATTR_LINE = "line";
-    private const string ATTR_NAME = "name";
-    private const string ATTR_VALUE = "value";
-    private string m_prefix = "log4net";
-    private string m_elmEvent = "event";
-    private string m_elmMessage = "message";
-    private string m_elmData = "data";
-    private string m_elmProperties = "properties";
-    private string m_elmGlobalProperties = "global-properties";
-    private string m_elmException = "exception";
-    private string m_elmLocation = "locationInfo";
-
-    public XmlLayout()
-    {
-    }
-
-    public XmlLayout(bool locationInfo)
-      : base(locationInfo)
-    {
-    }
-
-    public string Prefix
-    {
-      get => this.m_prefix;
-      set => this.m_prefix = value;
-    }
-
-    public override void ActivateOptions()
-    {
-      base.ActivateOptions();
-      if (this.m_prefix == null || this.m_prefix.Length <= 0)
-        return;
-      this.m_elmEvent = this.m_prefix + ":event";
-      this.m_elmMessage = this.m_prefix + ":message";
-      this.m_elmProperties = this.m_prefix + ":properties";
-      this.m_elmGlobalProperties = this.m_prefix + ":global-properties";
-      this.m_elmData = this.m_prefix + ":data";
-      this.m_elmException = this.m_prefix + ":exception";
-      this.m_elmLocation = this.m_prefix + ":locationInfo";
-    }
-
-    protected override void FormatXml(XmlWriter writer, LoggingEvent loggingEvent)
-    {
-      writer.WriteStartElement(this.m_elmEvent);
-      writer.WriteAttributeString("logger", loggingEvent.LoggerName);
-      writer.WriteAttributeString("timestamp", XmlConvert.ToString(loggingEvent.TimeStamp));
-      writer.WriteAttributeString("level", loggingEvent.Level.DisplayName);
-      writer.WriteAttributeString("thread", loggingEvent.ThreadName);
-      if (loggingEvent.Domain != null && loggingEvent.Domain.Length > 0)
-        writer.WriteAttributeString("domain", loggingEvent.Domain);
-      if (loggingEvent.Identity != null && loggingEvent.Identity.Length > 0)
-        writer.WriteAttributeString("identity", loggingEvent.Identity);
-      if (loggingEvent.UserName != null && loggingEvent.UserName.Length > 0)
-        writer.WriteAttributeString("username", loggingEvent.UserName);
-      writer.WriteStartElement(this.m_elmMessage);
-      Transform.WriteEscapedXmlString(writer, loggingEvent.RenderedMessage);
-      writer.WriteEndElement();
-      PropertiesDictionary properties = loggingEvent.GetProperties();
-      if (properties.Count > 0)
-      {
-        writer.WriteStartElement(this.m_elmGlobalProperties);
-        foreach (DictionaryEntry dictionaryEntry in (IEnumerable) properties)
-        {
-          writer.WriteStartElement(this.m_elmData);
-          writer.WriteAttributeString("name", (string) dictionaryEntry.Key);
-          string andRender = loggingEvent.Repository.RendererMap.FindAndRender(dictionaryEntry.Value);
-          writer.WriteAttributeString("value", andRender);
-          writer.WriteEndElement();
-        }
-        writer.WriteEndElement();
-      }
-      string exceptionString = loggingEvent.GetExceptionString();
-      if (exceptionString != null && exceptionString.Length > 0)
-      {
-        writer.WriteStartElement(this.m_elmException);
-        Transform.WriteEscapedXmlString(writer, exceptionString);
-        writer.WriteEndElement();
-      }
-      if (this.LocationInfo)
-      {
-        log4net.Core.LocationInfo locationInformation = loggingEvent.LocationInformation;
-        writer.WriteStartElement(this.m_elmLocation);
-        writer.WriteAttributeString("class", locationInformation.ClassName);
-        writer.WriteAttributeString("method", locationInformation.MethodName);
-        writer.WriteAttributeString("file", locationInformation.FileName);
-        writer.WriteAttributeString("line", locationInformation.LineNumber);
-        writer.WriteEndElement();
-      }
-      writer.WriteEndElement();
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Layout/XmlLayoutBase.cs b/MSHALTester/log4net/Layout/XmlLayoutBase.cs
deleted file mode 100644
index 0aaaff1..0000000
--- a/MSHALTester/log4net/Layout/XmlLayoutBase.cs
+++ /dev/null
@@ -1,55 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.IO;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public abstract class XmlLayoutBase : LayoutSkeleton
-  {
-    private bool m_locationInfo = false;
-    private readonly ProtectCloseTextWriter m_protectCloseTextWriter = new ProtectCloseTextWriter((TextWriter) null);
-
-    protected XmlLayoutBase()
-      : this(false)
-    {
-      this.IgnoresException = false;
-    }
-
-    protected XmlLayoutBase(bool locationInfo)
-    {
-      this.IgnoresException = false;
-      this.m_locationInfo = locationInfo;
-    }
-
-    public bool LocationInfo
-    {
-      get => this.m_locationInfo;
-      set => this.m_locationInfo = value;
-    }
-
-    public override void ActivateOptions()
-    {
-    }
-
-    public override string ContentType => "text/xml";
-
-    public override void Format(TextWriter writer, LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      this.m_protectCloseTextWriter.Attach(writer);
-      XmlTextWriter writer1 = new XmlTextWriter((TextWriter) this.m_protectCloseTextWriter);
-      writer1.Formatting = Formatting.None;
-      writer1.Namespaces = false;
-      this.FormatXml((XmlWriter) writer1, loggingEvent);
-      writer1.WriteWhitespace(SystemInfo.NewLine);
-      writer1.Close();
-      this.m_protectCloseTextWriter.Attach((TextWriter) null);
-    }
-
-    protected abstract void FormatXml(XmlWriter writer, LoggingEvent loggingEvent);
-  }
-}
diff --git a/MSHALTester/log4net/Layout/XmlLayoutSchemaLog4j.cs b/MSHALTester/log4net/Layout/XmlLayoutSchemaLog4j.cs
deleted file mode 100644
index 6246037..0000000
--- a/MSHALTester/log4net/Layout/XmlLayoutSchemaLog4j.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Layout
-{
-  public class XmlLayoutSchemaLog4j : XmlLayoutBase
-  {
-    private static readonly DateTime s_date1970 = new DateTime(1970, 1, 1);
-
-    public XmlLayoutSchemaLog4j()
-    {
-    }
-
-    public XmlLayoutSchemaLog4j(bool locationInfo)
-      : base(locationInfo)
-    {
-    }
-
-    public string Version
-    {
-      get => "1.2";
-      set
-      {
-        if (value != "1.2")
-          throw new ArgumentException("Only version 1.2 of the log4j schema is currently supported");
-      }
-    }
-
-    protected override void FormatXml(XmlWriter writer, LoggingEvent loggingEvent)
-    {
-      if (loggingEvent.LookupProperty("log4net:HostName") != null && loggingEvent.LookupProperty("log4jmachinename") == null)
-        loggingEvent.GetProperties()["log4jmachinename"] = loggingEvent.LookupProperty("log4net:HostName");
-      if (loggingEvent.LookupProperty("log4japp") == null && loggingEvent.Domain != null && loggingEvent.Domain.Length > 0)
-        loggingEvent.GetProperties()["log4japp"] = (object) loggingEvent.Domain;
-      if (loggingEvent.Identity != null && loggingEvent.Identity.Length > 0 && loggingEvent.LookupProperty("log4net:Identity") == null)
-        loggingEvent.GetProperties()["log4net:Identity"] = (object) loggingEvent.Identity;
-      if (loggingEvent.UserName != null && loggingEvent.UserName.Length > 0 && loggingEvent.LookupProperty("log4net:UserName") == null)
-        loggingEvent.GetProperties()["log4net:UserName"] = (object) loggingEvent.UserName;
-      writer.WriteStartElement("log4j:event");
-      writer.WriteAttributeString("logger", loggingEvent.LoggerName);
-      TimeSpan timeSpan = loggingEvent.TimeStamp.ToUniversalTime() - XmlLayoutSchemaLog4j.s_date1970;
-      writer.WriteAttributeString("timestamp", XmlConvert.ToString((long) timeSpan.TotalMilliseconds));
-      writer.WriteAttributeString("level", loggingEvent.Level.DisplayName);
-      writer.WriteAttributeString("thread", loggingEvent.ThreadName);
-      writer.WriteStartElement("log4j:message");
-      Transform.WriteEscapedXmlString(writer, loggingEvent.RenderedMessage);
-      writer.WriteEndElement();
-      object obj = loggingEvent.LookupProperty("NDC");
-      if (obj != null)
-      {
-        string andRender = loggingEvent.Repository.RendererMap.FindAndRender(obj);
-        if (andRender != null && andRender.Length > 0)
-        {
-          writer.WriteStartElement("log4j:NDC");
-          Transform.WriteEscapedXmlString(writer, andRender);
-          writer.WriteEndElement();
-        }
-      }
-      PropertiesDictionary properties = loggingEvent.GetProperties();
-      if (properties.Count > 0)
-      {
-        writer.WriteStartElement("log4j:properties");
-        foreach (DictionaryEntry dictionaryEntry in (IEnumerable) properties)
-        {
-          writer.WriteStartElement("log4j:data");
-          writer.WriteAttributeString("name", (string) dictionaryEntry.Key);
-          string andRender = loggingEvent.Repository.RendererMap.FindAndRender(dictionaryEntry.Value);
-          writer.WriteAttributeString("value", andRender);
-          writer.WriteEndElement();
-        }
-        writer.WriteEndElement();
-      }
-      string exceptionString = loggingEvent.GetExceptionString();
-      if (exceptionString != null && exceptionString.Length > 0)
-      {
-        writer.WriteStartElement("log4j:throwable");
-        Transform.WriteEscapedXmlString(writer, exceptionString);
-        writer.WriteEndElement();
-      }
-      if (this.LocationInfo)
-      {
-        log4net.Core.LocationInfo locationInformation = loggingEvent.LocationInformation;
-        writer.WriteStartElement("log4j:locationInfo");
-        writer.WriteAttributeString("class", locationInformation.ClassName);
-        writer.WriteAttributeString("method", locationInformation.MethodName);
-        writer.WriteAttributeString("file", locationInformation.FileName);
-        writer.WriteAttributeString("line", locationInformation.LineNumber);
-        writer.WriteEndElement();
-      }
-      writer.WriteEndElement();
-    }
-  }
-}
diff --git a/MSHALTester/log4net/LogManager.cs b/MSHALTester/log4net/LogManager.cs
deleted file mode 100644
index c35451f..0000000
--- a/MSHALTester/log4net/LogManager.cs
+++ /dev/null
@@ -1,208 +0,0 @@
-using log4net.Core;
-using log4net.Repository;
-using System;
-using System.Reflection;
-
-#nullable disable
-namespace log4net
-{
-  public sealed class LogManager
-  {
-    private static readonly WrapperMap s_wrapperMap = new WrapperMap(new log4net.Core.WrapperCreationHandler(LogManager.WrapperCreationHandler));
-
-    private LogManager()
-    {
-    }
-
-    public static ILog Exists(string name)
-    {
-      return LogManager.Exists(Assembly.GetCallingAssembly(), name);
-    }
-
-    public static ILog Exists(string repository, string name)
-    {
-      return LogManager.WrapLogger(LoggerManager.Exists(repository, name));
-    }
-
-    public static ILog Exists(Assembly repositoryAssembly, string name)
-    {
-      return LogManager.WrapLogger(LoggerManager.Exists(repositoryAssembly, name));
-    }
-
-    public static ILog[] GetCurrentLoggers()
-    {
-      return LogManager.GetCurrentLoggers(Assembly.GetCallingAssembly());
-    }
-
-    public static ILog[] GetCurrentLoggers(string repository)
-    {
-      return LogManager.WrapLoggers(LoggerManager.GetCurrentLoggers(repository));
-    }
-
-    public static ILog[] GetCurrentLoggers(Assembly repositoryAssembly)
-    {
-      return LogManager.WrapLoggers(LoggerManager.GetCurrentLoggers(repositoryAssembly));
-    }
-
-    public static ILog GetLogger(string name)
-    {
-      return LogManager.GetLogger(Assembly.GetCallingAssembly(), name);
-    }
-
-    public static ILog GetLogger(string repository, string name)
-    {
-      return LogManager.WrapLogger(LoggerManager.GetLogger(repository, name));
-    }
-
-    public static ILog GetLogger(Assembly repositoryAssembly, string name)
-    {
-      return LogManager.WrapLogger(LoggerManager.GetLogger(repositoryAssembly, name));
-    }
-
-    public static ILog GetLogger(Type type)
-    {
-      return LogManager.GetLogger(Assembly.GetCallingAssembly(), type.FullName);
-    }
-
-    public static ILog GetLogger(string repository, Type type)
-    {
-      return LogManager.WrapLogger(LoggerManager.GetLogger(repository, type));
-    }
-
-    public static ILog GetLogger(Assembly repositoryAssembly, Type type)
-    {
-      return LogManager.WrapLogger(LoggerManager.GetLogger(repositoryAssembly, type));
-    }
-
-    public static void Shutdown() => LoggerManager.Shutdown();
-
-    public static void ShutdownRepository()
-    {
-      LogManager.ShutdownRepository(Assembly.GetCallingAssembly());
-    }
-
-    public static void ShutdownRepository(string repository)
-    {
-      LoggerManager.ShutdownRepository(repository);
-    }
-
-    public static void ShutdownRepository(Assembly repositoryAssembly)
-    {
-      LoggerManager.ShutdownRepository(repositoryAssembly);
-    }
-
-    public static void ResetConfiguration()
-    {
-      LogManager.ResetConfiguration(Assembly.GetCallingAssembly());
-    }
-
-    public static void ResetConfiguration(string repository)
-    {
-      LoggerManager.ResetConfiguration(repository);
-    }
-
-    public static void ResetConfiguration(Assembly repositoryAssembly)
-    {
-      LoggerManager.ResetConfiguration(repositoryAssembly);
-    }
-
-    [Obsolete("Use GetRepository instead of GetLoggerRepository")]
-    public static ILoggerRepository GetLoggerRepository()
-    {
-      return LogManager.GetRepository(Assembly.GetCallingAssembly());
-    }
-
-    [Obsolete("Use GetRepository instead of GetLoggerRepository")]
-    public static ILoggerRepository GetLoggerRepository(string repository)
-    {
-      return LogManager.GetRepository(repository);
-    }
-
-    [Obsolete("Use GetRepository instead of GetLoggerRepository")]
-    public static ILoggerRepository GetLoggerRepository(Assembly repositoryAssembly)
-    {
-      return LogManager.GetRepository(repositoryAssembly);
-    }
-
-    public static ILoggerRepository GetRepository()
-    {
-      return LogManager.GetRepository(Assembly.GetCallingAssembly());
-    }
-
-    public static ILoggerRepository GetRepository(string repository)
-    {
-      return LoggerManager.GetRepository(repository);
-    }
-
-    public static ILoggerRepository GetRepository(Assembly repositoryAssembly)
-    {
-      return LoggerManager.GetRepository(repositoryAssembly);
-    }
-
-    [Obsolete("Use CreateRepository instead of CreateDomain")]
-    public static ILoggerRepository CreateDomain(Type repositoryType)
-    {
-      return LogManager.CreateRepository(Assembly.GetCallingAssembly(), repositoryType);
-    }
-
-    public static ILoggerRepository CreateRepository(Type repositoryType)
-    {
-      return LogManager.CreateRepository(Assembly.GetCallingAssembly(), repositoryType);
-    }
-
-    [Obsolete("Use CreateRepository instead of CreateDomain")]
-    public static ILoggerRepository CreateDomain(string repository)
-    {
-      return LoggerManager.CreateRepository(repository);
-    }
-
-    public static ILoggerRepository CreateRepository(string repository)
-    {
-      return LoggerManager.CreateRepository(repository);
-    }
-
-    [Obsolete("Use CreateRepository instead of CreateDomain")]
-    public static ILoggerRepository CreateDomain(string repository, Type repositoryType)
-    {
-      return LoggerManager.CreateRepository(repository, repositoryType);
-    }
-
-    public static ILoggerRepository CreateRepository(string repository, Type repositoryType)
-    {
-      return LoggerManager.CreateRepository(repository, repositoryType);
-    }
-
-    [Obsolete("Use CreateRepository instead of CreateDomain")]
-    public static ILoggerRepository CreateDomain(Assembly repositoryAssembly, Type repositoryType)
-    {
-      return LoggerManager.CreateRepository(repositoryAssembly, repositoryType);
-    }
-
-    public static ILoggerRepository CreateRepository(
-      Assembly repositoryAssembly,
-      Type repositoryType)
-    {
-      return LoggerManager.CreateRepository(repositoryAssembly, repositoryType);
-    }
-
-    public static ILoggerRepository[] GetAllRepositories() => LoggerManager.GetAllRepositories();
-
-    private static ILog WrapLogger(ILogger logger)
-    {
-      return (ILog) LogManager.s_wrapperMap.GetWrapper(logger);
-    }
-
-    private static ILog[] WrapLoggers(ILogger[] loggers)
-    {
-      ILog[] logArray = new ILog[loggers.Length];
-      for (int index = 0; index < loggers.Length; ++index)
-        logArray[index] = LogManager.WrapLogger(loggers[index]);
-      return logArray;
-    }
-
-    private static ILoggerWrapper WrapperCreationHandler(ILogger logger)
-    {
-      return (ILoggerWrapper) new LogImpl(logger);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/LogicalThreadContext.cs b/MSHALTester/log4net/LogicalThreadContext.cs
deleted file mode 100644
index 826cff8..0000000
--- a/MSHALTester/log4net/LogicalThreadContext.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using log4net.Util;
-
-#nullable disable
-namespace log4net
-{
-  public sealed class LogicalThreadContext
-  {
-    private static readonly LogicalThreadContextProperties s_properties = new LogicalThreadContextProperties();
-    private static readonly ThreadContextStacks s_stacks = new ThreadContextStacks((ContextPropertiesBase) LogicalThreadContext.s_properties);
-
-    private LogicalThreadContext()
-    {
-    }
-
-    public static LogicalThreadContextProperties Properties => LogicalThreadContext.s_properties;
-
-    public static ThreadContextStacks Stacks => LogicalThreadContext.s_stacks;
-  }
-}
diff --git a/MSHALTester/log4net/MDC.cs b/MSHALTester/log4net/MDC.cs
deleted file mode 100644
index 1403187..0000000
--- a/MSHALTester/log4net/MDC.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-#nullable disable
-namespace log4net
-{
-  public sealed class MDC
-  {
-    private MDC()
-    {
-    }
-
-    public static string Get(string key) => ThreadContext.Properties[key]?.ToString();
-
-    public static void Set(string key, string value)
-    {
-      ThreadContext.Properties[key] = (object) value;
-    }
-
-    public static void Remove(string key) => ThreadContext.Properties.Remove(key);
-
-    public static void Clear() => ThreadContext.Properties.Clear();
-  }
-}
diff --git a/MSHALTester/log4net/NDC.cs b/MSHALTester/log4net/NDC.cs
deleted file mode 100644
index 6d8889b..0000000
--- a/MSHALTester/log4net/NDC.cs
+++ /dev/null
@@ -1,52 +0,0 @@
-using log4net.Util;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net
-{
-  public sealed class NDC
-  {
-    private NDC()
-    {
-    }
-
-    public static int Depth => ThreadContext.Stacks[nameof (NDC)].Count;
-
-    public static void Clear() => ThreadContext.Stacks[nameof (NDC)].Clear();
-
-    public static Stack CloneStack() => ThreadContext.Stacks[nameof (NDC)].InternalStack;
-
-    public static void Inherit(Stack stack)
-    {
-      ThreadContext.Stacks[nameof (NDC)].InternalStack = stack;
-    }
-
-    public static string Pop() => ThreadContext.Stacks[nameof (NDC)].Pop();
-
-    public static IDisposable Push(string message)
-    {
-      return ThreadContext.Stacks[nameof (NDC)].Push(message);
-    }
-
-    public static void Remove()
-    {
-    }
-
-    public static void SetMaxDepth(int maxDepth)
-    {
-      if (maxDepth < 0)
-        return;
-      ThreadContextStack stack = ThreadContext.Stacks[nameof (NDC)];
-      if (maxDepth == 0)
-      {
-        stack.Clear();
-      }
-      else
-      {
-        while (stack.Count > maxDepth)
-          stack.Pop();
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/ObjectRenderer/DefaultRenderer.cs b/MSHALTester/log4net/ObjectRenderer/DefaultRenderer.cs
deleted file mode 100644
index ebbe3fb..0000000
--- a/MSHALTester/log4net/ObjectRenderer/DefaultRenderer.cs
+++ /dev/null
@@ -1,93 +0,0 @@
-using log4net.Util;
-using System;
-using System.Collections;
-using System.IO;
-
-#nullable disable
-namespace log4net.ObjectRenderer
-{
-  public sealed class DefaultRenderer : IObjectRenderer
-  {
-    private static readonly string NewLine = SystemInfo.NewLine;
-
-    public void RenderObject(RendererMap rendererMap, object obj, TextWriter writer)
-    {
-      if (rendererMap == null)
-        throw new ArgumentNullException(nameof (rendererMap));
-      switch (obj)
-      {
-        case null:
-          writer.Write("(null)");
-          break;
-        case Array array:
-          this.RenderArray(rendererMap, array, writer);
-          break;
-        case ICollection collection:
-          this.RenderCollection(rendererMap, collection, writer);
-          break;
-        case DictionaryEntry entry:
-          this.RenderDictionaryEntry(rendererMap, entry, writer);
-          break;
-        default:
-          string str = obj.ToString();
-          writer.Write(str == null ? "(null)" : str);
-          break;
-      }
-    }
-
-    private void RenderArray(RendererMap rendererMap, Array array, TextWriter writer)
-    {
-      if (array.Rank != 1)
-      {
-        writer.Write(array.ToString());
-      }
-      else
-      {
-        writer.Write(array.GetType().Name + " {");
-        int length = array.Length;
-        if (length > 0)
-        {
-          rendererMap.FindAndRender(array.GetValue(0), writer);
-          for (int index = 1; index < length; ++index)
-          {
-            writer.Write(", ");
-            rendererMap.FindAndRender(array.GetValue(index), writer);
-          }
-        }
-        writer.Write("}");
-      }
-    }
-
-    private void RenderCollection(
-      RendererMap rendererMap,
-      ICollection collection,
-      TextWriter writer)
-    {
-      writer.Write("{");
-      if (collection.Count > 0)
-      {
-        IEnumerator enumerator = collection.GetEnumerator();
-        if (enumerator != null && enumerator.MoveNext())
-        {
-          rendererMap.FindAndRender(enumerator.Current, writer);
-          while (enumerator.MoveNext())
-          {
-            writer.Write(", ");
-            rendererMap.FindAndRender(enumerator.Current, writer);
-          }
-        }
-      }
-      writer.Write("}");
-    }
-
-    private void RenderDictionaryEntry(
-      RendererMap rendererMap,
-      DictionaryEntry entry,
-      TextWriter writer)
-    {
-      rendererMap.FindAndRender(entry.Key, writer);
-      writer.Write("=");
-      rendererMap.FindAndRender(entry.Value, writer);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/ObjectRenderer/IObjectRenderer.cs b/MSHALTester/log4net/ObjectRenderer/IObjectRenderer.cs
deleted file mode 100644
index 00b9177..0000000
--- a/MSHALTester/log4net/ObjectRenderer/IObjectRenderer.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace log4net.ObjectRenderer
-{
-  public interface IObjectRenderer
-  {
-    void RenderObject(RendererMap rendererMap, object obj, TextWriter writer);
-  }
-}
diff --git a/MSHALTester/log4net/ObjectRenderer/RendererMap.cs b/MSHALTester/log4net/ObjectRenderer/RendererMap.cs
deleted file mode 100644
index 6e89a01..0000000
--- a/MSHALTester/log4net/ObjectRenderer/RendererMap.cs
+++ /dev/null
@@ -1,118 +0,0 @@
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.ObjectRenderer
-{
-  public class RendererMap
-  {
-    private Hashtable m_map;
-    private Hashtable m_cache = new Hashtable();
-    private static IObjectRenderer s_defaultRenderer = (IObjectRenderer) new log4net.ObjectRenderer.DefaultRenderer();
-
-    public RendererMap() => this.m_map = Hashtable.Synchronized(new Hashtable());
-
-    public string FindAndRender(object obj)
-    {
-      if (obj is string andRender)
-        return andRender;
-      StringWriter writer = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-      this.FindAndRender(obj, (TextWriter) writer);
-      return writer.ToString();
-    }
-
-    public void FindAndRender(object obj, TextWriter writer)
-    {
-      if (obj == null)
-        writer.Write("(null)");
-      else if (obj is string str)
-      {
-        writer.Write(str);
-      }
-      else
-      {
-        try
-        {
-          this.Get(obj.GetType()).RenderObject(this, obj, writer);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("RendererMap: Exception while rendering object of type [" + obj.GetType().FullName + "]", ex);
-          string str1 = "";
-          if (obj != null && obj.GetType() != null)
-            str1 = obj.GetType().FullName;
-          writer.Write("<log4net.Error>Exception rendering object type [" + str1 + "]");
-          if (ex != null)
-          {
-            string str2 = (string) null;
-            try
-            {
-              str2 = ex.ToString();
-            }
-            catch
-            {
-            }
-            writer.Write("<stackTrace>" + str2 + "</stackTrace>");
-          }
-          writer.Write("</log4net.Error>");
-        }
-      }
-    }
-
-    public IObjectRenderer Get(object obj)
-    {
-      return obj == null ? (IObjectRenderer) null : this.Get(obj.GetType());
-    }
-
-    public IObjectRenderer Get(Type type)
-    {
-      IObjectRenderer objectRenderer = type != null ? (IObjectRenderer) this.m_cache[(object) type] : throw new ArgumentNullException(nameof (type));
-      if (objectRenderer == null)
-      {
-        for (Type type1 = type; type1 != null; type1 = type1.BaseType)
-        {
-          objectRenderer = this.SearchTypeAndInterfaces(type1);
-          if (objectRenderer != null)
-            break;
-        }
-        if (objectRenderer == null)
-          objectRenderer = RendererMap.s_defaultRenderer;
-        this.m_cache[(object) type] = (object) objectRenderer;
-      }
-      return objectRenderer;
-    }
-
-    private IObjectRenderer SearchTypeAndInterfaces(Type type)
-    {
-      IObjectRenderer objectRenderer1 = (IObjectRenderer) this.m_map[(object) type];
-      if (objectRenderer1 != null)
-        return objectRenderer1;
-      foreach (Type type1 in type.GetInterfaces())
-      {
-        IObjectRenderer objectRenderer2 = this.SearchTypeAndInterfaces(type1);
-        if (objectRenderer2 != null)
-          return objectRenderer2;
-      }
-      return (IObjectRenderer) null;
-    }
-
-    public IObjectRenderer DefaultRenderer => RendererMap.s_defaultRenderer;
-
-    public void Clear()
-    {
-      this.m_map.Clear();
-      this.m_cache.Clear();
-    }
-
-    public void Put(Type typeToRender, IObjectRenderer renderer)
-    {
-      this.m_cache.Clear();
-      if (typeToRender == null)
-        throw new ArgumentNullException(nameof (typeToRender));
-      this.m_map[(object) typeToRender] = renderer != null ? (object) renderer : throw new ArgumentNullException(nameof (renderer));
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Plugin/IPlugin.cs b/MSHALTester/log4net/Plugin/IPlugin.cs
deleted file mode 100644
index dbf3b8b..0000000
--- a/MSHALTester/log4net/Plugin/IPlugin.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using log4net.Repository;
-
-#nullable disable
-namespace log4net.Plugin
-{
-  public interface IPlugin
-  {
-    string Name { get; }
-
-    void Attach(ILoggerRepository repository);
-
-    void Shutdown();
-  }
-}
diff --git a/MSHALTester/log4net/Plugin/IPluginFactory.cs b/MSHALTester/log4net/Plugin/IPluginFactory.cs
deleted file mode 100644
index 808291b..0000000
--- a/MSHALTester/log4net/Plugin/IPluginFactory.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace log4net.Plugin
-{
-  public interface IPluginFactory
-  {
-    IPlugin CreatePlugin();
-  }
-}
diff --git a/MSHALTester/log4net/Plugin/PluginCollection.cs b/MSHALTester/log4net/Plugin/PluginCollection.cs
deleted file mode 100644
index 6703950..0000000
--- a/MSHALTester/log4net/Plugin/PluginCollection.cs
+++ /dev/null
@@ -1,387 +0,0 @@
-using log4net.Util;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Plugin
-{
-  public class PluginCollection : IList, ICollection, IEnumerable, ICloneable
-  {
-    private const int DEFAULT_CAPACITY = 16;
-    private IPlugin[] m_array;
-    private int m_count = 0;
-    private int m_version = 0;
-
-    public static PluginCollection ReadOnly(PluginCollection list)
-    {
-      return list != null ? (PluginCollection) new PluginCollection.ReadOnlyPluginCollection(list) : throw new ArgumentNullException(nameof (list));
-    }
-
-    public PluginCollection() => this.m_array = new IPlugin[16];
-
-    public PluginCollection(int capacity) => this.m_array = new IPlugin[capacity];
-
-    public PluginCollection(PluginCollection c)
-    {
-      this.m_array = new IPlugin[c.Count];
-      this.AddRange(c);
-    }
-
-    public PluginCollection(IPlugin[] a)
-    {
-      this.m_array = new IPlugin[a.Length];
-      this.AddRange(a);
-    }
-
-    public PluginCollection(ICollection col)
-    {
-      this.m_array = new IPlugin[col.Count];
-      this.AddRange(col);
-    }
-
-    protected internal PluginCollection(PluginCollection.Tag tag)
-    {
-      this.m_array = (IPlugin[]) null;
-    }
-
-    public virtual int Count => this.m_count;
-
-    public virtual void CopyTo(IPlugin[] array) => this.CopyTo(array, 0);
-
-    public virtual void CopyTo(IPlugin[] array, int start)
-    {
-      if (this.m_count > array.GetUpperBound(0) + 1 - start)
-        throw new ArgumentException("Destination array was not long enough.");
-      Array.Copy((Array) this.m_array, 0, (Array) array, start, this.m_count);
-    }
-
-    public virtual bool IsSynchronized => this.m_array.IsSynchronized;
-
-    public virtual object SyncRoot => this.m_array.SyncRoot;
-
-    public virtual IPlugin this[int index]
-    {
-      get
-      {
-        this.ValidateIndex(index);
-        return this.m_array[index];
-      }
-      set
-      {
-        this.ValidateIndex(index);
-        ++this.m_version;
-        this.m_array[index] = value;
-      }
-    }
-
-    public virtual int Add(IPlugin item)
-    {
-      if (this.m_count == this.m_array.Length)
-        this.EnsureCapacity(this.m_count + 1);
-      this.m_array[this.m_count] = item;
-      ++this.m_version;
-      return this.m_count++;
-    }
-
-    public virtual void Clear()
-    {
-      ++this.m_version;
-      this.m_array = new IPlugin[16];
-      this.m_count = 0;
-    }
-
-    public virtual object Clone()
-    {
-      PluginCollection pluginCollection = new PluginCollection(this.m_count);
-      Array.Copy((Array) this.m_array, 0, (Array) pluginCollection.m_array, 0, this.m_count);
-      pluginCollection.m_count = this.m_count;
-      pluginCollection.m_version = this.m_version;
-      return (object) pluginCollection;
-    }
-
-    public virtual bool Contains(IPlugin item)
-    {
-      for (int index = 0; index != this.m_count; ++index)
-      {
-        if (this.m_array[index].Equals((object) item))
-          return true;
-      }
-      return false;
-    }
-
-    public virtual int IndexOf(IPlugin item)
-    {
-      for (int index = 0; index != this.m_count; ++index)
-      {
-        if (this.m_array[index].Equals((object) item))
-          return index;
-      }
-      return -1;
-    }
-
-    public virtual void Insert(int index, IPlugin item)
-    {
-      this.ValidateIndex(index, true);
-      if (this.m_count == this.m_array.Length)
-        this.EnsureCapacity(this.m_count + 1);
-      if (index < this.m_count)
-        Array.Copy((Array) this.m_array, index, (Array) this.m_array, index + 1, this.m_count - index);
-      this.m_array[index] = item;
-      ++this.m_count;
-      ++this.m_version;
-    }
-
-    public virtual void Remove(IPlugin item)
-    {
-      int index = this.IndexOf(item);
-      if (index < 0)
-        throw new ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");
-      ++this.m_version;
-      this.RemoveAt(index);
-    }
-
-    public virtual void RemoveAt(int index)
-    {
-      this.ValidateIndex(index);
-      --this.m_count;
-      if (index < this.m_count)
-        Array.Copy((Array) this.m_array, index + 1, (Array) this.m_array, index, this.m_count - index);
-      Array.Copy((Array) new IPlugin[1], 0, (Array) this.m_array, this.m_count, 1);
-      ++this.m_version;
-    }
-
-    public virtual bool IsFixedSize => false;
-
-    public virtual bool IsReadOnly => false;
-
-    public virtual PluginCollection.IPluginCollectionEnumerator GetEnumerator()
-    {
-      return (PluginCollection.IPluginCollectionEnumerator) new PluginCollection.Enumerator(this);
-    }
-
-    public virtual int Capacity
-    {
-      get => this.m_array.Length;
-      set
-      {
-        if (value < this.m_count)
-          value = this.m_count;
-        if (value == this.m_array.Length)
-          return;
-        if (value > 0)
-        {
-          IPlugin[] destinationArray = new IPlugin[value];
-          Array.Copy((Array) this.m_array, 0, (Array) destinationArray, 0, this.m_count);
-          this.m_array = destinationArray;
-        }
-        else
-          this.m_array = new IPlugin[16];
-      }
-    }
-
-    public virtual int AddRange(PluginCollection x)
-    {
-      if (this.m_count + x.Count >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + x.Count);
-      Array.Copy((Array) x.m_array, 0, (Array) this.m_array, this.m_count, x.Count);
-      this.m_count += x.Count;
-      ++this.m_version;
-      return this.m_count;
-    }
-
-    public virtual int AddRange(IPlugin[] x)
-    {
-      if (this.m_count + x.Length >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + x.Length);
-      Array.Copy((Array) x, 0, (Array) this.m_array, this.m_count, x.Length);
-      this.m_count += x.Length;
-      ++this.m_version;
-      return this.m_count;
-    }
-
-    public virtual int AddRange(ICollection col)
-    {
-      if (this.m_count + col.Count >= this.m_array.Length)
-        this.EnsureCapacity(this.m_count + col.Count);
-      foreach (IPlugin plugin in (IEnumerable) col)
-        this.Add(plugin);
-      return this.m_count;
-    }
-
-    public virtual void TrimToSize() => this.Capacity = this.m_count;
-
-    private void ValidateIndex(int i) => this.ValidateIndex(i, false);
-
-    private void ValidateIndex(int i, bool allowEqualEnd)
-    {
-      int num = allowEqualEnd ? this.m_count : this.m_count - 1;
-      if (i < 0 || i > num)
-        throw SystemInfo.CreateArgumentOutOfRangeException(nameof (i), (object) i, "Index was out of range. Must be non-negative and less than the size of the collection. [" + (object) i + "] Specified argument was out of the range of valid values.");
-    }
-
-    private void EnsureCapacity(int min)
-    {
-      int num = this.m_array.Length == 0 ? 16 : this.m_array.Length * 2;
-      if (num < min)
-        num = min;
-      this.Capacity = num;
-    }
-
-    void ICollection.CopyTo(Array array, int start)
-    {
-      Array.Copy((Array) this.m_array, 0, array, start, this.m_count);
-    }
-
-    object IList.this[int i]
-    {
-      get => (object) this[i];
-      set => this[i] = (IPlugin) value;
-    }
-
-    int IList.Add(object x) => this.Add((IPlugin) x);
-
-    bool IList.Contains(object x) => this.Contains((IPlugin) x);
-
-    int IList.IndexOf(object x) => this.IndexOf((IPlugin) x);
-
-    void IList.Insert(int pos, object x) => this.Insert(pos, (IPlugin) x);
-
-    void IList.Remove(object x) => this.Remove((IPlugin) x);
-
-    void IList.RemoveAt(int pos) => this.RemoveAt(pos);
-
-    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();
-
-    public interface IPluginCollectionEnumerator
-    {
-      IPlugin Current { get; }
-
-      bool MoveNext();
-
-      void Reset();
-    }
-
-    protected internal enum Tag
-    {
-      Default,
-    }
-
-    private sealed class Enumerator : IEnumerator, PluginCollection.IPluginCollectionEnumerator
-    {
-      private readonly PluginCollection m_collection;
-      private int m_index;
-      private int m_version;
-
-      internal Enumerator(PluginCollection tc)
-      {
-        this.m_collection = tc;
-        this.m_index = -1;
-        this.m_version = tc.m_version;
-      }
-
-      public IPlugin Current => this.m_collection[this.m_index];
-
-      public bool MoveNext()
-      {
-        if (this.m_version != this.m_collection.m_version)
-          throw new InvalidOperationException("Collection was modified; enumeration operation may not execute.");
-        ++this.m_index;
-        return this.m_index < this.m_collection.Count;
-      }
-
-      public void Reset() => this.m_index = -1;
-
-      object IEnumerator.Current => (object) this.Current;
-    }
-
-    private sealed class ReadOnlyPluginCollection : PluginCollection
-    {
-      private readonly PluginCollection m_collection;
-
-      internal ReadOnlyPluginCollection(PluginCollection list)
-        : base(PluginCollection.Tag.Default)
-      {
-        this.m_collection = list;
-      }
-
-      public override void CopyTo(IPlugin[] array) => this.m_collection.CopyTo(array);
-
-      public override void CopyTo(IPlugin[] array, int start)
-      {
-        this.m_collection.CopyTo(array, start);
-      }
-
-      public override int Count => this.m_collection.Count;
-
-      public override bool IsSynchronized => this.m_collection.IsSynchronized;
-
-      public override object SyncRoot => this.m_collection.SyncRoot;
-
-      public override IPlugin this[int i]
-      {
-        get => this.m_collection[i];
-        set
-        {
-          throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-        }
-      }
-
-      public override int Add(IPlugin x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void Clear()
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override bool Contains(IPlugin x) => this.m_collection.Contains(x);
-
-      public override int IndexOf(IPlugin x) => this.m_collection.IndexOf(x);
-
-      public override void Insert(int pos, IPlugin x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void Remove(IPlugin x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override void RemoveAt(int pos)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override bool IsFixedSize => true;
-
-      public override bool IsReadOnly => true;
-
-      public override PluginCollection.IPluginCollectionEnumerator GetEnumerator()
-      {
-        return this.m_collection.GetEnumerator();
-      }
-
-      public override int Capacity
-      {
-        get => this.m_collection.Capacity;
-        set
-        {
-          throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-        }
-      }
-
-      public override int AddRange(PluginCollection x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-
-      public override int AddRange(IPlugin[] x)
-      {
-        throw new NotSupportedException("This is a Read Only Collection and can not be modified");
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Plugin/PluginMap.cs b/MSHALTester/log4net/Plugin/PluginMap.cs
deleted file mode 100644
index bfaf27d..0000000
--- a/MSHALTester/log4net/Plugin/PluginMap.cs
+++ /dev/null
@@ -1,57 +0,0 @@
-using log4net.Repository;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Plugin
-{
-  public sealed class PluginMap
-  {
-    private readonly Hashtable m_mapName2Plugin = new Hashtable();
-    private readonly ILoggerRepository m_repository;
-
-    public PluginMap(ILoggerRepository repository) => this.m_repository = repository;
-
-    public IPlugin this[string name]
-    {
-      get
-      {
-        if (name == null)
-          throw new ArgumentNullException(nameof (name));
-        lock (this)
-          return (IPlugin) this.m_mapName2Plugin[(object) name];
-      }
-    }
-
-    public PluginCollection AllPlugins
-    {
-      get
-      {
-        lock (this)
-          return new PluginCollection(this.m_mapName2Plugin.Values);
-      }
-    }
-
-    public void Add(IPlugin plugin)
-    {
-      if (plugin == null)
-        throw new ArgumentNullException(nameof (plugin));
-      IPlugin plugin1 = (IPlugin) null;
-      lock (this)
-      {
-        plugin1 = this.m_mapName2Plugin[(object) plugin.Name] as IPlugin;
-        this.m_mapName2Plugin[(object) plugin.Name] = (object) plugin;
-      }
-      plugin1?.Shutdown();
-      plugin.Attach(this.m_repository);
-    }
-
-    public void Remove(IPlugin plugin)
-    {
-      if (plugin == null)
-        throw new ArgumentNullException(nameof (plugin));
-      lock (this)
-        this.m_mapName2Plugin.Remove((object) plugin.Name);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Plugin/PluginSkeleton.cs b/MSHALTester/log4net/Plugin/PluginSkeleton.cs
deleted file mode 100644
index 2b0d8ba..0000000
--- a/MSHALTester/log4net/Plugin/PluginSkeleton.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-using log4net.Repository;
-
-#nullable disable
-namespace log4net.Plugin
-{
-  public abstract class PluginSkeleton : IPlugin
-  {
-    private string m_name;
-    private ILoggerRepository m_repository;
-
-    protected PluginSkeleton(string name) => this.m_name = name;
-
-    public virtual string Name
-    {
-      get => this.m_name;
-      set => this.m_name = value;
-    }
-
-    public virtual void Attach(ILoggerRepository repository) => this.m_repository = repository;
-
-    public virtual void Shutdown()
-    {
-    }
-
-    protected virtual ILoggerRepository LoggerRepository
-    {
-      get => this.m_repository;
-      set => this.m_repository = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Plugin/RemoteLoggingServerPlugin.cs b/MSHALTester/log4net/Plugin/RemoteLoggingServerPlugin.cs
deleted file mode 100644
index e0bcf0e..0000000
--- a/MSHALTester/log4net/Plugin/RemoteLoggingServerPlugin.cs
+++ /dev/null
@@ -1,74 +0,0 @@
-using log4net.Appender;
-using log4net.Core;
-using log4net.Repository;
-using log4net.Util;
-using System;
-using System.Runtime.Remoting;
-
-#nullable disable
-namespace log4net.Plugin
-{
-  public class RemoteLoggingServerPlugin : PluginSkeleton
-  {
-    private RemoteLoggingServerPlugin.RemoteLoggingSinkImpl m_sink;
-    private string m_sinkUri;
-
-    public RemoteLoggingServerPlugin()
-      : base("RemoteLoggingServerPlugin:Unset URI")
-    {
-    }
-
-    public RemoteLoggingServerPlugin(string sinkUri)
-      : base("RemoteLoggingServerPlugin:" + sinkUri)
-    {
-      this.m_sinkUri = sinkUri;
-    }
-
-    public virtual string SinkUri
-    {
-      get => this.m_sinkUri;
-      set => this.m_sinkUri = value;
-    }
-
-    public override void Attach(ILoggerRepository repository)
-    {
-      base.Attach(repository);
-      this.m_sink = new RemoteLoggingServerPlugin.RemoteLoggingSinkImpl(repository);
-      try
-      {
-        RemotingServices.Marshal((MarshalByRefObject) this.m_sink, this.m_sinkUri, typeof (RemotingAppender.IRemoteLoggingSink));
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("RemoteLoggingServerPlugin: Failed to Marshal remoting sink", ex);
-      }
-    }
-
-    public override void Shutdown()
-    {
-      RemotingServices.Disconnect((MarshalByRefObject) this.m_sink);
-      this.m_sink = (RemoteLoggingServerPlugin.RemoteLoggingSinkImpl) null;
-      base.Shutdown();
-    }
-
-    private class RemoteLoggingSinkImpl : MarshalByRefObject, RemotingAppender.IRemoteLoggingSink
-    {
-      private readonly ILoggerRepository m_repository;
-
-      public RemoteLoggingSinkImpl(ILoggerRepository repository) => this.m_repository = repository;
-
-      public void LogEvents(LoggingEvent[] events)
-      {
-        if (events == null)
-          return;
-        foreach (LoggingEvent logEvent in events)
-        {
-          if (logEvent != null)
-            this.m_repository.Log(logEvent);
-        }
-      }
-
-      public override object InitializeLifetimeService() => (object) null;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/DefaultLoggerFactory.cs b/MSHALTester/log4net/Repository/Hierarchy/DefaultLoggerFactory.cs
deleted file mode 100644
index 4de49d8..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/DefaultLoggerFactory.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  internal class DefaultLoggerFactory : ILoggerFactory
-  {
-    internal DefaultLoggerFactory()
-    {
-    }
-
-    public Logger CreateLogger(string name)
-    {
-      return name == null ? (Logger) new RootLogger(Level.Debug) : (Logger) new DefaultLoggerFactory.LoggerImpl(name);
-    }
-
-    internal sealed class LoggerImpl : Logger
-    {
-      internal LoggerImpl(string name)
-        : base(name)
-      {
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/Hierarchy.cs b/MSHALTester/log4net/Repository/Hierarchy/Hierarchy.cs
deleted file mode 100644
index 1c18576..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/Hierarchy.cs
+++ /dev/null
@@ -1,337 +0,0 @@
-using log4net.Appender;
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  public class Hierarchy : 
-    LoggerRepositorySkeleton,
-    IBasicRepositoryConfigurator,
-    IXmlRepositoryConfigurator
-  {
-    private ILoggerFactory m_defaultFactory;
-    private Hashtable m_ht;
-    private Logger m_root;
-    private bool m_emittedNoAppenderWarning = false;
-
-    public event LoggerCreationEventHandler LoggerCreatedEvent
-    {
-      add => this.m_loggerCreatedEvent += value;
-      remove => this.m_loggerCreatedEvent -= value;
-    }
-
-    public Hierarchy()
-      : this((ILoggerFactory) new DefaultLoggerFactory())
-    {
-    }
-
-    public Hierarchy(PropertiesDictionary properties)
-      : this(properties, (ILoggerFactory) new DefaultLoggerFactory())
-    {
-    }
-
-    public Hierarchy(ILoggerFactory loggerFactory)
-      : this(new PropertiesDictionary(), loggerFactory)
-    {
-    }
-
-    public Hierarchy(PropertiesDictionary properties, ILoggerFactory loggerFactory)
-      : base(properties)
-    {
-      this.m_defaultFactory = loggerFactory != null ? loggerFactory : throw new ArgumentNullException(nameof (loggerFactory));
-      this.m_ht = Hashtable.Synchronized(new Hashtable());
-    }
-
-    public bool EmittedNoAppenderWarning
-    {
-      get => this.m_emittedNoAppenderWarning;
-      set => this.m_emittedNoAppenderWarning = value;
-    }
-
-    public Logger Root
-    {
-      get
-      {
-        if (this.m_root == null)
-        {
-          lock (this)
-          {
-            if (this.m_root == null)
-            {
-              Logger logger = this.m_defaultFactory.CreateLogger((string) null);
-              logger.Hierarchy = this;
-              this.m_root = logger;
-            }
-          }
-        }
-        return this.m_root;
-      }
-    }
-
-    public ILoggerFactory LoggerFactory
-    {
-      get => this.m_defaultFactory;
-      set
-      {
-        this.m_defaultFactory = value != null ? value : throw new ArgumentNullException(nameof (value));
-      }
-    }
-
-    public override ILogger Exists(string name)
-    {
-      return name != null ? (ILogger) (this.m_ht[(object) new LoggerKey(name)] as Logger) : throw new ArgumentNullException(nameof (name));
-    }
-
-    public override ILogger[] GetCurrentLoggers()
-    {
-      ArrayList arrayList = new ArrayList(this.m_ht.Count);
-      foreach (object obj in (IEnumerable) this.m_ht.Values)
-      {
-        if (obj is Logger)
-          arrayList.Add(obj);
-      }
-      return (ILogger[]) arrayList.ToArray(typeof (Logger));
-    }
-
-    public override ILogger GetLogger(string name)
-    {
-      return name != null ? (ILogger) this.GetLogger(name, this.m_defaultFactory) : throw new ArgumentNullException(nameof (name));
-    }
-
-    public override void Shutdown()
-    {
-      LogLog.Debug("Hierarchy: Shutdown called on Hierarchy [" + this.Name + "]");
-      this.Root.CloseNestedAppenders();
-      lock (this.m_ht)
-      {
-        ILogger[] currentLoggers = this.GetCurrentLoggers();
-        foreach (Logger logger in currentLoggers)
-          logger.CloseNestedAppenders();
-        this.Root.RemoveAllAppenders();
-        foreach (Logger logger in currentLoggers)
-          logger.RemoveAllAppenders();
-      }
-      base.Shutdown();
-    }
-
-    public override void ResetConfiguration()
-    {
-      this.Root.Level = Level.Debug;
-      this.Threshold = Level.All;
-      lock (this.m_ht)
-      {
-        this.Shutdown();
-        foreach (Logger currentLogger in this.GetCurrentLoggers())
-        {
-          currentLogger.Level = (Level) null;
-          currentLogger.Additivity = true;
-        }
-      }
-      base.ResetConfiguration();
-      this.OnConfigurationChanged((EventArgs) null);
-    }
-
-    public override void Log(LoggingEvent logEvent)
-    {
-      if (logEvent == null)
-        throw new ArgumentNullException(nameof (logEvent));
-      this.GetLogger(logEvent.LoggerName, this.m_defaultFactory).Log(logEvent);
-    }
-
-    public override IAppender[] GetAppenders()
-    {
-      ArrayList appenderList = new ArrayList();
-      log4net.Repository.Hierarchy.Hierarchy.CollectAppenders(appenderList, (IAppenderAttachable) this.Root);
-      foreach (Logger currentLogger in this.GetCurrentLoggers())
-        log4net.Repository.Hierarchy.Hierarchy.CollectAppenders(appenderList, (IAppenderAttachable) currentLogger);
-      return (IAppender[]) appenderList.ToArray(typeof (IAppender));
-    }
-
-    private static void CollectAppender(ArrayList appenderList, IAppender appender)
-    {
-      if (appenderList.Contains((object) appender))
-        return;
-      appenderList.Add((object) appender);
-      if (!(appender is IAppenderAttachable container))
-        return;
-      log4net.Repository.Hierarchy.Hierarchy.CollectAppenders(appenderList, container);
-    }
-
-    private static void CollectAppenders(ArrayList appenderList, IAppenderAttachable container)
-    {
-      foreach (IAppender appender in container.Appenders)
-        log4net.Repository.Hierarchy.Hierarchy.CollectAppender(appenderList, appender);
-    }
-
-    void IBasicRepositoryConfigurator.Configure(IAppender appender)
-    {
-      this.BasicRepositoryConfigure(appender);
-    }
-
-    protected void BasicRepositoryConfigure(IAppender appender)
-    {
-      this.Root.AddAppender(appender);
-      this.Configured = true;
-      this.OnConfigurationChanged((EventArgs) null);
-    }
-
-    void IXmlRepositoryConfigurator.Configure(XmlElement element)
-    {
-      this.XmlRepositoryConfigure(element);
-    }
-
-    protected void XmlRepositoryConfigure(XmlElement element)
-    {
-      new XmlHierarchyConfigurator(this).Configure(element);
-      this.Configured = true;
-      this.OnConfigurationChanged((EventArgs) null);
-    }
-
-    public bool IsDisabled(Level level)
-    {
-      if ((object) level == null)
-        throw new ArgumentNullException(nameof (level));
-      return !this.Configured || this.Threshold > level;
-    }
-
-    public void Clear() => this.m_ht.Clear();
-
-    public Logger GetLogger(string name, ILoggerFactory factory)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (factory == null)
-        throw new ArgumentNullException(nameof (factory));
-      LoggerKey key = new LoggerKey(name);
-      lock (this.m_ht)
-      {
-        switch (this.m_ht[(object) key])
-        {
-          case null:
-            Logger logger1 = factory.CreateLogger(name);
-            logger1.Hierarchy = this;
-            this.m_ht[(object) key] = (object) logger1;
-            this.UpdateParents(logger1);
-            this.OnLoggerCreationEvent(logger1);
-            return logger1;
-          case Logger logger3:
-            return logger3;
-          case ProvisionNode pn:
-            Logger logger2 = factory.CreateLogger(name);
-            logger2.Hierarchy = this;
-            this.m_ht[(object) key] = (object) logger2;
-            this.UpdateChildren(pn, logger2);
-            this.UpdateParents(logger2);
-            this.OnLoggerCreationEvent(logger2);
-            return logger2;
-          default:
-            return (Logger) null;
-        }
-      }
-    }
-
-    protected virtual void OnLoggerCreationEvent(Logger logger)
-    {
-      LoggerCreationEventHandler loggerCreatedEvent = this.m_loggerCreatedEvent;
-      if (loggerCreatedEvent == null)
-        return;
-      loggerCreatedEvent((object) this, new LoggerCreationEventArgs(logger));
-    }
-
-    private void UpdateParents(Logger log)
-    {
-      string name = log.Name;
-      int length1 = name.Length;
-      bool flag = false;
-      for (int length2 = name.LastIndexOf('.', length1 - 1); length2 >= 0; length2 = name.LastIndexOf('.', length2 - 1))
-      {
-        LoggerKey key = new LoggerKey(name.Substring(0, length2));
-        object obj = this.m_ht[(object) key];
-        switch (obj)
-        {
-          case null:
-            ProvisionNode provisionNode1 = new ProvisionNode(log);
-            this.m_ht[(object) key] = (object) provisionNode1;
-            break;
-          case Logger logger:
-            flag = true;
-            log.Parent = logger;
-            goto label_8;
-          case ProvisionNode provisionNode2:
-            provisionNode2.Add((object) log);
-            break;
-          default:
-            LogLog.Error("Hierarchy: Unexpected object type [" + (object) obj.GetType() + "] in ht.", (Exception) new LogException());
-            break;
-        }
-      }
-label_8:
-      if (flag)
-        return;
-      log.Parent = this.Root;
-    }
-
-    private void UpdateChildren(ProvisionNode pn, Logger log)
-    {
-      for (int index = 0; index < pn.Count; ++index)
-      {
-        Logger logger = (Logger) pn[index];
-        if (!logger.Parent.Name.StartsWith(log.Name))
-        {
-          log.Parent = logger.Parent;
-          logger.Parent = log;
-        }
-      }
-    }
-
-    internal void AddLevel(log4net.Repository.Hierarchy.Hierarchy.LevelEntry levelEntry)
-    {
-      if (levelEntry == null)
-        throw new ArgumentNullException(nameof (levelEntry));
-      if (levelEntry.Name == null)
-        throw new ArgumentNullException("levelEntry.Name");
-      if (levelEntry.Value == -1)
-      {
-        Level level = this.LevelMap[levelEntry.Name];
-        levelEntry.Value = !(level == (Level) null) ? level.Value : throw new InvalidOperationException("Cannot redefine level [" + levelEntry.Name + "] because it is not defined in the LevelMap. To define the level supply the level value.");
-      }
-      this.LevelMap.Add(levelEntry.Name, levelEntry.Value, levelEntry.DisplayName);
-    }
-
-    private event LoggerCreationEventHandler m_loggerCreatedEvent;
-
-    internal class LevelEntry
-    {
-      private int m_levelValue = -1;
-      private string m_levelName = (string) null;
-      private string m_levelDisplayName = (string) null;
-
-      public int Value
-      {
-        get => this.m_levelValue;
-        set => this.m_levelValue = value;
-      }
-
-      public string Name
-      {
-        get => this.m_levelName;
-        set => this.m_levelName = value;
-      }
-
-      public string DisplayName
-      {
-        get => this.m_levelDisplayName;
-        set => this.m_levelDisplayName = value;
-      }
-
-      public override string ToString()
-      {
-        return "LevelEntry(Value=" + (object) this.m_levelValue + ", Name=" + this.m_levelName + ", DisplayName=" + this.m_levelDisplayName + ")";
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/ILoggerFactory.cs b/MSHALTester/log4net/Repository/Hierarchy/ILoggerFactory.cs
deleted file mode 100644
index 7de66dc..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/ILoggerFactory.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  public interface ILoggerFactory
-  {
-    Logger CreateLogger(string name);
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/Logger.cs b/MSHALTester/log4net/Repository/Hierarchy/Logger.cs
deleted file mode 100644
index 177e687..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/Logger.cs
+++ /dev/null
@@ -1,269 +0,0 @@
-using log4net.Appender;
-using log4net.Core;
-using log4net.Util;
-using System;
-using System.Security;
-
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  public abstract class Logger : IAppenderAttachable, ILogger
-  {
-    private static readonly Type ThisDeclaringType = typeof (Logger);
-    private readonly string m_name;
-    private Level m_level;
-    private Logger m_parent;
-    private log4net.Repository.Hierarchy.Hierarchy m_hierarchy;
-    private AppenderAttachedImpl m_appenderAttachedImpl;
-    private bool m_additive = true;
-    private readonly ReaderWriterLock m_appenderLock = new ReaderWriterLock();
-
-    protected Logger(string name) => this.m_name = string.Intern(name);
-
-    public virtual Logger Parent
-    {
-      get => this.m_parent;
-      set => this.m_parent = value;
-    }
-
-    public virtual bool Additivity
-    {
-      get => this.m_additive;
-      set => this.m_additive = value;
-    }
-
-    public virtual Level EffectiveLevel
-    {
-      get
-      {
-        for (Logger logger = this; logger != null; logger = logger.m_parent)
-        {
-          Level level = logger.m_level;
-          if ((object) level != null)
-            return level;
-        }
-        return (Level) null;
-      }
-    }
-
-    public virtual log4net.Repository.Hierarchy.Hierarchy Hierarchy
-    {
-      get => this.m_hierarchy;
-      set => this.m_hierarchy = value;
-    }
-
-    public virtual Level Level
-    {
-      get => this.m_level;
-      set => this.m_level = value;
-    }
-
-    public virtual void AddAppender(IAppender newAppender)
-    {
-      if (newAppender == null)
-        throw new ArgumentNullException(nameof (newAppender));
-      this.m_appenderLock.AcquireWriterLock();
-      try
-      {
-        if (this.m_appenderAttachedImpl == null)
-          this.m_appenderAttachedImpl = new AppenderAttachedImpl();
-        this.m_appenderAttachedImpl.AddAppender(newAppender);
-      }
-      finally
-      {
-        this.m_appenderLock.ReleaseWriterLock();
-      }
-    }
-
-    public virtual AppenderCollection Appenders
-    {
-      get
-      {
-        this.m_appenderLock.AcquireReaderLock();
-        try
-        {
-          return this.m_appenderAttachedImpl == null ? AppenderCollection.EmptyCollection : this.m_appenderAttachedImpl.Appenders;
-        }
-        finally
-        {
-          this.m_appenderLock.ReleaseReaderLock();
-        }
-      }
-    }
-
-    public virtual IAppender GetAppender(string name)
-    {
-      this.m_appenderLock.AcquireReaderLock();
-      try
-      {
-        return this.m_appenderAttachedImpl == null || name == null ? (IAppender) null : this.m_appenderAttachedImpl.GetAppender(name);
-      }
-      finally
-      {
-        this.m_appenderLock.ReleaseReaderLock();
-      }
-    }
-
-    public virtual void RemoveAllAppenders()
-    {
-      this.m_appenderLock.AcquireWriterLock();
-      try
-      {
-        if (this.m_appenderAttachedImpl == null)
-          return;
-        this.m_appenderAttachedImpl.RemoveAllAppenders();
-        this.m_appenderAttachedImpl = (AppenderAttachedImpl) null;
-      }
-      finally
-      {
-        this.m_appenderLock.ReleaseWriterLock();
-      }
-    }
-
-    public virtual IAppender RemoveAppender(IAppender appender)
-    {
-      this.m_appenderLock.AcquireWriterLock();
-      try
-      {
-        if (appender != null)
-        {
-          if (this.m_appenderAttachedImpl != null)
-            return this.m_appenderAttachedImpl.RemoveAppender(appender);
-        }
-      }
-      finally
-      {
-        this.m_appenderLock.ReleaseWriterLock();
-      }
-      return (IAppender) null;
-    }
-
-    public virtual IAppender RemoveAppender(string name)
-    {
-      this.m_appenderLock.AcquireWriterLock();
-      try
-      {
-        if (name != null)
-        {
-          if (this.m_appenderAttachedImpl != null)
-            return this.m_appenderAttachedImpl.RemoveAppender(name);
-        }
-      }
-      finally
-      {
-        this.m_appenderLock.ReleaseWriterLock();
-      }
-      return (IAppender) null;
-    }
-
-    public virtual string Name => this.m_name;
-
-    public virtual void Log(
-      Type callerStackBoundaryDeclaringType,
-      Level level,
-      object message,
-      Exception exception)
-    {
-      if (!this.IsEnabledFor(level))
-        return;
-      this.ForcedLog(callerStackBoundaryDeclaringType != null ? callerStackBoundaryDeclaringType : Logger.ThisDeclaringType, level, message, exception);
-    }
-
-    public virtual void Log(LoggingEvent logEvent)
-    {
-      if (logEvent == null)
-        throw new ArgumentNullException(nameof (logEvent));
-      if (!this.IsEnabledFor(logEvent.Level))
-        return;
-      this.ForcedLog(logEvent);
-    }
-
-    public virtual bool IsEnabledFor(Level level)
-    {
-      return !this.m_hierarchy.IsDisabled(level) && level >= this.EffectiveLevel;
-    }
-
-    public ILoggerRepository Repository => (ILoggerRepository) this.m_hierarchy;
-
-    protected virtual void CallAppenders(LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      int num = 0;
-      for (Logger logger = this; logger != null; logger = logger.m_parent)
-      {
-        if (logger.m_appenderAttachedImpl != null)
-        {
-          logger.m_appenderLock.AcquireReaderLock();
-          try
-          {
-            if (logger.m_appenderAttachedImpl != null)
-              num += logger.m_appenderAttachedImpl.AppendLoopOnAppenders(loggingEvent);
-          }
-          finally
-          {
-            logger.m_appenderLock.ReleaseReaderLock();
-          }
-        }
-        if (!logger.m_additive)
-          break;
-      }
-      if (this.m_hierarchy.EmittedNoAppenderWarning || num != 0)
-        return;
-      LogLog.Debug("Logger: No appenders could be found for logger [" + this.Name + "] repository [" + this.Repository.Name + "]");
-      LogLog.Debug("Logger: Please initialize the log4net system properly.");
-      try
-      {
-        LogLog.Debug("Logger:    Current AppDomain context information: ");
-        LogLog.Debug("Logger:       BaseDirectory   : " + SystemInfo.ApplicationBaseDirectory);
-        LogLog.Debug("Logger:       FriendlyName    : " + AppDomain.CurrentDomain.FriendlyName);
-        LogLog.Debug("Logger:       DynamicDirectory: " + AppDomain.CurrentDomain.DynamicDirectory);
-      }
-      catch (SecurityException ex)
-      {
-      }
-      this.m_hierarchy.EmittedNoAppenderWarning = true;
-    }
-
-    public virtual void CloseNestedAppenders()
-    {
-      this.m_appenderLock.AcquireWriterLock();
-      try
-      {
-        if (this.m_appenderAttachedImpl == null)
-          return;
-        foreach (IAppender appender in this.m_appenderAttachedImpl.Appenders)
-        {
-          if (appender is IAppenderAttachable)
-            appender.Close();
-        }
-      }
-      finally
-      {
-        this.m_appenderLock.ReleaseWriterLock();
-      }
-    }
-
-    public virtual void Log(Level level, object message, Exception exception)
-    {
-      if (!this.IsEnabledFor(level))
-        return;
-      this.ForcedLog(Logger.ThisDeclaringType, level, message, exception);
-    }
-
-    protected virtual void ForcedLog(
-      Type callerStackBoundaryDeclaringType,
-      Level level,
-      object message,
-      Exception exception)
-    {
-      this.CallAppenders(new LoggingEvent(callerStackBoundaryDeclaringType, (ILoggerRepository) this.Hierarchy, this.Name, level, message, exception));
-    }
-
-    protected virtual void ForcedLog(LoggingEvent logEvent)
-    {
-      logEvent.EnsureRepository((ILoggerRepository) this.Hierarchy);
-      this.CallAppenders(logEvent);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/LoggerCreationEventArgs.cs b/MSHALTester/log4net/Repository/Hierarchy/LoggerCreationEventArgs.cs
deleted file mode 100644
index 56185e3..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/LoggerCreationEventArgs.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  public class LoggerCreationEventArgs : EventArgs
-  {
-    private Logger m_log;
-
-    public LoggerCreationEventArgs(Logger log) => this.m_log = log;
-
-    public Logger Logger => this.m_log;
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/LoggerCreationEventHandler.cs b/MSHALTester/log4net/Repository/Hierarchy/LoggerCreationEventHandler.cs
deleted file mode 100644
index da3b040..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/LoggerCreationEventHandler.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  public delegate void LoggerCreationEventHandler(object sender, LoggerCreationEventArgs e);
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/LoggerKey.cs b/MSHALTester/log4net/Repository/Hierarchy/LoggerKey.cs
deleted file mode 100644
index b279e41..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/LoggerKey.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  internal sealed class LoggerKey
-  {
-    private readonly string m_name;
-    private readonly int m_hashCache;
-
-    internal LoggerKey(string name)
-    {
-      this.m_name = string.Intern(name);
-      this.m_hashCache = name.GetHashCode();
-    }
-
-    public override int GetHashCode() => this.m_hashCache;
-
-    public override bool Equals(object obj)
-    {
-      if (this == obj)
-        return true;
-      return obj is LoggerKey loggerKey && (object) this.m_name == (object) loggerKey.m_name;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/ProvisionNode.cs b/MSHALTester/log4net/Repository/Hierarchy/ProvisionNode.cs
deleted file mode 100644
index 4b820f9..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/ProvisionNode.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System.Collections;
-
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  internal sealed class ProvisionNode : ArrayList
-  {
-    internal ProvisionNode(Logger log) => this.Add((object) log);
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/RootLogger.cs b/MSHALTester/log4net/Repository/Hierarchy/RootLogger.cs
deleted file mode 100644
index 0af2e4d..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/RootLogger.cs
+++ /dev/null
@@ -1,30 +0,0 @@
-using log4net.Core;
-using log4net.Util;
-using System;
-
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  public class RootLogger : Logger
-  {
-    public RootLogger(Level level)
-      : base("root")
-    {
-      this.Level = level;
-    }
-
-    public override Level EffectiveLevel => base.Level;
-
-    public override Level Level
-    {
-      get => base.Level;
-      set
-      {
-        if (value == (Level) null)
-          LogLog.Error("RootLogger: You have tried to set a null level to root.", (Exception) new LogException());
-        else
-          base.Level = value;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Repository/Hierarchy/XmlHierarchyConfigurator.cs b/MSHALTester/log4net/Repository/Hierarchy/XmlHierarchyConfigurator.cs
deleted file mode 100644
index 19275d6..0000000
--- a/MSHALTester/log4net/Repository/Hierarchy/XmlHierarchyConfigurator.cs
+++ /dev/null
@@ -1,534 +0,0 @@
-using log4net.Appender;
-using log4net.Core;
-using log4net.ObjectRenderer;
-using log4net.Util;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.Reflection;
-using System.Security;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Repository.Hierarchy
-{
-  public class XmlHierarchyConfigurator
-  {
-    private const string CONFIGURATION_TAG = "log4net";
-    private const string RENDERER_TAG = "renderer";
-    private const string APPENDER_TAG = "appender";
-    private const string APPENDER_REF_TAG = "appender-ref";
-    private const string PARAM_TAG = "param";
-    private const string CATEGORY_TAG = "category";
-    private const string PRIORITY_TAG = "priority";
-    private const string LOGGER_TAG = "logger";
-    private const string NAME_ATTR = "name";
-    private const string TYPE_ATTR = "type";
-    private const string VALUE_ATTR = "value";
-    private const string ROOT_TAG = "root";
-    private const string LEVEL_TAG = "level";
-    private const string REF_ATTR = "ref";
-    private const string ADDITIVITY_ATTR = "additivity";
-    private const string THRESHOLD_ATTR = "threshold";
-    private const string CONFIG_DEBUG_ATTR = "configDebug";
-    private const string INTERNAL_DEBUG_ATTR = "debug";
-    private const string CONFIG_UPDATE_MODE_ATTR = "update";
-    private const string RENDERING_TYPE_ATTR = "renderingClass";
-    private const string RENDERED_TYPE_ATTR = "renderedClass";
-    private const string INHERITED = "inherited";
-    private Hashtable m_appenderBag;
-    private readonly log4net.Repository.Hierarchy.Hierarchy m_hierarchy;
-
-    public XmlHierarchyConfigurator(log4net.Repository.Hierarchy.Hierarchy hierarchy)
-    {
-      this.m_hierarchy = hierarchy;
-      this.m_appenderBag = new Hashtable();
-    }
-
-    public void Configure(XmlElement element)
-    {
-      if (element == null || this.m_hierarchy == null)
-        return;
-      if (element.LocalName != "log4net")
-      {
-        LogLog.Error("XmlHierarchyConfigurator: Xml element is - not a <log4net> element.");
-      }
-      else
-      {
-        if (!LogLog.InternalDebugging)
-        {
-          string attribute1 = element.GetAttribute("debug");
-          LogLog.Debug("XmlHierarchyConfigurator: debug attribute [" + attribute1 + "].");
-          if (attribute1.Length > 0 && attribute1 != "null")
-            LogLog.InternalDebugging = OptionConverter.ToBoolean(attribute1, true);
-          else
-            LogLog.Debug("XmlHierarchyConfigurator: Ignoring debug attribute.");
-          string attribute2 = element.GetAttribute("configDebug");
-          if (attribute2.Length > 0 && attribute2 != "null")
-          {
-            LogLog.Warn("XmlHierarchyConfigurator: The \"configDebug\" attribute is deprecated.");
-            LogLog.Warn("XmlHierarchyConfigurator: Use the \"debug\" attribute instead.");
-            LogLog.InternalDebugging = OptionConverter.ToBoolean(attribute2, true);
-          }
-        }
-        XmlHierarchyConfigurator.ConfigUpdateMode configUpdateMode = XmlHierarchyConfigurator.ConfigUpdateMode.Merge;
-        string attribute3 = element.GetAttribute("update");
-        if (attribute3 != null)
-        {
-          if (attribute3.Length > 0)
-          {
-            try
-            {
-              configUpdateMode = (XmlHierarchyConfigurator.ConfigUpdateMode) OptionConverter.ConvertStringTo(typeof (XmlHierarchyConfigurator.ConfigUpdateMode), attribute3);
-            }
-            catch
-            {
-              LogLog.Error("XmlHierarchyConfigurator: Invalid update attribute value [" + attribute3 + "]");
-            }
-          }
-        }
-        LogLog.Debug("XmlHierarchyConfigurator: Configuration update mode [" + configUpdateMode.ToString((IFormatProvider) CultureInfo.InvariantCulture) + "].");
-        if (configUpdateMode == XmlHierarchyConfigurator.ConfigUpdateMode.Overwrite)
-        {
-          this.m_hierarchy.ResetConfiguration();
-          LogLog.Debug("XmlHierarchyConfigurator: Configuration reset before reading config.");
-        }
-        foreach (XmlNode childNode in element.ChildNodes)
-        {
-          if (childNode.NodeType == XmlNodeType.Element)
-          {
-            XmlElement xmlElement = (XmlElement) childNode;
-            if (xmlElement.LocalName == "logger")
-              this.ParseLogger(xmlElement);
-            else if (xmlElement.LocalName == "category")
-              this.ParseLogger(xmlElement);
-            else if (xmlElement.LocalName == "root")
-              this.ParseRoot(xmlElement);
-            else if (xmlElement.LocalName == "renderer")
-              this.ParseRenderer(xmlElement);
-            else if (!(xmlElement.LocalName == "appender"))
-              this.SetParameter(xmlElement, (object) this.m_hierarchy);
-          }
-        }
-        string attribute4 = element.GetAttribute("threshold");
-        LogLog.Debug("XmlHierarchyConfigurator: Hierarchy Threshold [" + attribute4 + "]");
-        if (attribute4.Length <= 0 || !(attribute4 != "null"))
-          return;
-        Level level = (Level) this.ConvertStringTo(typeof (Level), attribute4);
-        if (level != (Level) null)
-          this.m_hierarchy.Threshold = level;
-        else
-          LogLog.Warn("XmlHierarchyConfigurator: Unable to set hierarchy threshold using value [" + attribute4 + "] (with acceptable conversion types)");
-      }
-    }
-
-    protected IAppender FindAppenderByReference(XmlElement appenderRef)
-    {
-      string attribute = appenderRef.GetAttribute("ref");
-      IAppender appenderByReference = (IAppender) this.m_appenderBag[(object) attribute];
-      if (appenderByReference != null)
-        return appenderByReference;
-      XmlElement appenderElement = (XmlElement) null;
-      if (attribute != null && attribute.Length > 0)
-      {
-        foreach (XmlElement xmlElement in appenderRef.OwnerDocument.GetElementsByTagName("appender"))
-        {
-          if (xmlElement.GetAttribute("name") == attribute)
-          {
-            appenderElement = xmlElement;
-            break;
-          }
-        }
-      }
-      if (appenderElement == null)
-      {
-        LogLog.Error("XmlHierarchyConfigurator: No appender named [" + attribute + "] could be found.");
-        return (IAppender) null;
-      }
-      IAppender appender = this.ParseAppender(appenderElement);
-      if (appender != null)
-        this.m_appenderBag[(object) attribute] = (object) appender;
-      return appender;
-    }
-
-    protected IAppender ParseAppender(XmlElement appenderElement)
-    {
-      string attribute1 = appenderElement.GetAttribute("name");
-      string attribute2 = appenderElement.GetAttribute("type");
-      LogLog.Debug("XmlHierarchyConfigurator: Loading Appender [" + attribute1 + "] type: [" + attribute2 + "]");
-      try
-      {
-        IAppender instance = (IAppender) Activator.CreateInstance(SystemInfo.GetTypeFromString(attribute2, true, true));
-        instance.Name = attribute1;
-        foreach (XmlNode childNode in appenderElement.ChildNodes)
-        {
-          if (childNode.NodeType == XmlNodeType.Element)
-          {
-            XmlElement xmlElement = (XmlElement) childNode;
-            if (xmlElement.LocalName == "appender-ref")
-            {
-              string attribute3 = xmlElement.GetAttribute("ref");
-              if (instance is IAppenderAttachable appenderAttachable)
-              {
-                LogLog.Debug("XmlHierarchyConfigurator: Attaching appender named [" + attribute3 + "] to appender named [" + instance.Name + "].");
-                IAppender appenderByReference = this.FindAppenderByReference(xmlElement);
-                if (appenderByReference != null)
-                  appenderAttachable.AddAppender(appenderByReference);
-              }
-              else
-                LogLog.Error("XmlHierarchyConfigurator: Requesting attachment of appender named [" + attribute3 + "] to appender named [" + instance.Name + "] which does not implement log4net.Core.IAppenderAttachable.");
-            }
-            else
-              this.SetParameter(xmlElement, (object) instance);
-          }
-        }
-        if (instance is IOptionHandler optionHandler)
-          optionHandler.ActivateOptions();
-        LogLog.Debug("XmlHierarchyConfigurator: Created Appender [" + attribute1 + "]");
-        return instance;
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("XmlHierarchyConfigurator: Could not create Appender [" + attribute1 + "] of type [" + attribute2 + "]. Reported error follows.", ex);
-        return (IAppender) null;
-      }
-    }
-
-    protected void ParseLogger(XmlElement loggerElement)
-    {
-      string attribute = loggerElement.GetAttribute("name");
-      LogLog.Debug("XmlHierarchyConfigurator: Retrieving an instance of log4net.Repository.Logger for logger [" + attribute + "].");
-      Logger logger = this.m_hierarchy.GetLogger(attribute) as Logger;
-      lock (logger)
-      {
-        bool boolean = OptionConverter.ToBoolean(loggerElement.GetAttribute("additivity"), true);
-        LogLog.Debug("XmlHierarchyConfigurator: Setting [" + logger.Name + "] additivity to [" + (object) boolean + "].");
-        logger.Additivity = boolean;
-        this.ParseChildrenOfLoggerElement(loggerElement, logger, false);
-      }
-    }
-
-    protected void ParseRoot(XmlElement rootElement)
-    {
-      Logger root = this.m_hierarchy.Root;
-      lock (root)
-        this.ParseChildrenOfLoggerElement(rootElement, root, true);
-    }
-
-    protected void ParseChildrenOfLoggerElement(XmlElement catElement, Logger log, bool isRoot)
-    {
-      log.RemoveAllAppenders();
-      foreach (XmlNode childNode in catElement.ChildNodes)
-      {
-        if (childNode.NodeType == XmlNodeType.Element)
-        {
-          XmlElement xmlElement = (XmlElement) childNode;
-          if (xmlElement.LocalName == "appender-ref")
-          {
-            IAppender appenderByReference = this.FindAppenderByReference(xmlElement);
-            string attribute = xmlElement.GetAttribute("ref");
-            if (appenderByReference != null)
-            {
-              LogLog.Debug("XmlHierarchyConfigurator: Adding appender named [" + attribute + "] to logger [" + log.Name + "].");
-              log.AddAppender(appenderByReference);
-            }
-            else
-              LogLog.Error("XmlHierarchyConfigurator: Appender named [" + attribute + "] not found.");
-          }
-          else if (xmlElement.LocalName == "level" || xmlElement.LocalName == "priority")
-            this.ParseLevel(xmlElement, log, isRoot);
-          else
-            this.SetParameter(xmlElement, (object) log);
-        }
-      }
-      if (!(log is IOptionHandler optionHandler))
-        return;
-      optionHandler.ActivateOptions();
-    }
-
-    protected void ParseRenderer(XmlElement element)
-    {
-      string attribute1 = element.GetAttribute("renderingClass");
-      string attribute2 = element.GetAttribute("renderedClass");
-      LogLog.Debug("XmlHierarchyConfigurator: Rendering class [" + attribute1 + "], Rendered class [" + attribute2 + "].");
-      IObjectRenderer renderer = (IObjectRenderer) OptionConverter.InstantiateByClassName(attribute1, typeof (IObjectRenderer), (object) null);
-      if (renderer == null)
-      {
-        LogLog.Error("XmlHierarchyConfigurator: Could not instantiate renderer [" + attribute1 + "].");
-      }
-      else
-      {
-        try
-        {
-          this.m_hierarchy.RendererMap.Put(SystemInfo.GetTypeFromString(attribute2, true, true), renderer);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("XmlHierarchyConfigurator: Could not find class [" + attribute2 + "].", ex);
-        }
-      }
-    }
-
-    protected void ParseLevel(XmlElement element, Logger log, bool isRoot)
-    {
-      string str = log.Name;
-      if (isRoot)
-        str = "root";
-      string attribute = element.GetAttribute("value");
-      LogLog.Debug("XmlHierarchyConfigurator: Logger [" + str + "] Level string is [" + attribute + "].");
-      if ("inherited" == attribute)
-      {
-        if (isRoot)
-        {
-          LogLog.Error("XmlHierarchyConfigurator: Root level cannot be inherited. Ignoring directive.");
-        }
-        else
-        {
-          LogLog.Debug("XmlHierarchyConfigurator: Logger [" + str + "] level set to inherit from parent.");
-          log.Level = (Level) null;
-        }
-      }
-      else
-      {
-        log.Level = log.Hierarchy.LevelMap[attribute];
-        if (log.Level == (Level) null)
-          LogLog.Error("XmlHierarchyConfigurator: Undefined level [" + attribute + "] on Logger [" + str + "].");
-        else
-          LogLog.Debug("XmlHierarchyConfigurator: Logger [" + str + "] level set to [name=\"" + log.Level.Name + "\",value=" + (object) log.Level.Value + "].");
-      }
-    }
-
-    protected void SetParameter(XmlElement element, object target)
-    {
-      string name = element.GetAttribute("name");
-      if (element.LocalName != "param" || name == null || name.Length == 0)
-        name = element.LocalName;
-      Type type1 = target.GetType();
-      Type type2 = (Type) null;
-      MethodInfo methodInfo = (MethodInfo) null;
-      PropertyInfo propertyInfo = type1.GetProperty(name, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
-      if (propertyInfo != null && propertyInfo.CanWrite)
-      {
-        type2 = propertyInfo.PropertyType;
-      }
-      else
-      {
-        propertyInfo = (PropertyInfo) null;
-        methodInfo = this.FindMethodInfo(type1, name);
-        if (methodInfo != null)
-          type2 = methodInfo.GetParameters()[0].ParameterType;
-      }
-      if (type2 == null)
-        LogLog.Error("XmlHierarchyConfigurator: Cannot find Property [" + name + "] to set object on [" + target.ToString() + "]");
-      else if (element.GetAttributeNode("value") != null)
-      {
-        string str = element.GetAttribute("value");
-        try
-        {
-          str = OptionConverter.SubstituteVariables(str, Environment.GetEnvironmentVariables());
-        }
-        catch (SecurityException ex)
-        {
-          LogLog.Debug("XmlHierarchyConfigurator: Security exception while trying to expand environment variables. Error Ignored. No Expansion.");
-        }
-        Type targetType = (Type) null;
-        string attribute = element.GetAttribute("type");
-        if (attribute != null)
-        {
-          if (attribute.Length > 0)
-          {
-            try
-            {
-              Type typeFromString = SystemInfo.GetTypeFromString(attribute, true, true);
-              LogLog.Debug("XmlHierarchyConfigurator: Parameter [" + name + "] specified subtype [" + typeFromString.FullName + "]");
-              if (!type2.IsAssignableFrom(typeFromString))
-              {
-                if (OptionConverter.CanConvertTypeTo(typeFromString, type2))
-                {
-                  targetType = type2;
-                  type2 = typeFromString;
-                }
-                else
-                  LogLog.Error("XmlHierarchyConfigurator: Subtype [" + typeFromString.FullName + "] set on [" + name + "] is not a subclass of property type [" + type2.FullName + "] and there are no acceptable type conversions.");
-              }
-              else
-                type2 = typeFromString;
-            }
-            catch (Exception ex)
-            {
-              LogLog.Error("XmlHierarchyConfigurator: Failed to find type [" + attribute + "] set on [" + name + "]", ex);
-            }
-          }
-        }
-        object sourceInstance = this.ConvertStringTo(type2, str);
-        if (sourceInstance != null && targetType != null)
-        {
-          LogLog.Debug("XmlHierarchyConfigurator: Performing additional conversion of value from [" + sourceInstance.GetType().Name + "] to [" + targetType.Name + "]");
-          sourceInstance = OptionConverter.ConvertTypeTo(sourceInstance, targetType);
-        }
-        if (sourceInstance != null)
-        {
-          if (propertyInfo != null)
-          {
-            LogLog.Debug("XmlHierarchyConfigurator: Setting Property [" + propertyInfo.Name + "] to " + sourceInstance.GetType().Name + " value [" + sourceInstance.ToString() + "]");
-            try
-            {
-              propertyInfo.SetValue(target, sourceInstance, BindingFlags.SetProperty, (Binder) null, (object[]) null, CultureInfo.InvariantCulture);
-            }
-            catch (TargetInvocationException ex)
-            {
-              LogLog.Error("XmlHierarchyConfigurator: Failed to set parameter [" + propertyInfo.Name + "] on object [" + target + "] using value [" + sourceInstance + "]", ex.InnerException);
-            }
-          }
-          else
-          {
-            if (methodInfo == null)
-              return;
-            LogLog.Debug("XmlHierarchyConfigurator: Setting Collection Property [" + methodInfo.Name + "] to " + sourceInstance.GetType().Name + " value [" + sourceInstance.ToString() + "]");
-            try
-            {
-              methodInfo.Invoke(target, BindingFlags.InvokeMethod, (Binder) null, new object[1]
-              {
-                sourceInstance
-              }, CultureInfo.InvariantCulture);
-            }
-            catch (TargetInvocationException ex)
-            {
-              LogLog.Error("XmlHierarchyConfigurator: Failed to set parameter [" + name + "] on object [" + target + "] using value [" + sourceInstance + "]", ex.InnerException);
-            }
-          }
-        }
-        else
-          LogLog.Warn("XmlHierarchyConfigurator: Unable to set property [" + name + "] on object [" + target + "] using value [" + str + "] (with acceptable conversion types)");
-      }
-      else
-      {
-        Type defaultTargetType = (Type) null;
-        if (type2.IsClass && !type2.IsAbstract)
-          defaultTargetType = type2;
-        object objectFromXml = this.CreateObjectFromXml(element, defaultTargetType, type2);
-        if (objectFromXml == null)
-          LogLog.Error("XmlHierarchyConfigurator: Failed to create object to set param: " + name);
-        else if (propertyInfo != null)
-        {
-          LogLog.Debug("XmlHierarchyConfigurator: Setting Property [" + propertyInfo.Name + "] to object [" + objectFromXml + "]");
-          try
-          {
-            propertyInfo.SetValue(target, objectFromXml, BindingFlags.SetProperty, (Binder) null, (object[]) null, CultureInfo.InvariantCulture);
-          }
-          catch (TargetInvocationException ex)
-          {
-            LogLog.Error("XmlHierarchyConfigurator: Failed to set parameter [" + propertyInfo.Name + "] on object [" + target + "] using value [" + objectFromXml + "]", ex.InnerException);
-          }
-        }
-        else
-        {
-          if (methodInfo == null)
-            return;
-          LogLog.Debug("XmlHierarchyConfigurator: Setting Collection Property [" + methodInfo.Name + "] to object [" + objectFromXml + "]");
-          try
-          {
-            methodInfo.Invoke(target, BindingFlags.InvokeMethod, (Binder) null, new object[1]
-            {
-              objectFromXml
-            }, CultureInfo.InvariantCulture);
-          }
-          catch (TargetInvocationException ex)
-          {
-            LogLog.Error("XmlHierarchyConfigurator: Failed to set parameter [" + methodInfo.Name + "] on object [" + target + "] using value [" + objectFromXml + "]", ex.InnerException);
-          }
-        }
-      }
-    }
-
-    private MethodInfo FindMethodInfo(Type targetType, string name)
-    {
-      string strB1 = name;
-      string strB2 = "Add" + name;
-      foreach (MethodInfo method in targetType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic))
-      {
-        if (!method.IsStatic && (string.Compare(method.Name, strB1, true, CultureInfo.InvariantCulture) == 0 || string.Compare(method.Name, strB2, true, CultureInfo.InvariantCulture) == 0) && method.GetParameters().Length == 1)
-          return method;
-      }
-      return (MethodInfo) null;
-    }
-
-    protected object ConvertStringTo(Type type, string value)
-    {
-      if (!type.IsAssignableFrom(typeof (Level)))
-        return OptionConverter.ConvertStringTo(type, value);
-      Level level = this.m_hierarchy.LevelMap[value];
-      if (level == (Level) null)
-        LogLog.Error("XmlHierarchyConfigurator: Unknown Level Specified [" + value + "]");
-      return (object) level;
-    }
-
-    protected object CreateObjectFromXml(
-      XmlElement element,
-      Type defaultTargetType,
-      Type typeConstraint)
-    {
-      string attribute = element.GetAttribute("type");
-      Type type;
-      if (attribute != null)
-      {
-        if (attribute.Length != 0)
-        {
-          try
-          {
-            type = SystemInfo.GetTypeFromString(attribute, true, true);
-            goto label_7;
-          }
-          catch (Exception ex)
-          {
-            LogLog.Error("XmlHierarchyConfigurator: Failed to find type [" + attribute + "]", ex);
-            return (object) null;
-          }
-        }
-      }
-      if (defaultTargetType == null)
-      {
-        LogLog.Error("XmlHierarchyConfigurator: Object type not specified. Cannot create object.");
-        return (object) null;
-      }
-      type = defaultTargetType;
-label_7:
-      bool flag = false;
-      if (typeConstraint != null && !typeConstraint.IsAssignableFrom(type))
-      {
-        if (OptionConverter.CanConvertTypeTo(type, typeConstraint))
-        {
-          flag = true;
-        }
-        else
-        {
-          LogLog.Error("XmlHierarchyConfigurator: Object type [" + type.FullName + "] is not assignable to type [" + typeConstraint.FullName + "]. There are no acceptable type conversions.");
-          return (object) null;
-        }
-      }
-      object obj = (object) null;
-      try
-      {
-        obj = Activator.CreateInstance(type);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("XmlHierarchyConfigurator: Failed to construct object of type [" + type.FullName + "] Exception: " + ex.ToString());
-      }
-      foreach (XmlNode childNode in element.ChildNodes)
-      {
-        if (childNode.NodeType == XmlNodeType.Element)
-          this.SetParameter((XmlElement) childNode, obj);
-      }
-      if (obj is IOptionHandler optionHandler)
-        optionHandler.ActivateOptions();
-      return flag ? OptionConverter.ConvertTypeTo(obj, typeConstraint) : obj;
-    }
-
-    private enum ConfigUpdateMode
-    {
-      Merge,
-      Overwrite,
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Repository/IBasicRepositoryConfigurator.cs b/MSHALTester/log4net/Repository/IBasicRepositoryConfigurator.cs
deleted file mode 100644
index 0c74cbe..0000000
--- a/MSHALTester/log4net/Repository/IBasicRepositoryConfigurator.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using log4net.Appender;
-
-#nullable disable
-namespace log4net.Repository
-{
-  public interface IBasicRepositoryConfigurator
-  {
-    void Configure(IAppender appender);
-  }
-}
diff --git a/MSHALTester/log4net/Repository/ILoggerRepository.cs b/MSHALTester/log4net/Repository/ILoggerRepository.cs
deleted file mode 100644
index e7c55fd..0000000
--- a/MSHALTester/log4net/Repository/ILoggerRepository.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-using log4net.Appender;
-using log4net.Core;
-using log4net.ObjectRenderer;
-using log4net.Plugin;
-using log4net.Util;
-
-#nullable disable
-namespace log4net.Repository
-{
-  public interface ILoggerRepository
-  {
-    string Name { get; set; }
-
-    RendererMap RendererMap { get; }
-
-    PluginMap PluginMap { get; }
-
-    LevelMap LevelMap { get; }
-
-    Level Threshold { get; set; }
-
-    ILogger Exists(string name);
-
-    ILogger[] GetCurrentLoggers();
-
-    ILogger GetLogger(string name);
-
-    void Shutdown();
-
-    void ResetConfiguration();
-
-    void Log(LoggingEvent logEvent);
-
-    bool Configured { get; set; }
-
-    event LoggerRepositoryShutdownEventHandler ShutdownEvent;
-
-    event LoggerRepositoryConfigurationResetEventHandler ConfigurationReset;
-
-    event LoggerRepositoryConfigurationChangedEventHandler ConfigurationChanged;
-
-    PropertiesDictionary Properties { get; }
-
-    IAppender[] GetAppenders();
-  }
-}
diff --git a/MSHALTester/log4net/Repository/IXmlRepositoryConfigurator.cs b/MSHALTester/log4net/Repository/IXmlRepositoryConfigurator.cs
deleted file mode 100644
index 51b9e86..0000000
--- a/MSHALTester/log4net/Repository/IXmlRepositoryConfigurator.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-using System.Xml;
-
-#nullable disable
-namespace log4net.Repository
-{
-  public interface IXmlRepositoryConfigurator
-  {
-    void Configure(XmlElement element);
-  }
-}
diff --git a/MSHALTester/log4net/Repository/LoggerRepositoryConfigurationChangedEventHandler.cs b/MSHALTester/log4net/Repository/LoggerRepositoryConfigurationChangedEventHandler.cs
deleted file mode 100644
index 9622b92..0000000
--- a/MSHALTester/log4net/Repository/LoggerRepositoryConfigurationChangedEventHandler.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Repository
-{
-  public delegate void LoggerRepositoryConfigurationChangedEventHandler(object sender, EventArgs e);
-}
diff --git a/MSHALTester/log4net/Repository/LoggerRepositoryConfigurationResetEventHandler.cs b/MSHALTester/log4net/Repository/LoggerRepositoryConfigurationResetEventHandler.cs
deleted file mode 100644
index 79e4d13..0000000
--- a/MSHALTester/log4net/Repository/LoggerRepositoryConfigurationResetEventHandler.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Repository
-{
-  public delegate void LoggerRepositoryConfigurationResetEventHandler(object sender, EventArgs e);
-}
diff --git a/MSHALTester/log4net/Repository/LoggerRepositoryShutdownEventHandler.cs b/MSHALTester/log4net/Repository/LoggerRepositoryShutdownEventHandler.cs
deleted file mode 100644
index 3f4cb8e..0000000
--- a/MSHALTester/log4net/Repository/LoggerRepositoryShutdownEventHandler.cs
+++ /dev/null
@@ -1,7 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Repository
-{
-  public delegate void LoggerRepositoryShutdownEventHandler(object sender, EventArgs e);
-}
diff --git a/MSHALTester/log4net/Repository/LoggerRepositorySkeleton.cs b/MSHALTester/log4net/Repository/LoggerRepositorySkeleton.cs
deleted file mode 100644
index 54304f4..0000000
--- a/MSHALTester/log4net/Repository/LoggerRepositorySkeleton.cs
+++ /dev/null
@@ -1,186 +0,0 @@
-using log4net.Appender;
-using log4net.Core;
-using log4net.ObjectRenderer;
-using log4net.Plugin;
-using log4net.Util;
-using System;
-
-#nullable disable
-namespace log4net.Repository
-{
-  public abstract class LoggerRepositorySkeleton : ILoggerRepository
-  {
-    private string m_name;
-    private RendererMap m_rendererMap;
-    private PluginMap m_pluginMap;
-    private LevelMap m_levelMap;
-    private Level m_threshold;
-    private bool m_configured;
-    private PropertiesDictionary m_properties;
-
-    private event LoggerRepositoryShutdownEventHandler m_shutdownEvent;
-
-    private event LoggerRepositoryConfigurationResetEventHandler m_configurationResetEvent;
-
-    private event LoggerRepositoryConfigurationChangedEventHandler m_configurationChangedEvent;
-
-    protected LoggerRepositorySkeleton()
-      : this(new PropertiesDictionary())
-    {
-    }
-
-    protected LoggerRepositorySkeleton(PropertiesDictionary properties)
-    {
-      this.m_properties = properties;
-      this.m_rendererMap = new RendererMap();
-      this.m_pluginMap = new PluginMap((ILoggerRepository) this);
-      this.m_levelMap = new LevelMap();
-      this.m_configured = false;
-      this.AddBuiltinLevels();
-      this.m_threshold = Level.All;
-    }
-
-    public virtual string Name
-    {
-      get => this.m_name;
-      set => this.m_name = value;
-    }
-
-    public virtual Level Threshold
-    {
-      get => this.m_threshold;
-      set
-      {
-        if (value != (Level) null)
-        {
-          this.m_threshold = value;
-        }
-        else
-        {
-          LogLog.Warn("LoggerRepositorySkeleton: Threshold cannot be set to null. Setting to ALL");
-          this.m_threshold = Level.All;
-        }
-      }
-    }
-
-    public virtual RendererMap RendererMap => this.m_rendererMap;
-
-    public virtual PluginMap PluginMap => this.m_pluginMap;
-
-    public virtual LevelMap LevelMap => this.m_levelMap;
-
-    public abstract ILogger Exists(string name);
-
-    public abstract ILogger[] GetCurrentLoggers();
-
-    public abstract ILogger GetLogger(string name);
-
-    public virtual void Shutdown()
-    {
-      foreach (IPlugin allPlugin in this.PluginMap.AllPlugins)
-        allPlugin.Shutdown();
-      this.OnShutdown((EventArgs) null);
-    }
-
-    public virtual void ResetConfiguration()
-    {
-      this.m_rendererMap.Clear();
-      this.m_levelMap.Clear();
-      this.AddBuiltinLevels();
-      this.Configured = false;
-      this.OnConfigurationReset((EventArgs) null);
-    }
-
-    public abstract void Log(LoggingEvent logEvent);
-
-    public virtual bool Configured
-    {
-      get => this.m_configured;
-      set => this.m_configured = value;
-    }
-
-    public event LoggerRepositoryShutdownEventHandler ShutdownEvent
-    {
-      add => this.m_shutdownEvent += value;
-      remove => this.m_shutdownEvent -= value;
-    }
-
-    public event LoggerRepositoryConfigurationResetEventHandler ConfigurationReset
-    {
-      add => this.m_configurationResetEvent += value;
-      remove => this.m_configurationResetEvent -= value;
-    }
-
-    public event LoggerRepositoryConfigurationChangedEventHandler ConfigurationChanged
-    {
-      add => this.m_configurationChangedEvent += value;
-      remove => this.m_configurationChangedEvent -= value;
-    }
-
-    public PropertiesDictionary Properties => this.m_properties;
-
-    public abstract IAppender[] GetAppenders();
-
-    private void AddBuiltinLevels()
-    {
-      this.m_levelMap.Add(Level.Off);
-      this.m_levelMap.Add(Level.Emergency);
-      this.m_levelMap.Add(Level.Fatal);
-      this.m_levelMap.Add(Level.Alert);
-      this.m_levelMap.Add(Level.Critical);
-      this.m_levelMap.Add(Level.Severe);
-      this.m_levelMap.Add(Level.Error);
-      this.m_levelMap.Add(Level.Warn);
-      this.m_levelMap.Add(Level.Notice);
-      this.m_levelMap.Add(Level.Info);
-      this.m_levelMap.Add(Level.Debug);
-      this.m_levelMap.Add(Level.Fine);
-      this.m_levelMap.Add(Level.Trace);
-      this.m_levelMap.Add(Level.Finer);
-      this.m_levelMap.Add(Level.Verbose);
-      this.m_levelMap.Add(Level.Finest);
-      this.m_levelMap.Add(Level.All);
-    }
-
-    public virtual void AddRenderer(Type typeToRender, IObjectRenderer rendererInstance)
-    {
-      if (typeToRender == null)
-        throw new ArgumentNullException(nameof (typeToRender));
-      if (rendererInstance == null)
-        throw new ArgumentNullException(nameof (rendererInstance));
-      this.m_rendererMap.Put(typeToRender, rendererInstance);
-    }
-
-    protected virtual void OnShutdown(EventArgs e)
-    {
-      if (e == null)
-        e = EventArgs.Empty;
-      LoggerRepositoryShutdownEventHandler shutdownEvent = this.m_shutdownEvent;
-      if (shutdownEvent == null)
-        return;
-      shutdownEvent((object) this, e);
-    }
-
-    protected virtual void OnConfigurationReset(EventArgs e)
-    {
-      if (e == null)
-        e = EventArgs.Empty;
-      LoggerRepositoryConfigurationResetEventHandler configurationResetEvent = this.m_configurationResetEvent;
-      if (configurationResetEvent == null)
-        return;
-      configurationResetEvent((object) this, e);
-    }
-
-    protected virtual void OnConfigurationChanged(EventArgs e)
-    {
-      if (e == null)
-        e = EventArgs.Empty;
-      LoggerRepositoryConfigurationChangedEventHandler configurationChangedEvent = this.m_configurationChangedEvent;
-      if (configurationChangedEvent == null)
-        return;
-      configurationChangedEvent((object) this, EventArgs.Empty);
-    }
-
-    public void RaiseConfigurationChanged(EventArgs e) => this.OnConfigurationChanged(e);
-  }
-}
diff --git a/MSHALTester/log4net/ThreadContext.cs b/MSHALTester/log4net/ThreadContext.cs
deleted file mode 100644
index 24fe2ee..0000000
--- a/MSHALTester/log4net/ThreadContext.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using log4net.Util;
-
-#nullable disable
-namespace log4net
-{
-  public sealed class ThreadContext
-  {
-    private static readonly ThreadContextProperties s_properties = new ThreadContextProperties();
-    private static readonly ThreadContextStacks s_stacks = new ThreadContextStacks((ContextPropertiesBase) ThreadContext.s_properties);
-
-    private ThreadContext()
-    {
-    }
-
-    public static ThreadContextProperties Properties => ThreadContext.s_properties;
-
-    public static ThreadContextStacks Stacks => ThreadContext.s_stacks;
-  }
-}
diff --git a/MSHALTester/log4net/Util/AppenderAttachedImpl.cs b/MSHALTester/log4net/Util/AppenderAttachedImpl.cs
deleted file mode 100644
index 2a22a5f..0000000
--- a/MSHALTester/log4net/Util/AppenderAttachedImpl.cs
+++ /dev/null
@@ -1,101 +0,0 @@
-using log4net.Appender;
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class AppenderAttachedImpl : IAppenderAttachable
-  {
-    private AppenderCollection m_appenderList;
-    private IAppender[] m_appenderArray;
-
-    public int AppendLoopOnAppenders(LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      if (this.m_appenderList == null)
-        return 0;
-      if (this.m_appenderArray == null)
-        this.m_appenderArray = this.m_appenderList.ToArray();
-      foreach (IAppender appender in this.m_appenderArray)
-      {
-        try
-        {
-          appender.DoAppend(loggingEvent);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("AppenderAttachedImpl: Failed to append to appender [" + appender.Name + "]", ex);
-        }
-      }
-      return this.m_appenderList.Count;
-    }
-
-    public void AddAppender(IAppender newAppender)
-    {
-      if (newAppender == null)
-        throw new ArgumentNullException(nameof (newAppender));
-      this.m_appenderArray = (IAppender[]) null;
-      if (this.m_appenderList == null)
-        this.m_appenderList = new AppenderCollection(1);
-      if (this.m_appenderList.Contains(newAppender))
-        return;
-      this.m_appenderList.Add(newAppender);
-    }
-
-    public AppenderCollection Appenders
-    {
-      get
-      {
-        return this.m_appenderList == null ? AppenderCollection.EmptyCollection : AppenderCollection.ReadOnly(this.m_appenderList);
-      }
-    }
-
-    public IAppender GetAppender(string name)
-    {
-      if (this.m_appenderList != null && name != null)
-      {
-        foreach (IAppender appender in this.m_appenderList)
-        {
-          if (name == appender.Name)
-            return appender;
-        }
-      }
-      return (IAppender) null;
-    }
-
-    public void RemoveAllAppenders()
-    {
-      if (this.m_appenderList == null)
-        return;
-      foreach (IAppender appender in this.m_appenderList)
-      {
-        try
-        {
-          appender.Close();
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("AppenderAttachedImpl: Failed to Close appender [" + appender.Name + "]", ex);
-        }
-      }
-      this.m_appenderList = (AppenderCollection) null;
-      this.m_appenderArray = (IAppender[]) null;
-    }
-
-    public IAppender RemoveAppender(IAppender appender)
-    {
-      if (appender != null && this.m_appenderList != null)
-      {
-        this.m_appenderList.Remove(appender);
-        if (this.m_appenderList.Count == 0)
-          this.m_appenderList = (AppenderCollection) null;
-        this.m_appenderArray = (IAppender[]) null;
-      }
-      return appender;
-    }
-
-    public IAppender RemoveAppender(string name) => this.RemoveAppender(this.GetAppender(name));
-  }
-}
diff --git a/MSHALTester/log4net/Util/CompositeProperties.cs b/MSHALTester/log4net/Util/CompositeProperties.cs
deleted file mode 100644
index 6c0ac11..0000000
--- a/MSHALTester/log4net/Util/CompositeProperties.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-using System.Collections;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class CompositeProperties
-  {
-    private PropertiesDictionary m_flattened = (PropertiesDictionary) null;
-    private ArrayList m_nestedProperties = new ArrayList();
-
-    internal CompositeProperties()
-    {
-    }
-
-    public object this[string key]
-    {
-      get
-      {
-        if (this.m_flattened != null)
-          return this.m_flattened[key];
-        foreach (ReadOnlyPropertiesDictionary nestedProperty in this.m_nestedProperties)
-        {
-          if (nestedProperty.Contains(key))
-            return nestedProperty[key];
-        }
-        return (object) null;
-      }
-    }
-
-    public void Add(ReadOnlyPropertiesDictionary properties)
-    {
-      this.m_flattened = (PropertiesDictionary) null;
-      this.m_nestedProperties.Add((object) properties);
-    }
-
-    public PropertiesDictionary Flatten()
-    {
-      if (this.m_flattened == null)
-      {
-        this.m_flattened = new PropertiesDictionary();
-        int count = this.m_nestedProperties.Count;
-        while (--count >= 0)
-        {
-          foreach (DictionaryEntry dictionaryEntry in (IEnumerable) this.m_nestedProperties[count])
-            this.m_flattened[(string) dictionaryEntry.Key] = dictionaryEntry.Value;
-        }
-      }
-      return this.m_flattened;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/ContextPropertiesBase.cs b/MSHALTester/log4net/Util/ContextPropertiesBase.cs
deleted file mode 100644
index 373d799..0000000
--- a/MSHALTester/log4net/Util/ContextPropertiesBase.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-#nullable disable
-namespace log4net.Util
-{
-  public abstract class ContextPropertiesBase
-  {
-    public abstract object this[string key] { get; set; }
-  }
-}
diff --git a/MSHALTester/log4net/Util/CountingQuietTextWriter.cs b/MSHALTester/log4net/Util/CountingQuietTextWriter.cs
deleted file mode 100644
index f95124e..0000000
--- a/MSHALTester/log4net/Util/CountingQuietTextWriter.cs
+++ /dev/null
@@ -1,41 +0,0 @@
-using log4net.Core;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class CountingQuietTextWriter : QuietTextWriter
-  {
-    private long m_countBytes;
-
-    public CountingQuietTextWriter(TextWriter writer, IErrorHandler errorHandler)
-      : base(writer, errorHandler)
-    {
-      this.m_countBytes = 0L;
-    }
-
-    public override void Write(string str)
-    {
-      if (str == null)
-        return;
-      if (str.Length <= 0)
-        return;
-      try
-      {
-        base.Write(str);
-        this.m_countBytes += (long) this.Encoding.GetByteCount(str);
-      }
-      catch (Exception ex)
-      {
-        this.ErrorHandler.Error("Failed to write [" + str + "].", ex, ErrorCode.WriteFailure);
-      }
-    }
-
-    public long Count
-    {
-      get => this.m_countBytes;
-      set => this.m_countBytes = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/CyclicBuffer.cs b/MSHALTester/log4net/Util/CyclicBuffer.cs
deleted file mode 100644
index a2cf40c..0000000
--- a/MSHALTester/log4net/Util/CyclicBuffer.cs
+++ /dev/null
@@ -1,111 +0,0 @@
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class CyclicBuffer
-  {
-    private LoggingEvent[] m_events;
-    private int m_first;
-    private int m_last;
-    private int m_numElems;
-    private int m_maxSize;
-
-    public CyclicBuffer(int maxSize)
-    {
-      this.m_maxSize = maxSize >= 1 ? maxSize : throw SystemInfo.CreateArgumentOutOfRangeException(nameof (maxSize), (object) maxSize, "Parameter: maxSize, Value: [" + (object) maxSize + "] out of range. Non zero positive integer required");
-      this.m_events = new LoggingEvent[maxSize];
-      this.m_first = 0;
-      this.m_last = 0;
-      this.m_numElems = 0;
-    }
-
-    public LoggingEvent Append(LoggingEvent loggingEvent)
-    {
-      if (loggingEvent == null)
-        throw new ArgumentNullException(nameof (loggingEvent));
-      lock (this)
-      {
-        LoggingEvent loggingEvent1 = this.m_events[this.m_last];
-        this.m_events[this.m_last] = loggingEvent;
-        if (++this.m_last == this.m_maxSize)
-          this.m_last = 0;
-        if (this.m_numElems < this.m_maxSize)
-          ++this.m_numElems;
-        else if (++this.m_first == this.m_maxSize)
-          this.m_first = 0;
-        return this.m_numElems < this.m_maxSize ? (LoggingEvent) null : loggingEvent1;
-      }
-    }
-
-    public LoggingEvent PopOldest()
-    {
-      lock (this)
-      {
-        LoggingEvent loggingEvent = (LoggingEvent) null;
-        if (this.m_numElems > 0)
-        {
-          --this.m_numElems;
-          loggingEvent = this.m_events[this.m_first];
-          this.m_events[this.m_first] = (LoggingEvent) null;
-          if (++this.m_first == this.m_maxSize)
-            this.m_first = 0;
-        }
-        return loggingEvent;
-      }
-    }
-
-    public LoggingEvent[] PopAll()
-    {
-      lock (this)
-      {
-        LoggingEvent[] destinationArray = new LoggingEvent[this.m_numElems];
-        if (this.m_numElems > 0)
-        {
-          if (this.m_first < this.m_last)
-          {
-            Array.Copy((Array) this.m_events, this.m_first, (Array) destinationArray, 0, this.m_numElems);
-          }
-          else
-          {
-            Array.Copy((Array) this.m_events, this.m_first, (Array) destinationArray, 0, this.m_maxSize - this.m_first);
-            Array.Copy((Array) this.m_events, 0, (Array) destinationArray, this.m_maxSize - this.m_first, this.m_last);
-          }
-        }
-        Array.Clear((Array) this.m_events, 0, this.m_events.Length);
-        this.m_first = 0;
-        this.m_last = 0;
-        this.m_numElems = 0;
-        return destinationArray;
-      }
-    }
-
-    public LoggingEvent this[int i]
-    {
-      get
-      {
-        lock (this)
-          return i < 0 || i >= this.m_numElems ? (LoggingEvent) null : this.m_events[(this.m_first + i) % this.m_maxSize];
-      }
-    }
-
-    public int MaxSize
-    {
-      get
-      {
-        lock (this)
-          return this.m_maxSize;
-      }
-    }
-
-    public int Length
-    {
-      get
-      {
-        lock (this)
-          return this.m_numElems;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/EmptyCollection.cs b/MSHALTester/log4net/Util/EmptyCollection.cs
deleted file mode 100644
index 12a22db..0000000
--- a/MSHALTester/log4net/Util/EmptyCollection.cs
+++ /dev/null
@@ -1,30 +0,0 @@
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Util
-{
-  [Serializable]
-  public sealed class EmptyCollection : ICollection, IEnumerable
-  {
-    private static readonly EmptyCollection s_instance = new EmptyCollection();
-
-    private EmptyCollection()
-    {
-    }
-
-    public static EmptyCollection Instance => EmptyCollection.s_instance;
-
-    public void CopyTo(Array array, int index)
-    {
-    }
-
-    public bool IsSynchronized => true;
-
-    public int Count => 0;
-
-    public object SyncRoot => (object) this;
-
-    public IEnumerator GetEnumerator() => (IEnumerator) NullEnumerator.Instance;
-  }
-}
diff --git a/MSHALTester/log4net/Util/EmptyDictionary.cs b/MSHALTester/log4net/Util/EmptyDictionary.cs
deleted file mode 100644
index 256150a..0000000
--- a/MSHALTester/log4net/Util/EmptyDictionary.cs
+++ /dev/null
@@ -1,57 +0,0 @@
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Util
-{
-  [Serializable]
-  public sealed class EmptyDictionary : IDictionary, ICollection, IEnumerable
-  {
-    private static readonly EmptyDictionary s_instance = new EmptyDictionary();
-
-    private EmptyDictionary()
-    {
-    }
-
-    public static EmptyDictionary Instance => EmptyDictionary.s_instance;
-
-    public void CopyTo(Array array, int index)
-    {
-    }
-
-    public bool IsSynchronized => true;
-
-    public int Count => 0;
-
-    public object SyncRoot => (object) this;
-
-    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) NullEnumerator.Instance;
-
-    public void Add(object key, object value) => throw new InvalidOperationException();
-
-    public void Clear() => throw new InvalidOperationException();
-
-    public bool Contains(object key) => false;
-
-    public IDictionaryEnumerator GetEnumerator()
-    {
-      return (IDictionaryEnumerator) NullDictionaryEnumerator.Instance;
-    }
-
-    public void Remove(object key) => throw new InvalidOperationException();
-
-    public bool IsFixedSize => true;
-
-    public bool IsReadOnly => true;
-
-    public ICollection Keys => (ICollection) EmptyCollection.Instance;
-
-    public ICollection Values => (ICollection) EmptyCollection.Instance;
-
-    public object this[object key]
-    {
-      get => (object) null;
-      set => throw new InvalidOperationException();
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/FormattingInfo.cs b/MSHALTester/log4net/Util/FormattingInfo.cs
deleted file mode 100644
index 730e132..0000000
--- a/MSHALTester/log4net/Util/FormattingInfo.cs
+++ /dev/null
@@ -1,39 +0,0 @@
-#nullable disable
-namespace log4net.Util
-{
-  public class FormattingInfo
-  {
-    private int m_min = -1;
-    private int m_max = int.MaxValue;
-    private bool m_leftAlign = false;
-
-    public FormattingInfo()
-    {
-    }
-
-    public FormattingInfo(int min, int max, bool leftAlign)
-    {
-      this.m_min = min;
-      this.m_max = max;
-      this.m_leftAlign = leftAlign;
-    }
-
-    public int Min
-    {
-      get => this.m_min;
-      set => this.m_min = value;
-    }
-
-    public int Max
-    {
-      get => this.m_max;
-      set => this.m_max = value;
-    }
-
-    public bool LeftAlign
-    {
-      get => this.m_leftAlign;
-      set => this.m_leftAlign = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/GlobalContextProperties.cs b/MSHALTester/log4net/Util/GlobalContextProperties.cs
deleted file mode 100644
index c2af457..0000000
--- a/MSHALTester/log4net/Util/GlobalContextProperties.cs
+++ /dev/null
@@ -1,47 +0,0 @@
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class GlobalContextProperties : ContextPropertiesBase
-  {
-    private volatile ReadOnlyPropertiesDictionary m_readOnlyProperties = new ReadOnlyPropertiesDictionary();
-    private readonly object m_syncRoot = new object();
-
-    internal GlobalContextProperties()
-    {
-    }
-
-    public override object this[string key]
-    {
-      get => this.m_readOnlyProperties[key];
-      set
-      {
-        lock (this.m_syncRoot)
-        {
-          PropertiesDictionary propertiesDictionary = new PropertiesDictionary(this.m_readOnlyProperties);
-          propertiesDictionary[key] = value;
-          this.m_readOnlyProperties = new ReadOnlyPropertiesDictionary((ReadOnlyPropertiesDictionary) propertiesDictionary);
-        }
-      }
-    }
-
-    public void Remove(string key)
-    {
-      lock (this.m_syncRoot)
-      {
-        if (!this.m_readOnlyProperties.Contains(key))
-          return;
-        PropertiesDictionary propertiesDictionary = new PropertiesDictionary(this.m_readOnlyProperties);
-        propertiesDictionary.Remove(key);
-        this.m_readOnlyProperties = new ReadOnlyPropertiesDictionary((ReadOnlyPropertiesDictionary) propertiesDictionary);
-      }
-    }
-
-    public void Clear()
-    {
-      lock (this.m_syncRoot)
-        this.m_readOnlyProperties = new ReadOnlyPropertiesDictionary();
-    }
-
-    internal ReadOnlyPropertiesDictionary GetReadOnlyProperties() => this.m_readOnlyProperties;
-  }
-}
diff --git a/MSHALTester/log4net/Util/LevelMapping.cs b/MSHALTester/log4net/Util/LevelMapping.cs
deleted file mode 100644
index c2808f6..0000000
--- a/MSHALTester/log4net/Util/LevelMapping.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-using log4net.Core;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class LevelMapping : IOptionHandler
-  {
-    private Hashtable m_entriesMap = new Hashtable();
-    private LevelMappingEntry[] m_entries = (LevelMappingEntry[]) null;
-
-    public void Add(LevelMappingEntry entry)
-    {
-      if (this.m_entriesMap.ContainsKey((object) entry.Level))
-        this.m_entriesMap.Remove((object) entry.Level);
-      this.m_entriesMap.Add((object) entry.Level, (object) entry);
-    }
-
-    public LevelMappingEntry Lookup(Level level)
-    {
-      if (this.m_entries != null)
-      {
-        foreach (LevelMappingEntry entry in this.m_entries)
-        {
-          if (level >= entry.Level)
-            return entry;
-        }
-      }
-      return (LevelMappingEntry) null;
-    }
-
-    public void ActivateOptions()
-    {
-      Level[] keys = new Level[this.m_entriesMap.Count];
-      LevelMappingEntry[] items = new LevelMappingEntry[this.m_entriesMap.Count];
-      this.m_entriesMap.Keys.CopyTo((Array) keys, 0);
-      this.m_entriesMap.Values.CopyTo((Array) items, 0);
-      Array.Sort((Array) keys, (Array) items, 0, keys.Length, (IComparer) null);
-      Array.Reverse((Array) items, 0, items.Length);
-      foreach (LevelMappingEntry levelMappingEntry in items)
-        levelMappingEntry.ActivateOptions();
-      this.m_entries = items;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/LevelMappingEntry.cs b/MSHALTester/log4net/Util/LevelMappingEntry.cs
deleted file mode 100644
index 1de7dda..0000000
--- a/MSHALTester/log4net/Util/LevelMappingEntry.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-using log4net.Core;
-
-#nullable disable
-namespace log4net.Util
-{
-  public abstract class LevelMappingEntry : IOptionHandler
-  {
-    private Level m_level;
-
-    public Level Level
-    {
-      get => this.m_level;
-      set => this.m_level = value;
-    }
-
-    public virtual void ActivateOptions()
-    {
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/LogLog.cs b/MSHALTester/log4net/Util/LogLog.cs
deleted file mode 100644
index 75b4a69..0000000
--- a/MSHALTester/log4net/Util/LogLog.cs
+++ /dev/null
@@ -1,114 +0,0 @@
-using System;
-using System.Configuration;
-using System.Diagnostics;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class LogLog
-  {
-    private const string PREFIX = "log4net: ";
-    private const string ERR_PREFIX = "log4net:ERROR ";
-    private const string WARN_PREFIX = "log4net:WARN ";
-    private static bool s_debugEnabled = false;
-    private static bool s_quietMode = false;
-
-    private LogLog()
-    {
-    }
-
-    static LogLog()
-    {
-      try
-      {
-        LogLog.InternalDebugging = OptionConverter.ToBoolean(ConfigurationSettings.AppSettings["log4net.Internal.Debug"], false);
-        LogLog.QuietMode = OptionConverter.ToBoolean(ConfigurationSettings.AppSettings["log4net.Internal.Quiet"], false);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("LogLog: Exception while reading ConfigurationSettings. Check your .config file is well formed XML.", ex);
-      }
-    }
-
-    public static bool InternalDebugging
-    {
-      get => LogLog.s_debugEnabled;
-      set => LogLog.s_debugEnabled = value;
-    }
-
-    public static bool QuietMode
-    {
-      get => LogLog.s_quietMode;
-      set => LogLog.s_quietMode = value;
-    }
-
-    public static bool IsDebugEnabled => LogLog.s_debugEnabled && !LogLog.s_quietMode;
-
-    public static void Debug(string message)
-    {
-      if (!LogLog.IsDebugEnabled)
-        return;
-      LogLog.EmitOutLine("log4net: " + message);
-    }
-
-    public static void Debug(string message, Exception exception)
-    {
-      if (!LogLog.IsDebugEnabled)
-        return;
-      LogLog.EmitOutLine("log4net: " + message);
-      if (exception == null)
-        return;
-      LogLog.EmitOutLine(exception.ToString());
-    }
-
-    public static bool IsWarnEnabled => !LogLog.s_quietMode;
-
-    public static void Warn(string message)
-    {
-      if (!LogLog.IsWarnEnabled)
-        return;
-      LogLog.EmitErrorLine("log4net:WARN " + message);
-    }
-
-    public static void Warn(string message, Exception exception)
-    {
-      if (!LogLog.IsWarnEnabled)
-        return;
-      LogLog.EmitErrorLine("log4net:WARN " + message);
-      if (exception == null)
-        return;
-      LogLog.EmitErrorLine(exception.ToString());
-    }
-
-    public static bool IsErrorEnabled => !LogLog.s_quietMode;
-
-    public static void Error(string message)
-    {
-      if (!LogLog.IsErrorEnabled)
-        return;
-      LogLog.EmitErrorLine("log4net:ERROR " + message);
-    }
-
-    public static void Error(string message, Exception exception)
-    {
-      if (!LogLog.IsErrorEnabled)
-        return;
-      LogLog.EmitErrorLine("log4net:ERROR " + message);
-      if (exception == null)
-        return;
-      LogLog.EmitErrorLine(exception.ToString());
-    }
-
-    private static void EmitOutLine(string message)
-    {
-      Console.Out.WriteLine(message);
-      Trace.WriteLine(message);
-    }
-
-    private static void EmitErrorLine(string message)
-    {
-      Console.Error.WriteLine(message);
-      Trace.WriteLine(message);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/LogicalThreadContextProperties.cs b/MSHALTester/log4net/Util/LogicalThreadContextProperties.cs
deleted file mode 100644
index 10534c7..0000000
--- a/MSHALTester/log4net/Util/LogicalThreadContextProperties.cs
+++ /dev/null
@@ -1,33 +0,0 @@
-using System.Runtime.Remoting.Messaging;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class LogicalThreadContextProperties : ContextPropertiesBase
-  {
-    internal LogicalThreadContextProperties()
-    {
-    }
-
-    public override object this[string key]
-    {
-      get => this.GetProperties(false)?[key];
-      set => this.GetProperties(true)[key] = value;
-    }
-
-    public void Remove(string key) => this.GetProperties(false)?.Remove(key);
-
-    public void Clear() => this.GetProperties(false)?.Clear();
-
-    internal PropertiesDictionary GetProperties(bool create)
-    {
-      PropertiesDictionary data = (PropertiesDictionary) CallContext.GetData("log4net.Util.LogicalThreadContextProperties");
-      if (data == null && create)
-      {
-        data = new PropertiesDictionary();
-        CallContext.SetData("log4net.Util.LogicalThreadContextProperties", (object) data);
-      }
-      return data;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/NativeError.cs b/MSHALTester/log4net/Util/NativeError.cs
deleted file mode 100644
index fbfd029..0000000
--- a/MSHALTester/log4net/Util/NativeError.cs
+++ /dev/null
@@ -1,70 +0,0 @@
-using System;
-using System.Globalization;
-using System.Runtime.InteropServices;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class NativeError
-  {
-    private int m_number;
-    private string m_message;
-
-    private NativeError(int number, string message)
-    {
-      this.m_number = number;
-      this.m_message = message;
-    }
-
-    public int Number => this.m_number;
-
-    public string Message => this.m_message;
-
-    public static NativeError GetLastError()
-    {
-      int lastWin32Error = Marshal.GetLastWin32Error();
-      return new NativeError(lastWin32Error, NativeError.GetErrorMessage(lastWin32Error));
-    }
-
-    public static NativeError GetError(int number)
-    {
-      return new NativeError(number, NativeError.GetErrorMessage(number));
-    }
-
-    public static string GetErrorMessage(int messageId)
-    {
-      int num1 = 256;
-      int num2 = 512;
-      int num3 = 4096;
-      string lpBuffer = "";
-      IntPtr lpSource = new IntPtr();
-      IntPtr Arguments = new IntPtr();
-      string errorMessage;
-      if (messageId != 0)
-      {
-        if (NativeError.FormatMessage(num1 | num3 | num2, ref lpSource, messageId, 0, ref lpBuffer, (int) byte.MaxValue, Arguments) > 0)
-          errorMessage = lpBuffer.TrimEnd('\r', '\n');
-        else
-          errorMessage = (string) null;
-      }
-      else
-        errorMessage = (string) null;
-      return errorMessage;
-    }
-
-    public override string ToString()
-    {
-      return string.Format((IFormatProvider) CultureInfo.InvariantCulture, "0x{0:x8}", (object) this.Number) + (this.Message != null ? ": " + this.Message : "");
-    }
-
-    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
-    private static extern int FormatMessage(
-      int dwFlags,
-      ref IntPtr lpSource,
-      int dwMessageId,
-      int dwLanguageId,
-      ref string lpBuffer,
-      int nSize,
-      IntPtr Arguments);
-  }
-}
diff --git a/MSHALTester/log4net/Util/NullDictionaryEnumerator.cs b/MSHALTester/log4net/Util/NullDictionaryEnumerator.cs
deleted file mode 100644
index c0163bf..0000000
--- a/MSHALTester/log4net/Util/NullDictionaryEnumerator.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class NullDictionaryEnumerator : IDictionaryEnumerator, IEnumerator
-  {
-    private static readonly NullDictionaryEnumerator s_instance = new NullDictionaryEnumerator();
-
-    private NullDictionaryEnumerator()
-    {
-    }
-
-    public static NullDictionaryEnumerator Instance => NullDictionaryEnumerator.s_instance;
-
-    public object Current => throw new InvalidOperationException();
-
-    public bool MoveNext() => false;
-
-    public void Reset()
-    {
-    }
-
-    public object Key => throw new InvalidOperationException();
-
-    public object Value => throw new InvalidOperationException();
-
-    public DictionaryEntry Entry => throw new InvalidOperationException();
-  }
-}
diff --git a/MSHALTester/log4net/Util/NullEnumerator.cs b/MSHALTester/log4net/Util/NullEnumerator.cs
deleted file mode 100644
index 4a31748..0000000
--- a/MSHALTester/log4net/Util/NullEnumerator.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class NullEnumerator : IEnumerator
-  {
-    private static readonly NullEnumerator s_instance = new NullEnumerator();
-
-    private NullEnumerator()
-    {
-    }
-
-    public static NullEnumerator Instance => NullEnumerator.s_instance;
-
-    public object Current => throw new InvalidOperationException();
-
-    public bool MoveNext() => false;
-
-    public void Reset()
-    {
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/NullSecurityContext.cs b/MSHALTester/log4net/Util/NullSecurityContext.cs
deleted file mode 100644
index 0372fa5..0000000
--- a/MSHALTester/log4net/Util/NullSecurityContext.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class NullSecurityContext : SecurityContext
-  {
-    public static readonly NullSecurityContext Instance = new NullSecurityContext();
-
-    private NullSecurityContext()
-    {
-    }
-
-    public override IDisposable Impersonate(object state) => (IDisposable) null;
-  }
-}
diff --git a/MSHALTester/log4net/Util/OnlyOnceErrorHandler.cs b/MSHALTester/log4net/Util/OnlyOnceErrorHandler.cs
deleted file mode 100644
index 0ed5e38..0000000
--- a/MSHALTester/log4net/Util/OnlyOnceErrorHandler.cs
+++ /dev/null
@@ -1,50 +0,0 @@
-using log4net.Core;
-using System;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class OnlyOnceErrorHandler : IErrorHandler
-  {
-    private bool m_firstTime = true;
-    private readonly string m_prefix;
-
-    public OnlyOnceErrorHandler() => this.m_prefix = "";
-
-    public OnlyOnceErrorHandler(string prefix) => this.m_prefix = prefix;
-
-    public void Error(string message, Exception e, ErrorCode errorCode)
-    {
-      if (!this.IsEnabled)
-        return;
-      LogLog.Error("[" + this.m_prefix + "] " + message, e);
-    }
-
-    public void Error(string message, Exception e)
-    {
-      if (!this.IsEnabled)
-        return;
-      LogLog.Error("[" + this.m_prefix + "] " + message, e);
-    }
-
-    public void Error(string message)
-    {
-      if (!this.IsEnabled)
-        return;
-      LogLog.Error("[" + this.m_prefix + "] " + message);
-    }
-
-    private bool IsEnabled
-    {
-      get
-      {
-        if (this.m_firstTime)
-        {
-          this.m_firstTime = false;
-          return true;
-        }
-        return LogLog.InternalDebugging && !LogLog.QuietMode;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/OptionConverter.cs b/MSHALTester/log4net/Util/OptionConverter.cs
deleted file mode 100644
index 156285e..0000000
--- a/MSHALTester/log4net/Util/OptionConverter.cs
+++ /dev/null
@@ -1,190 +0,0 @@
-using log4net.Core;
-using log4net.Util.TypeConverters;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.Reflection;
-using System.Text;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class OptionConverter
-  {
-    private const string DELIM_START = "${";
-    private const char DELIM_STOP = '}';
-    private const int DELIM_START_LEN = 2;
-    private const int DELIM_STOP_LEN = 1;
-
-    private OptionConverter()
-    {
-    }
-
-    public static bool ToBoolean(string argValue, bool defaultValue)
-    {
-      if (argValue != null)
-      {
-        if (argValue.Length > 0)
-        {
-          try
-          {
-            return bool.Parse(argValue);
-          }
-          catch (Exception ex)
-          {
-            LogLog.Error("OptionConverter: [" + argValue + "] is not in proper bool form.", ex);
-          }
-        }
-      }
-      return defaultValue;
-    }
-
-    public static long ToFileSize(string argValue, long defaultValue)
-    {
-      if (argValue == null)
-        return defaultValue;
-      string str = argValue.Trim().ToUpper(CultureInfo.InvariantCulture);
-      long num = 1;
-      int length1;
-      if ((length1 = str.IndexOf("KB")) != -1)
-      {
-        num = 1024L;
-        str = str.Substring(0, length1);
-      }
-      else
-      {
-        int length2;
-        if ((length2 = str.IndexOf("MB")) != -1)
-        {
-          num = 1048576L;
-          str = str.Substring(0, length2);
-        }
-        else
-        {
-          int length3;
-          if ((length3 = str.IndexOf("GB")) != -1)
-          {
-            num = 1073741824L;
-            str = str.Substring(0, length3);
-          }
-        }
-      }
-      if (str != null)
-      {
-        string s = str.Trim();
-        long val;
-        if (SystemInfo.TryParse(s, out val))
-          return val * num;
-        LogLog.Error("OptionConverter: [" + s + "] is not in the correct file size syntax.");
-      }
-      return defaultValue;
-    }
-
-    public static object ConvertStringTo(Type target, string txt)
-    {
-      if (target == null)
-        throw new ArgumentNullException(nameof (target));
-      if (target == typeof (string))
-        return (object) txt;
-      IConvertFrom convertFrom = ConverterRegistry.GetConvertFrom(target);
-      if (convertFrom != null && convertFrom.CanConvertFrom(typeof (string)))
-        return convertFrom.ConvertFrom((object) txt);
-      if (target.IsEnum)
-        return OptionConverter.ParseEnum(target, txt, true);
-      return target.GetMethod("Parse", new Type[1]
-      {
-        typeof (string)
-      })?.Invoke((object) null, BindingFlags.InvokeMethod, (Binder) null, new object[1]
-      {
-        (object) txt
-      }, CultureInfo.InvariantCulture);
-    }
-
-    public static bool CanConvertTypeTo(Type sourceType, Type targetType)
-    {
-      if (sourceType == null || targetType == null)
-        return false;
-      if (targetType.IsAssignableFrom(sourceType))
-        return true;
-      IConvertTo convertTo = ConverterRegistry.GetConvertTo(sourceType, targetType);
-      if (convertTo != null && convertTo.CanConvertTo(targetType))
-        return true;
-      IConvertFrom convertFrom = ConverterRegistry.GetConvertFrom(targetType);
-      return convertFrom != null && convertFrom.CanConvertFrom(sourceType);
-    }
-
-    public static object ConvertTypeTo(object sourceInstance, Type targetType)
-    {
-      Type type = sourceInstance.GetType();
-      if (targetType.IsAssignableFrom(type))
-        return sourceInstance;
-      IConvertTo convertTo = ConverterRegistry.GetConvertTo(type, targetType);
-      if (convertTo != null && convertTo.CanConvertTo(targetType))
-        return convertTo.ConvertTo(sourceInstance, targetType);
-      IConvertFrom convertFrom = ConverterRegistry.GetConvertFrom(targetType);
-      return convertFrom != null && convertFrom.CanConvertFrom(type) ? convertFrom.ConvertFrom(sourceInstance) : throw new ArgumentException("Cannot convert source object [" + sourceInstance.ToString() + "] to target type [" + targetType.Name + "]", nameof (sourceInstance));
-    }
-
-    public static object InstantiateByClassName(
-      string className,
-      Type superClass,
-      object defaultValue)
-    {
-      if (className != null)
-      {
-        try
-        {
-          Type typeFromString = SystemInfo.GetTypeFromString(className, true, true);
-          if (superClass.IsAssignableFrom(typeFromString))
-            return Activator.CreateInstance(typeFromString);
-          LogLog.Error("OptionConverter: A [" + className + "] object is not assignable to a [" + superClass.FullName + "] variable.");
-          return defaultValue;
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("OptionConverter: Could not instantiate class [" + className + "].", ex);
-        }
-      }
-      return defaultValue;
-    }
-
-    public static string SubstituteVariables(string value, IDictionary props)
-    {
-      StringBuilder stringBuilder = new StringBuilder();
-      int startIndex1 = 0;
-      int startIndex2;
-      while (true)
-      {
-        startIndex2 = value.IndexOf("${", startIndex1);
-        if (startIndex2 != -1)
-        {
-          stringBuilder.Append(value.Substring(startIndex1, startIndex2 - startIndex1));
-          int num = value.IndexOf('}', startIndex2);
-          if (num != -1)
-          {
-            int startIndex3 = startIndex2 + 2;
-            string key = value.Substring(startIndex3, num - startIndex3);
-            if (props[(object) key] is string prop)
-              stringBuilder.Append(prop);
-            startIndex1 = num + 1;
-          }
-          else
-            goto label_6;
-        }
-        else
-          break;
-      }
-      if (startIndex1 == 0)
-        return value;
-      stringBuilder.Append(value.Substring(startIndex1, value.Length - startIndex1));
-      return stringBuilder.ToString();
-label_6:
-      throw new LogException("[" + value + "] has no closing brace. Opening brace at position [" + (object) startIndex2 + "]");
-    }
-
-    private static object ParseEnum(Type enumType, string value, bool ignoreCase)
-    {
-      return Enum.Parse(enumType, value, ignoreCase);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternConverter.cs b/MSHALTester/log4net/Util/PatternConverter.cs
deleted file mode 100644
index 179d506..0000000
--- a/MSHALTester/log4net/Util/PatternConverter.cs
+++ /dev/null
@@ -1,134 +0,0 @@
-using log4net.Repository;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace log4net.Util
-{
-  public abstract class PatternConverter
-  {
-    private const int c_renderBufferSize = 256;
-    private const int c_renderBufferMaxCapacity = 1024;
-    private static readonly string[] SPACES = new string[6]
-    {
-      " ",
-      "  ",
-      "    ",
-      "        ",
-      "                ",
-      "                                "
-    };
-    private PatternConverter m_next;
-    private int m_min = -1;
-    private int m_max = int.MaxValue;
-    private bool m_leftAlign = false;
-    private string m_option = (string) null;
-    private ReusableStringWriter m_formatWriter = new ReusableStringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-
-    public virtual PatternConverter Next => this.m_next;
-
-    public virtual FormattingInfo FormattingInfo
-    {
-      get => new FormattingInfo(this.m_min, this.m_max, this.m_leftAlign);
-      set
-      {
-        this.m_min = value.Min;
-        this.m_max = value.Max;
-        this.m_leftAlign = value.LeftAlign;
-      }
-    }
-
-    public virtual string Option
-    {
-      get => this.m_option;
-      set => this.m_option = value;
-    }
-
-    protected abstract void Convert(TextWriter writer, object state);
-
-    public virtual PatternConverter SetNext(PatternConverter patternConverter)
-    {
-      this.m_next = patternConverter;
-      return this.m_next;
-    }
-
-    public virtual void Format(TextWriter writer, object state)
-    {
-      if (this.m_min < 0 && this.m_max == int.MaxValue)
-      {
-        this.Convert(writer, state);
-      }
-      else
-      {
-        this.m_formatWriter.Reset(1024, 256);
-        this.Convert((TextWriter) this.m_formatWriter, state);
-        StringBuilder stringBuilder = this.m_formatWriter.GetStringBuilder();
-        int length = stringBuilder.Length;
-        if (length > this.m_max)
-          writer.Write(stringBuilder.ToString(length - this.m_max, this.m_max));
-        else if (length < this.m_min)
-        {
-          if (this.m_leftAlign)
-          {
-            writer.Write(stringBuilder.ToString());
-            PatternConverter.SpacePad(writer, this.m_min - length);
-          }
-          else
-          {
-            PatternConverter.SpacePad(writer, this.m_min - length);
-            writer.Write(stringBuilder.ToString());
-          }
-        }
-        else
-          writer.Write(stringBuilder.ToString());
-      }
-    }
-
-    protected static void SpacePad(TextWriter writer, int length)
-    {
-      for (; length >= 32; length -= 32)
-        writer.Write(PatternConverter.SPACES[5]);
-      for (int index = 4; index >= 0; --index)
-      {
-        if ((length & 1 << index) != 0)
-          writer.Write(PatternConverter.SPACES[index]);
-      }
-    }
-
-    protected static void WriteDictionary(
-      TextWriter writer,
-      ILoggerRepository repository,
-      IDictionary value)
-    {
-      writer.Write("{");
-      bool flag = true;
-      foreach (DictionaryEntry dictionaryEntry in value)
-      {
-        if (flag)
-          flag = false;
-        else
-          writer.Write(", ");
-        PatternConverter.WriteObject(writer, repository, dictionaryEntry.Key);
-        writer.Write("=");
-        PatternConverter.WriteObject(writer, repository, dictionaryEntry.Value);
-      }
-      writer.Write("}");
-    }
-
-    protected static void WriteObject(
-      TextWriter writer,
-      ILoggerRepository repository,
-      object value)
-    {
-      if (repository != null)
-        repository.RendererMap.FindAndRender(value, writer);
-      else if (value == null)
-        writer.Write("(null)");
-      else
-        writer.Write(value.ToString());
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternParser.cs b/MSHALTester/log4net/Util/PatternParser.cs
deleted file mode 100644
index fe60582..0000000
--- a/MSHALTester/log4net/Util/PatternParser.cs
+++ /dev/null
@@ -1,165 +0,0 @@
-using log4net.Core;
-using System;
-using System.Collections;
-using System.Globalization;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class PatternParser
-  {
-    private const char ESCAPE_CHAR = '%';
-    private PatternConverter m_head;
-    private PatternConverter m_tail;
-    private string m_pattern;
-    private Hashtable m_patternConverters = new Hashtable();
-
-    public PatternParser(string pattern) => this.m_pattern = pattern;
-
-    public PatternConverter Parse()
-    {
-      this.ParseInternal(this.m_pattern, this.BuildCache());
-      return this.m_head;
-    }
-
-    public Hashtable PatternConverters => this.m_patternConverters;
-
-    private string[] BuildCache()
-    {
-      string[] strArray = new string[this.m_patternConverters.Keys.Count];
-      this.m_patternConverters.Keys.CopyTo((Array) strArray, 0);
-      Array.Sort((Array) strArray, 0, strArray.Length, (IComparer) PatternParser.StringLengthComparer.Instance);
-      return strArray;
-    }
-
-    private void ParseInternal(string pattern, string[] matches)
-    {
-      int num1 = 0;
-      while (num1 < pattern.Length)
-      {
-        int num2 = pattern.IndexOf('%', num1);
-        if (num2 < 0 || num2 == pattern.Length - 1)
-        {
-          this.ProcessLiteral(pattern.Substring(num1));
-          num1 = pattern.Length;
-        }
-        else if (pattern[num2 + 1] == '%')
-        {
-          this.ProcessLiteral(pattern.Substring(num1, num2 - num1 + 1));
-          num1 = num2 + 2;
-        }
-        else
-        {
-          this.ProcessLiteral(pattern.Substring(num1, num2 - num1));
-          num1 = num2 + 1;
-          FormattingInfo formattingInfo = new FormattingInfo();
-          if (num1 < pattern.Length && pattern[num1] == '-')
-          {
-            formattingInfo.LeftAlign = true;
-            ++num1;
-          }
-          for (; num1 < pattern.Length && char.IsDigit(pattern[num1]); ++num1)
-          {
-            if (formattingInfo.Min < 0)
-              formattingInfo.Min = 0;
-            formattingInfo.Min = formattingInfo.Min * 10 + int.Parse(pattern[num1].ToString((IFormatProvider) CultureInfo.InvariantCulture), (IFormatProvider) NumberFormatInfo.InvariantInfo);
-          }
-          if (num1 < pattern.Length && pattern[num1] == '.')
-            ++num1;
-          for (; num1 < pattern.Length && char.IsDigit(pattern[num1]); ++num1)
-          {
-            if (formattingInfo.Max == int.MaxValue)
-              formattingInfo.Max = 0;
-            formattingInfo.Max = formattingInfo.Max * 10 + int.Parse(pattern[num1].ToString((IFormatProvider) CultureInfo.InvariantCulture), (IFormatProvider) NumberFormatInfo.InvariantInfo);
-          }
-          int num3 = pattern.Length - num1;
-          for (int index = 0; index < matches.Length; ++index)
-          {
-            if (matches[index].Length <= num3 && string.Compare(pattern, num1, matches[index], 0, matches[index].Length, false, CultureInfo.InvariantCulture) == 0)
-            {
-              num1 += matches[index].Length;
-              string option = (string) null;
-              if (num1 < pattern.Length && pattern[num1] == '{')
-              {
-                ++num1;
-                int num4 = pattern.IndexOf('}', num1);
-                if (num4 >= 0)
-                {
-                  option = pattern.Substring(num1, num4 - num1);
-                  num1 = num4 + 1;
-                }
-              }
-              this.ProcessConverter(matches[index], option, formattingInfo);
-              break;
-            }
-          }
-        }
-      }
-    }
-
-    private void ProcessLiteral(string text)
-    {
-      if (text.Length <= 0)
-        return;
-      this.ProcessConverter("literal", text, new FormattingInfo());
-    }
-
-    private void ProcessConverter(
-      string converterName,
-      string option,
-      FormattingInfo formattingInfo)
-    {
-      LogLog.Debug("PatternParser: Converter [" + converterName + "] Option [" + option + "] Format [min=" + (object) formattingInfo.Min + ",max=" + (object) formattingInfo.Max + ",leftAlign=" + (object) formattingInfo.LeftAlign + "]");
-      Type patternConverter = (Type) this.m_patternConverters[(object) converterName];
-      if (patternConverter == null)
-      {
-        LogLog.Error("PatternParser: Unknown converter name [" + converterName + "] in conversion pattern.");
-      }
-      else
-      {
-        PatternConverter pc = (PatternConverter) null;
-        try
-        {
-          pc = (PatternConverter) Activator.CreateInstance(patternConverter);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("PatternParser: Failed to create instance of Type [" + patternConverter.FullName + "] using default constructor. Exception: " + ex.ToString());
-        }
-        pc.FormattingInfo = formattingInfo;
-        pc.Option = option;
-        if (pc is IOptionHandler optionHandler)
-          optionHandler.ActivateOptions();
-        this.AddConverter(pc);
-      }
-    }
-
-    private void AddConverter(PatternConverter pc)
-    {
-      if (this.m_head == null)
-        this.m_head = this.m_tail = pc;
-      else
-        this.m_tail = this.m_tail.SetNext(pc);
-    }
-
-    private sealed class StringLengthComparer : IComparer
-    {
-      public static readonly PatternParser.StringLengthComparer Instance = new PatternParser.StringLengthComparer();
-
-      private StringLengthComparer()
-      {
-      }
-
-      public int Compare(object x, object y)
-      {
-        string str1 = x as string;
-        string str2 = y as string;
-        if (str1 == null && str2 == null)
-          return 0;
-        if (str1 == null)
-          return 1;
-        return str2 == null ? -1 : str2.Length.CompareTo((object) str1.Length);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternString.cs b/MSHALTester/log4net/Util/PatternString.cs
deleted file mode 100644
index a4fc40d..0000000
--- a/MSHALTester/log4net/Util/PatternString.cs
+++ /dev/null
@@ -1,113 +0,0 @@
-using log4net.Core;
-using log4net.Util.PatternStringConverters;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class PatternString : IOptionHandler
-  {
-    private static Hashtable s_globalRulesRegistry = new Hashtable(10);
-    private string m_pattern;
-    private PatternConverter m_head;
-    private Hashtable m_instanceRulesRegistry = new Hashtable();
-
-    static PatternString()
-    {
-      PatternString.s_globalRulesRegistry.Add((object) "appdomain", (object) typeof (AppDomainPatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "date", (object) typeof (DatePatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "env", (object) typeof (EnvironmentPatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "identity", (object) typeof (IdentityPatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "literal", (object) typeof (LiteralPatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "newline", (object) typeof (NewLinePatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "processid", (object) typeof (ProcessIdPatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "property", (object) typeof (PropertyPatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "random", (object) typeof (RandomStringPatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "username", (object) typeof (UserNamePatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "utcdate", (object) typeof (UtcDatePatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "utcDate", (object) typeof (UtcDatePatternConverter));
-      PatternString.s_globalRulesRegistry.Add((object) "UtcDate", (object) typeof (UtcDatePatternConverter));
-    }
-
-    public PatternString()
-    {
-    }
-
-    public PatternString(string pattern)
-    {
-      this.m_pattern = pattern;
-      this.ActivateOptions();
-    }
-
-    public string ConversionPattern
-    {
-      get => this.m_pattern;
-      set => this.m_pattern = value;
-    }
-
-    public virtual void ActivateOptions()
-    {
-      this.m_head = this.CreatePatternParser(this.m_pattern).Parse();
-    }
-
-    private PatternParser CreatePatternParser(string pattern)
-    {
-      PatternParser patternParser = new PatternParser(pattern);
-      foreach (DictionaryEntry dictionaryEntry in PatternString.s_globalRulesRegistry)
-        patternParser.PatternConverters.Add(dictionaryEntry.Key, dictionaryEntry.Value);
-      foreach (DictionaryEntry dictionaryEntry in this.m_instanceRulesRegistry)
-        patternParser.PatternConverters[dictionaryEntry.Key] = dictionaryEntry.Value;
-      return patternParser;
-    }
-
-    public void Format(TextWriter writer)
-    {
-      if (writer == null)
-        throw new ArgumentNullException(nameof (writer));
-      for (PatternConverter patternConverter = this.m_head; patternConverter != null; patternConverter = patternConverter.Next)
-        patternConverter.Format(writer, (object) null);
-    }
-
-    public string Format()
-    {
-      StringWriter writer = new StringWriter((IFormatProvider) CultureInfo.InvariantCulture);
-      this.Format((TextWriter) writer);
-      return writer.ToString();
-    }
-
-    public void AddConverter(PatternString.ConverterInfo converterInfo)
-    {
-      this.AddConverter(converterInfo.Name, converterInfo.Type);
-    }
-
-    public void AddConverter(string name, Type type)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (type == null)
-        throw new ArgumentNullException(nameof (type));
-      this.m_instanceRulesRegistry[(object) name] = typeof (PatternConverter).IsAssignableFrom(type) ? (object) type : throw new ArgumentException("The converter type specified [" + (object) type + "] must be a subclass of log4net.Util.PatternConverter", nameof (type));
-    }
-
-    public sealed class ConverterInfo
-    {
-      private string m_name;
-      private Type m_type;
-
-      public string Name
-      {
-        get => this.m_name;
-        set => this.m_name = value;
-      }
-
-      public Type Type
-      {
-        get => this.m_type;
-        set => this.m_type = value;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/AppDomainPatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/AppDomainPatternConverter.cs
deleted file mode 100644
index 86acd28..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/AppDomainPatternConverter.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal sealed class AppDomainPatternConverter : PatternConverter
-  {
-    protected override void Convert(TextWriter writer, object state)
-    {
-      writer.Write(SystemInfo.ApplicationFriendlyName);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/DatePatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/DatePatternConverter.cs
deleted file mode 100644
index c26c66f..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/DatePatternConverter.cs
+++ /dev/null
@@ -1,51 +0,0 @@
-using log4net.Core;
-using log4net.DateFormatter;
-using System;
-using System.Globalization;
-using System.IO;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal class DatePatternConverter : PatternConverter, IOptionHandler
-  {
-    protected IDateFormatter m_dateFormatter;
-
-    public void ActivateOptions()
-    {
-      string str = this.Option ?? "ISO8601";
-      if (string.Compare(str, "ISO8601", true, CultureInfo.InvariantCulture) == 0)
-        this.m_dateFormatter = (IDateFormatter) new Iso8601DateFormatter();
-      else if (string.Compare(str, "ABSOLUTE", true, CultureInfo.InvariantCulture) == 0)
-        this.m_dateFormatter = (IDateFormatter) new AbsoluteTimeDateFormatter();
-      else if (string.Compare(str, "DATE", true, CultureInfo.InvariantCulture) == 0)
-      {
-        this.m_dateFormatter = (IDateFormatter) new DateTimeDateFormatter();
-      }
-      else
-      {
-        try
-        {
-          this.m_dateFormatter = (IDateFormatter) new SimpleDateFormatter(str);
-        }
-        catch (Exception ex)
-        {
-          LogLog.Error("DatePatternConverter: Could not instantiate SimpleDateFormatter with [" + str + "]", ex);
-          this.m_dateFormatter = (IDateFormatter) new Iso8601DateFormatter();
-        }
-      }
-    }
-
-    protected override void Convert(TextWriter writer, object state)
-    {
-      try
-      {
-        this.m_dateFormatter.FormatDate(DateTime.Now, writer);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("DatePatternConverter: Error occurred while converting date.", ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/EnvironmentPatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/EnvironmentPatternConverter.cs
deleted file mode 100644
index e946ec3..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/EnvironmentPatternConverter.cs
+++ /dev/null
@@ -1,31 +0,0 @@
-using System;
-using System.IO;
-using System.Security;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal sealed class EnvironmentPatternConverter : PatternConverter
-  {
-    protected override void Convert(TextWriter writer, object state)
-    {
-      try
-      {
-        if (this.Option == null || this.Option.Length <= 0)
-          return;
-        string environmentVariable = Environment.GetEnvironmentVariable(this.Option);
-        if (environmentVariable == null || environmentVariable.Length <= 0)
-          return;
-        writer.Write(environmentVariable);
-      }
-      catch (SecurityException ex)
-      {
-        LogLog.Debug("EnvironmentPatternConverter: Security exception while trying to expand environment variables. Error Ignored. No Expansion.", (Exception) ex);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("EnvironmentPatternConverter: Error occurred while converting environment variable.", ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/IdentityPatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/IdentityPatternConverter.cs
deleted file mode 100644
index 5091dea..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/IdentityPatternConverter.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-using System.IO;
-using System.Security;
-using System.Threading;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal sealed class IdentityPatternConverter : PatternConverter
-  {
-    protected override void Convert(TextWriter writer, object state)
-    {
-      try
-      {
-        if (Thread.CurrentPrincipal == null || Thread.CurrentPrincipal.Identity == null || Thread.CurrentPrincipal.Identity.Name == null)
-          return;
-        writer.Write(Thread.CurrentPrincipal.Identity.Name);
-      }
-      catch (SecurityException ex)
-      {
-        LogLog.Debug("IdentityPatternConverter: Security exception while trying to get current thread principal. Error Ignored.");
-        writer.Write("NOT AVAILABLE");
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/LiteralPatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/LiteralPatternConverter.cs
deleted file mode 100644
index 333065b..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/LiteralPatternConverter.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal class LiteralPatternConverter : PatternConverter
-  {
-    public override PatternConverter SetNext(PatternConverter pc)
-    {
-      if (!(pc is LiteralPatternConverter patternConverter))
-        return base.SetNext(pc);
-      this.Option += patternConverter.Option;
-      return (PatternConverter) this;
-    }
-
-    public override void Format(TextWriter writer, object state) => writer.Write(this.Option);
-
-    protected override void Convert(TextWriter writer, object state)
-    {
-      throw new InvalidOperationException("Should never get here because of the overridden Format method");
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/NewLinePatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/NewLinePatternConverter.cs
deleted file mode 100644
index a567d9b..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/NewLinePatternConverter.cs
+++ /dev/null
@@ -1,19 +0,0 @@
-using log4net.Core;
-using System.Globalization;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal sealed class NewLinePatternConverter : LiteralPatternConverter, IOptionHandler
-  {
-    public void ActivateOptions()
-    {
-      if (string.Compare(this.Option, "DOS", true, CultureInfo.InvariantCulture) == 0)
-        this.Option = "\r\n";
-      else if (string.Compare(this.Option, "UNIX", true, CultureInfo.InvariantCulture) == 0)
-        this.Option = "\n";
-      else
-        this.Option = SystemInfo.NewLine;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/ProcessIdPatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/ProcessIdPatternConverter.cs
deleted file mode 100644
index a296df9..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/ProcessIdPatternConverter.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-using System.Diagnostics;
-using System.IO;
-using System.Security;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal sealed class ProcessIdPatternConverter : PatternConverter
-  {
-    protected override void Convert(TextWriter writer, object state)
-    {
-      try
-      {
-        writer.Write(Process.GetCurrentProcess().Id);
-      }
-      catch (SecurityException ex)
-      {
-        LogLog.Debug("ProcessIdPatternConverter: Security exception while trying to get current process id. Error Ignored.");
-        writer.Write("NOT AVAILABLE");
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/PropertyPatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/PropertyPatternConverter.cs
deleted file mode 100644
index 9c50fa6..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/PropertyPatternConverter.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using log4net.Repository;
-using System.Collections;
-using System.IO;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal sealed class PropertyPatternConverter : PatternConverter
-  {
-    protected override void Convert(TextWriter writer, object state)
-    {
-      CompositeProperties compositeProperties = new CompositeProperties();
-      PropertiesDictionary properties1 = LogicalThreadContext.Properties.GetProperties(false);
-      if (properties1 != null)
-        compositeProperties.Add((ReadOnlyPropertiesDictionary) properties1);
-      PropertiesDictionary properties2 = ThreadContext.Properties.GetProperties(false);
-      if (properties2 != null)
-        compositeProperties.Add((ReadOnlyPropertiesDictionary) properties2);
-      compositeProperties.Add(GlobalContext.Properties.GetReadOnlyProperties());
-      if (this.Option != null)
-        PatternConverter.WriteObject(writer, (ILoggerRepository) null, compositeProperties[this.Option]);
-      else
-        PatternConverter.WriteDictionary(writer, (ILoggerRepository) null, (IDictionary) compositeProperties.Flatten());
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/RandomStringPatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/RandomStringPatternConverter.cs
deleted file mode 100644
index d3bc888..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/RandomStringPatternConverter.cs
+++ /dev/null
@@ -1,55 +0,0 @@
-using log4net.Core;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal sealed class RandomStringPatternConverter : PatternConverter, IOptionHandler
-  {
-    private static readonly Random s_random = new Random();
-    private int m_length = 4;
-
-    public void ActivateOptions()
-    {
-      string option = this.Option;
-      if (option == null || option.Length <= 0)
-        return;
-      int val;
-      if (SystemInfo.TryParse(option, out val))
-        this.m_length = val;
-      else
-        LogLog.Error("RandomStringPatternConverter: Could not convert Option [" + option + "] to Length Int32");
-    }
-
-    protected override void Convert(TextWriter writer, object state)
-    {
-      try
-      {
-        lock (RandomStringPatternConverter.s_random)
-        {
-          for (int index = 0; index < this.m_length; ++index)
-          {
-            int num = RandomStringPatternConverter.s_random.Next(36);
-            if (num < 26)
-            {
-              char ch = (char) (65 + num);
-              writer.Write(ch);
-            }
-            else if (num < 36)
-            {
-              char ch = (char) (48 + (num - 26));
-              writer.Write(ch);
-            }
-            else
-              writer.Write('X');
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("RandomStringPatternConverter: Error occurred while converting.", ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/UserNamePatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/UserNamePatternConverter.cs
deleted file mode 100644
index a72f867..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/UserNamePatternConverter.cs
+++ /dev/null
@@ -1,26 +0,0 @@
-using System.IO;
-using System.Security;
-using System.Security.Principal;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal sealed class UserNamePatternConverter : PatternConverter
-  {
-    protected override void Convert(TextWriter writer, object state)
-    {
-      try
-      {
-        WindowsIdentity current = WindowsIdentity.GetCurrent();
-        if (current == null || current.Name == null)
-          return;
-        writer.Write(current.Name);
-      }
-      catch (SecurityException ex)
-      {
-        LogLog.Debug("UserNamePatternConverter: Security exception while trying to get current windows identity. Error Ignored.");
-        writer.Write("NOT AVAILABLE");
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PatternStringConverters/UtcDatePatternConverter.cs b/MSHALTester/log4net/Util/PatternStringConverters/UtcDatePatternConverter.cs
deleted file mode 100644
index aebdd9b..0000000
--- a/MSHALTester/log4net/Util/PatternStringConverters/UtcDatePatternConverter.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Util.PatternStringConverters
-{
-  internal class UtcDatePatternConverter : DatePatternConverter
-  {
-    protected override void Convert(TextWriter writer, object state)
-    {
-      try
-      {
-        this.m_dateFormatter.FormatDate(DateTime.UtcNow, writer);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("UtcDatePatternConverter: Error occurred while converting date.", ex);
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/PropertiesDictionary.cs b/MSHALTester/log4net/Util/PropertiesDictionary.cs
deleted file mode 100644
index 7cf387d..0000000
--- a/MSHALTester/log4net/Util/PropertiesDictionary.cs
+++ /dev/null
@@ -1,83 +0,0 @@
-using System;
-using System.Collections;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace log4net.Util
-{
-  [Serializable]
-  public sealed class PropertiesDictionary : 
-    ReadOnlyPropertiesDictionary,
-    ISerializable,
-    IDictionary,
-    ICollection,
-    IEnumerable
-  {
-    public PropertiesDictionary()
-    {
-    }
-
-    public PropertiesDictionary(ReadOnlyPropertiesDictionary propertiesDictionary)
-      : base(propertiesDictionary)
-    {
-    }
-
-    private PropertiesDictionary(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public override object this[string key]
-    {
-      get => this.InnerHashtable[(object) key];
-      set => this.InnerHashtable[(object) key] = value;
-    }
-
-    public void Remove(string key) => this.InnerHashtable.Remove((object) key);
-
-    IDictionaryEnumerator IDictionary.GetEnumerator() => this.InnerHashtable.GetEnumerator();
-
-    void IDictionary.Remove(object key) => this.InnerHashtable.Remove(key);
-
-    bool IDictionary.Contains(object key) => this.InnerHashtable.Contains(key);
-
-    public override void Clear() => this.InnerHashtable.Clear();
-
-    void IDictionary.Add(object key, object value)
-    {
-      if (!(key is string))
-        throw new ArgumentException("key must be a string", nameof (key));
-      this.InnerHashtable.Add(key, value);
-    }
-
-    bool IDictionary.IsReadOnly => false;
-
-    object IDictionary.this[object key]
-    {
-      get
-      {
-        return key is string ? this.InnerHashtable[key] : throw new ArgumentException("key must be a string", nameof (key));
-      }
-      set
-      {
-        if (!(key is string))
-          throw new ArgumentException("key must be a string", nameof (key));
-        this.InnerHashtable[key] = value;
-      }
-    }
-
-    ICollection IDictionary.Values => this.InnerHashtable.Values;
-
-    ICollection IDictionary.Keys => this.InnerHashtable.Keys;
-
-    bool IDictionary.IsFixedSize => false;
-
-    void ICollection.CopyTo(Array array, int index) => this.InnerHashtable.CopyTo(array, index);
-
-    bool ICollection.IsSynchronized => this.InnerHashtable.IsSynchronized;
-
-    object ICollection.SyncRoot => this.InnerHashtable.SyncRoot;
-
-    IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable) this.InnerHashtable).GetEnumerator();
-  }
-}
diff --git a/MSHALTester/log4net/Util/ProtectCloseTextWriter.cs b/MSHALTester/log4net/Util/ProtectCloseTextWriter.cs
deleted file mode 100644
index 51d5a3e..0000000
--- a/MSHALTester/log4net/Util/ProtectCloseTextWriter.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-using System.IO;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class ProtectCloseTextWriter(TextWriter writer) : TextWriterAdapter(writer)
-  {
-    public void Attach(TextWriter writer) => this.Writer = writer;
-
-    public override void Close()
-    {
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/QuietTextWriter.cs b/MSHALTester/log4net/Util/QuietTextWriter.cs
deleted file mode 100644
index c0e5a3d..0000000
--- a/MSHALTester/log4net/Util/QuietTextWriter.cs
+++ /dev/null
@@ -1,72 +0,0 @@
-using log4net.Core;
-using System;
-using System.IO;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class QuietTextWriter : TextWriterAdapter
-  {
-    private IErrorHandler m_errorHandler;
-    private bool m_closed = false;
-
-    public QuietTextWriter(TextWriter writer, IErrorHandler errorHandler)
-      : base(writer)
-    {
-      this.ErrorHandler = errorHandler != null ? errorHandler : throw new ArgumentNullException(nameof (errorHandler));
-    }
-
-    public IErrorHandler ErrorHandler
-    {
-      get => this.m_errorHandler;
-      set
-      {
-        this.m_errorHandler = value != null ? value : throw new ArgumentNullException(nameof (value));
-      }
-    }
-
-    public bool Closed => this.m_closed;
-
-    public override void Write(char value)
-    {
-      try
-      {
-        base.Write(value);
-      }
-      catch (Exception ex)
-      {
-        this.m_errorHandler.Error("Failed to write [" + (object) value + "].", ex, ErrorCode.WriteFailure);
-      }
-    }
-
-    public override void Write(char[] buffer, int index, int count)
-    {
-      try
-      {
-        base.Write(buffer, index, count);
-      }
-      catch (Exception ex)
-      {
-        this.m_errorHandler.Error("Failed to write buffer.", ex, ErrorCode.WriteFailure);
-      }
-    }
-
-    public override void Write(string value)
-    {
-      try
-      {
-        base.Write(value);
-      }
-      catch (Exception ex)
-      {
-        this.m_errorHandler.Error("Failed to write [" + value + "].", ex, ErrorCode.WriteFailure);
-      }
-    }
-
-    public override void Close()
-    {
-      this.m_closed = true;
-      base.Close();
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/ReadOnlyPropertiesDictionary.cs b/MSHALTester/log4net/Util/ReadOnlyPropertiesDictionary.cs
deleted file mode 100644
index f4003f4..0000000
--- a/MSHALTester/log4net/Util/ReadOnlyPropertiesDictionary.cs
+++ /dev/null
@@ -1,110 +0,0 @@
-using System;
-using System.Collections;
-using System.Runtime.Serialization;
-using System.Security.Permissions;
-using System.Xml;
-
-#nullable disable
-namespace log4net.Util
-{
-  [Serializable]
-  public class ReadOnlyPropertiesDictionary : ISerializable, IDictionary, ICollection, IEnumerable
-  {
-    private Hashtable m_hashtable = new Hashtable();
-
-    public ReadOnlyPropertiesDictionary()
-    {
-    }
-
-    public ReadOnlyPropertiesDictionary(ReadOnlyPropertiesDictionary propertiesDictionary)
-    {
-      foreach (DictionaryEntry properties in (IEnumerable) propertiesDictionary)
-        this.InnerHashtable.Add(properties.Key, properties.Value);
-    }
-
-    protected ReadOnlyPropertiesDictionary(SerializationInfo info, StreamingContext context)
-    {
-      foreach (SerializationEntry serializationEntry in info)
-        this.InnerHashtable[(object) XmlConvert.DecodeName(serializationEntry.Name)] = serializationEntry.Value;
-    }
-
-    public string[] GetKeys()
-    {
-      string[] keys = new string[this.InnerHashtable.Count];
-      this.InnerHashtable.Keys.CopyTo((Array) keys, 0);
-      return keys;
-    }
-
-    public virtual object this[string key]
-    {
-      get => this.InnerHashtable[(object) key];
-      set
-      {
-        throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");
-      }
-    }
-
-    public bool Contains(string key) => this.InnerHashtable.Contains((object) key);
-
-    protected Hashtable InnerHashtable => this.m_hashtable;
-
-    [PermissionSet(SecurityAction.Demand, XML = "<PermissionSet class=\"System.Security.PermissionSet\"\r\n               version=\"1\">\r\n   <IPermission class=\"System.Security.Permissions.SecurityPermission, mscorlib, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\"\r\n                version=\"1\"\r\n                Flags=\"SerializationFormatter\"/>\r\n</PermissionSet>\r\n")]
-    public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
-    {
-      foreach (DictionaryEntry dictionaryEntry in this.InnerHashtable)
-      {
-        if (dictionaryEntry.Value.GetType().IsSerializable)
-          info.AddValue(XmlConvert.EncodeLocalName(dictionaryEntry.Key as string), dictionaryEntry.Value);
-      }
-    }
-
-    IDictionaryEnumerator IDictionary.GetEnumerator() => this.InnerHashtable.GetEnumerator();
-
-    void IDictionary.Remove(object key)
-    {
-      throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");
-    }
-
-    bool IDictionary.Contains(object key) => this.InnerHashtable.Contains(key);
-
-    public virtual void Clear()
-    {
-      throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");
-    }
-
-    void IDictionary.Add(object key, object value)
-    {
-      throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");
-    }
-
-    bool IDictionary.IsReadOnly => true;
-
-    object IDictionary.this[object key]
-    {
-      get
-      {
-        return key is string ? this.InnerHashtable[key] : throw new ArgumentException("key must be a string");
-      }
-      set
-      {
-        throw new NotSupportedException("This is a Read Only Dictionary and can not be modified");
-      }
-    }
-
-    ICollection IDictionary.Values => this.InnerHashtable.Values;
-
-    ICollection IDictionary.Keys => this.InnerHashtable.Keys;
-
-    bool IDictionary.IsFixedSize => this.InnerHashtable.IsFixedSize;
-
-    void ICollection.CopyTo(Array array, int index) => this.InnerHashtable.CopyTo(array, index);
-
-    bool ICollection.IsSynchronized => this.InnerHashtable.IsSynchronized;
-
-    public int Count => this.InnerHashtable.Count;
-
-    object ICollection.SyncRoot => this.InnerHashtable.SyncRoot;
-
-    IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable) this.InnerHashtable).GetEnumerator();
-  }
-}
diff --git a/MSHALTester/log4net/Util/ReaderWriterLock.cs b/MSHALTester/log4net/Util/ReaderWriterLock.cs
deleted file mode 100644
index 5863b14..0000000
--- a/MSHALTester/log4net/Util/ReaderWriterLock.cs
+++ /dev/null
@@ -1,18 +0,0 @@
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class ReaderWriterLock
-  {
-    private System.Threading.ReaderWriterLock m_lock;
-
-    public ReaderWriterLock() => this.m_lock = new System.Threading.ReaderWriterLock();
-
-    public void AcquireReaderLock() => this.m_lock.AcquireReaderLock(-1);
-
-    public void ReleaseReaderLock() => this.m_lock.ReleaseReaderLock();
-
-    public void AcquireWriterLock() => this.m_lock.AcquireWriterLock(-1);
-
-    public void ReleaseWriterLock() => this.m_lock.ReleaseWriterLock();
-  }
-}
diff --git a/MSHALTester/log4net/Util/ReusableStringWriter.cs b/MSHALTester/log4net/Util/ReusableStringWriter.cs
deleted file mode 100644
index 0554b12..0000000
--- a/MSHALTester/log4net/Util/ReusableStringWriter.cs
+++ /dev/null
@@ -1,23 +0,0 @@
-using System;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class ReusableStringWriter(IFormatProvider formatProvider) : StringWriter(formatProvider)
-  {
-    protected override void Dispose(bool disposing)
-    {
-    }
-
-    public void Reset(int maxCapacity, int defaultSize)
-    {
-      StringBuilder stringBuilder = this.GetStringBuilder();
-      stringBuilder.Length = 0;
-      if (stringBuilder.Capacity <= maxCapacity)
-        return;
-      stringBuilder.Capacity = defaultSize;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/SystemInfo.cs b/MSHALTester/log4net/Util/SystemInfo.cs
deleted file mode 100644
index 8dbfe45..0000000
--- a/MSHALTester/log4net/Util/SystemInfo.cs
+++ /dev/null
@@ -1,279 +0,0 @@
-using System;
-using System.Diagnostics;
-using System.Globalization;
-using System.IO;
-using System.Net;
-using System.Net.Sockets;
-using System.Reflection;
-using System.Security;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class SystemInfo
-  {
-    private static DateTime s_processStartTime = DateTime.MinValue;
-    public static readonly Type[] EmptyTypes = new Type[0];
-    private static string s_hostName;
-    private static string s_appFriendlyName;
-
-    private SystemInfo()
-    {
-    }
-
-    public static string NewLine => Environment.NewLine;
-
-    public static string ApplicationBaseDirectory => AppDomain.CurrentDomain.BaseDirectory;
-
-    public static string ConfigurationFileLocation
-    {
-      get => AppDomain.CurrentDomain.SetupInformation.ConfigurationFile;
-    }
-
-    public static string EntryAssemblyLocation => Assembly.GetEntryAssembly().Location;
-
-    public static int CurrentThreadId => AppDomain.GetCurrentThreadId();
-
-    public static string HostName
-    {
-      get
-      {
-        if (SystemInfo.s_hostName == null)
-        {
-          try
-          {
-            SystemInfo.s_hostName = Dns.GetHostName();
-          }
-          catch (SocketException ex)
-          {
-          }
-          catch (SecurityException ex)
-          {
-          }
-          if (SystemInfo.s_hostName != null)
-          {
-            if (SystemInfo.s_hostName.Length != 0)
-              goto label_9;
-          }
-          try
-          {
-            SystemInfo.s_hostName = Environment.MachineName;
-          }
-          catch (InvalidOperationException ex)
-          {
-          }
-          catch (SecurityException ex)
-          {
-          }
-label_9:
-          if (SystemInfo.s_hostName == null || SystemInfo.s_hostName.Length == 0)
-            SystemInfo.s_hostName = "NOT AVAILABLE";
-        }
-        return SystemInfo.s_hostName;
-      }
-    }
-
-    public static string ApplicationFriendlyName
-    {
-      get
-      {
-        if (SystemInfo.s_appFriendlyName == null)
-        {
-          try
-          {
-            SystemInfo.s_appFriendlyName = AppDomain.CurrentDomain.FriendlyName;
-          }
-          catch (SecurityException ex)
-          {
-            LogLog.Debug("SystemInfo: Security exception while trying to get current domain friendly name. Error Ignored.");
-          }
-          if (SystemInfo.s_appFriendlyName != null)
-          {
-            if (SystemInfo.s_appFriendlyName.Length != 0)
-              goto label_7;
-          }
-          try
-          {
-            SystemInfo.s_appFriendlyName = Path.GetFileName(SystemInfo.EntryAssemblyLocation);
-          }
-          catch (SecurityException ex)
-          {
-          }
-label_7:
-          if (SystemInfo.s_appFriendlyName == null || SystemInfo.s_appFriendlyName.Length == 0)
-            SystemInfo.s_appFriendlyName = "NOT AVAILABLE";
-        }
-        return SystemInfo.s_appFriendlyName;
-      }
-    }
-
-    public static DateTime ProcessStartTime
-    {
-      get
-      {
-        if (SystemInfo.s_processStartTime == DateTime.MinValue)
-        {
-          try
-          {
-            SystemInfo.s_processStartTime = Process.GetCurrentProcess().StartTime;
-          }
-          catch
-          {
-            SystemInfo.s_processStartTime = DateTime.Now;
-          }
-        }
-        return SystemInfo.s_processStartTime;
-      }
-    }
-
-    public static string AssemblyLocationInfo(Assembly myAssembly)
-    {
-      if (myAssembly.GlobalAssemblyCache)
-        return "Global Assembly Cache";
-      try
-      {
-        return myAssembly.Location;
-      }
-      catch (SecurityException ex)
-      {
-        return "Location Permission Denied";
-      }
-    }
-
-    public static string AssemblyQualifiedName(Type type)
-    {
-      return type.FullName + ", " + type.Assembly.FullName;
-    }
-
-    public static string AssemblyShortName(Assembly myAssembly)
-    {
-      string str = myAssembly.FullName;
-      int length = str.IndexOf(',');
-      if (length > 0)
-        str = str.Substring(0, length);
-      return str.Trim();
-    }
-
-    public static string AssemblyFileName(Assembly myAssembly)
-    {
-      return Path.GetFileName(myAssembly.Location);
-    }
-
-    public static Type GetTypeFromString(
-      Type relativeType,
-      string typeName,
-      bool throwOnError,
-      bool ignoreCase)
-    {
-      return SystemInfo.GetTypeFromString(relativeType.Assembly, typeName, throwOnError, ignoreCase);
-    }
-
-    public static Type GetTypeFromString(string typeName, bool throwOnError, bool ignoreCase)
-    {
-      return SystemInfo.GetTypeFromString(Assembly.GetCallingAssembly(), typeName, throwOnError, ignoreCase);
-    }
-
-    public static Type GetTypeFromString(
-      Assembly relativeAssembly,
-      string typeName,
-      bool throwOnError,
-      bool ignoreCase)
-    {
-      if (typeName.IndexOf(',') != -1)
-        return Type.GetType(typeName, throwOnError, ignoreCase);
-      Type type1 = relativeAssembly.GetType(typeName, false, ignoreCase);
-      if (type1 != null)
-        return type1;
-      Assembly[] assemblyArray = (Assembly[]) null;
-      try
-      {
-        assemblyArray = AppDomain.CurrentDomain.GetAssemblies();
-      }
-      catch (SecurityException ex)
-      {
-      }
-      if (assemblyArray != null)
-      {
-        foreach (Assembly assembly in assemblyArray)
-        {
-          Type type2 = assembly.GetType(typeName, false, ignoreCase);
-          if (type2 != null)
-          {
-            LogLog.Debug("SystemInfo: Loaded type [" + typeName + "] from assembly [" + assembly.FullName + "] by searching loaded assemblies.");
-            return type2;
-          }
-        }
-      }
-      if (throwOnError)
-        throw new TypeLoadException("Could not load type [" + typeName + "]. Tried assembly [" + relativeAssembly.FullName + "] and all loaded assemblies");
-      return (Type) null;
-    }
-
-    public static Guid NewGuid() => Guid.NewGuid();
-
-    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(
-      string parameterName,
-      object actualValue,
-      string message)
-    {
-      return new ArgumentOutOfRangeException(parameterName, actualValue, message);
-    }
-
-    public static bool TryParse(string s, out int val)
-    {
-      val = 0;
-      try
-      {
-        double result;
-        if (double.TryParse(s, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result))
-        {
-          val = Convert.ToInt32(result);
-          return true;
-        }
-      }
-      catch
-      {
-      }
-      return false;
-    }
-
-    public static bool TryParse(string s, out long val)
-    {
-      val = 0L;
-      try
-      {
-        double result;
-        if (double.TryParse(s, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result))
-        {
-          val = Convert.ToInt64(result);
-          return true;
-        }
-      }
-      catch
-      {
-      }
-      return false;
-    }
-
-    public static string ConvertToFullPath(string path)
-    {
-      if (path == null)
-        throw new ArgumentNullException(nameof (path));
-      string path1 = "";
-      try
-      {
-        string applicationBaseDirectory = SystemInfo.ApplicationBaseDirectory;
-        if (applicationBaseDirectory != null)
-        {
-          Uri uri = new Uri(applicationBaseDirectory);
-          if (uri.IsFile)
-            path1 = uri.LocalPath;
-        }
-      }
-      catch
-      {
-      }
-      return path1 != null && path1.Length > 0 ? Path.GetFullPath(Path.Combine(path1, path)) : Path.GetFullPath(path);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TextWriterAdapter.cs b/MSHALTester/log4net/Util/TextWriterAdapter.cs
deleted file mode 100644
index 4734aec..0000000
--- a/MSHALTester/log4net/Util/TextWriterAdapter.cs
+++ /dev/null
@@ -1,55 +0,0 @@
-using System;
-using System.Globalization;
-using System.IO;
-using System.Text;
-
-#nullable disable
-namespace log4net.Util
-{
-  public abstract class TextWriterAdapter : TextWriter
-  {
-    private TextWriter m_writer;
-
-    protected TextWriterAdapter(TextWriter writer)
-      : base((IFormatProvider) CultureInfo.InvariantCulture)
-    {
-      this.m_writer = writer;
-    }
-
-    protected TextWriter Writer
-    {
-      get => this.m_writer;
-      set => this.m_writer = value;
-    }
-
-    public override Encoding Encoding => this.m_writer.Encoding;
-
-    public override IFormatProvider FormatProvider => this.m_writer.FormatProvider;
-
-    public override string NewLine
-    {
-      get => this.m_writer.NewLine;
-      set => this.m_writer.NewLine = value;
-    }
-
-    public override void Close() => this.m_writer.Close();
-
-    protected override void Dispose(bool disposing)
-    {
-      if (!disposing)
-        return;
-      this.m_writer.Dispose();
-    }
-
-    public override void Flush() => this.m_writer.Flush();
-
-    public override void Write(char value) => this.m_writer.Write(value);
-
-    public override void Write(char[] buffer, int index, int count)
-    {
-      this.m_writer.Write(buffer, index, count);
-    }
-
-    public override void Write(string value) => this.m_writer.Write(value);
-  }
-}
diff --git a/MSHALTester/log4net/Util/ThreadContextProperties.cs b/MSHALTester/log4net/Util/ThreadContextProperties.cs
deleted file mode 100644
index 819f299..0000000
--- a/MSHALTester/log4net/Util/ThreadContextProperties.cs
+++ /dev/null
@@ -1,36 +0,0 @@
-using System;
-using System.Threading;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class ThreadContextProperties : ContextPropertiesBase
-  {
-    private static readonly LocalDataStoreSlot s_threadLocalSlot = Thread.AllocateDataSlot();
-
-    internal ThreadContextProperties()
-    {
-    }
-
-    public override object this[string key]
-    {
-      get => this.GetProperties(false)?[key];
-      set => this.GetProperties(true)[key] = value;
-    }
-
-    public void Remove(string key) => this.GetProperties(false)?.Remove(key);
-
-    public void Clear() => this.GetProperties(false)?.Clear();
-
-    internal PropertiesDictionary GetProperties(bool create)
-    {
-      PropertiesDictionary data = (PropertiesDictionary) Thread.GetData(ThreadContextProperties.s_threadLocalSlot);
-      if (data == null && create)
-      {
-        data = new PropertiesDictionary();
-        Thread.SetData(ThreadContextProperties.s_threadLocalSlot, (object) data);
-      }
-      return data;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/ThreadContextStack.cs b/MSHALTester/log4net/Util/ThreadContextStack.cs
deleted file mode 100644
index 32d14ef..0000000
--- a/MSHALTester/log4net/Util/ThreadContextStack.cs
+++ /dev/null
@@ -1,97 +0,0 @@
-using log4net.Core;
-using System;
-using System.Collections;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class ThreadContextStack : IFixingRequired
-  {
-    private Stack m_stack = new Stack();
-
-    internal ThreadContextStack()
-    {
-    }
-
-    public int Count => this.m_stack.Count;
-
-    public void Clear() => this.m_stack.Clear();
-
-    public string Pop()
-    {
-      Stack stack = this.m_stack;
-      return stack.Count > 0 ? ((ThreadContextStack.StackFrame) stack.Pop()).Message : "";
-    }
-
-    public IDisposable Push(string message)
-    {
-      Stack stack = this.m_stack;
-      stack.Push((object) new ThreadContextStack.StackFrame(message, stack.Count > 0 ? (ThreadContextStack.StackFrame) stack.Peek() : (ThreadContextStack.StackFrame) null));
-      return (IDisposable) new ThreadContextStack.AutoPopStackFrame(stack, stack.Count - 1);
-    }
-
-    internal string GetFullMessage()
-    {
-      Stack stack = this.m_stack;
-      return stack.Count > 0 ? ((ThreadContextStack.StackFrame) stack.Peek()).FullMessage : (string) null;
-    }
-
-    internal Stack InternalStack
-    {
-      get => this.m_stack;
-      set => this.m_stack = value;
-    }
-
-    public override string ToString() => this.GetFullMessage();
-
-    object IFixingRequired.GetFixedObject() => (object) this.GetFullMessage();
-
-    private sealed class StackFrame
-    {
-      private readonly string m_message;
-      private readonly ThreadContextStack.StackFrame m_parent;
-      private string m_fullMessage = (string) null;
-
-      internal StackFrame(string message, ThreadContextStack.StackFrame parent)
-      {
-        this.m_message = message;
-        this.m_parent = parent;
-        if (parent != null)
-          return;
-        this.m_fullMessage = message;
-      }
-
-      internal string Message => this.m_message;
-
-      internal string FullMessage
-      {
-        get
-        {
-          if (this.m_fullMessage == null)
-            this.m_fullMessage = this.m_parent.FullMessage + " " + this.m_message;
-          return this.m_fullMessage;
-        }
-      }
-    }
-
-    private struct AutoPopStackFrame : IDisposable
-    {
-      private Stack m_frameStack;
-      private int m_frameDepth;
-
-      internal AutoPopStackFrame(Stack frameStack, int frameDepth)
-      {
-        this.m_frameStack = frameStack;
-        this.m_frameDepth = frameDepth;
-      }
-
-      public void Dispose()
-      {
-        if (this.m_frameDepth < 0 || this.m_frameStack == null)
-          return;
-        while (this.m_frameStack.Count > this.m_frameDepth)
-          this.m_frameStack.Pop();
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/ThreadContextStacks.cs b/MSHALTester/log4net/Util/ThreadContextStacks.cs
deleted file mode 100644
index 15586b1..0000000
--- a/MSHALTester/log4net/Util/ThreadContextStacks.cs
+++ /dev/null
@@ -1,40 +0,0 @@
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class ThreadContextStacks
-  {
-    private readonly ContextPropertiesBase m_properties;
-
-    internal ThreadContextStacks(ContextPropertiesBase properties)
-    {
-      this.m_properties = properties;
-    }
-
-    public ThreadContextStack this[string key]
-    {
-      get
-      {
-        object property = this.m_properties[key];
-        if (property == null)
-        {
-          threadContextStack = new ThreadContextStack();
-          this.m_properties[key] = (object) threadContextStack;
-        }
-        else if (!(property is ThreadContextStack threadContextStack))
-        {
-          string str = "(null)";
-          try
-          {
-            str = property.ToString();
-          }
-          catch
-          {
-          }
-          LogLog.Error("ThreadContextStacks: Request for stack named [" + key + "] failed because a property with the same name exists which is a [" + property.GetType().Name + "] with value [" + str + "]");
-          threadContextStack = new ThreadContextStack();
-        }
-        return threadContextStack;
-      }
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/Transform.cs b/MSHALTester/log4net/Util/Transform.cs
deleted file mode 100644
index 62f2c20..0000000
--- a/MSHALTester/log4net/Util/Transform.cs
+++ /dev/null
@@ -1,71 +0,0 @@
-using System.Xml;
-
-#nullable disable
-namespace log4net.Util
-{
-  public sealed class Transform
-  {
-    private const string CDATA_END = "]]>";
-    private const string CDATA_UNESCAPABLE_TOKEN = "]]";
-
-    private Transform()
-    {
-    }
-
-    public static void WriteEscapedXmlString(XmlWriter writer, string stringData)
-    {
-      int num1 = 12 * (1 + Transform.CountSubstrings(stringData, "]]>"));
-      if (3 * (Transform.CountSubstrings(stringData, "<") + Transform.CountSubstrings(stringData, ">")) + 4 * Transform.CountSubstrings(stringData, "&") <= num1)
-      {
-        writer.WriteString(stringData);
-      }
-      else
-      {
-        int num2 = stringData.IndexOf("]]>");
-        if (num2 < 0)
-        {
-          writer.WriteCData(stringData);
-        }
-        else
-        {
-          int startIndex = 0;
-          for (; num2 > -1; num2 = stringData.IndexOf("]]>", startIndex))
-          {
-            writer.WriteCData(stringData.Substring(startIndex, num2 - startIndex));
-            if (num2 == stringData.Length - 3)
-            {
-              startIndex = stringData.Length;
-              writer.WriteString("]]>");
-              break;
-            }
-            writer.WriteString("]]");
-            startIndex = num2 + 2;
-          }
-          if (startIndex >= stringData.Length)
-            return;
-          writer.WriteCData(stringData.Substring(startIndex));
-        }
-      }
-    }
-
-    private static int CountSubstrings(string text, string substring)
-    {
-      int num1 = 0;
-      int startIndex = 0;
-      int length1 = text.Length;
-      int length2 = substring.Length;
-      if (length1 == 0 || length2 == 0)
-        return 0;
-      int num2;
-      for (; startIndex < length1; startIndex = num2 + length2)
-      {
-        num2 = text.IndexOf(substring, startIndex);
-        if (num2 != -1)
-          ++num1;
-        else
-          break;
-      }
-      return num1;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/BooleanConverter.cs b/MSHALTester/log4net/Util/TypeConverters/BooleanConverter.cs
deleted file mode 100644
index 07c5f56..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/BooleanConverter.cs
+++ /dev/null
@@ -1,15 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  internal class BooleanConverter : IConvertFrom
-  {
-    public bool CanConvertFrom(Type sourceType) => sourceType == typeof (string);
-
-    public object ConvertFrom(object source)
-    {
-      return source is string str ? (object) bool.Parse(str) : throw ConversionNotSupportedException.Create(typeof (bool), source);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/ConversionNotSupportedException.cs b/MSHALTester/log4net/Util/TypeConverters/ConversionNotSupportedException.cs
deleted file mode 100644
index 156f49f..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/ConversionNotSupportedException.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-using System;
-using System.Runtime.Serialization;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  [Serializable]
-  public class ConversionNotSupportedException : ApplicationException
-  {
-    public ConversionNotSupportedException()
-    {
-    }
-
-    public ConversionNotSupportedException(string message)
-      : base(message)
-    {
-    }
-
-    public ConversionNotSupportedException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-
-    protected ConversionNotSupportedException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public static ConversionNotSupportedException Create(Type destinationType, object sourceValue)
-    {
-      return ConversionNotSupportedException.Create(destinationType, sourceValue, (Exception) null);
-    }
-
-    public static ConversionNotSupportedException Create(
-      Type destinationType,
-      object sourceValue,
-      Exception innerException)
-    {
-      if (sourceValue == null)
-        return new ConversionNotSupportedException("Cannot convert value [null] to type [" + (object) destinationType + "]", innerException);
-      return new ConversionNotSupportedException("Cannot convert from type [" + (object) sourceValue.GetType() + "] value [" + sourceValue + "] to type [" + (object) destinationType + "]", innerException);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/ConverterRegistry.cs b/MSHALTester/log4net/Util/TypeConverters/ConverterRegistry.cs
deleted file mode 100644
index 2deb09c..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/ConverterRegistry.cs
+++ /dev/null
@@ -1,91 +0,0 @@
-using log4net.Layout;
-using System;
-using System.Collections;
-using System.Net;
-using System.Text;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  public sealed class ConverterRegistry
-  {
-    private static Hashtable s_type2converter = new Hashtable();
-
-    private ConverterRegistry()
-    {
-    }
-
-    static ConverterRegistry()
-    {
-      ConverterRegistry.AddConverter(typeof (bool), typeof (BooleanConverter));
-      ConverterRegistry.AddConverter(typeof (Encoding), typeof (EncodingConverter));
-      ConverterRegistry.AddConverter(typeof (Type), typeof (TypeConverter));
-      ConverterRegistry.AddConverter(typeof (PatternLayout), typeof (PatternLayoutConverter));
-      ConverterRegistry.AddConverter(typeof (PatternString), typeof (PatternStringConverter));
-      ConverterRegistry.AddConverter(typeof (IPAddress), typeof (IPAddressConverter));
-    }
-
-    public static void AddConverter(Type destinationType, object converter)
-    {
-      if (destinationType == null || converter == null)
-        return;
-      lock (ConverterRegistry.s_type2converter)
-        ConverterRegistry.s_type2converter[(object) destinationType] = converter;
-    }
-
-    public static void AddConverter(Type destinationType, Type converterType)
-    {
-      ConverterRegistry.AddConverter(destinationType, ConverterRegistry.CreateConverterInstance(converterType));
-    }
-
-    public static IConvertTo GetConvertTo(Type sourceType, Type destinationType)
-    {
-      lock (ConverterRegistry.s_type2converter)
-      {
-        if (!(ConverterRegistry.s_type2converter[(object) sourceType] is IConvertTo converterFromAttribute2) && ConverterRegistry.GetConverterFromAttribute(sourceType) is IConvertTo converterFromAttribute2)
-          ConverterRegistry.s_type2converter[(object) sourceType] = (object) converterFromAttribute2;
-        return converterFromAttribute2;
-      }
-    }
-
-    public static IConvertFrom GetConvertFrom(Type destinationType)
-    {
-      lock (ConverterRegistry.s_type2converter)
-      {
-        if (!(ConverterRegistry.s_type2converter[(object) destinationType] is IConvertFrom converterFromAttribute2) && ConverterRegistry.GetConverterFromAttribute(destinationType) is IConvertFrom converterFromAttribute2)
-          ConverterRegistry.s_type2converter[(object) destinationType] = (object) converterFromAttribute2;
-        return converterFromAttribute2;
-      }
-    }
-
-    private static object GetConverterFromAttribute(Type destinationType)
-    {
-      object[] customAttributes = destinationType.GetCustomAttributes(typeof (TypeConverterAttribute), true);
-      return customAttributes != null && customAttributes.Length > 0 && customAttributes[0] is TypeConverterAttribute converterAttribute ? ConverterRegistry.CreateConverterInstance(SystemInfo.GetTypeFromString(destinationType, converterAttribute.ConverterTypeName, false, true)) : (object) null;
-    }
-
-    private static object CreateConverterInstance(Type converterType)
-    {
-      if (converterType == null)
-        throw new ArgumentNullException(nameof (converterType), "CreateConverterInstance cannot create instance, converterType is null");
-      if (!typeof (IConvertFrom).IsAssignableFrom(converterType))
-      {
-        if (!typeof (IConvertTo).IsAssignableFrom(converterType))
-        {
-          LogLog.Error("ConverterRegistry: Cannot CreateConverterInstance of type [" + converterType.FullName + "], type does not implement IConvertFrom or IConvertTo");
-          goto label_7;
-        }
-      }
-      try
-      {
-        return Activator.CreateInstance(converterType);
-      }
-      catch (Exception ex)
-      {
-        LogLog.Error("ConverterRegistry: Cannot CreateConverterInstance of type [" + converterType.FullName + "], Exception in call to Activator.CreateInstance", ex);
-      }
-label_7:
-      return (object) null;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/EncodingConverter.cs b/MSHALTester/log4net/Util/TypeConverters/EncodingConverter.cs
deleted file mode 100644
index 9572ee0..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/EncodingConverter.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-using System;
-using System.Text;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  internal class EncodingConverter : IConvertFrom
-  {
-    public bool CanConvertFrom(Type sourceType) => sourceType == typeof (string);
-
-    public object ConvertFrom(object source)
-    {
-      return source is string name ? (object) Encoding.GetEncoding(name) : throw ConversionNotSupportedException.Create(typeof (Encoding), source);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/IConvertFrom.cs b/MSHALTester/log4net/Util/TypeConverters/IConvertFrom.cs
deleted file mode 100644
index 087f6ba..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/IConvertFrom.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  public interface IConvertFrom
-  {
-    bool CanConvertFrom(Type sourceType);
-
-    object ConvertFrom(object source);
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/IConvertTo.cs b/MSHALTester/log4net/Util/TypeConverters/IConvertTo.cs
deleted file mode 100644
index 6210bac..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/IConvertTo.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  public interface IConvertTo
-  {
-    bool CanConvertTo(Type targetType);
-
-    object ConvertTo(object source, Type targetType);
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/IPAddressConverter.cs b/MSHALTester/log4net/Util/TypeConverters/IPAddressConverter.cs
deleted file mode 100644
index 5b41def..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/IPAddressConverter.cs
+++ /dev/null
@@ -1,82 +0,0 @@
-using System;
-using System.Net;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  internal class IPAddressConverter : IConvertFrom
-  {
-    private static readonly char[] validIpAddressChars = new char[27]
-    {
-      '0',
-      '1',
-      '2',
-      '3',
-      '4',
-      '5',
-      '6',
-      '7',
-      '8',
-      '9',
-      'a',
-      'b',
-      'c',
-      'd',
-      'e',
-      'f',
-      'A',
-      'B',
-      'C',
-      'D',
-      'E',
-      'F',
-      'x',
-      'X',
-      '.',
-      ':',
-      '%'
-    };
-
-    public bool CanConvertFrom(Type sourceType) => sourceType == typeof (string);
-
-    public object ConvertFrom(object source)
-    {
-      if (source is string str)
-      {
-        if (str.Length > 0)
-        {
-          try
-          {
-            if (str.Trim(IPAddressConverter.validIpAddressChars).Length == 0)
-            {
-              try
-              {
-                return (object) IPAddress.Parse(str);
-              }
-              catch (FormatException ex)
-              {
-              }
-            }
-            IPHostEntry hostByName = Dns.GetHostByName(str);
-            if (hostByName != null)
-            {
-              if (hostByName.AddressList != null)
-              {
-                if (hostByName.AddressList.Length > 0)
-                {
-                  if (hostByName.AddressList[0] != null)
-                    return (object) hostByName.AddressList[0];
-                }
-              }
-            }
-          }
-          catch (Exception ex)
-          {
-            throw ConversionNotSupportedException.Create(typeof (IPAddress), source, ex);
-          }
-        }
-      }
-      throw ConversionNotSupportedException.Create(typeof (IPAddress), source);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/PatternLayoutConverter.cs b/MSHALTester/log4net/Util/TypeConverters/PatternLayoutConverter.cs
deleted file mode 100644
index 653a68a..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/PatternLayoutConverter.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-using log4net.Layout;
-using System;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  internal class PatternLayoutConverter : IConvertFrom
-  {
-    public bool CanConvertFrom(Type sourceType) => sourceType == typeof (string);
-
-    public object ConvertFrom(object source)
-    {
-      return source is string pattern ? (object) new PatternLayout(pattern) : throw ConversionNotSupportedException.Create(typeof (PatternLayout), source);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/PatternStringConverter.cs b/MSHALTester/log4net/Util/TypeConverters/PatternStringConverter.cs
deleted file mode 100644
index b420480..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/PatternStringConverter.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  internal class PatternStringConverter : IConvertTo, IConvertFrom
-  {
-    public bool CanConvertTo(Type targetType) => typeof (string).IsAssignableFrom(targetType);
-
-    public object ConvertTo(object source, Type targetType)
-    {
-      if (source is PatternString patternString && this.CanConvertTo(targetType))
-        return (object) patternString.Format();
-      throw ConversionNotSupportedException.Create(targetType, source);
-    }
-
-    public bool CanConvertFrom(Type sourceType) => sourceType == typeof (string);
-
-    public object ConvertFrom(object source)
-    {
-      return source is string pattern ? (object) new PatternString(pattern) : throw ConversionNotSupportedException.Create(typeof (PatternString), source);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/TypeConverter.cs b/MSHALTester/log4net/Util/TypeConverters/TypeConverter.cs
deleted file mode 100644
index 5ccda11..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/TypeConverter.cs
+++ /dev/null
@@ -1,15 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  internal class TypeConverter : IConvertFrom
-  {
-    public bool CanConvertFrom(Type sourceType) => sourceType == typeof (string);
-
-    public object ConvertFrom(object source)
-    {
-      return source is string typeName ? (object) SystemInfo.GetTypeFromString(typeName, true, true) : throw ConversionNotSupportedException.Create(typeof (Type), source);
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/TypeConverters/TypeConverterAttribute.cs b/MSHALTester/log4net/Util/TypeConverters/TypeConverterAttribute.cs
deleted file mode 100644
index bb6fd5b..0000000
--- a/MSHALTester/log4net/Util/TypeConverters/TypeConverterAttribute.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-using System;
-
-#nullable disable
-namespace log4net.Util.TypeConverters
-{
-  [AttributeUsage(AttributeTargets.Class | AttributeTargets.Enum | AttributeTargets.Interface)]
-  public sealed class TypeConverterAttribute : Attribute
-  {
-    private string m_typeName = (string) null;
-
-    public TypeConverterAttribute()
-    {
-    }
-
-    public TypeConverterAttribute(string typeName) => this.m_typeName = typeName;
-
-    public TypeConverterAttribute(Type converterType)
-    {
-      this.m_typeName = SystemInfo.AssemblyQualifiedName(converterType);
-    }
-
-    public string ConverterTypeName
-    {
-      get => this.m_typeName;
-      set => this.m_typeName = value;
-    }
-  }
-}
diff --git a/MSHALTester/log4net/Util/WindowsSecurityContext.cs b/MSHALTester/log4net/Util/WindowsSecurityContext.cs
deleted file mode 100644
index 2bf5ac7..0000000
--- a/MSHALTester/log4net/Util/WindowsSecurityContext.cs
+++ /dev/null
@@ -1,125 +0,0 @@
-using log4net.Core;
-using System;
-using System.Runtime.InteropServices;
-using System.Security.Principal;
-
-#nullable disable
-namespace log4net.Util
-{
-  public class WindowsSecurityContext : SecurityContext, IOptionHandler
-  {
-    private WindowsSecurityContext.ImpersonationMode m_impersonationMode = WindowsSecurityContext.ImpersonationMode.User;
-    private string m_userName;
-    private string m_domainName = Environment.MachineName;
-    private string m_password;
-    private WindowsIdentity m_identity;
-
-    public WindowsSecurityContext.ImpersonationMode Credentials
-    {
-      get => this.m_impersonationMode;
-      set => this.m_impersonationMode = value;
-    }
-
-    public string UserName
-    {
-      get => this.m_userName;
-      set => this.m_userName = value;
-    }
-
-    public string DomainName
-    {
-      get => this.m_domainName;
-      set => this.m_domainName = value;
-    }
-
-    public string Password
-    {
-      set => this.m_password = value;
-    }
-
-    public void ActivateOptions()
-    {
-      if (this.m_impersonationMode != WindowsSecurityContext.ImpersonationMode.User)
-        return;
-      if (this.m_userName == null)
-        throw new ArgumentNullException("m_userName");
-      if (this.m_domainName == null)
-        throw new ArgumentNullException("m_domainName");
-      if (this.m_password == null)
-        throw new ArgumentNullException("m_password");
-      this.m_identity = WindowsSecurityContext.LogonUser(this.m_userName, this.m_domainName, this.m_password);
-    }
-
-    public override IDisposable Impersonate(object state)
-    {
-      if (this.m_impersonationMode == WindowsSecurityContext.ImpersonationMode.User)
-      {
-        if (this.m_identity != null)
-          return (IDisposable) new WindowsSecurityContext.DisposableImpersonationContext(this.m_identity.Impersonate());
-      }
-      else if (this.m_impersonationMode == WindowsSecurityContext.ImpersonationMode.Process)
-        return (IDisposable) new WindowsSecurityContext.DisposableImpersonationContext(WindowsIdentity.Impersonate(IntPtr.Zero));
-      return (IDisposable) null;
-    }
-
-    private static WindowsIdentity LogonUser(string userName, string domainName, string password)
-    {
-      IntPtr zero1 = IntPtr.Zero;
-      if (!WindowsSecurityContext.LogonUser(userName, domainName, password, 2, 0, ref zero1))
-      {
-        NativeError lastError = NativeError.GetLastError();
-        throw new Exception("Failed to LogonUser [" + userName + "] in Domain [" + domainName + "]. Error: " + lastError.ToString());
-      }
-      IntPtr zero2 = IntPtr.Zero;
-      if (!WindowsSecurityContext.DuplicateToken(zero1, 2, ref zero2))
-      {
-        NativeError lastError = NativeError.GetLastError();
-        if (zero1 != IntPtr.Zero)
-          WindowsSecurityContext.CloseHandle(zero1);
-        throw new Exception("Failed to DuplicateToken after LogonUser. Error: " + lastError.ToString());
-      }
-      WindowsIdentity windowsIdentity = new WindowsIdentity(zero2);
-      if (zero2 != IntPtr.Zero)
-        WindowsSecurityContext.CloseHandle(zero2);
-      if (zero1 != IntPtr.Zero)
-        WindowsSecurityContext.CloseHandle(zero1);
-      return windowsIdentity;
-    }
-
-    [DllImport("advapi32.dll", SetLastError = true)]
-    private static extern bool LogonUser(
-      string lpszUsername,
-      string lpszDomain,
-      string lpszPassword,
-      int dwLogonType,
-      int dwLogonProvider,
-      ref IntPtr phToken);
-
-    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
-    private static extern bool CloseHandle(IntPtr handle);
-
-    [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
-    private static extern bool DuplicateToken(
-      IntPtr ExistingTokenHandle,
-      int SECURITY_IMPERSONATION_LEVEL,
-      ref IntPtr DuplicateTokenHandle);
-
-    public enum ImpersonationMode
-    {
-      User,
-      Process,
-    }
-
-    private sealed class DisposableImpersonationContext : IDisposable
-    {
-      private readonly WindowsImpersonationContext m_impersonationContext;
-
-      public DisposableImpersonationContext(WindowsImpersonationContext impersonationContext)
-      {
-        this.m_impersonationContext = impersonationContext;
-      }
-
-      public void Dispose() => this.m_impersonationContext.Undo();
-    }
-  }
-}
diff --git a/MSHALTester/log4net630819/_003CPrivateImplementationDetails_003E.cs b/MSHALTester/log4net630819/_003CPrivateImplementationDetails_003E.cs
deleted file mode 100644
index 197bf61..0000000
--- a/MSHALTester/log4net630819/_003CPrivateImplementationDetails_003E.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-using System.Runtime.InteropServices;
-
-#nullable disable
-internal class log4net630819\u002E\u003CPrivateImplementationDetails\u003E
-{
-  internal static log4net630819.\u003CPrivateImplementationDetails\u003E.\u0024\u0024struct0x60005a5\u002D1 \u0024\u0024method0x60005a5\u002D1;
-
-  [StructLayout(LayoutKind.Explicit, Size = 54, Pack = 1)]
-  private struct \u0024\u0024struct0x60005a5\u002D1
-  {
-  }
-}
diff --git a/MSHALTester/packages.config b/MSHALTester/packages.config
new file mode 100644
index 0000000..db0189f
--- /dev/null
+++ b/MSHALTester/packages.config
@@ -0,0 +1,7 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<packages>
+  <package id="log4net" version="2.0.17" targetFramework="net35" />
+  <package id="Newtonsoft.Json" version="13.0.3" targetFramework="net35" />
+  <package id="SevenZip" version="19.0.0" targetFramework="net35" />
+  <package id="SharpZipLib" version="0.86.0" targetFramework="net35" />
+</packages>
\ No newline at end of file
-- 
2.44.0.windows.1

