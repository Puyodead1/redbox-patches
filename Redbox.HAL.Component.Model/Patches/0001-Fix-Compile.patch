From 5f1c02534381670672d5f70e0307cad4481ae2f6 Mon Sep 17 00:00:00 2001
From: Puyodead1 <puyodead@proton.me>
Date: Mon, 25 Nov 2024 15:05:53 -0500
Subject: [PATCH] Fix Compile

---
 Redbox.HAL.Component.Model/AssemblyInfo.cs    |    2 -
 .../ICSharpCode/SharpZipLib/BZip2/BZip2.cs    |   45 -
 .../SharpZipLib/BZip2/BZip2Constants.cs       |  536 -----
 .../SharpZipLib/BZip2/BZip2Exception.cs       |   29 -
 .../SharpZipLib/BZip2/BZip2InputStream.cs     |  715 -------
 .../SharpZipLib/BZip2/BZip2OutputStream.cs    | 1326 ------------
 .../SharpZipLib/Checksums/Adler32.cs          |   63 -
 .../SharpZipLib/Checksums/Crc32.cs            |  311 ---
 .../SharpZipLib/Checksums/IChecksum.cs        |   16 -
 .../SharpZipLib/Checksums/StrangeCRC.cs       |  304 ---
 .../SharpZipLib/Core/DirectoryEventArgs.cs    |   16 -
 .../Core/DirectoryFailureDelegate.cs          |    5 -
 .../SharpZipLib/Core/ExtendedPathFilter.cs    |   89 -
 .../SharpZipLib/Core/FileFailureDelegate.cs   |    5 -
 .../SharpZipLib/Core/FileSystemScanner.cs     |  151 --
 .../SharpZipLib/Core/INameTransform.cs        |   10 -
 .../SharpZipLib/Core/IScanFilter.cs           |    8 -
 .../SharpZipLib/Core/NameAndSizeFilter.cs     |   49 -
 .../SharpZipLib/Core/NameFilter.cs            |  117 --
 .../SharpZipLib/Core/PathFilter.cs            |   20 -
 .../Core/ProcessDirectoryDelegate.cs          |    5 -
 .../SharpZipLib/Core/ProcessFileDelegate.cs   |    5 -
 .../SharpZipLib/Core/ScanEventArgs.cs         |   21 -
 .../SharpZipLib/Core/ScanFailureEventArgs.cs  |   29 -
 .../SharpZipLib/Core/StreamUtils.cs           |   64 -
 .../SharpZipLib/Encryption/PkzipClassic.cs    |   46 -
 .../Encryption/PkzipClassicCryptoBase.cs      |   44 -
 .../PkzipClassicDecryptCryptoTransform.cs     |   47 -
 .../PkzipClassicEncryptCryptoTransform.cs     |   47 -
 .../Encryption/PkzipClassicManaged.cs         |   69 -
 .../SharpZipLib/GZip/GZipConstants.cs         |   17 -
 .../SharpZipLib/GZip/GZipException.cs         |   29 -
 .../SharpZipLib/GZip/GZipInputStream.cs       |  147 --
 .../SharpZipLib/GZip/GZipOutputStream.cs      |   88 -
 .../SharpZipLib/SharpZipBaseException.cs      |   29 -
 .../SharpZipLib/Tar/InvalidHeaderException.cs |   29 -
 .../SharpZipLib/Tar/ProgressMessageHandler.cs |    5 -
 .../ICSharpCode/SharpZipLib/Tar/TarArchive.cs |  467 -----
 .../ICSharpCode/SharpZipLib/Tar/TarBuffer.cs  |  221 --
 .../ICSharpCode/SharpZipLib/Tar/TarEntry.cs   |  199 --
 .../SharpZipLib/Tar/TarException.cs           |   29 -
 .../ICSharpCode/SharpZipLib/Tar/TarHeader.cs  |  486 -----
 .../SharpZipLib/Tar/TarInputStream.cs         |  290 ---
 .../SharpZipLib/Tar/TarOutputStream.cs        |  191 --
 .../SharpZipLib/Zip/BaseArchiveStorage.cs     |   24 -
 .../Zip/Compression/DeflateStrategy.cs        |   10 -
 .../SharpZipLib/Zip/Compression/Deflater.cs   |  178 --
 .../Zip/Compression/DeflaterConstants.cs      |   96 -
 .../Zip/Compression/DeflaterEngine.cs         |  426 ----
 .../Zip/Compression/DeflaterHuffman.cs        |  582 ------
 .../Zip/Compression/DeflaterPending.cs        |   11 -
 .../SharpZipLib/Zip/Compression/Inflater.cs   |  504 -----
 .../Zip/Compression/InflaterDynHeader.cs      |  197 --
 .../Zip/Compression/InflaterHuffmanTree.cs    |  147 --
 .../Zip/Compression/PendingBuffer.cs          |  111 -
 .../Streams/DeflaterOutputStream.cs           |  221 --
 .../Streams/InflaterInputBuffer.cs            |  167 --
 .../Streams/InflaterInputStream.cs            |  153 --
 .../Zip/Compression/Streams/OutputWindow.cs   |  116 --
 .../Compression/Streams/StreamManipulator.cs  |  111 -
 .../SharpZipLib/Zip/CompressionMethod.cs      |   12 -
 .../SharpZipLib/Zip/DiskArchiveStorage.cs     |  134 --
 .../SharpZipLib/Zip/DynamicDiskDataSource.cs  |   16 -
 .../SharpZipLib/Zip/EncryptionAlgorithm.cs    |   21 -
 .../ICSharpCode/SharpZipLib/Zip/FastZip.cs    |  293 ---
 .../SharpZipLib/Zip/FastZipEvents.cs          |   62 -
 .../SharpZipLib/Zip/FileUpdateMode.cs         |    9 -
 .../SharpZipLib/Zip/GeneralBitFlags.cs        |   25 -
 .../SharpZipLib/Zip/HostSystemID.cs           |   28 -
 .../SharpZipLib/Zip/IArchiveStorage.cs        |   20 -
 .../SharpZipLib/Zip/IDynamicDataSource.cs     |   10 -
 .../SharpZipLib/Zip/IEntryFactory.cs          |   14 -
 .../SharpZipLib/Zip/IStaticDataSource.cs      |   10 -
 .../SharpZipLib/Zip/KeysRequiredEventArgs.cs  |   27 -
 .../SharpZipLib/Zip/MemoryArchiveStorage.cs   |   69 -
 .../SharpZipLib/Zip/StaticDiskDataSource.cs   |   14 -
 .../SharpZipLib/Zip/TestOperation.cs          |   13 -
 .../ICSharpCode/SharpZipLib/Zip/TestStatus.cs |   44 -
 .../SharpZipLib/Zip/TestStrategy.cs           |    9 -
 .../ICSharpCode/SharpZipLib/Zip/UseZip64.cs   |   10 -
 .../SharpZipLib/Zip/ZipConstants.cs           |  107 -
 .../ICSharpCode/SharpZipLib/Zip/ZipEntry.cs   |  399 ----
 .../SharpZipLib/Zip/ZipEntryFactory.cs        |  148 --
 .../SharpZipLib/Zip/ZipException.cs           |   29 -
 .../SharpZipLib/Zip/ZipExtraData.cs           |  230 --
 .../ICSharpCode/SharpZipLib/Zip/ZipFile.cs    | 1851 -----------------
 .../SharpZipLib/Zip/ZipHelperStream.cs        |  189 --
 .../SharpZipLib/Zip/ZipInputStream.cs         |  299 ---
 .../SharpZipLib/Zip/ZipNameTransform.cs       |   90 -
 .../SharpZipLib/Zip/ZipOutputStream.cs        |  406 ----
 .../SharpZipLib/Zip/ZipTestResultHandler.cs   |    5 -
 .../LzmaAlone/Properties/Settings.cs          |   37 -
 .../Redbox.HAL.Component.Model.csproj         |  130 +-
 .../Redbox.HAL.Component.Model.sln            |   10 +-
 Redbox.HAL.Component.Model/SevenZip/CRC.cs    |   56 -
 .../SevenZip/CoderPropID.cs                   |   22 -
 .../SevenZip/Compression/LZ/BinTree.cs        |  370 ----
 .../Compression/LZ/IInWindowStream.cs         |   20 -
 .../SevenZip/Compression/LZ/IMatchFinder.cs   |   16 -
 .../SevenZip/Compression/LZ/InWindow.cs       |  127 --
 .../SevenZip/Compression/LZ/OutWindow.cs      |   86 -
 .../SevenZip/Compression/LZMA/Base.cs         |   65 -
 .../SevenZip/Compression/LZMA/Decoder.cs      |  349 ----
 .../SevenZip/Compression/LZMA/Encoder.cs      | 1336 ------------
 .../Compression/RangeCoder/BitDecoder.cs      |   46 -
 .../Compression/RangeCoder/BitEncoder.cs      |   66 -
 .../Compression/RangeCoder/BitTreeDecoder.cs  |   55 -
 .../Compression/RangeCoder/BitTreeEncoder.cs  |  106 -
 .../Compression/RangeCoder/Decoder.cs         |   90 -
 .../Compression/RangeCoder/Encoder.cs         |  106 -
 .../SevenZip/DataErrorException.cs            |   13 -
 .../SevenZip/ICodeProgress.cs                 |   11 -
 Redbox.HAL.Component.Model/SevenZip/ICoder.cs |   17 -
 .../SevenZip/ISetCoderProperties.cs           |   11 -
 .../SevenZip/ISetDecoderProperties.cs         |   11 -
 .../SevenZip/IWriteCoderProperties.cs         |   12 -
 .../SevenZip/InvalidParamException.cs         |   13 -
 Redbox.HAL.Component.Model/packages.config    |    5 +
 118 files changed, 27 insertions(+), 17227 deletions(-)
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2Constants.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2Exception.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2InputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2OutputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/Adler32.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/Crc32.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/IChecksum.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/StrangeCRC.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/DirectoryEventArgs.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/DirectoryFailureDelegate.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ExtendedPathFilter.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/FileFailureDelegate.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/FileSystemScanner.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/INameTransform.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/IScanFilter.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/NameAndSizeFilter.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/NameFilter.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/PathFilter.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ProcessDirectoryDelegate.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ProcessFileDelegate.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ScanEventArgs.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ScanFailureEventArgs.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/StreamUtils.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassic.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicCryptoBase.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicDecryptCryptoTransform.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicEncryptCryptoTransform.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicManaged.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipConstants.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipException.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipInputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipOutputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/SharpZipBaseException.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/InvalidHeaderException.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/ProgressMessageHandler.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarArchive.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarBuffer.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarEntry.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarException.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarHeader.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarInputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarOutputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/BaseArchiveStorage.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflateStrategy.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Deflater.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterConstants.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterEngine.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterHuffman.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterPending.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Inflater.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/InflaterDynHeader.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/PendingBuffer.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputBuffer.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/CompressionMethod.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/DiskArchiveStorage.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/DynamicDiskDataSource.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/EncryptionAlgorithm.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FastZip.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FastZipEvents.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FileUpdateMode.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/GeneralBitFlags.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/HostSystemID.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IArchiveStorage.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IDynamicDataSource.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IEntryFactory.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IStaticDataSource.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/KeysRequiredEventArgs.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/MemoryArchiveStorage.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/StaticDiskDataSource.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestOperation.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestStatus.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestStrategy.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/UseZip64.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipConstants.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipEntry.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipEntryFactory.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipException.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipExtraData.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipFile.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipHelperStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipInputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipNameTransform.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipOutputStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipTestResultHandler.cs
 delete mode 100644 Redbox.HAL.Component.Model/LzmaAlone/Properties/Settings.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/CRC.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/CoderPropID.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/LZ/BinTree.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/LZ/IInWindowStream.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/LZ/IMatchFinder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/LZ/InWindow.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/LZ/OutWindow.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Base.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Decoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Encoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitDecoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitEncoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitTreeDecoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitTreeEncoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/Decoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/Encoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/DataErrorException.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/ICodeProgress.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/ICoder.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/ISetCoderProperties.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/ISetDecoderProperties.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/IWriteCoderProperties.cs
 delete mode 100644 Redbox.HAL.Component.Model/SevenZip/InvalidParamException.cs
 create mode 100644 Redbox.HAL.Component.Model/packages.config

diff --git a/Redbox.HAL.Component.Model/AssemblyInfo.cs b/Redbox.HAL.Component.Model/AssemblyInfo.cs
index 232dfd4..cd6f465 100644
--- a/Redbox.HAL.Component.Model/AssemblyInfo.cs
+++ b/Redbox.HAL.Component.Model/AssemblyInfo.cs
@@ -1,8 +1,6 @@
 using System.Reflection;
-using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 
-[assembly: Extension]
 [assembly: AssemblyTitle("Redbox.HAL.Component.Model")]
 [assembly: AssemblyDescription("")]
 [assembly: AssemblyConfiguration("")]
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2.cs
deleted file mode 100644
index 612b2e3..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2.cs
+++ /dev/null
@@ -1,45 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  public sealed class BZip2
-  {
-    public static void Decompress(Stream inStream, Stream outStream)
-    {
-      if (inStream == null)
-        throw new ArgumentNullException(nameof (inStream));
-      if (outStream == null)
-        throw new ArgumentNullException(nameof (outStream));
-      using (outStream)
-      {
-        using (BZip2InputStream bzip2InputStream = new BZip2InputStream(inStream))
-        {
-          for (int index = bzip2InputStream.ReadByte(); index != -1; index = bzip2InputStream.ReadByte())
-            outStream.WriteByte((byte) index);
-        }
-      }
-    }
-
-    public static void Compress(Stream inStream, Stream outStream, int blockSize)
-    {
-      if (inStream == null)
-        throw new ArgumentNullException(nameof (inStream));
-      if (outStream == null)
-        throw new ArgumentNullException(nameof (outStream));
-      using (inStream)
-      {
-        using (BZip2OutputStream bzip2OutputStream = new BZip2OutputStream(outStream, blockSize))
-        {
-          for (int index = inStream.ReadByte(); index != -1; index = inStream.ReadByte())
-            bzip2OutputStream.WriteByte((byte) index);
-        }
-      }
-    }
-
-    private BZip2()
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2Constants.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2Constants.cs
deleted file mode 100644
index 266b4ed..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2Constants.cs
+++ /dev/null
@@ -1,536 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  public sealed class BZip2Constants
-  {
-    public const int baseBlockSize = 100000;
-    public const int MAX_ALPHA_SIZE = 258;
-    public const int MAX_CODE_LEN = 23;
-    public const int RUNA = 0;
-    public const int RUNB = 1;
-    public const int N_GROUPS = 6;
-    public const int G_SIZE = 50;
-    public const int N_ITERS = 4;
-    public const int MAX_SELECTORS = 18002;
-    public const int NUM_OVERSHOOT_BYTES = 20;
-    public static readonly int[] rNums = new int[512]
-    {
-      619,
-      720,
-      (int) sbyte.MaxValue,
-      481,
-      931,
-      816,
-      813,
-      233,
-      566,
-      247,
-      985,
-      724,
-      205,
-      454,
-      863,
-      491,
-      741,
-      242,
-      949,
-      214,
-      733,
-      859,
-      335,
-      708,
-      621,
-      574,
-      73,
-      654,
-      730,
-      472,
-      419,
-      436,
-      278,
-      496,
-      867,
-      210,
-      399,
-      680,
-      480,
-      51,
-      878,
-      465,
-      811,
-      169,
-      869,
-      675,
-      611,
-      697,
-      867,
-      561,
-      862,
-      687,
-      507,
-      283,
-      482,
-      129,
-      807,
-      591,
-      733,
-      623,
-      150,
-      238,
-      59,
-      379,
-      684,
-      877,
-      625,
-      169,
-      643,
-      105,
-      170,
-      607,
-      520,
-      932,
-      727,
-      476,
-      693,
-      425,
-      174,
-      647,
-      73,
-      122,
-      335,
-      530,
-      442,
-      853,
-      695,
-      249,
-      445,
-      515,
-      909,
-      545,
-      703,
-      919,
-      874,
-      474,
-      882,
-      500,
-      594,
-      612,
-      641,
-      801,
-      220,
-      162,
-      819,
-      984,
-      589,
-      513,
-      495,
-      799,
-      161,
-      604,
-      958,
-      533,
-      221,
-      400,
-      386,
-      867,
-      600,
-      782,
-      382,
-      596,
-      414,
-      171,
-      516,
-      375,
-      682,
-      485,
-      911,
-      276,
-      98,
-      553,
-      163,
-      354,
-      666,
-      933,
-      424,
-      341,
-      533,
-      870,
-      227,
-      730,
-      475,
-      186,
-      263,
-      647,
-      537,
-      686,
-      600,
-      224,
-      469,
-      68,
-      770,
-      919,
-      190,
-      373,
-      294,
-      822,
-      808,
-      206,
-      184,
-      943,
-      795,
-      384,
-      383,
-      461,
-      404,
-      758,
-      839,
-      887,
-      715,
-      67,
-      618,
-      276,
-      204,
-      918,
-      873,
-      777,
-      604,
-      560,
-      951,
-      160,
-      578,
-      722,
-      79,
-      804,
-      96,
-      409,
-      713,
-      940,
-      652,
-      934,
-      970,
-      447,
-      318,
-      353,
-      859,
-      672,
-      112,
-      785,
-      645,
-      863,
-      803,
-      350,
-      139,
-      93,
-      354,
-      99,
-      820,
-      908,
-      609,
-      772,
-      154,
-      274,
-      580,
-      184,
-      79,
-      626,
-      630,
-      742,
-      653,
-      282,
-      762,
-      623,
-      680,
-      81,
-      927,
-      626,
-      789,
-      125,
-      411,
-      521,
-      938,
-      300,
-      821,
-      78,
-      343,
-      175,
-      128,
-      250,
-      170,
-      774,
-      972,
-      275,
-      999,
-      639,
-      495,
-      78,
-      352,
-      126,
-      857,
-      956,
-      358,
-      619,
-      580,
-      124,
-      737,
-      594,
-      701,
-      612,
-      669,
-      112,
-      134,
-      694,
-      363,
-      992,
-      809,
-      743,
-      168,
-      974,
-      944,
-      375,
-      748,
-      52,
-      600,
-      747,
-      642,
-      182,
-      862,
-      81,
-      344,
-      805,
-      988,
-      739,
-      511,
-      655,
-      814,
-      334,
-      249,
-      515,
-      897,
-      955,
-      664,
-      981,
-      649,
-      113,
-      974,
-      459,
-      893,
-      228,
-      433,
-      837,
-      553,
-      268,
-      926,
-      240,
-      102,
-      654,
-      459,
-      51,
-      686,
-      754,
-      806,
-      760,
-      493,
-      403,
-      415,
-      394,
-      687,
-      700,
-      946,
-      670,
-      656,
-      610,
-      738,
-      392,
-      760,
-      799,
-      887,
-      653,
-      978,
-      321,
-      576,
-      617,
-      626,
-      502,
-      894,
-      679,
-      243,
-      440,
-      680,
-      879,
-      194,
-      572,
-      640,
-      724,
-      926,
-      56,
-      204,
-      700,
-      707,
-      151,
-      457,
-      449,
-      797,
-      195,
-      791,
-      558,
-      945,
-      679,
-      297,
-      59,
-      87,
-      824,
-      713,
-      663,
-      412,
-      693,
-      342,
-      606,
-      134,
-      108,
-      571,
-      364,
-      631,
-      212,
-      174,
-      643,
-      304,
-      329,
-      343,
-      97,
-      430,
-      751,
-      497,
-      314,
-      983,
-      374,
-      822,
-      928,
-      140,
-      206,
-      73,
-      263,
-      980,
-      736,
-      876,
-      478,
-      430,
-      305,
-      170,
-      514,
-      364,
-      692,
-      829,
-      82,
-      855,
-      953,
-      676,
-      246,
-      369,
-      970,
-      294,
-      750,
-      807,
-      827,
-      150,
-      790,
-      288,
-      923,
-      804,
-      378,
-      215,
-      828,
-      592,
-      281,
-      565,
-      555,
-      710,
-      82,
-      896,
-      831,
-      547,
-      261,
-      524,
-      462,
-      293,
-      465,
-      502,
-      56,
-      661,
-      821,
-      976,
-      991,
-      658,
-      869,
-      905,
-      758,
-      745,
-      193,
-      768,
-      550,
-      608,
-      933,
-      378,
-      286,
-      215,
-      979,
-      792,
-      961,
-      61,
-      688,
-      793,
-      644,
-      986,
-      403,
-      106,
-      366,
-      905,
-      644,
-      372,
-      567,
-      466,
-      434,
-      645,
-      210,
-      389,
-      550,
-      919,
-      135,
-      780,
-      773,
-      635,
-      389,
-      707,
-      100,
-      626,
-      958,
-      165,
-      504,
-      920,
-      176,
-      193,
-      713,
-      857,
-      265,
-      203,
-      50,
-      668,
-      108,
-      645,
-      990,
-      626,
-      197,
-      510,
-      357,
-      358,
-      850,
-      858,
-      364,
-      936,
-      638
-    };
-
-    private BZip2Constants()
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2Exception.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2Exception.cs
deleted file mode 100644
index fd23b3e..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2Exception.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-
-using System;
-using System.Runtime.Serialization;
-
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  [Serializable]
-  public class BZip2Exception : SharpZipBaseException
-  {
-    protected BZip2Exception(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public BZip2Exception()
-    {
-    }
-
-    public BZip2Exception(string message)
-      : base(message)
-    {
-    }
-
-    public BZip2Exception(string message, Exception exception)
-      : base(message, exception)
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2InputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2InputStream.cs
deleted file mode 100644
index a306ae2..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2InputStream.cs
+++ /dev/null
@@ -1,715 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  public class BZip2InputStream : Stream
-  {
-    private const int START_BLOCK_STATE = 1;
-    private const int RAND_PART_A_STATE = 2;
-    private const int RAND_PART_B_STATE = 3;
-    private const int RAND_PART_C_STATE = 4;
-    private const int NO_RAND_PART_A_STATE = 5;
-    private const int NO_RAND_PART_B_STATE = 6;
-    private const int NO_RAND_PART_C_STATE = 7;
-    private int last;
-    private int origPtr;
-    private int blockSize100k;
-    private bool blockRandomised;
-    private int bsBuff;
-    private int bsLive;
-    private IChecksum mCrc = (IChecksum) new StrangeCRC();
-    private bool[] inUse = new bool[256];
-    private int nInUse;
-    private byte[] seqToUnseq = new byte[256];
-    private byte[] unseqToSeq = new byte[256];
-    private byte[] selector = new byte[18002];
-    private byte[] selectorMtf = new byte[18002];
-    private int[] tt;
-    private byte[] ll8;
-    private int[] unzftab = new int[256];
-    private int[][] limit = new int[6][];
-    private int[][] baseArray = new int[6][];
-    private int[][] perm = new int[6][];
-    private int[] minLens = new int[6];
-    private Stream baseStream;
-    private bool streamEnd;
-    private int currentChar = -1;
-    private int currentState = 1;
-    private int storedBlockCRC;
-    private int storedCombinedCRC;
-    private int computedBlockCRC;
-    private uint computedCombinedCRC;
-    private int count;
-    private int chPrev;
-    private int ch2;
-    private int tPos;
-    private int rNToGo;
-    private int rTPos;
-    private int i2;
-    private int j2;
-    private byte z;
-    private bool isStreamOwner = true;
-
-    public BZip2InputStream(Stream stream)
-    {
-      for (int index = 0; index < 6; ++index)
-      {
-        this.limit[index] = new int[258];
-        this.baseArray[index] = new int[258];
-        this.perm[index] = new int[258];
-      }
-      this.BsSetStream(stream);
-      this.Initialize();
-      this.InitBlock();
-      this.SetupBlock();
-    }
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public override bool CanRead => this.baseStream.CanRead;
-
-    public override bool CanSeek => this.baseStream.CanSeek;
-
-    public override bool CanWrite => false;
-
-    public override long Length => this.baseStream.Length;
-
-    public override long Position
-    {
-      get => this.baseStream.Position;
-      set => throw new NotSupportedException("BZip2InputStream position cannot be set");
-    }
-
-    public override void Flush()
-    {
-      if (this.baseStream == null)
-        return;
-      this.baseStream.Flush();
-    }
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("BZip2InputStream Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("BZip2InputStream SetLength not supported");
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("BZip2InputStream Write not supported");
-    }
-
-    public override void WriteByte(byte value)
-    {
-      throw new NotSupportedException("BZip2InputStream WriteByte not supported");
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      for (int index = 0; index < count; ++index)
-      {
-        int num = this.ReadByte();
-        if (num == -1)
-          return index;
-        buffer[offset + index] = (byte) num;
-      }
-      return count;
-    }
-
-    public override void Close()
-    {
-      if (!this.IsStreamOwner || this.baseStream == null)
-        return;
-      this.baseStream.Close();
-    }
-
-    public override int ReadByte()
-    {
-      if (this.streamEnd)
-        return -1;
-      int currentChar = this.currentChar;
-      switch (this.currentState)
-      {
-        case 3:
-          this.SetupRandPartB();
-          break;
-        case 4:
-          this.SetupRandPartC();
-          break;
-        case 6:
-          this.SetupNoRandPartB();
-          break;
-        case 7:
-          this.SetupNoRandPartC();
-          break;
-      }
-      return currentChar;
-    }
-
-    private void MakeMaps()
-    {
-      this.nInUse = 0;
-      for (int index = 0; index < 256; ++index)
-      {
-        if (this.inUse[index])
-        {
-          this.seqToUnseq[this.nInUse] = (byte) index;
-          this.unseqToSeq[index] = (byte) this.nInUse;
-          ++this.nInUse;
-        }
-      }
-    }
-
-    private void Initialize()
-    {
-      char uchar1 = this.BsGetUChar();
-      char uchar2 = this.BsGetUChar();
-      char uchar3 = this.BsGetUChar();
-      char uchar4 = this.BsGetUChar();
-      if (uchar1 != 'B' || uchar2 != 'Z' || uchar3 != 'h' || uchar4 < '1' || uchar4 > '9')
-      {
-        this.streamEnd = true;
-      }
-      else
-      {
-        this.SetDecompressStructureSizes((int) uchar4 - 48);
-        this.computedCombinedCRC = 0U;
-      }
-    }
-
-    private void InitBlock()
-    {
-      char uchar1 = this.BsGetUChar();
-      char uchar2 = this.BsGetUChar();
-      char uchar3 = this.BsGetUChar();
-      char uchar4 = this.BsGetUChar();
-      char uchar5 = this.BsGetUChar();
-      char uchar6 = this.BsGetUChar();
-      if (uchar1 == '\u0017' && uchar2 == 'r' && uchar3 == 'E' && uchar4 == '8' && uchar5 == 'P' && uchar6 == '\u0090')
-        this.Complete();
-      else if (uchar1 != '1' || uchar2 != 'A' || uchar3 != 'Y' || uchar4 != '&' || uchar5 != 'S' || uchar6 != 'Y')
-      {
-        BZip2InputStream.BadBlockHeader();
-        this.streamEnd = true;
-      }
-      else
-      {
-        this.storedBlockCRC = this.BsGetInt32();
-        this.blockRandomised = this.BsR(1) == 1;
-        this.GetAndMoveToFrontDecode();
-        this.mCrc.Reset();
-        this.currentState = 1;
-      }
-    }
-
-    private void EndBlock()
-    {
-      this.computedBlockCRC = (int) this.mCrc.Value;
-      if (this.storedBlockCRC != this.computedBlockCRC)
-        BZip2InputStream.CrcError();
-      this.computedCombinedCRC = (uint) ((int) this.computedCombinedCRC << 1 & -1) | this.computedCombinedCRC >> 31;
-      this.computedCombinedCRC ^= (uint) this.computedBlockCRC;
-    }
-
-    private void Complete()
-    {
-      this.storedCombinedCRC = this.BsGetInt32();
-      if (this.storedCombinedCRC != (int) this.computedCombinedCRC)
-        BZip2InputStream.CrcError();
-      this.streamEnd = true;
-    }
-
-    private void BsSetStream(Stream stream)
-    {
-      this.baseStream = stream;
-      this.bsLive = 0;
-      this.bsBuff = 0;
-    }
-
-    private void FillBuffer()
-    {
-      int num = 0;
-      try
-      {
-        num = this.baseStream.ReadByte();
-      }
-      catch (Exception ex)
-      {
-        BZip2InputStream.CompressedStreamEOF();
-      }
-      if (num == -1)
-        BZip2InputStream.CompressedStreamEOF();
-      this.bsBuff = this.bsBuff << 8 | num & (int) byte.MaxValue;
-      this.bsLive += 8;
-    }
-
-    private int BsR(int n)
-    {
-      while (this.bsLive < n)
-        this.FillBuffer();
-      int num = this.bsBuff >> this.bsLive - n & (1 << n) - 1;
-      this.bsLive -= n;
-      return num;
-    }
-
-    private char BsGetUChar() => (char) this.BsR(8);
-
-    private int BsGetint()
-    {
-      return ((this.BsR(8) << 8 | this.BsR(8)) << 8 | this.BsR(8)) << 8 | this.BsR(8);
-    }
-
-    private int BsGetIntVS(int numBits) => this.BsR(numBits);
-
-    private int BsGetInt32() => this.BsGetint();
-
-    private void RecvDecodingTables()
-    {
-      char[][] chArray = new char[6][];
-      for (int index = 0; index < 6; ++index)
-        chArray[index] = new char[258];
-      bool[] flagArray = new bool[16];
-      for (int index = 0; index < 16; ++index)
-        flagArray[index] = this.BsR(1) == 1;
-      for (int index1 = 0; index1 < 16; ++index1)
-      {
-        if (flagArray[index1])
-        {
-          for (int index2 = 0; index2 < 16; ++index2)
-            this.inUse[index1 * 16 + index2] = this.BsR(1) == 1;
-        }
-        else
-        {
-          for (int index3 = 0; index3 < 16; ++index3)
-            this.inUse[index1 * 16 + index3] = false;
-        }
-      }
-      this.MakeMaps();
-      int alphaSize = this.nInUse + 2;
-      int num1 = this.BsR(3);
-      int num2 = this.BsR(15);
-      for (int index = 0; index < num2; ++index)
-      {
-        int num3 = 0;
-        while (this.BsR(1) == 1)
-          ++num3;
-        this.selectorMtf[index] = (byte) num3;
-      }
-      byte[] numArray = new byte[6];
-      for (int index = 0; index < num1; ++index)
-        numArray[index] = (byte) index;
-      for (int index4 = 0; index4 < num2; ++index4)
-      {
-        int index5 = (int) this.selectorMtf[index4];
-        byte num4 = numArray[index5];
-        for (; index5 > 0; --index5)
-          numArray[index5] = numArray[index5 - 1];
-        numArray[0] = num4;
-        this.selector[index4] = num4;
-      }
-      for (int index6 = 0; index6 < num1; ++index6)
-      {
-        int num5 = this.BsR(5);
-        for (int index7 = 0; index7 < alphaSize; ++index7)
-        {
-          while (this.BsR(1) == 1)
-          {
-            if (this.BsR(1) == 0)
-              ++num5;
-            else
-              --num5;
-          }
-          chArray[index6][index7] = (char) num5;
-        }
-      }
-      for (int index8 = 0; index8 < num1; ++index8)
-      {
-        int num6 = 32;
-        int num7 = 0;
-        for (int index9 = 0; index9 < alphaSize; ++index9)
-        {
-          num7 = Math.Max(num7, (int) chArray[index8][index9]);
-          num6 = Math.Min(num6, (int) chArray[index8][index9]);
-        }
-        BZip2InputStream.HbCreateDecodeTables(this.limit[index8], this.baseArray[index8], this.perm[index8], chArray[index8], num6, num7, alphaSize);
-        this.minLens[index8] = num6;
-      }
-    }
-
-    private void GetAndMoveToFrontDecode()
-    {
-      byte[] numArray = new byte[256];
-      int num1 = 100000 * this.blockSize100k;
-      this.origPtr = this.BsGetIntVS(24);
-      this.RecvDecodingTables();
-      int num2 = this.nInUse + 1;
-      int index1 = -1;
-      int num3 = 0;
-      for (int index2 = 0; index2 <= (int) byte.MaxValue; ++index2)
-        this.unzftab[index2] = 0;
-      for (int index3 = 0; index3 <= (int) byte.MaxValue; ++index3)
-        numArray[index3] = (byte) index3;
-      this.last = -1;
-      if (num3 == 0)
-      {
-        ++index1;
-        num3 = 50;
-      }
-      int num4 = num3 - 1;
-      int index4 = (int) this.selector[index1];
-      int minLen1 = this.minLens[index4];
-      int num5;
-      int num6;
-      for (num5 = this.BsR(minLen1); num5 > this.limit[index4][minLen1]; num5 = num5 << 1 | num6)
-      {
-        if (minLen1 > 20)
-          throw new BZip2Exception("Bzip data error");
-        ++minLen1;
-        while (this.bsLive < 1)
-          this.FillBuffer();
-        num6 = this.bsBuff >> this.bsLive - 1 & 1;
-        --this.bsLive;
-      }
-      if (num5 - this.baseArray[index4][minLen1] < 0 || num5 - this.baseArray[index4][minLen1] >= 258)
-        throw new BZip2Exception("Bzip data error");
-      int num7 = this.perm[index4][num5 - this.baseArray[index4][minLen1]];
-      while (num7 != num2)
-      {
-        if (num7 == 0 || num7 == 1)
-        {
-          int num8 = -1;
-          int num9 = 1;
-label_22:
-          if (num7 == 0)
-            num8 += num9;
-          else if (num7 == 1)
-            num8 += 2 * num9;
-          num9 <<= 1;
-          if (num4 == 0)
-          {
-            ++index1;
-            num4 = 50;
-          }
-          --num4;
-          int index5 = (int) this.selector[index1];
-          int minLen2 = this.minLens[index5];
-          int num10;
-          int num11;
-          for (num10 = this.BsR(minLen2); num10 > this.limit[index5][minLen2]; num10 = num10 << 1 | num11)
-          {
-            ++minLen2;
-            while (this.bsLive < 1)
-              this.FillBuffer();
-            num11 = this.bsBuff >> this.bsLive - 1 & 1;
-            --this.bsLive;
-          }
-          num7 = this.perm[index5][num10 - this.baseArray[index5][minLen2]];
-          switch (num7)
-          {
-            case 0:
-            case 1:
-              goto label_22;
-            default:
-              int num12 = num8 + 1;
-              byte index6 = this.seqToUnseq[(int) numArray[0]];
-              this.unzftab[(int) index6] += num12;
-              for (; num12 > 0; --num12)
-              {
-                ++this.last;
-                this.ll8[this.last] = index6;
-              }
-              if (this.last >= num1)
-              {
-                BZip2InputStream.BlockOverrun();
-                continue;
-              }
-              continue;
-          }
-        }
-        else
-        {
-          ++this.last;
-          if (this.last >= num1)
-            BZip2InputStream.BlockOverrun();
-          byte index7 = numArray[num7 - 1];
-          ++this.unzftab[(int) this.seqToUnseq[(int) index7]];
-          this.ll8[this.last] = this.seqToUnseq[(int) index7];
-          for (int index8 = num7 - 1; index8 > 0; --index8)
-            numArray[index8] = numArray[index8 - 1];
-          numArray[0] = index7;
-          if (num4 == 0)
-          {
-            ++index1;
-            num4 = 50;
-          }
-          --num4;
-          int index9 = (int) this.selector[index1];
-          int minLen3 = this.minLens[index9];
-          int num13;
-          int num14;
-          for (num13 = this.BsR(minLen3); num13 > this.limit[index9][minLen3]; num13 = num13 << 1 | num14)
-          {
-            ++minLen3;
-            while (this.bsLive < 1)
-              this.FillBuffer();
-            num14 = this.bsBuff >> this.bsLive - 1 & 1;
-            --this.bsLive;
-          }
-          num7 = this.perm[index9][num13 - this.baseArray[index9][minLen3]];
-        }
-      }
-    }
-
-    private void SetupBlock()
-    {
-      int[] destinationArray = new int[257];
-      destinationArray[0] = 0;
-      Array.Copy((Array) this.unzftab, 0, (Array) destinationArray, 1, 256);
-      for (int index = 1; index <= 256; ++index)
-        destinationArray[index] += destinationArray[index - 1];
-      for (int index1 = 0; index1 <= this.last; ++index1)
-      {
-        byte index2 = this.ll8[index1];
-        this.tt[destinationArray[(int) index2]] = index1;
-        ++destinationArray[(int) index2];
-      }
-      this.tPos = this.tt[this.origPtr];
-      this.count = 0;
-      this.i2 = 0;
-      this.ch2 = 256;
-      if (this.blockRandomised)
-      {
-        this.rNToGo = 0;
-        this.rTPos = 0;
-        this.SetupRandPartA();
-      }
-      else
-        this.SetupNoRandPartA();
-    }
-
-    private void SetupRandPartA()
-    {
-      if (this.i2 <= this.last)
-      {
-        this.chPrev = this.ch2;
-        this.ch2 = (int) this.ll8[this.tPos];
-        this.tPos = this.tt[this.tPos];
-        if (this.rNToGo == 0)
-        {
-          this.rNToGo = BZip2Constants.rNums[this.rTPos];
-          ++this.rTPos;
-          if (this.rTPos == 512)
-            this.rTPos = 0;
-        }
-        --this.rNToGo;
-        this.ch2 ^= this.rNToGo == 1 ? 1 : 0;
-        ++this.i2;
-        this.currentChar = this.ch2;
-        this.currentState = 3;
-        this.mCrc.Update(this.ch2);
-      }
-      else
-      {
-        this.EndBlock();
-        this.InitBlock();
-        this.SetupBlock();
-      }
-    }
-
-    private void SetupNoRandPartA()
-    {
-      if (this.i2 <= this.last)
-      {
-        this.chPrev = this.ch2;
-        this.ch2 = (int) this.ll8[this.tPos];
-        this.tPos = this.tt[this.tPos];
-        ++this.i2;
-        this.currentChar = this.ch2;
-        this.currentState = 6;
-        this.mCrc.Update(this.ch2);
-      }
-      else
-      {
-        this.EndBlock();
-        this.InitBlock();
-        this.SetupBlock();
-      }
-    }
-
-    private void SetupRandPartB()
-    {
-      if (this.ch2 != this.chPrev)
-      {
-        this.currentState = 2;
-        this.count = 1;
-        this.SetupRandPartA();
-      }
-      else
-      {
-        ++this.count;
-        if (this.count >= 4)
-        {
-          this.z = this.ll8[this.tPos];
-          this.tPos = this.tt[this.tPos];
-          if (this.rNToGo == 0)
-          {
-            this.rNToGo = BZip2Constants.rNums[this.rTPos];
-            ++this.rTPos;
-            if (this.rTPos == 512)
-              this.rTPos = 0;
-          }
-          --this.rNToGo;
-          this.z ^= this.rNToGo == 1 ? (byte) 1 : (byte) 0;
-          this.j2 = 0;
-          this.currentState = 4;
-          this.SetupRandPartC();
-        }
-        else
-        {
-          this.currentState = 2;
-          this.SetupRandPartA();
-        }
-      }
-    }
-
-    private void SetupRandPartC()
-    {
-      if (this.j2 < (int) this.z)
-      {
-        this.currentChar = this.ch2;
-        this.mCrc.Update(this.ch2);
-        ++this.j2;
-      }
-      else
-      {
-        this.currentState = 2;
-        ++this.i2;
-        this.count = 0;
-        this.SetupRandPartA();
-      }
-    }
-
-    private void SetupNoRandPartB()
-    {
-      if (this.ch2 != this.chPrev)
-      {
-        this.currentState = 5;
-        this.count = 1;
-        this.SetupNoRandPartA();
-      }
-      else
-      {
-        ++this.count;
-        if (this.count >= 4)
-        {
-          this.z = this.ll8[this.tPos];
-          this.tPos = this.tt[this.tPos];
-          this.currentState = 7;
-          this.j2 = 0;
-          this.SetupNoRandPartC();
-        }
-        else
-        {
-          this.currentState = 5;
-          this.SetupNoRandPartA();
-        }
-      }
-    }
-
-    private void SetupNoRandPartC()
-    {
-      if (this.j2 < (int) this.z)
-      {
-        this.currentChar = this.ch2;
-        this.mCrc.Update(this.ch2);
-        ++this.j2;
-      }
-      else
-      {
-        this.currentState = 5;
-        ++this.i2;
-        this.count = 0;
-        this.SetupNoRandPartA();
-      }
-    }
-
-    private void SetDecompressStructureSizes(int newSize100k)
-    {
-      this.blockSize100k = 0 <= newSize100k && newSize100k <= 9 && 0 <= this.blockSize100k && this.blockSize100k <= 9 ? newSize100k : throw new BZip2Exception("Invalid block size");
-      if (newSize100k == 0)
-        return;
-      int length = 100000 * newSize100k;
-      this.ll8 = new byte[length];
-      this.tt = new int[length];
-    }
-
-    private static void CompressedStreamEOF()
-    {
-      throw new EndOfStreamException("BZip2 input stream end of compressed stream");
-    }
-
-    private static void BlockOverrun()
-    {
-      throw new BZip2Exception("BZip2 input stream block overrun");
-    }
-
-    private static void BadBlockHeader()
-    {
-      throw new BZip2Exception("BZip2 input stream bad block header");
-    }
-
-    private static void CrcError() => throw new BZip2Exception("BZip2 input stream crc error");
-
-    private static void HbCreateDecodeTables(
-      int[] limit,
-      int[] baseArray,
-      int[] perm,
-      char[] length,
-      int minLen,
-      int maxLen,
-      int alphaSize)
-    {
-      int index1 = 0;
-      for (int index2 = minLen; index2 <= maxLen; ++index2)
-      {
-        for (int index3 = 0; index3 < alphaSize; ++index3)
-        {
-          if ((int) length[index3] == index2)
-          {
-            perm[index1] = index3;
-            ++index1;
-          }
-        }
-      }
-      for (int index4 = 0; index4 < 23; ++index4)
-        baseArray[index4] = 0;
-      for (int index5 = 0; index5 < alphaSize; ++index5)
-        ++baseArray[(int) length[index5] + 1];
-      for (int index6 = 1; index6 < 23; ++index6)
-        baseArray[index6] += baseArray[index6 - 1];
-      for (int index7 = 0; index7 < 23; ++index7)
-        limit[index7] = 0;
-      int num1 = 0;
-      for (int index8 = minLen; index8 <= maxLen; ++index8)
-      {
-        int num2 = num1 + (baseArray[index8 + 1] - baseArray[index8]);
-        limit[index8] = num2 - 1;
-        num1 = num2 << 1;
-      }
-      for (int index9 = minLen + 1; index9 <= maxLen; ++index9)
-        baseArray[index9] = (limit[index9 - 1] + 1 << 1) - baseArray[index9];
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2OutputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2OutputStream.cs
deleted file mode 100644
index 1cfadbd..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/BZip2/BZip2OutputStream.cs
+++ /dev/null
@@ -1,1326 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.BZip2
-{
-  public class BZip2OutputStream : Stream
-  {
-    private const int SETMASK = 2097152;
-    private const int CLEARMASK = -2097153;
-    private const int GREATER_ICOST = 15;
-    private const int LESSER_ICOST = 0;
-    private const int SMALL_THRESH = 20;
-    private const int DEPTH_THRESH = 10;
-    private const int QSORT_STACK_SIZE = 1000;
-    private readonly int[] increments = new int[14]
-    {
-      1,
-      4,
-      13,
-      40,
-      121,
-      364,
-      1093,
-      3280,
-      9841,
-      29524,
-      88573,
-      265720,
-      797161,
-      2391484
-    };
-    private bool isStreamOwner = true;
-    private int last;
-    private int origPtr;
-    private int blockSize100k;
-    private bool blockRandomised;
-    private int bytesOut;
-    private int bsBuff;
-    private int bsLive;
-    private IChecksum mCrc = (IChecksum) new StrangeCRC();
-    private bool[] inUse = new bool[256];
-    private int nInUse;
-    private char[] seqToUnseq = new char[256];
-    private char[] unseqToSeq = new char[256];
-    private char[] selector = new char[18002];
-    private char[] selectorMtf = new char[18002];
-    private byte[] block;
-    private int[] quadrant;
-    private int[] zptr;
-    private short[] szptr;
-    private int[] ftab;
-    private int nMTF;
-    private int[] mtfFreq = new int[258];
-    private int workFactor;
-    private int workDone;
-    private int workLimit;
-    private bool firstAttempt;
-    private int nBlocksRandomised;
-    private int currentChar = -1;
-    private int runLength;
-    private uint blockCRC;
-    private uint combinedCRC;
-    private int allowableBlockSize;
-    private Stream baseStream;
-    private bool disposed_;
-
-    public BZip2OutputStream(Stream stream)
-      : this(stream, 9)
-    {
-    }
-
-    public BZip2OutputStream(Stream stream, int blockSize)
-    {
-      this.BsSetStream(stream);
-      this.workFactor = 50;
-      if (blockSize > 9)
-        blockSize = 9;
-      if (blockSize < 1)
-        blockSize = 1;
-      this.blockSize100k = blockSize;
-      this.AllocateCompressStructures();
-      this.Initialize();
-      this.InitBlock();
-    }
-
-    ~BZip2OutputStream() => this.Dispose(false);
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public override bool CanRead => false;
-
-    public override bool CanSeek => false;
-
-    public override bool CanWrite => this.baseStream.CanWrite;
-
-    public override long Length => this.baseStream.Length;
-
-    public override long Position
-    {
-      get => this.baseStream.Position;
-      set => throw new NotSupportedException("BZip2OutputStream position cannot be set");
-    }
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("BZip2OutputStream Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("BZip2OutputStream SetLength not supported");
-    }
-
-    public override int ReadByte()
-    {
-      throw new NotSupportedException("BZip2OutputStream ReadByte not supported");
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("BZip2OutputStream Read not supported");
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (buffer.Length - offset < count)
-        throw new ArgumentException("Offset/count out of range");
-      for (int index = 0; index < count; ++index)
-        this.WriteByte(buffer[offset + index]);
-    }
-
-    public override void WriteByte(byte value)
-    {
-      int num = (256 + (int) value) % 256;
-      if (this.currentChar != -1)
-      {
-        if (this.currentChar == num)
-        {
-          ++this.runLength;
-          if (this.runLength <= 254)
-            return;
-          this.WriteRun();
-          this.currentChar = -1;
-          this.runLength = 0;
-        }
-        else
-        {
-          this.WriteRun();
-          this.runLength = 1;
-          this.currentChar = num;
-        }
-      }
-      else
-      {
-        this.currentChar = num;
-        ++this.runLength;
-      }
-    }
-
-    public override void Close()
-    {
-      this.Dispose(true);
-      GC.SuppressFinalize((object) this);
-    }
-
-    private void MakeMaps()
-    {
-      this.nInUse = 0;
-      for (int index = 0; index < 256; ++index)
-      {
-        if (this.inUse[index])
-        {
-          this.seqToUnseq[this.nInUse] = (char) index;
-          this.unseqToSeq[index] = (char) this.nInUse;
-          ++this.nInUse;
-        }
-      }
-    }
-
-    private void WriteRun()
-    {
-      if (this.last < this.allowableBlockSize)
-      {
-        this.inUse[this.currentChar] = true;
-        for (int index = 0; index < this.runLength; ++index)
-          this.mCrc.Update(this.currentChar);
-        switch (this.runLength)
-        {
-          case 1:
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            break;
-          case 2:
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            break;
-          case 3:
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            break;
-          default:
-            this.inUse[this.runLength - 4] = true;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) this.currentChar;
-            ++this.last;
-            this.block[this.last + 1] = (byte) (this.runLength - 4);
-            break;
-        }
-      }
-      else
-      {
-        this.EndBlock();
-        this.InitBlock();
-        this.WriteRun();
-      }
-    }
-
-    public int BytesWritten => this.bytesOut;
-
-    protected override void Dispose(bool disposing)
-    {
-      base.Dispose(disposing);
-      if (this.disposed_)
-        return;
-      this.disposed_ = true;
-      if (this.runLength > 0)
-        this.WriteRun();
-      this.currentChar = -1;
-      this.EndBlock();
-      this.EndCompression();
-      this.Flush();
-      if (!disposing || !this.IsStreamOwner)
-        return;
-      this.baseStream.Close();
-    }
-
-    public override void Flush() => this.baseStream.Flush();
-
-    private void Initialize()
-    {
-      this.bytesOut = 0;
-      this.nBlocksRandomised = 0;
-      this.BsPutUChar(66);
-      this.BsPutUChar(90);
-      this.BsPutUChar(104);
-      this.BsPutUChar(48 + this.blockSize100k);
-      this.combinedCRC = 0U;
-    }
-
-    private void InitBlock()
-    {
-      this.mCrc.Reset();
-      this.last = -1;
-      for (int index = 0; index < 256; ++index)
-        this.inUse[index] = false;
-      this.allowableBlockSize = 100000 * this.blockSize100k - 20;
-    }
-
-    private void EndBlock()
-    {
-      if (this.last < 0)
-        return;
-      this.blockCRC = (uint) this.mCrc.Value;
-      this.combinedCRC = this.combinedCRC << 1 | this.combinedCRC >> 31;
-      this.combinedCRC ^= this.blockCRC;
-      this.DoReversibleTransformation();
-      this.BsPutUChar(49);
-      this.BsPutUChar(65);
-      this.BsPutUChar(89);
-      this.BsPutUChar(38);
-      this.BsPutUChar(83);
-      this.BsPutUChar(89);
-      this.BsPutint((int) this.blockCRC);
-      if (this.blockRandomised)
-      {
-        this.BsW(1, 1);
-        ++this.nBlocksRandomised;
-      }
-      else
-        this.BsW(1, 0);
-      this.MoveToFrontCodeAndSend();
-    }
-
-    private void EndCompression()
-    {
-      this.BsPutUChar(23);
-      this.BsPutUChar(114);
-      this.BsPutUChar(69);
-      this.BsPutUChar(56);
-      this.BsPutUChar(80);
-      this.BsPutUChar(144);
-      this.BsPutint((int) this.combinedCRC);
-      this.BsFinishedWithStream();
-    }
-
-    private void BsSetStream(Stream stream)
-    {
-      this.baseStream = stream;
-      this.bsLive = 0;
-      this.bsBuff = 0;
-      this.bytesOut = 0;
-    }
-
-    private void BsFinishedWithStream()
-    {
-      while (this.bsLive > 0)
-      {
-        this.baseStream.WriteByte((byte) (this.bsBuff >> 24));
-        this.bsBuff <<= 8;
-        this.bsLive -= 8;
-        ++this.bytesOut;
-      }
-    }
-
-    private void BsW(int n, int v)
-    {
-      while (this.bsLive >= 8)
-      {
-        this.baseStream.WriteByte((byte) (this.bsBuff >> 24));
-        this.bsBuff <<= 8;
-        this.bsLive -= 8;
-        ++this.bytesOut;
-      }
-      this.bsBuff |= v << 32 - this.bsLive - n;
-      this.bsLive += n;
-    }
-
-    private void BsPutUChar(int c) => this.BsW(8, c);
-
-    private void BsPutint(int u)
-    {
-      this.BsW(8, u >> 24 & (int) byte.MaxValue);
-      this.BsW(8, u >> 16 & (int) byte.MaxValue);
-      this.BsW(8, u >> 8 & (int) byte.MaxValue);
-      this.BsW(8, u & (int) byte.MaxValue);
-    }
-
-    private void BsPutIntVS(int numBits, int c) => this.BsW(numBits, c);
-
-    private void SendMTFValues()
-    {
-      char[][] chArray1 = new char[6][];
-      for (int index = 0; index < 6; ++index)
-        chArray1[index] = new char[258];
-      int v1 = 0;
-      int alphaSize = this.nInUse + 2;
-      for (int index1 = 0; index1 < 6; ++index1)
-      {
-        for (int index2 = 0; index2 < alphaSize; ++index2)
-          chArray1[index1][index2] = '\u000F';
-      }
-      if (this.nMTF <= 0)
-        BZip2OutputStream.Panic();
-      int v2 = this.nMTF >= 200 ? (this.nMTF >= 600 ? (this.nMTF >= 1200 ? (this.nMTF >= 2400 ? 6 : 5) : 4) : 3) : 2;
-      int num1 = v2;
-      int nMtf = this.nMTF;
-      int num2 = 0;
-      while (num1 > 0)
-      {
-        int num3 = nMtf / num1;
-        int num4 = 0;
-        int index3;
-        for (index3 = num2 - 1; num4 < num3 && index3 < alphaSize - 1; num4 += this.mtfFreq[index3])
-          ++index3;
-        if (index3 > num2 && num1 != v2 && num1 != 1 && (v2 - num1) % 2 == 1)
-        {
-          num4 -= this.mtfFreq[index3];
-          --index3;
-        }
-        for (int index4 = 0; index4 < alphaSize; ++index4)
-          chArray1[num1 - 1][index4] = index4 < num2 || index4 > index3 ? '\u000F' : char.MinValue;
-        --num1;
-        num2 = index3 + 1;
-        nMtf -= num4;
-      }
-      int[][] numArray1 = new int[6][];
-      for (int index = 0; index < 6; ++index)
-        numArray1[index] = new int[258];
-      int[] numArray2 = new int[6];
-      short[] numArray3 = new short[6];
-      for (int index5 = 0; index5 < 4; ++index5)
-      {
-        for (int index6 = 0; index6 < v2; ++index6)
-          numArray2[index6] = 0;
-        for (int index7 = 0; index7 < v2; ++index7)
-        {
-          for (int index8 = 0; index8 < alphaSize; ++index8)
-            numArray1[index7][index8] = 0;
-        }
-        v1 = 0;
-        int num5 = 0;
-        int num6;
-        for (int index9 = 0; index9 < this.nMTF; index9 = num6 + 1)
-        {
-          num6 = index9 + 50 - 1;
-          if (num6 >= this.nMTF)
-            num6 = this.nMTF - 1;
-          for (int index10 = 0; index10 < v2; ++index10)
-            numArray3[index10] = (short) 0;
-          if (v2 == 6)
-          {
-            int num7;
-            short num8 = (short) (num7 = 0);
-            short num9 = (short) num7;
-            short num10 = (short) num7;
-            short num11 = (short) num7;
-            short num12 = (short) num7;
-            short num13 = (short) num7;
-            for (int index11 = index9; index11 <= num6; ++index11)
-            {
-              short index12 = this.szptr[index11];
-              num13 += (short) chArray1[0][(int) index12];
-              num12 += (short) chArray1[1][(int) index12];
-              num11 += (short) chArray1[2][(int) index12];
-              num10 += (short) chArray1[3][(int) index12];
-              num9 += (short) chArray1[4][(int) index12];
-              num8 += (short) chArray1[5][(int) index12];
-            }
-            numArray3[0] = num13;
-            numArray3[1] = num12;
-            numArray3[2] = num11;
-            numArray3[3] = num10;
-            numArray3[4] = num9;
-            numArray3[5] = num8;
-          }
-          else
-          {
-            for (int index13 = index9; index13 <= num6; ++index13)
-            {
-              short index14 = this.szptr[index13];
-              for (int index15 = 0; index15 < v2; ++index15)
-                numArray3[index15] += (short) chArray1[index15][(int) index14];
-            }
-          }
-          int num14 = 999999999;
-          int index16 = -1;
-          for (int index17 = 0; index17 < v2; ++index17)
-          {
-            if ((int) numArray3[index17] < num14)
-            {
-              num14 = (int) numArray3[index17];
-              index16 = index17;
-            }
-          }
-          num5 += num14;
-          ++numArray2[index16];
-          this.selector[v1] = (char) index16;
-          ++v1;
-          for (int index18 = index9; index18 <= num6; ++index18)
-            ++numArray1[index16][(int) this.szptr[index18]];
-        }
-        for (int index19 = 0; index19 < v2; ++index19)
-          BZip2OutputStream.HbMakeCodeLengths(chArray1[index19], numArray1[index19], alphaSize, 20);
-      }
-      if (v2 >= 8)
-        BZip2OutputStream.Panic();
-      if (v1 >= 32768 || v1 > 18002)
-        BZip2OutputStream.Panic();
-      char[] chArray2 = new char[6];
-      for (int index = 0; index < v2; ++index)
-        chArray2[index] = (char) index;
-      for (int index20 = 0; index20 < v1; ++index20)
-      {
-        char ch1 = this.selector[index20];
-        int index21 = 0;
-        char ch2 = chArray2[index21];
-        while ((int) ch1 != (int) ch2)
-        {
-          ++index21;
-          char ch3 = ch2;
-          ch2 = chArray2[index21];
-          chArray2[index21] = ch3;
-        }
-        chArray2[0] = ch2;
-        this.selectorMtf[index20] = (char) index21;
-      }
-      int[][] numArray4 = new int[6][];
-      for (int index = 0; index < 6; ++index)
-        numArray4[index] = new int[258];
-      for (int index22 = 0; index22 < v2; ++index22)
-      {
-        int minLen = 32;
-        int maxLen = 0;
-        for (int index23 = 0; index23 < alphaSize; ++index23)
-        {
-          if ((int) chArray1[index22][index23] > maxLen)
-            maxLen = (int) chArray1[index22][index23];
-          if ((int) chArray1[index22][index23] < minLen)
-            minLen = (int) chArray1[index22][index23];
-        }
-        if (maxLen > 20)
-          BZip2OutputStream.Panic();
-        if (minLen < 1)
-          BZip2OutputStream.Panic();
-        BZip2OutputStream.HbAssignCodes(numArray4[index22], chArray1[index22], minLen, maxLen, alphaSize);
-      }
-      bool[] flagArray = new bool[16];
-      for (int index24 = 0; index24 < 16; ++index24)
-      {
-        flagArray[index24] = false;
-        for (int index25 = 0; index25 < 16; ++index25)
-        {
-          if (this.inUse[index24 * 16 + index25])
-            flagArray[index24] = true;
-        }
-      }
-      for (int index = 0; index < 16; ++index)
-      {
-        if (flagArray[index])
-          this.BsW(1, 1);
-        else
-          this.BsW(1, 0);
-      }
-      for (int index26 = 0; index26 < 16; ++index26)
-      {
-        if (flagArray[index26])
-        {
-          for (int index27 = 0; index27 < 16; ++index27)
-          {
-            if (this.inUse[index26 * 16 + index27])
-              this.BsW(1, 1);
-            else
-              this.BsW(1, 0);
-          }
-        }
-      }
-      this.BsW(3, v2);
-      this.BsW(15, v1);
-      for (int index28 = 0; index28 < v1; ++index28)
-      {
-        for (int index29 = 0; index29 < (int) this.selectorMtf[index28]; ++index29)
-          this.BsW(1, 1);
-        this.BsW(1, 0);
-      }
-      for (int index30 = 0; index30 < v2; ++index30)
-      {
-        int v3 = (int) chArray1[index30][0];
-        this.BsW(5, v3);
-        for (int index31 = 0; index31 < alphaSize; ++index31)
-        {
-          for (; v3 < (int) chArray1[index30][index31]; ++v3)
-            this.BsW(2, 2);
-          for (; v3 > (int) chArray1[index30][index31]; --v3)
-            this.BsW(2, 3);
-          this.BsW(1, 0);
-        }
-      }
-      int index32 = 0;
-      int num15 = 0;
-      while (num15 < this.nMTF)
-      {
-        int num16 = num15 + 50 - 1;
-        if (num16 >= this.nMTF)
-          num16 = this.nMTF - 1;
-        for (int index33 = num15; index33 <= num16; ++index33)
-          this.BsW((int) chArray1[(int) this.selector[index32]][(int) this.szptr[index33]], numArray4[(int) this.selector[index32]][(int) this.szptr[index33]]);
-        num15 = num16 + 1;
-        ++index32;
-      }
-      if (index32 == v1)
-        return;
-      BZip2OutputStream.Panic();
-    }
-
-    private void MoveToFrontCodeAndSend()
-    {
-      this.BsPutIntVS(24, this.origPtr);
-      this.GenerateMTFValues();
-      this.SendMTFValues();
-    }
-
-    private void SimpleSort(int lo, int hi, int d)
-    {
-      int num1 = hi - lo + 1;
-      if (num1 < 2)
-        return;
-      int index1 = 0;
-      while (this.increments[index1] < num1)
-        ++index1;
-      for (int index2 = index1 - 1; index2 >= 0; --index2)
-      {
-        int increment = this.increments[index2];
-        int index3 = lo + increment;
-        while (index3 <= hi)
-        {
-          int num2 = this.zptr[index3];
-          int index4 = index3;
-          while (this.FullGtU(this.zptr[index4 - increment] + d, num2 + d))
-          {
-            this.zptr[index4] = this.zptr[index4 - increment];
-            index4 -= increment;
-            if (index4 <= lo + increment - 1)
-              break;
-          }
-          this.zptr[index4] = num2;
-          int index5 = index3 + 1;
-          if (index5 <= hi)
-          {
-            int num3 = this.zptr[index5];
-            int index6 = index5;
-            while (this.FullGtU(this.zptr[index6 - increment] + d, num3 + d))
-            {
-              this.zptr[index6] = this.zptr[index6 - increment];
-              index6 -= increment;
-              if (index6 <= lo + increment - 1)
-                break;
-            }
-            this.zptr[index6] = num3;
-            int index7 = index5 + 1;
-            if (index7 <= hi)
-            {
-              int num4 = this.zptr[index7];
-              int index8 = index7;
-              while (this.FullGtU(this.zptr[index8 - increment] + d, num4 + d))
-              {
-                this.zptr[index8] = this.zptr[index8 - increment];
-                index8 -= increment;
-                if (index8 <= lo + increment - 1)
-                  break;
-              }
-              this.zptr[index8] = num4;
-              index3 = index7 + 1;
-              if (this.workDone > this.workLimit && this.firstAttempt)
-                return;
-            }
-            else
-              break;
-          }
-          else
-            break;
-        }
-      }
-    }
-
-    private void Vswap(int p1, int p2, int n)
-    {
-      for (; n > 0; --n)
-      {
-        int num = this.zptr[p1];
-        this.zptr[p1] = this.zptr[p2];
-        this.zptr[p2] = num;
-        ++p1;
-        ++p2;
-      }
-    }
-
-    private void QSort3(int loSt, int hiSt, int dSt)
-    {
-      BZip2OutputStream.StackElement[] stackElementArray = new BZip2OutputStream.StackElement[1000];
-      for (int index = 0; index < 1000; ++index)
-        stackElementArray[index] = new BZip2OutputStream.StackElement();
-      int index1 = 0;
-      stackElementArray[index1].ll = loSt;
-      stackElementArray[index1].hh = hiSt;
-      stackElementArray[index1].dd = dSt;
-      int index2 = index1 + 1;
-      while (index2 > 0)
-      {
-        if (index2 >= 1000)
-          BZip2OutputStream.Panic();
-        --index2;
-        int ll = stackElementArray[index2].ll;
-        int hh = stackElementArray[index2].hh;
-        int dd = stackElementArray[index2].dd;
-        if (hh - ll < 20 || dd > 10)
-        {
-          this.SimpleSort(ll, hh, dd);
-          if (this.workDone > this.workLimit && this.firstAttempt)
-            break;
-        }
-        else
-        {
-          int num1 = (int) BZip2OutputStream.Med3(this.block[this.zptr[ll] + dd + 1], this.block[this.zptr[hh] + dd + 1], this.block[this.zptr[ll + hh >> 1] + dd + 1]);
-          int index3;
-          int p1 = index3 = ll;
-          int index4;
-          int index5 = index4 = hh;
-          while (true)
-          {
-            while (p1 <= index5)
-            {
-              int num2 = (int) this.block[this.zptr[p1] + dd + 1] - num1;
-              if (num2 == 0)
-              {
-                int num3 = this.zptr[p1];
-                this.zptr[p1] = this.zptr[index3];
-                this.zptr[index3] = num3;
-                ++index3;
-                ++p1;
-              }
-              else if (num2 <= 0)
-                ++p1;
-              else
-                break;
-            }
-            while (p1 <= index5)
-            {
-              int num4 = (int) this.block[this.zptr[index5] + dd + 1] - num1;
-              if (num4 == 0)
-              {
-                int num5 = this.zptr[index5];
-                this.zptr[index5] = this.zptr[index4];
-                this.zptr[index4] = num5;
-                --index4;
-                --index5;
-              }
-              else if (num4 >= 0)
-                --index5;
-              else
-                break;
-            }
-            if (p1 <= index5)
-            {
-              int num6 = this.zptr[p1];
-              this.zptr[p1] = this.zptr[index5];
-              this.zptr[index5] = num6;
-              ++p1;
-              --index5;
-            }
-            else
-              break;
-          }
-          if (index4 < index3)
-          {
-            stackElementArray[index2].ll = ll;
-            stackElementArray[index2].hh = hh;
-            stackElementArray[index2].dd = dd + 1;
-            ++index2;
-          }
-          else
-          {
-            int n1 = index3 - ll < p1 - index3 ? index3 - ll : p1 - index3;
-            this.Vswap(ll, p1 - n1, n1);
-            int n2 = hh - index4 < index4 - index5 ? hh - index4 : index4 - index5;
-            this.Vswap(p1, hh - n2 + 1, n2);
-            int num7 = ll + p1 - index3 - 1;
-            int num8 = hh - (index4 - index5) + 1;
-            stackElementArray[index2].ll = ll;
-            stackElementArray[index2].hh = num7;
-            stackElementArray[index2].dd = dd;
-            int index6 = index2 + 1;
-            stackElementArray[index6].ll = num7 + 1;
-            stackElementArray[index6].hh = num8 - 1;
-            stackElementArray[index6].dd = dd + 1;
-            int index7 = index6 + 1;
-            stackElementArray[index7].ll = num8;
-            stackElementArray[index7].hh = hh;
-            stackElementArray[index7].dd = dd;
-            index2 = index7 + 1;
-          }
-        }
-      }
-    }
-
-    private void MainSort()
-    {
-      int[] numArray1 = new int[256];
-      int[] numArray2 = new int[256];
-      bool[] flagArray = new bool[256];
-      for (int index = 0; index < 20; ++index)
-        this.block[this.last + index + 2] = this.block[index % (this.last + 1) + 1];
-      for (int index = 0; index <= this.last + 20; ++index)
-        this.quadrant[index] = 0;
-      this.block[0] = this.block[this.last + 1];
-      if (this.last < 4000)
-      {
-        for (int index = 0; index <= this.last; ++index)
-          this.zptr[index] = index;
-        this.firstAttempt = false;
-        this.workDone = this.workLimit = 0;
-        this.SimpleSort(0, this.last, 0);
-      }
-      else
-      {
-        int num1 = 0;
-        for (int index = 0; index <= (int) byte.MaxValue; ++index)
-          flagArray[index] = false;
-        for (int index = 0; index <= 65536; ++index)
-          this.ftab[index] = 0;
-        int num2 = (int) this.block[0];
-        for (int index = 0; index <= this.last; ++index)
-        {
-          int num3 = (int) this.block[index + 1];
-          ++this.ftab[(num2 << 8) + num3];
-          num2 = num3;
-        }
-        for (int index = 1; index <= 65536; ++index)
-          this.ftab[index] += this.ftab[index - 1];
-        int num4 = (int) this.block[1];
-        for (int index1 = 0; index1 < this.last; ++index1)
-        {
-          int num5 = (int) this.block[index1 + 2];
-          int index2 = (num4 << 8) + num5;
-          num4 = num5;
-          --this.ftab[index2];
-          this.zptr[this.ftab[index2]] = index1;
-        }
-        int index3 = ((int) this.block[this.last + 1] << 8) + (int) this.block[1];
-        --this.ftab[index3];
-        this.zptr[this.ftab[index3]] = this.last;
-        for (int index4 = 0; index4 <= (int) byte.MaxValue; ++index4)
-          numArray1[index4] = index4;
-        int num6 = 1;
-        do
-        {
-          num6 = 3 * num6 + 1;
-        }
-        while (num6 <= 256);
-        do
-        {
-          num6 /= 3;
-          for (int index5 = num6; index5 <= (int) byte.MaxValue; ++index5)
-          {
-            int num7 = numArray1[index5];
-            int index6 = index5;
-            while (this.ftab[numArray1[index6 - num6] + 1 << 8] - this.ftab[numArray1[index6 - num6] << 8] > this.ftab[num7 + 1 << 8] - this.ftab[num7 << 8])
-            {
-              numArray1[index6] = numArray1[index6 - num6];
-              index6 -= num6;
-              if (index6 <= num6 - 1)
-                break;
-            }
-            numArray1[index6] = num7;
-          }
-        }
-        while (num6 != 1);
-        for (int index7 = 0; index7 <= (int) byte.MaxValue; ++index7)
-        {
-          int index8 = numArray1[index7];
-          for (int index9 = 0; index9 <= (int) byte.MaxValue; ++index9)
-          {
-            int index10 = (index8 << 8) + index9;
-            if ((this.ftab[index10] & 2097152) != 2097152)
-            {
-              int loSt = this.ftab[index10] & -2097153;
-              int hiSt = (this.ftab[index10 + 1] & -2097153) - 1;
-              if (hiSt > loSt)
-              {
-                this.QSort3(loSt, hiSt, 2);
-                num1 += hiSt - loSt + 1;
-                if (this.workDone > this.workLimit && this.firstAttempt)
-                  return;
-              }
-              this.ftab[index10] |= 2097152;
-            }
-          }
-          flagArray[index8] = true;
-          if (index7 < (int) byte.MaxValue)
-          {
-            int num8 = this.ftab[index8 << 8] & -2097153;
-            int num9 = (this.ftab[index8 + 1 << 8] & -2097153) - num8;
-            int num10 = 0;
-            while (num9 >> num10 > 65534)
-              ++num10;
-            for (int index11 = 0; index11 < num9; ++index11)
-            {
-              int index12 = this.zptr[num8 + index11];
-              int num11 = index11 >> num10;
-              this.quadrant[index12] = num11;
-              if (index12 < 20)
-                this.quadrant[index12 + this.last + 1] = num11;
-            }
-            if (num9 - 1 >> num10 > (int) ushort.MaxValue)
-              BZip2OutputStream.Panic();
-          }
-          for (int index13 = 0; index13 <= (int) byte.MaxValue; ++index13)
-            numArray2[index13] = this.ftab[(index13 << 8) + index8] & -2097153;
-          for (int index14 = this.ftab[index8 << 8] & -2097153; index14 < (this.ftab[index8 + 1 << 8] & -2097153); ++index14)
-          {
-            int index15 = (int) this.block[this.zptr[index14]];
-            if (!flagArray[index15])
-            {
-              this.zptr[numArray2[index15]] = this.zptr[index14] == 0 ? this.last : this.zptr[index14] - 1;
-              ++numArray2[index15];
-            }
-          }
-          for (int index16 = 0; index16 <= (int) byte.MaxValue; ++index16)
-            this.ftab[(index16 << 8) + index8] |= 2097152;
-        }
-      }
-    }
-
-    private void RandomiseBlock()
-    {
-      int num = 0;
-      int index1 = 0;
-      for (int index2 = 0; index2 < 256; ++index2)
-        this.inUse[index2] = false;
-      for (int index3 = 0; index3 <= this.last; ++index3)
-      {
-        if (num == 0)
-        {
-          num = BZip2Constants.rNums[index1];
-          ++index1;
-          if (index1 == 512)
-            index1 = 0;
-        }
-        --num;
-        this.block[index3 + 1] ^= num == 1 ? (byte) 1 : (byte) 0;
-        this.block[index3 + 1] &= byte.MaxValue;
-        this.inUse[(int) this.block[index3 + 1]] = true;
-      }
-    }
-
-    private void DoReversibleTransformation()
-    {
-      this.workLimit = this.workFactor * this.last;
-      this.workDone = 0;
-      this.blockRandomised = false;
-      this.firstAttempt = true;
-      this.MainSort();
-      if (this.workDone > this.workLimit && this.firstAttempt)
-      {
-        this.RandomiseBlock();
-        this.workLimit = this.workDone = 0;
-        this.blockRandomised = true;
-        this.firstAttempt = false;
-        this.MainSort();
-      }
-      this.origPtr = -1;
-      for (int index = 0; index <= this.last; ++index)
-      {
-        if (this.zptr[index] == 0)
-        {
-          this.origPtr = index;
-          break;
-        }
-      }
-      if (this.origPtr != -1)
-        return;
-      BZip2OutputStream.Panic();
-    }
-
-    private bool FullGtU(int i1, int i2)
-    {
-      byte num1 = this.block[i1 + 1];
-      byte num2 = this.block[i2 + 1];
-      if ((int) num1 != (int) num2)
-        return (int) num1 > (int) num2;
-      ++i1;
-      ++i2;
-      byte num3 = this.block[i1 + 1];
-      byte num4 = this.block[i2 + 1];
-      if ((int) num3 != (int) num4)
-        return (int) num3 > (int) num4;
-      ++i1;
-      ++i2;
-      byte num5 = this.block[i1 + 1];
-      byte num6 = this.block[i2 + 1];
-      if ((int) num5 != (int) num6)
-        return (int) num5 > (int) num6;
-      ++i1;
-      ++i2;
-      byte num7 = this.block[i1 + 1];
-      byte num8 = this.block[i2 + 1];
-      if ((int) num7 != (int) num8)
-        return (int) num7 > (int) num8;
-      ++i1;
-      ++i2;
-      byte num9 = this.block[i1 + 1];
-      byte num10 = this.block[i2 + 1];
-      if ((int) num9 != (int) num10)
-        return (int) num9 > (int) num10;
-      ++i1;
-      ++i2;
-      byte num11 = this.block[i1 + 1];
-      byte num12 = this.block[i2 + 1];
-      if ((int) num11 != (int) num12)
-        return (int) num11 > (int) num12;
-      ++i1;
-      ++i2;
-      int num13 = this.last + 1;
-      do
-      {
-        byte num14 = this.block[i1 + 1];
-        byte num15 = this.block[i2 + 1];
-        if ((int) num14 != (int) num15)
-          return (int) num14 > (int) num15;
-        int num16 = this.quadrant[i1];
-        int num17 = this.quadrant[i2];
-        if (num16 != num17)
-          return num16 > num17;
-        ++i1;
-        ++i2;
-        byte num18 = this.block[i1 + 1];
-        byte num19 = this.block[i2 + 1];
-        if ((int) num18 != (int) num19)
-          return (int) num18 > (int) num19;
-        int num20 = this.quadrant[i1];
-        int num21 = this.quadrant[i2];
-        if (num20 != num21)
-          return num20 > num21;
-        ++i1;
-        ++i2;
-        byte num22 = this.block[i1 + 1];
-        byte num23 = this.block[i2 + 1];
-        if ((int) num22 != (int) num23)
-          return (int) num22 > (int) num23;
-        int num24 = this.quadrant[i1];
-        int num25 = this.quadrant[i2];
-        if (num24 != num25)
-          return num24 > num25;
-        ++i1;
-        ++i2;
-        byte num26 = this.block[i1 + 1];
-        byte num27 = this.block[i2 + 1];
-        if ((int) num26 != (int) num27)
-          return (int) num26 > (int) num27;
-        int num28 = this.quadrant[i1];
-        int num29 = this.quadrant[i2];
-        if (num28 != num29)
-          return num28 > num29;
-        ++i1;
-        ++i2;
-        if (i1 > this.last)
-        {
-          i1 -= this.last;
-          --i1;
-        }
-        if (i2 > this.last)
-        {
-          i2 -= this.last;
-          --i2;
-        }
-        num13 -= 4;
-        ++this.workDone;
-      }
-      while (num13 >= 0);
-      return false;
-    }
-
-    private void AllocateCompressStructures()
-    {
-      int length = 100000 * this.blockSize100k;
-      this.block = new byte[length + 1 + 20];
-      this.quadrant = new int[length + 20];
-      this.zptr = new int[length];
-      this.ftab = new int[65537];
-      if (this.block != null && this.quadrant != null && this.zptr != null)
-      {
-        int[] ftab = this.ftab;
-      }
-      this.szptr = new short[2 * length];
-    }
-
-    private void GenerateMTFValues()
-    {
-      char[] chArray = new char[256];
-      this.MakeMaps();
-      int index1 = this.nInUse + 1;
-      for (int index2 = 0; index2 <= index1; ++index2)
-        this.mtfFreq[index2] = 0;
-      int index3 = 0;
-      int num1 = 0;
-      for (int index4 = 0; index4 < this.nInUse; ++index4)
-        chArray[index4] = (char) index4;
-      for (int index5 = 0; index5 <= this.last; ++index5)
-      {
-        char ch1 = this.unseqToSeq[(int) this.block[this.zptr[index5]]];
-        int index6 = 0;
-        char ch2 = chArray[index6];
-        while ((int) ch1 != (int) ch2)
-        {
-          ++index6;
-          char ch3 = ch2;
-          ch2 = chArray[index6];
-          chArray[index6] = ch3;
-        }
-        chArray[0] = ch2;
-        if (index6 == 0)
-        {
-          ++num1;
-        }
-        else
-        {
-          if (num1 > 0)
-          {
-            int num2 = num1 - 1;
-            while (true)
-            {
-              switch (num2 % 2)
-              {
-                case 0:
-                  this.szptr[index3] = (short) 0;
-                  ++index3;
-                  ++this.mtfFreq[0];
-                  break;
-                case 1:
-                  this.szptr[index3] = (short) 1;
-                  ++index3;
-                  ++this.mtfFreq[1];
-                  break;
-              }
-              if (num2 >= 2)
-                num2 = (num2 - 2) / 2;
-              else
-                break;
-            }
-            num1 = 0;
-          }
-          this.szptr[index3] = (short) (index6 + 1);
-          ++index3;
-          ++this.mtfFreq[index6 + 1];
-        }
-      }
-      if (num1 > 0)
-      {
-        int num3 = num1 - 1;
-        while (true)
-        {
-          switch (num3 % 2)
-          {
-            case 0:
-              this.szptr[index3] = (short) 0;
-              ++index3;
-              ++this.mtfFreq[0];
-              break;
-            case 1:
-              this.szptr[index3] = (short) 1;
-              ++index3;
-              ++this.mtfFreq[1];
-              break;
-          }
-          if (num3 >= 2)
-            num3 = (num3 - 2) / 2;
-          else
-            break;
-        }
-      }
-      this.szptr[index3] = (short) index1;
-      int num4 = index3 + 1;
-      ++this.mtfFreq[index1];
-      this.nMTF = num4;
-    }
-
-    private static void Panic() => throw new BZip2Exception("BZip2 output stream panic");
-
-    private static void HbMakeCodeLengths(char[] len, int[] freq, int alphaSize, int maxLen)
-    {
-      int[] numArray1 = new int[260];
-      int[] numArray2 = new int[516];
-      int[] numArray3 = new int[516];
-      for (int index = 0; index < alphaSize; ++index)
-        numArray2[index + 1] = (freq[index] == 0 ? 1 : freq[index]) << 8;
-label_3:
-      int index1 = alphaSize;
-      int index2 = 0;
-      numArray1[0] = 0;
-      numArray2[0] = 0;
-      numArray3[0] = -2;
-      for (int index3 = 1; index3 <= alphaSize; ++index3)
-      {
-        numArray3[index3] = -1;
-        ++index2;
-        numArray1[index2] = index3;
-        int index4 = index2;
-        int index5;
-        for (index5 = numArray1[index4]; numArray2[index5] < numArray2[numArray1[index4 >> 1]]; index4 >>= 1)
-          numArray1[index4] = numArray1[index4 >> 1];
-        numArray1[index4] = index5;
-      }
-      if (index2 >= 260)
-        BZip2OutputStream.Panic();
-      while (index2 > 1)
-      {
-        int index6 = numArray1[1];
-        numArray1[1] = numArray1[index2];
-        int index7 = index2 - 1;
-        int index8 = 1;
-        int num1 = 0;
-        int index9 = numArray1[index8];
-        while (true)
-        {
-          int index10 = index8 << 1;
-          if (index10 <= index7)
-          {
-            if (index10 < index7 && numArray2[numArray1[index10 + 1]] < numArray2[numArray1[index10]])
-              ++index10;
-            if (numArray2[index9] >= numArray2[numArray1[index10]])
-            {
-              numArray1[index8] = numArray1[index10];
-              index8 = index10;
-            }
-            else
-              break;
-          }
-          else
-            break;
-        }
-        numArray1[index8] = index9;
-        int index11 = numArray1[1];
-        numArray1[1] = numArray1[index7];
-        int num2 = index7 - 1;
-        int index12 = 1;
-        num1 = 0;
-        int index13 = numArray1[index12];
-        while (true)
-        {
-          int index14 = index12 << 1;
-          if (index14 <= num2)
-          {
-            if (index14 < num2 && numArray2[numArray1[index14 + 1]] < numArray2[numArray1[index14]])
-              ++index14;
-            if (numArray2[index13] >= numArray2[numArray1[index14]])
-            {
-              numArray1[index12] = numArray1[index14];
-              index12 = index14;
-            }
-            else
-              break;
-          }
-          else
-            break;
-        }
-        numArray1[index12] = index13;
-        ++index1;
-        numArray3[index6] = numArray3[index11] = index1;
-        numArray2[index1] = (int) (((long) numArray2[index6] & 4294967040L) + ((long) numArray2[index11] & 4294967040L)) | 1 + ((numArray2[index6] & (int) byte.MaxValue) > (numArray2[index11] & (int) byte.MaxValue) ? numArray2[index6] & (int) byte.MaxValue : numArray2[index11] & (int) byte.MaxValue);
-        numArray3[index1] = -1;
-        index2 = num2 + 1;
-        numArray1[index2] = index1;
-        int index15 = index2;
-        int index16;
-        for (index16 = numArray1[index15]; numArray2[index16] < numArray2[numArray1[index15 >> 1]]; index15 >>= 1)
-          numArray1[index15] = numArray1[index15 >> 1];
-        numArray1[index15] = index16;
-      }
-      if (index1 >= 516)
-        BZip2OutputStream.Panic();
-      bool flag = false;
-      for (int index17 = 1; index17 <= alphaSize; ++index17)
-      {
-        int num = 0;
-        int index18 = index17;
-        while (numArray3[index18] >= 0)
-        {
-          index18 = numArray3[index18];
-          ++num;
-        }
-        len[index17 - 1] = (char) num;
-        if (num > maxLen)
-          flag = true;
-      }
-      if (!flag)
-        return;
-      for (int index19 = 1; index19 < alphaSize; ++index19)
-      {
-        int num = 1 + (numArray2[index19] >> 8) / 2;
-        numArray2[index19] = num << 8;
-      }
-      goto label_3;
-    }
-
-    private static void HbAssignCodes(
-      int[] code,
-      char[] length,
-      int minLen,
-      int maxLen,
-      int alphaSize)
-    {
-      int num = 0;
-      for (int index1 = minLen; index1 <= maxLen; ++index1)
-      {
-        for (int index2 = 0; index2 < alphaSize; ++index2)
-        {
-          if ((int) length[index2] == index1)
-          {
-            code[index2] = num;
-            ++num;
-          }
-        }
-        num <<= 1;
-      }
-    }
-
-    private static byte Med3(byte a, byte b, byte c)
-    {
-      if ((int) a > (int) b)
-      {
-        byte num = a;
-        a = b;
-        b = num;
-      }
-      if ((int) b > (int) c)
-      {
-        byte num = b;
-        b = c;
-        c = num;
-      }
-      if ((int) a > (int) b)
-        b = a;
-      return b;
-    }
-
-    private class StackElement
-    {
-      public int ll;
-      public int hh;
-      public int dd;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/Adler32.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/Adler32.cs
deleted file mode 100644
index fbfff06..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/Adler32.cs
+++ /dev/null
@@ -1,63 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Checksums
-{
-  public sealed class Adler32 : IChecksum
-  {
-    private const uint BASE = 65521;
-    private uint checksum;
-
-    public long Value => (long) this.checksum;
-
-    public Adler32() => this.Reset();
-
-    public void Reset() => this.checksum = 1U;
-
-    public void Update(int value)
-    {
-      uint num1 = this.checksum & (uint) ushort.MaxValue;
-      uint num2 = this.checksum >> 16;
-      uint num3 = (num1 + (uint) (value & (int) byte.MaxValue)) % 65521U;
-      this.checksum = ((num3 + num2) % 65521U << 16) + num3;
-    }
-
-    public void Update(byte[] buffer)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      this.Update(buffer, 0, buffer.Length);
-    }
-
-    public void Update(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "cannot be negative");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "cannot be negative");
-      if (offset >= buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (offset), "not a valid index into buffer");
-      if (offset + count > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count), "exceeds buffer size");
-      uint num1 = this.checksum & (uint) ushort.MaxValue;
-      uint num2 = this.checksum >> 16;
-      while (count > 0)
-      {
-        int num3 = 3800;
-        if (num3 > count)
-          num3 = count;
-        count -= num3;
-        while (--num3 >= 0)
-        {
-          num1 += (uint) buffer[offset++] & (uint) byte.MaxValue;
-          num2 += num1;
-        }
-        num1 %= 65521U;
-        num2 %= 65521U;
-      }
-      this.checksum = num2 << 16 | num1;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/Crc32.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/Crc32.cs
deleted file mode 100644
index b955511..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/Crc32.cs
+++ /dev/null
@@ -1,311 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Checksums
-{
-  public sealed class Crc32 : IChecksum
-  {
-    private static readonly uint CrcSeed = uint.MaxValue;
-    private static readonly uint[] CrcTable = new uint[256]
-    {
-      0U,
-      1996959894U,
-      3993919788U,
-      2567524794U,
-      124634137U,
-      1886057615U,
-      3915621685U,
-      2657392035U,
-      249268274U,
-      2044508324U,
-      3772115230U,
-      2547177864U,
-      162941995U,
-      2125561021U,
-      3887607047U,
-      2428444049U,
-      498536548U,
-      1789927666U,
-      4089016648U,
-      2227061214U,
-      450548861U,
-      1843258603U,
-      4107580753U,
-      2211677639U,
-      325883990U,
-      1684777152U,
-      4251122042U,
-      2321926636U,
-      335633487U,
-      1661365465U,
-      4195302755U,
-      2366115317U,
-      997073096U,
-      1281953886U,
-      3579855332U,
-      2724688242U,
-      1006888145U,
-      1258607687U,
-      3524101629U,
-      2768942443U,
-      901097722U,
-      1119000684U,
-      3686517206U,
-      2898065728U,
-      853044451U,
-      1172266101U,
-      3705015759U,
-      2882616665U,
-      651767980U,
-      1373503546U,
-      3369554304U,
-      3218104598U,
-      565507253U,
-      1454621731U,
-      3485111705U,
-      3099436303U,
-      671266974U,
-      1594198024U,
-      3322730930U,
-      2970347812U,
-      795835527U,
-      1483230225U,
-      3244367275U,
-      3060149565U,
-      1994146192U,
-      31158534U,
-      2563907772U,
-      4023717930U,
-      1907459465U,
-      112637215U,
-      2680153253U,
-      3904427059U,
-      2013776290U,
-      251722036U,
-      2517215374U,
-      3775830040U,
-      2137656763U,
-      141376813U,
-      2439277719U,
-      3865271297U,
-      1802195444U,
-      476864866U,
-      2238001368U,
-      4066508878U,
-      1812370925U,
-      453092731U,
-      2181625025U,
-      4111451223U,
-      1706088902U,
-      314042704U,
-      2344532202U,
-      4240017532U,
-      1658658271U,
-      366619977U,
-      2362670323U,
-      4224994405U,
-      1303535960U,
-      984961486U,
-      2747007092U,
-      3569037538U,
-      1256170817U,
-      1037604311U,
-      2765210733U,
-      3554079995U,
-      1131014506U,
-      879679996U,
-      2909243462U,
-      3663771856U,
-      1141124467U,
-      855842277U,
-      2852801631U,
-      3708648649U,
-      1342533948U,
-      654459306U,
-      3188396048U,
-      3373015174U,
-      1466479909U,
-      544179635U,
-      3110523913U,
-      3462522015U,
-      1591671054U,
-      702138776U,
-      2966460450U,
-      3352799412U,
-      1504918807U,
-      783551873U,
-      3082640443U,
-      3233442989U,
-      3988292384U,
-      2596254646U,
-      62317068U,
-      1957810842U,
-      3939845945U,
-      2647816111U,
-      81470997U,
-      1943803523U,
-      3814918930U,
-      2489596804U,
-      225274430U,
-      2053790376U,
-      3826175755U,
-      2466906013U,
-      167816743U,
-      2097651377U,
-      4027552580U,
-      2265490386U,
-      503444072U,
-      1762050814U,
-      4150417245U,
-      2154129355U,
-      426522225U,
-      1852507879U,
-      4275313526U,
-      2312317920U,
-      282753626U,
-      1742555852U,
-      4189708143U,
-      2394877945U,
-      397917763U,
-      1622183637U,
-      3604390888U,
-      2714866558U,
-      953729732U,
-      1340076626U,
-      3518719985U,
-      2797360999U,
-      1068828381U,
-      1219638859U,
-      3624741850U,
-      2936675148U,
-      906185462U,
-      1090812512U,
-      3747672003U,
-      2825379669U,
-      829329135U,
-      1181335161U,
-      3412177804U,
-      3160834842U,
-      628085408U,
-      1382605366U,
-      3423369109U,
-      3138078467U,
-      570562233U,
-      1426400815U,
-      3317316542U,
-      2998733608U,
-      733239954U,
-      1555261956U,
-      3268935591U,
-      3050360625U,
-      752459403U,
-      1541320221U,
-      2607071920U,
-      3965973030U,
-      1969922972U,
-      40735498U,
-      2617837225U,
-      3943577151U,
-      1913087877U,
-      83908371U,
-      2512341634U,
-      3803740692U,
-      2075208622U,
-      213261112U,
-      2463272603U,
-      3855990285U,
-      2094854071U,
-      198958881U,
-      2262029012U,
-      4057260610U,
-      1759359992U,
-      534414190U,
-      2176718541U,
-      4139329115U,
-      1873836001U,
-      414664567U,
-      2282248934U,
-      4279200368U,
-      1711684554U,
-      285281116U,
-      2405801727U,
-      4167216745U,
-      1634467795U,
-      376229701U,
-      2685067896U,
-      3608007406U,
-      1308918612U,
-      956543938U,
-      2808555105U,
-      3495958263U,
-      1231636301U,
-      1047427035U,
-      2932959818U,
-      3654703836U,
-      1088359270U,
-      936918000U,
-      2847714899U,
-      3736837829U,
-      1202900863U,
-      817233897U,
-      3183342108U,
-      3401237130U,
-      1404277552U,
-      615818150U,
-      3134207493U,
-      3453421203U,
-      1423857449U,
-      601450431U,
-      3009837614U,
-      3294710456U,
-      1567103746U,
-      711928724U,
-      3020668471U,
-      3272380065U,
-      1510334235U,
-      755167117U
-    };
-    private uint crc;
-
-    internal static uint ComputeCrc32(uint oldCrc, byte value)
-    {
-      return Crc32.CrcTable[(IntPtr) (uint) (((int) oldCrc ^ (int) value) & (int) byte.MaxValue)] ^ oldCrc >> 8;
-    }
-
-    public long Value
-    {
-      get => (long) this.crc;
-      set => this.crc = (uint) value;
-    }
-
-    public void Reset() => this.crc = 0U;
-
-    public void Update(int value)
-    {
-      this.crc ^= Crc32.CrcSeed;
-      this.crc = Crc32.CrcTable[((long) this.crc ^ (long) value) & (long) byte.MaxValue] ^ this.crc >> 8;
-      this.crc ^= Crc32.CrcSeed;
-    }
-
-    public void Update(byte[] buffer)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      this.Update(buffer, 0, buffer.Length);
-    }
-
-    public void Update(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Count cannot be less than zero");
-      if (offset < 0 || offset + count > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      this.crc ^= Crc32.CrcSeed;
-      while (--count >= 0)
-        this.crc = Crc32.CrcTable[(IntPtr) (uint) (((int) this.crc ^ (int) buffer[offset++]) & (int) byte.MaxValue)] ^ this.crc >> 8;
-      this.crc ^= Crc32.CrcSeed;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/IChecksum.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/IChecksum.cs
deleted file mode 100644
index 604ccf5..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/IChecksum.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Checksums
-{
-  public interface IChecksum
-  {
-    long Value { get; }
-
-    void Reset();
-
-    void Update(int value);
-
-    void Update(byte[] buffer);
-
-    void Update(byte[] buffer, int offset, int count);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/StrangeCRC.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/StrangeCRC.cs
deleted file mode 100644
index 2e60845..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Checksums/StrangeCRC.cs
+++ /dev/null
@@ -1,304 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Checksums
-{
-  public class StrangeCRC : IChecksum
-  {
-    private static readonly uint[] crc32Table = new uint[256]
-    {
-      0U,
-      79764919U,
-      159529838U,
-      222504665U,
-      319059676U,
-      398814059U,
-      445009330U,
-      507990021U,
-      638119352U,
-      583659535U,
-      797628118U,
-      726387553U,
-      890018660U,
-      835552979U,
-      1015980042U,
-      944750013U,
-      1276238704U,
-      1221641927U,
-      1167319070U,
-      1095957929U,
-      1595256236U,
-      1540665371U,
-      1452775106U,
-      1381403509U,
-      1780037320U,
-      1859660671U,
-      1671105958U,
-      1733955601U,
-      2031960084U,
-      2111593891U,
-      1889500026U,
-      1952343757U,
-      2552477408U,
-      2632100695U,
-      2443283854U,
-      2506133561U,
-      2334638140U,
-      2414271883U,
-      2191915858U,
-      2254759653U,
-      3190512472U,
-      3135915759U,
-      3081330742U,
-      3009969537U,
-      2905550212U,
-      2850959411U,
-      2762807018U,
-      2691435357U,
-      3560074640U,
-      3505614887U,
-      3719321342U,
-      3648080713U,
-      3342211916U,
-      3287746299U,
-      3467911202U,
-      3396681109U,
-      4063920168U,
-      4143685023U,
-      4223187782U,
-      4286162673U,
-      3779000052U,
-      3858754371U,
-      3904687514U,
-      3967668269U,
-      881225847U,
-      809987520U,
-      1023691545U,
-      969234094U,
-      662832811U,
-      591600412U,
-      771767749U,
-      717299826U,
-      311336399U,
-      374308984U,
-      453813921U,
-      533576470U,
-      25881363U,
-      88864420U,
-      134795389U,
-      214552010U,
-      2023205639U,
-      2086057648U,
-      1897238633U,
-      1976864222U,
-      1804852699U,
-      1867694188U,
-      1645340341U,
-      1724971778U,
-      1587496639U,
-      1516133128U,
-      1461550545U,
-      1406951526U,
-      1302016099U,
-      1230646740U,
-      1142491917U,
-      1087903418U,
-      2896545431U,
-      2825181984U,
-      2770861561U,
-      2716262478U,
-      3215044683U,
-      3143675388U,
-      3055782693U,
-      3001194130U,
-      2326604591U,
-      2389456536U,
-      2200899649U,
-      2280525302U,
-      2578013683U,
-      2640855108U,
-      2418763421U,
-      2498394922U,
-      3769900519U,
-      3832873040U,
-      3912640137U,
-      3992402750U,
-      4088425275U,
-      4151408268U,
-      4197601365U,
-      4277358050U,
-      3334271071U,
-      3263032808U,
-      3476998961U,
-      3422541446U,
-      3585640067U,
-      3514407732U,
-      3694837229U,
-      3640369242U,
-      1762451694U,
-      1842216281U,
-      1619975040U,
-      1682949687U,
-      2047383090U,
-      2127137669U,
-      1938468188U,
-      2001449195U,
-      1325665622U,
-      1271206113U,
-      1183200824U,
-      1111960463U,
-      1543535498U,
-      1489069629U,
-      1434599652U,
-      1363369299U,
-      622672798U,
-      568075817U,
-      748617968U,
-      677256519U,
-      907627842U,
-      853037301U,
-      1067152940U,
-      995781531U,
-      51762726U,
-      131386257U,
-      177728840U,
-      240578815U,
-      269590778U,
-      349224269U,
-      429104020U,
-      491947555U,
-      4046411278U,
-      4126034873U,
-      4172115296U,
-      4234965207U,
-      3794477266U,
-      3874110821U,
-      3953728444U,
-      4016571915U,
-      3609705398U,
-      3555108353U,
-      3735388376U,
-      3664026991U,
-      3290680682U,
-      3236090077U,
-      3449943556U,
-      3378572211U,
-      3174993278U,
-      3120533705U,
-      3032266256U,
-      2961025959U,
-      2923101090U,
-      2868635157U,
-      2813903052U,
-      2742672763U,
-      2604032198U,
-      2683796849U,
-      2461293480U,
-      2524268063U,
-      2284983834U,
-      2364738477U,
-      2175806836U,
-      2238787779U,
-      1569362073U,
-      1498123566U,
-      1409854455U,
-      1355396672U,
-      1317987909U,
-      1246755826U,
-      1192025387U,
-      1137557660U,
-      2072149281U,
-      2135122070U,
-      1912620623U,
-      1992383480U,
-      1753615357U,
-      1816598090U,
-      1627664531U,
-      1707420964U,
-      295390185U,
-      358241886U,
-      404320391U,
-      483945776U,
-      43990325U,
-      106832002U,
-      186451547U,
-      266083308U,
-      932423249U,
-      861060070U,
-      1041341759U,
-      986742920U,
-      613929101U,
-      542559546U,
-      756411363U,
-      701822548U,
-      3316196985U,
-      3244833742U,
-      3425377559U,
-      3370778784U,
-      3601682597U,
-      3530312978U,
-      3744426955U,
-      3689838204U,
-      3819031489U,
-      3881883254U,
-      3928223919U,
-      4007849240U,
-      4037393693U,
-      4100235434U,
-      4180117107U,
-      4259748804U,
-      2310601993U,
-      2373574846U,
-      2151335527U,
-      2231098320U,
-      2596047829U,
-      2659030626U,
-      2470359227U,
-      2550115596U,
-      2947551409U,
-      2876312838U,
-      2788305887U,
-      2733848168U,
-      3165939309U,
-      3094707162U,
-      3040238851U,
-      2985771188U
-    };
-    private int globalCrc;
-
-    public StrangeCRC() => this.Reset();
-
-    public void Reset() => this.globalCrc = -1;
-
-    public long Value => (long) ~this.globalCrc;
-
-    public void Update(int value)
-    {
-      int index = this.globalCrc >> 24 ^ value;
-      if (index < 0)
-        index = 256 + index;
-      this.globalCrc = (int) ((long) (this.globalCrc << 8) ^ (long) StrangeCRC.crc32Table[index]);
-    }
-
-    public void Update(byte[] buffer)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      this.Update(buffer, 0, buffer.Length);
-    }
-
-    public void Update(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "cannot be less than zero");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "cannot be less than zero");
-      if (offset + count > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      for (int index = 0; index < count; ++index)
-        this.Update((int) buffer[offset++]);
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/DirectoryEventArgs.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/DirectoryEventArgs.cs
deleted file mode 100644
index 014f420..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/DirectoryEventArgs.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class DirectoryEventArgs : ScanEventArgs
-  {
-    private bool hasMatchingFiles_;
-
-    public DirectoryEventArgs(string name, bool hasMatchingFiles)
-      : base(name)
-    {
-      this.hasMatchingFiles_ = hasMatchingFiles;
-    }
-
-    public bool HasMatchingFiles => this.hasMatchingFiles_;
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/DirectoryFailureDelegate.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/DirectoryFailureDelegate.cs
deleted file mode 100644
index c2fc394..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/DirectoryFailureDelegate.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public delegate void DirectoryFailureDelegate(object sender, ScanFailureEventArgs e);
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ExtendedPathFilter.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ExtendedPathFilter.cs
deleted file mode 100644
index 9c8003a..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ExtendedPathFilter.cs
+++ /dev/null
@@ -1,89 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class ExtendedPathFilter : PathFilter
-  {
-    private long minSize_;
-    private long maxSize_ = long.MaxValue;
-    private DateTime minDate_ = DateTime.MinValue;
-    private DateTime maxDate_ = DateTime.MaxValue;
-
-    public ExtendedPathFilter(string filter, long minSize, long maxSize)
-      : base(filter)
-    {
-      this.MinSize = minSize;
-      this.MaxSize = maxSize;
-    }
-
-    public ExtendedPathFilter(string filter, DateTime minDate, DateTime maxDate)
-      : base(filter)
-    {
-      this.MinDate = minDate;
-      this.MaxDate = maxDate;
-    }
-
-    public ExtendedPathFilter(
-      string filter,
-      long minSize,
-      long maxSize,
-      DateTime minDate,
-      DateTime maxDate)
-      : base(filter)
-    {
-      this.MinSize = minSize;
-      this.MaxSize = maxSize;
-      this.MinDate = minDate;
-      this.MaxDate = maxDate;
-    }
-
-    public override bool IsMatch(string name)
-    {
-      bool flag = base.IsMatch(name);
-      if (flag)
-      {
-        FileInfo fileInfo = new FileInfo(name);
-        flag = this.MinSize <= fileInfo.Length && this.MaxSize >= fileInfo.Length && this.MinDate <= fileInfo.LastWriteTime && this.MaxDate >= fileInfo.LastWriteTime;
-      }
-      return flag;
-    }
-
-    public long MinSize
-    {
-      get => this.minSize_;
-      set
-      {
-        this.minSize_ = value >= 0L && this.maxSize_ >= value ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public long MaxSize
-    {
-      get => this.maxSize_;
-      set
-      {
-        this.maxSize_ = value >= 0L && this.minSize_ <= value ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public DateTime MinDate
-    {
-      get => this.minDate_;
-      set
-      {
-        this.minDate_ = !(value > this.maxDate_) ? value : throw new ArgumentException("Exceeds MaxDate", nameof (value));
-      }
-    }
-
-    public DateTime MaxDate
-    {
-      get => this.maxDate_;
-      set
-      {
-        this.maxDate_ = !(this.minDate_ > value) ? value : throw new ArgumentException("Exceeds MinDate", nameof (value));
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/FileFailureDelegate.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/FileFailureDelegate.cs
deleted file mode 100644
index fe78717..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/FileFailureDelegate.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public delegate void FileFailureDelegate(object sender, ScanFailureEventArgs e);
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/FileSystemScanner.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/FileSystemScanner.cs
deleted file mode 100644
index d851555..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/FileSystemScanner.cs
+++ /dev/null
@@ -1,151 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class FileSystemScanner
-  {
-    public ProcessDirectoryDelegate ProcessDirectory;
-    public ProcessFileDelegate ProcessFile;
-    public DirectoryFailureDelegate DirectoryFailure;
-    public FileFailureDelegate FileFailure;
-    private IScanFilter fileFilter_;
-    private IScanFilter directoryFilter_;
-    private bool alive_;
-
-    public FileSystemScanner(string filter)
-    {
-      this.fileFilter_ = (IScanFilter) new PathFilter(filter);
-    }
-
-    public FileSystemScanner(string fileFilter, string directoryFilter)
-    {
-      this.fileFilter_ = (IScanFilter) new PathFilter(fileFilter);
-      this.directoryFilter_ = (IScanFilter) new PathFilter(directoryFilter);
-    }
-
-    public FileSystemScanner(IScanFilter fileFilter) => this.fileFilter_ = fileFilter;
-
-    public FileSystemScanner(IScanFilter fileFilter, IScanFilter directoryFilter)
-    {
-      this.fileFilter_ = fileFilter;
-      this.directoryFilter_ = directoryFilter;
-    }
-
-    public void OnDirectoryFailure(string directory, Exception e)
-    {
-      if (this.DirectoryFailure == null)
-      {
-        this.alive_ = false;
-      }
-      else
-      {
-        ScanFailureEventArgs e1 = new ScanFailureEventArgs(directory, e);
-        this.DirectoryFailure((object) this, e1);
-        this.alive_ = e1.ContinueRunning;
-      }
-    }
-
-    public void OnFileFailure(string file, Exception e)
-    {
-      if (this.FileFailure == null)
-      {
-        this.alive_ = false;
-      }
-      else
-      {
-        ScanFailureEventArgs e1 = new ScanFailureEventArgs(file, e);
-        this.FileFailure((object) this, e1);
-        this.alive_ = e1.ContinueRunning;
-      }
-    }
-
-    public void OnProcessFile(string file)
-    {
-      if (this.ProcessFile == null)
-        return;
-      ScanEventArgs e = new ScanEventArgs(file);
-      this.ProcessFile((object) this, e);
-      this.alive_ = e.ContinueRunning;
-    }
-
-    public void OnProcessDirectory(string directory, bool hasMatchingFiles)
-    {
-      if (this.ProcessDirectory == null)
-        return;
-      DirectoryEventArgs e = new DirectoryEventArgs(directory, hasMatchingFiles);
-      this.ProcessDirectory((object) this, e);
-      this.alive_ = e.ContinueRunning;
-    }
-
-    public void Scan(string directory, bool recurse)
-    {
-      this.alive_ = true;
-      this.ScanDir(directory, recurse);
-    }
-
-    private void ScanDir(string directory, bool recurse)
-    {
-      try
-      {
-        string[] files = Directory.GetFiles(directory);
-        bool hasMatchingFiles = false;
-        for (int index = 0; index < files.Length; ++index)
-        {
-          if (!this.fileFilter_.IsMatch(files[index]))
-            files[index] = (string) null;
-          else
-            hasMatchingFiles = true;
-        }
-        this.OnProcessDirectory(directory, hasMatchingFiles);
-        if (this.alive_)
-        {
-          if (hasMatchingFiles)
-          {
-            foreach (string file in files)
-            {
-              try
-              {
-                if (file != null)
-                {
-                  this.OnProcessFile(file);
-                  if (!this.alive_)
-                    break;
-                }
-              }
-              catch (Exception ex)
-              {
-                this.OnFileFailure(file, ex);
-              }
-            }
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        this.OnDirectoryFailure(directory, ex);
-      }
-      if (!this.alive_)
-        return;
-      if (!recurse)
-        return;
-      try
-      {
-        foreach (string directory1 in Directory.GetDirectories(directory))
-        {
-          if (this.directoryFilter_ == null || this.directoryFilter_.IsMatch(directory1))
-          {
-            this.ScanDir(directory1, true);
-            if (!this.alive_)
-              break;
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        this.OnDirectoryFailure(directory, ex);
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/INameTransform.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/INameTransform.cs
deleted file mode 100644
index 87fd5dd..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/INameTransform.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public interface INameTransform
-  {
-    string TransformFile(string name);
-
-    string TransformDirectory(string name);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/IScanFilter.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/IScanFilter.cs
deleted file mode 100644
index 9d655ec..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/IScanFilter.cs
+++ /dev/null
@@ -1,8 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public interface IScanFilter
-  {
-    bool IsMatch(string name);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/NameAndSizeFilter.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/NameAndSizeFilter.cs
deleted file mode 100644
index b185d8c..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/NameAndSizeFilter.cs
+++ /dev/null
@@ -1,49 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  [Obsolete("Use ExtendedPathFilter instead")]
-  public class NameAndSizeFilter : PathFilter
-  {
-    private long minSize_;
-    private long maxSize_ = long.MaxValue;
-
-    public NameAndSizeFilter(string filter, long minSize, long maxSize)
-      : base(filter)
-    {
-      this.MinSize = minSize;
-      this.MaxSize = maxSize;
-    }
-
-    public override bool IsMatch(string name)
-    {
-      bool flag = base.IsMatch(name);
-      if (flag)
-      {
-        long length = new FileInfo(name).Length;
-        flag = this.MinSize <= length && this.MaxSize >= length;
-      }
-      return flag;
-    }
-
-    public long MinSize
-    {
-      get => this.minSize_;
-      set
-      {
-        this.minSize_ = value >= 0L && this.maxSize_ >= value ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-
-    public long MaxSize
-    {
-      get => this.maxSize_;
-      set
-      {
-        this.maxSize_ = value >= 0L && this.minSize_ <= value ? value : throw new ArgumentOutOfRangeException(nameof (value));
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/NameFilter.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/NameFilter.cs
deleted file mode 100644
index 728a503..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/NameFilter.cs
+++ /dev/null
@@ -1,117 +0,0 @@
-
-using System;
-using System.Collections;
-using System.Text.RegularExpressions;
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class NameFilter : IScanFilter
-  {
-    private string filter_;
-    private ArrayList inclusions_;
-    private ArrayList exclusions_;
-
-    public NameFilter(string filter)
-    {
-      this.filter_ = filter;
-      this.inclusions_ = new ArrayList();
-      this.exclusions_ = new ArrayList();
-      this.Compile();
-    }
-
-    public static bool IsValidExpression(string expression)
-    {
-      bool flag = true;
-      try
-      {
-        Regex regex = new Regex(expression, RegexOptions.IgnoreCase | RegexOptions.Singleline);
-      }
-      catch
-      {
-        flag = false;
-      }
-      return flag;
-    }
-
-    public static bool IsValidFilterExpression(string toTest)
-    {
-      if (toTest == null)
-        throw new ArgumentNullException(nameof (toTest));
-      bool flag = true;
-      try
-      {
-        string[] strArray = toTest.Split(';');
-        for (int index = 0; index < strArray.Length; ++index)
-        {
-          if (strArray[index] != null && strArray[index].Length > 0)
-          {
-            Regex regex = new Regex(strArray[index][0] != '+' ? (strArray[index][0] != '-' ? strArray[index] : strArray[index].Substring(1, strArray[index].Length - 1)) : strArray[index].Substring(1, strArray[index].Length - 1), RegexOptions.IgnoreCase | RegexOptions.Singleline);
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        flag = false;
-      }
-      return flag;
-    }
-
-    public override string ToString() => this.filter_;
-
-    public bool IsIncluded(string name)
-    {
-      bool flag = false;
-      if (this.inclusions_.Count == 0)
-      {
-        flag = true;
-      }
-      else
-      {
-        foreach (Regex inclusion in this.inclusions_)
-        {
-          if (inclusion.IsMatch(name))
-          {
-            flag = true;
-            break;
-          }
-        }
-      }
-      return flag;
-    }
-
-    public bool IsExcluded(string name)
-    {
-      bool flag = false;
-      foreach (Regex exclusion in this.exclusions_)
-      {
-        if (exclusion.IsMatch(name))
-        {
-          flag = true;
-          break;
-        }
-      }
-      return flag;
-    }
-
-    public bool IsMatch(string name) => this.IsIncluded(name) && !this.IsExcluded(name);
-
-    private void Compile()
-    {
-      if (this.filter_ == null)
-        return;
-      string[] strArray = this.filter_.Split(';');
-      for (int index = 0; index < strArray.Length; ++index)
-      {
-        if (strArray[index] != null && strArray[index].Length > 0)
-        {
-          bool flag = strArray[index][0] != '-';
-          string pattern = strArray[index][0] != '+' ? (strArray[index][0] != '-' ? strArray[index] : strArray[index].Substring(1, strArray[index].Length - 1)) : strArray[index].Substring(1, strArray[index].Length - 1);
-          if (flag)
-            this.inclusions_.Add((object) new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
-          else
-            this.exclusions_.Add((object) new Regex(pattern, RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline));
-        }
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/PathFilter.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/PathFilter.cs
deleted file mode 100644
index 3b1a531..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/PathFilter.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class PathFilter : IScanFilter
-  {
-    private NameFilter nameFilter_;
-
-    public PathFilter(string filter) => this.nameFilter_ = new NameFilter(filter);
-
-    public virtual bool IsMatch(string name)
-    {
-      bool flag = false;
-      if (name != null)
-        flag = this.nameFilter_.IsMatch(name.Length > 0 ? Path.GetFullPath(name) : "");
-      return flag;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ProcessDirectoryDelegate.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ProcessDirectoryDelegate.cs
deleted file mode 100644
index 04df72f..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ProcessDirectoryDelegate.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public delegate void ProcessDirectoryDelegate(object sender, DirectoryEventArgs e);
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ProcessFileDelegate.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ProcessFileDelegate.cs
deleted file mode 100644
index 6e5ebf3..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ProcessFileDelegate.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public delegate void ProcessFileDelegate(object sender, ScanEventArgs e);
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ScanEventArgs.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ScanEventArgs.cs
deleted file mode 100644
index 169570b..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ScanEventArgs.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class ScanEventArgs : EventArgs
-  {
-    private string name_;
-    private bool continueRunning_ = true;
-
-    public ScanEventArgs(string name) => this.name_ = name;
-
-    public string Name => this.name_;
-
-    public bool ContinueRunning
-    {
-      get => this.continueRunning_;
-      set => this.continueRunning_ = value;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ScanFailureEventArgs.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ScanFailureEventArgs.cs
deleted file mode 100644
index 4b37efa..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/ScanFailureEventArgs.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public class ScanFailureEventArgs
-  {
-    private string name_;
-    private Exception exception_;
-    private bool continueRunning_;
-
-    public ScanFailureEventArgs(string name, Exception e)
-    {
-      this.name_ = name;
-      this.exception_ = e;
-      this.continueRunning_ = true;
-    }
-
-    public string Name => this.name_;
-
-    public Exception Exception => this.exception_;
-
-    public bool ContinueRunning
-    {
-      get => this.continueRunning_;
-      set => this.continueRunning_ = value;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/StreamUtils.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/StreamUtils.cs
deleted file mode 100644
index 798b1b6..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Core/StreamUtils.cs
+++ /dev/null
@@ -1,64 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Core
-{
-  public sealed class StreamUtils
-  {
-    public static void ReadFully(Stream stream, byte[] buffer)
-    {
-      StreamUtils.ReadFully(stream, buffer, 0, buffer.Length);
-    }
-
-    public static void ReadFully(Stream stream, byte[] buffer, int offset, int count)
-    {
-      if (stream == null)
-        throw new ArgumentNullException(nameof (stream));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0 || offset > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      if (count < 0 || offset + count > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      int num;
-      for (; count > 0; count -= num)
-      {
-        num = stream.Read(buffer, offset, count);
-        if (num <= 0)
-          throw new EndOfStreamException();
-        offset += num;
-      }
-    }
-
-    public static void Copy(Stream source, Stream destination, byte[] buffer)
-    {
-      if (source == null)
-        throw new ArgumentNullException(nameof (source));
-      if (destination == null)
-        throw new ArgumentNullException(nameof (destination));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (buffer.Length < 128)
-        throw new ArgumentException("Buffer is too small", nameof (buffer));
-      bool flag = true;
-      while (flag)
-      {
-        int count = source.Read(buffer, 0, buffer.Length);
-        if (count > 0)
-        {
-          destination.Write(buffer, 0, count);
-        }
-        else
-        {
-          destination.Flush();
-          flag = false;
-        }
-      }
-    }
-
-    private StreamUtils()
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassic.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassic.cs
deleted file mode 100644
index f07a783..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassic.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-using System.Security.Cryptography;
-
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  public abstract class PkzipClassic : SymmetricAlgorithm
-  {
-    public static byte[] GenerateKeys(byte[] seed)
-    {
-      if (seed == null)
-        throw new ArgumentNullException(nameof (seed));
-      if (seed.Length == 0)
-        throw new ArgumentException("Length is zero", nameof (seed));
-      uint[] numArray = new uint[3]
-      {
-        305419896U,
-        591751049U,
-        878082192U
-      };
-      for (int index = 0; index < seed.Length; ++index)
-      {
-        numArray[0] = Crc32.ComputeCrc32(numArray[0], seed[index]);
-        numArray[1] = numArray[1] + (uint) (byte) numArray[0];
-        numArray[1] = (uint) ((int) numArray[1] * 134775813 + 1);
-        numArray[2] = Crc32.ComputeCrc32(numArray[2], (byte) (numArray[1] >> 24));
-      }
-      return new byte[12]
-      {
-        (byte) (numArray[0] & (uint) byte.MaxValue),
-        (byte) (numArray[0] >> 8 & (uint) byte.MaxValue),
-        (byte) (numArray[0] >> 16 & (uint) byte.MaxValue),
-        (byte) (numArray[0] >> 24 & (uint) byte.MaxValue),
-        (byte) (numArray[1] & (uint) byte.MaxValue),
-        (byte) (numArray[1] >> 8 & (uint) byte.MaxValue),
-        (byte) (numArray[1] >> 16 & (uint) byte.MaxValue),
-        (byte) (numArray[1] >> 24 & (uint) byte.MaxValue),
-        (byte) (numArray[2] & (uint) byte.MaxValue),
-        (byte) (numArray[2] >> 8 & (uint) byte.MaxValue),
-        (byte) (numArray[2] >> 16 & (uint) byte.MaxValue),
-        (byte) (numArray[2] >> 24 & (uint) byte.MaxValue)
-      };
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicCryptoBase.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicCryptoBase.cs
deleted file mode 100644
index a5b7b97..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicCryptoBase.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  internal class PkzipClassicCryptoBase
-  {
-    private uint[] keys;
-
-    protected byte TransformByte()
-    {
-      uint num = (uint) ((int) this.keys[2] & (int) ushort.MaxValue | 2);
-      return (byte) (num * (num ^ 1U) >> 8);
-    }
-
-    protected void SetKeys(byte[] keyData)
-    {
-      if (keyData == null)
-        throw new ArgumentNullException(nameof (keyData));
-      if (keyData.Length != 12)
-        throw new InvalidOperationException("Key length is not valid");
-      this.keys = new uint[3];
-      this.keys[0] = (uint) ((int) keyData[3] << 24 | (int) keyData[2] << 16 | (int) keyData[1] << 8) | (uint) keyData[0];
-      this.keys[1] = (uint) ((int) keyData[7] << 24 | (int) keyData[6] << 16 | (int) keyData[5] << 8) | (uint) keyData[4];
-      this.keys[2] = (uint) ((int) keyData[11] << 24 | (int) keyData[10] << 16 | (int) keyData[9] << 8) | (uint) keyData[8];
-    }
-
-    protected void UpdateKeys(byte ch)
-    {
-      this.keys[0] = Crc32.ComputeCrc32(this.keys[0], ch);
-      this.keys[1] = this.keys[1] + (uint) (byte) this.keys[0];
-      this.keys[1] = (uint) ((int) this.keys[1] * 134775813 + 1);
-      this.keys[2] = Crc32.ComputeCrc32(this.keys[2], (byte) (this.keys[1] >> 24));
-    }
-
-    protected void Reset()
-    {
-      this.keys[0] = 0U;
-      this.keys[1] = 0U;
-      this.keys[2] = 0U;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicDecryptCryptoTransform.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicDecryptCryptoTransform.cs
deleted file mode 100644
index ce31fec..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicDecryptCryptoTransform.cs
+++ /dev/null
@@ -1,47 +0,0 @@
-
-using System;
-using System.Security.Cryptography;
-
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  internal class PkzipClassicDecryptCryptoTransform : 
-    PkzipClassicCryptoBase,
-    ICryptoTransform,
-    IDisposable
-  {
-    internal PkzipClassicDecryptCryptoTransform(byte[] keyBlock) => this.SetKeys(keyBlock);
-
-    public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
-    {
-      byte[] outputBuffer = new byte[inputCount];
-      this.TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, 0);
-      return outputBuffer;
-    }
-
-    public int TransformBlock(
-      byte[] inputBuffer,
-      int inputOffset,
-      int inputCount,
-      byte[] outputBuffer,
-      int outputOffset)
-    {
-      for (int index = inputOffset; index < inputOffset + inputCount; ++index)
-      {
-        byte ch = (byte) ((uint) inputBuffer[index] ^ (uint) this.TransformByte());
-        outputBuffer[outputOffset++] = ch;
-        this.UpdateKeys(ch);
-      }
-      return inputCount;
-    }
-
-    public bool CanReuseTransform => true;
-
-    public int InputBlockSize => 1;
-
-    public int OutputBlockSize => 1;
-
-    public bool CanTransformMultipleBlocks => true;
-
-    public void Dispose() => this.Reset();
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicEncryptCryptoTransform.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicEncryptCryptoTransform.cs
deleted file mode 100644
index 53c1df3..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicEncryptCryptoTransform.cs
+++ /dev/null
@@ -1,47 +0,0 @@
-
-using System;
-using System.Security.Cryptography;
-
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  internal class PkzipClassicEncryptCryptoTransform : 
-    PkzipClassicCryptoBase,
-    ICryptoTransform,
-    IDisposable
-  {
-    internal PkzipClassicEncryptCryptoTransform(byte[] keyBlock) => this.SetKeys(keyBlock);
-
-    public byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount)
-    {
-      byte[] outputBuffer = new byte[inputCount];
-      this.TransformBlock(inputBuffer, inputOffset, inputCount, outputBuffer, 0);
-      return outputBuffer;
-    }
-
-    public int TransformBlock(
-      byte[] inputBuffer,
-      int inputOffset,
-      int inputCount,
-      byte[] outputBuffer,
-      int outputOffset)
-    {
-      for (int index = inputOffset; index < inputOffset + inputCount; ++index)
-      {
-        byte ch = inputBuffer[index];
-        outputBuffer[outputOffset++] = (byte) ((uint) inputBuffer[index] ^ (uint) this.TransformByte());
-        this.UpdateKeys(ch);
-      }
-      return inputCount;
-    }
-
-    public bool CanReuseTransform => true;
-
-    public int InputBlockSize => 1;
-
-    public int OutputBlockSize => 1;
-
-    public bool CanTransformMultipleBlocks => true;
-
-    public void Dispose() => this.Reset();
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicManaged.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicManaged.cs
deleted file mode 100644
index 804c1d4..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Encryption/PkzipClassicManaged.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-
-using System;
-using System.Security.Cryptography;
-
-namespace ICSharpCode.SharpZipLib.Encryption
-{
-  public sealed class PkzipClassicManaged : PkzipClassic
-  {
-    private byte[] key_;
-
-    public override int BlockSize
-    {
-      get => 8;
-      set
-      {
-        if (value != 8)
-          throw new CryptographicException("Block size is invalid");
-      }
-    }
-
-    public override KeySizes[] LegalKeySizes
-    {
-      get => new KeySizes[1]{ new KeySizes(96, 96, 0) };
-    }
-
-    public override void GenerateIV()
-    {
-    }
-
-    public override KeySizes[] LegalBlockSizes
-    {
-      get => new KeySizes[1]{ new KeySizes(8, 8, 0) };
-    }
-
-    public override byte[] Key
-    {
-      get
-      {
-        if (this.key_ == null)
-          this.GenerateKey();
-        return (byte[]) this.key_.Clone();
-      }
-      set
-      {
-        if (value == null)
-          throw new ArgumentNullException(nameof (value));
-        this.key_ = value.Length == 12 ? (byte[]) value.Clone() : throw new CryptographicException("Key size is illegal");
-      }
-    }
-
-    public override void GenerateKey()
-    {
-      this.key_ = new byte[12];
-      new Random().NextBytes(this.key_);
-    }
-
-    public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
-    {
-      this.key_ = rgbKey;
-      return (ICryptoTransform) new PkzipClassicEncryptCryptoTransform(this.Key);
-    }
-
-    public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
-    {
-      this.key_ = rgbKey;
-      return (ICryptoTransform) new PkzipClassicDecryptCryptoTransform(this.Key);
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipConstants.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipConstants.cs
deleted file mode 100644
index d97f700..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipConstants.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.GZip
-{
-  public sealed class GZipConstants
-  {
-    public const int GZIP_MAGIC = 8075;
-    public const int FTEXT = 1;
-    public const int FHCRC = 2;
-    public const int FEXTRA = 4;
-    public const int FNAME = 8;
-    public const int FCOMMENT = 16;
-
-    private GZipConstants()
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipException.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipException.cs
deleted file mode 100644
index dad78d3..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-
-using System;
-using System.Runtime.Serialization;
-
-namespace ICSharpCode.SharpZipLib.GZip
-{
-  [Serializable]
-  public class GZipException : SharpZipBaseException
-  {
-    protected GZipException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public GZipException()
-    {
-    }
-
-    public GZipException(string message)
-      : base(message)
-    {
-    }
-
-    public GZipException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipInputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipInputStream.cs
deleted file mode 100644
index 5294113..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipInputStream.cs
+++ /dev/null
@@ -1,147 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.GZip
-{
-  public class GZipInputStream(Stream baseInputStream, int size) : InflaterInputStream(baseInputStream, new Inflater(true), size)
-  {
-    protected Crc32 crc = new Crc32();
-    protected bool eos;
-    private bool readGZIPHeader;
-
-    public GZipInputStream(Stream baseInputStream)
-      : this(baseInputStream, 4096)
-    {
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (!this.readGZIPHeader)
-        this.ReadHeader();
-      if (this.eos)
-        return 0;
-      int count1 = base.Read(buffer, offset, count);
-      if (count1 > 0)
-        this.crc.Update(buffer, offset, count1);
-      if (this.inf.IsFinished)
-        this.ReadFooter();
-      return count1;
-    }
-
-    private void ReadHeader()
-    {
-      Crc32 crc32 = new Crc32();
-      int num1 = this.baseInputStream.ReadByte();
-      if (num1 < 0)
-        throw new EndOfStreamException("EOS reading GZIP header");
-      crc32.Update(num1);
-      if (num1 != 31)
-        throw new GZipException("Error GZIP header, first magic byte doesn't match");
-      int num2 = this.baseInputStream.ReadByte();
-      if (num2 < 0)
-        throw new EndOfStreamException("EOS reading GZIP header");
-      if (num2 != 139)
-        throw new GZipException("Error GZIP header,  second magic byte doesn't match");
-      crc32.Update(num2);
-      int num3 = this.baseInputStream.ReadByte();
-      if (num3 < 0)
-        throw new EndOfStreamException("EOS reading GZIP header");
-      if (num3 != 8)
-        throw new GZipException("Error GZIP header, data not deflate format");
-      crc32.Update(num3);
-      int num4 = this.baseInputStream.ReadByte();
-      if (num4 < 0)
-        throw new EndOfStreamException("EOS reading GZIP header");
-      crc32.Update(num4);
-      if ((num4 & 208) != 0)
-        throw new GZipException("Reserved flag bits in GZIP header != 0");
-      for (int index = 0; index < 6; ++index)
-      {
-        int num5 = this.baseInputStream.ReadByte();
-        if (num5 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        crc32.Update(num5);
-      }
-      if ((num4 & 4) != 0)
-      {
-        for (int index = 0; index < 2; ++index)
-        {
-          int num6 = this.baseInputStream.ReadByte();
-          if (num6 < 0)
-            throw new EndOfStreamException("EOS reading GZIP header");
-          crc32.Update(num6);
-        }
-        int num7 = this.baseInputStream.ReadByte() >= 0 && this.baseInputStream.ReadByte() >= 0 ? this.baseInputStream.ReadByte() : throw new EndOfStreamException("EOS reading GZIP header");
-        int num8 = this.baseInputStream.ReadByte();
-        if (num7 < 0 || num8 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        crc32.Update(num7);
-        crc32.Update(num8);
-        int num9 = num7 << 8 | num8;
-        for (int index = 0; index < num9; ++index)
-        {
-          int num10 = this.baseInputStream.ReadByte();
-          if (num10 < 0)
-            throw new EndOfStreamException("EOS reading GZIP header");
-          crc32.Update(num10);
-        }
-      }
-      if ((num4 & 8) != 0)
-      {
-        int num11;
-        while ((num11 = this.baseInputStream.ReadByte()) > 0)
-          crc32.Update(num11);
-        if (num11 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        crc32.Update(num11);
-      }
-      if ((num4 & 16) != 0)
-      {
-        int num12;
-        while ((num12 = this.baseInputStream.ReadByte()) > 0)
-          crc32.Update(num12);
-        if (num12 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        crc32.Update(num12);
-      }
-      if ((num4 & 2) != 0)
-      {
-        int num13 = this.baseInputStream.ReadByte();
-        if (num13 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        int num14 = this.baseInputStream.ReadByte();
-        if (num14 < 0)
-          throw new EndOfStreamException("EOS reading GZIP header");
-        if ((num13 << 8 | num14) != ((int) crc32.Value & (int) ushort.MaxValue))
-          throw new GZipException("Header CRC value mismatch");
-      }
-      this.readGZIPHeader = true;
-    }
-
-    private void ReadFooter()
-    {
-      byte[] numArray = new byte[8];
-      int length = this.inf.RemainingInput;
-      if (length > 8)
-        length = 8;
-      Array.Copy((Array) this.inputBuffer.RawData, this.inputBuffer.RawLength - this.inf.RemainingInput, (Array) numArray, 0, length);
-      int num1;
-      for (int count = 8 - length; count > 0; count -= num1)
-      {
-        num1 = this.baseInputStream.Read(numArray, 8 - count, count);
-        if (num1 <= 0)
-          throw new EndOfStreamException("EOS reading GZIP footer");
-      }
-      int num2 = (int) numArray[0] & (int) byte.MaxValue | ((int) numArray[1] & (int) byte.MaxValue) << 8 | ((int) numArray[2] & (int) byte.MaxValue) << 16 | (int) numArray[3] << 24;
-      if (num2 != (int) this.crc.Value)
-        throw new GZipException("GZIP crc sum mismatch, theirs \"" + (object) num2 + "\" and ours \"" + (object) (int) this.crc.Value);
-      if ((long) ((int) numArray[4] & (int) byte.MaxValue | ((int) numArray[5] & (int) byte.MaxValue) << 8 | ((int) numArray[6] & (int) byte.MaxValue) << 16 | (int) numArray[7] << 24) != this.inf.TotalOut)
-        throw new GZipException("Number of bytes mismatch in footer");
-      this.eos = true;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipOutputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipOutputStream.cs
deleted file mode 100644
index 52d2f69..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/GZip/GZipOutputStream.cs
+++ /dev/null
@@ -1,88 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.GZip
-{
-  public class GZipOutputStream(Stream baseOutputStream, int size) : DeflaterOutputStream(baseOutputStream, new Deflater(-1, true), size)
-  {
-    protected Crc32 crc = new Crc32();
-    private bool headerWritten_;
-
-    public GZipOutputStream(Stream baseOutputStream)
-      : this(baseOutputStream, 4096)
-    {
-    }
-
-    public void SetLevel(int level)
-    {
-      if (level < 1)
-        throw new ArgumentOutOfRangeException(nameof (level));
-      this.def.SetLevel(level);
-    }
-
-    public int GetLevel() => this.def.GetLevel();
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      if (!this.headerWritten_)
-        this.WriteHeader();
-      this.crc.Update(buffer, offset, count);
-      base.Write(buffer, offset, count);
-    }
-
-    public override void Close()
-    {
-      this.Finish();
-      if (!this.IsStreamOwner)
-        return;
-      this.baseOutputStream.Close();
-    }
-
-    public override void Finish()
-    {
-      if (!this.headerWritten_)
-        this.WriteHeader();
-      base.Finish();
-      int totalIn = this.def.TotalIn;
-      int num = (int) (this.crc.Value & (long) uint.MaxValue);
-      byte[] buffer = new byte[8]
-      {
-        (byte) num,
-        (byte) (num >> 8),
-        (byte) (num >> 16),
-        (byte) (num >> 24),
-        (byte) totalIn,
-        (byte) (totalIn >> 8),
-        (byte) (totalIn >> 16),
-        (byte) (totalIn >> 24)
-      };
-      this.baseOutputStream.Write(buffer, 0, buffer.Length);
-    }
-
-    private void WriteHeader()
-    {
-      if (this.headerWritten_)
-        return;
-      this.headerWritten_ = true;
-      int num = (int) ((DateTime.Now.Ticks - new DateTime(1970, 1, 1).Ticks) / 10000000L);
-      byte[] buffer = new byte[10]
-      {
-        (byte) 31,
-        (byte) 139,
-        (byte) 8,
-        (byte) 0,
-        (byte) num,
-        (byte) (num >> 8),
-        (byte) (num >> 16),
-        (byte) (num >> 24),
-        (byte) 0,
-        byte.MaxValue
-      };
-      this.baseOutputStream.Write(buffer, 0, buffer.Length);
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/SharpZipBaseException.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/SharpZipBaseException.cs
deleted file mode 100644
index 8baecbd..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/SharpZipBaseException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-
-using System;
-using System.Runtime.Serialization;
-
-namespace ICSharpCode.SharpZipLib
-{
-  [Serializable]
-  public class SharpZipBaseException : ApplicationException
-  {
-    protected SharpZipBaseException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public SharpZipBaseException()
-    {
-    }
-
-    public SharpZipBaseException(string message)
-      : base(message)
-    {
-    }
-
-    public SharpZipBaseException(string message, Exception innerException)
-      : base(message, innerException)
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/InvalidHeaderException.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/InvalidHeaderException.cs
deleted file mode 100644
index 1637576..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/InvalidHeaderException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-
-using System;
-using System.Runtime.Serialization;
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  [Serializable]
-  public class InvalidHeaderException : TarException
-  {
-    protected InvalidHeaderException(SerializationInfo information, StreamingContext context)
-      : base(information, context)
-    {
-    }
-
-    public InvalidHeaderException()
-    {
-    }
-
-    public InvalidHeaderException(string message)
-      : base(message)
-    {
-    }
-
-    public InvalidHeaderException(string message, Exception exception)
-      : base(message, exception)
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/ProgressMessageHandler.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/ProgressMessageHandler.cs
deleted file mode 100644
index 7eb0cb1..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/ProgressMessageHandler.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public delegate void ProgressMessageHandler(TarArchive archive, TarEntry entry, string message);
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarArchive.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarArchive.cs
deleted file mode 100644
index b64e4f8..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarArchive.cs
+++ /dev/null
@@ -1,467 +0,0 @@
-
-using System;
-using System.IO;
-using System.Text;
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarArchive : IDisposable
-  {
-    private bool keepOldFiles;
-    private bool asciiTranslate;
-    private int userId;
-    private string userName = string.Empty;
-    private int groupId;
-    private string groupName = string.Empty;
-    private string rootPath;
-    private string pathPrefix;
-    private bool applyUserInfoOverrides;
-    private TarInputStream tarIn;
-    private TarOutputStream tarOut;
-    private bool isDisposed;
-
-    public event ProgressMessageHandler ProgressMessageEvent;
-
-    protected virtual void OnProgressMessageEvent(TarEntry entry, string message)
-    {
-      if (this.ProgressMessageEvent == null)
-        return;
-      this.ProgressMessageEvent(this, entry, message);
-    }
-
-    protected TarArchive()
-    {
-    }
-
-    protected TarArchive(TarInputStream stream)
-    {
-      this.tarIn = stream != null ? stream : throw new ArgumentNullException(nameof (stream));
-    }
-
-    protected TarArchive(TarOutputStream stream)
-    {
-      this.tarOut = stream != null ? stream : throw new ArgumentNullException(nameof (stream));
-    }
-
-    public static TarArchive CreateInputTarArchive(Stream inputStream)
-    {
-      return inputStream != null ? TarArchive.CreateInputTarArchive(inputStream, 20) : throw new ArgumentNullException(nameof (inputStream));
-    }
-
-    public static TarArchive CreateInputTarArchive(Stream inputStream, int blockFactor)
-    {
-      return inputStream != null ? new TarArchive(new TarInputStream(inputStream, blockFactor)) : throw new ArgumentNullException(nameof (inputStream));
-    }
-
-    public static TarArchive CreateOutputTarArchive(Stream outputStream)
-    {
-      return outputStream != null ? TarArchive.CreateOutputTarArchive(outputStream, 20) : throw new ArgumentNullException(nameof (outputStream));
-    }
-
-    public static TarArchive CreateOutputTarArchive(Stream outputStream, int blockFactor)
-    {
-      return outputStream != null ? new TarArchive(new TarOutputStream(outputStream, blockFactor)) : throw new ArgumentNullException(nameof (outputStream));
-    }
-
-    public void SetKeepOldFiles(bool keepOldFiles)
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      this.keepOldFiles = keepOldFiles;
-    }
-
-    public bool AsciiTranslate
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.asciiTranslate;
-      }
-      set
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        this.asciiTranslate = value;
-      }
-    }
-
-    [Obsolete("Use the AsciiTranslate property")]
-    public void SetAsciiTranslation(bool asciiTranslate)
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      this.asciiTranslate = asciiTranslate;
-    }
-
-    public string PathPrefix
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.pathPrefix;
-      }
-      set
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        this.pathPrefix = value;
-      }
-    }
-
-    public string RootPath
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.rootPath;
-      }
-      set
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        this.rootPath = value;
-      }
-    }
-
-    public void SetUserInfo(int userId, string userName, int groupId, string groupName)
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      this.userId = userId;
-      this.userName = userName;
-      this.groupId = groupId;
-      this.groupName = groupName;
-      this.applyUserInfoOverrides = true;
-    }
-
-    public bool ApplyUserInfoOverrides
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.applyUserInfoOverrides;
-      }
-      set
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        this.applyUserInfoOverrides = value;
-      }
-    }
-
-    public int UserId
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.userId;
-      }
-    }
-
-    public string UserName
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.userName;
-      }
-    }
-
-    public int GroupId
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.groupId;
-      }
-    }
-
-    public string GroupName
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        return this.groupName;
-      }
-    }
-
-    public int RecordSize
-    {
-      get
-      {
-        if (this.isDisposed)
-          throw new ObjectDisposedException(nameof (TarArchive));
-        if (this.tarIn != null)
-          return this.tarIn.RecordSize;
-        return this.tarOut != null ? this.tarOut.RecordSize : 10240;
-      }
-    }
-
-    [Obsolete("Use Close instead")]
-    public void CloseArchive() => this.Close();
-
-    public void ListContents()
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      while (true)
-      {
-        TarEntry nextEntry = this.tarIn.GetNextEntry();
-        if (nextEntry != null)
-          this.OnProgressMessageEvent(nextEntry, (string) null);
-        else
-          break;
-      }
-    }
-
-    public void ExtractContents(string destinationDirectory)
-    {
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      while (true)
-      {
-        TarEntry nextEntry = this.tarIn.GetNextEntry();
-        if (nextEntry != null)
-          this.ExtractEntry(destinationDirectory, nextEntry);
-        else
-          break;
-      }
-    }
-
-    private void ExtractEntry(string destDir, TarEntry entry)
-    {
-      this.OnProgressMessageEvent(entry, (string) null);
-      string path = entry.Name;
-      if (Path.IsPathRooted(path))
-        path = path.Substring(Path.GetPathRoot(path).Length);
-      string path2 = path.Replace('/', Path.DirectorySeparatorChar);
-      string str1 = Path.Combine(destDir, path2);
-      if (entry.IsDirectory)
-      {
-        TarArchive.EnsureDirectoryExists(str1);
-      }
-      else
-      {
-        TarArchive.EnsureDirectoryExists(Path.GetDirectoryName(str1));
-        bool flag1 = true;
-        FileInfo fileInfo = new FileInfo(str1);
-        if (fileInfo.Exists)
-        {
-          if (this.keepOldFiles)
-          {
-            this.OnProgressMessageEvent(entry, "Destination file already exists");
-            flag1 = false;
-          }
-          else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != (FileAttributes) 0)
-          {
-            this.OnProgressMessageEvent(entry, "Destination file already exists, and is read-only");
-            flag1 = false;
-          }
-        }
-        if (!flag1)
-          return;
-        bool flag2 = false;
-        Stream stream = (Stream) File.Create(str1);
-        if (this.asciiTranslate)
-          flag2 = !TarArchive.IsBinary(str1);
-        StreamWriter streamWriter = (StreamWriter) null;
-        if (flag2)
-          streamWriter = new StreamWriter(stream);
-        byte[] numArray = new byte[32768];
-label_15:
-        int count;
-        while (true)
-        {
-          count = this.tarIn.Read(numArray, 0, numArray.Length);
-          if (count > 0)
-          {
-            if (!flag2)
-              stream.Write(numArray, 0, count);
-            else
-              break;
-          }
-          else
-            goto label_24;
-        }
-        int index1 = 0;
-        for (int index2 = 0; index2 < count; ++index2)
-        {
-          if (numArray[index2] == (byte) 10)
-          {
-            string str2 = Encoding.ASCII.GetString(numArray, index1, index2 - index1);
-            streamWriter.WriteLine(str2);
-            index1 = index2 + 1;
-          }
-        }
-        goto label_15;
-label_24:
-        if (flag2)
-          streamWriter.Close();
-        else
-          stream.Close();
-      }
-    }
-
-    public void WriteEntry(TarEntry sourceEntry, bool recurse)
-    {
-      if (sourceEntry == null)
-        throw new ArgumentNullException(nameof (sourceEntry));
-      if (this.isDisposed)
-        throw new ObjectDisposedException(nameof (TarArchive));
-      try
-      {
-        if (recurse)
-          TarHeader.SetValueDefaults(sourceEntry.UserId, sourceEntry.UserName, sourceEntry.GroupId, sourceEntry.GroupName);
-        this.InternalWriteEntry(sourceEntry, recurse);
-      }
-      finally
-      {
-        if (recurse)
-          TarHeader.RestoreSetValues();
-      }
-    }
-
-    private void InternalWriteEntry(TarEntry sourceEntry, bool recurse)
-    {
-      string str1 = (string) null;
-      string str2 = sourceEntry.File;
-      TarEntry entry = (TarEntry) sourceEntry.Clone();
-      if (this.applyUserInfoOverrides)
-      {
-        entry.GroupId = this.groupId;
-        entry.GroupName = this.groupName;
-        entry.UserId = this.userId;
-        entry.UserName = this.userName;
-      }
-      this.OnProgressMessageEvent(entry, (string) null);
-      if (this.asciiTranslate && !entry.IsDirectory && !TarArchive.IsBinary(str2))
-      {
-        str1 = Path.GetTempFileName();
-        using (StreamReader streamReader = File.OpenText(str2))
-        {
-          using (Stream stream = (Stream) File.Create(str1))
-          {
-            while (true)
-            {
-              string s = streamReader.ReadLine();
-              if (s != null)
-              {
-                byte[] bytes = Encoding.ASCII.GetBytes(s);
-                stream.Write(bytes, 0, bytes.Length);
-                stream.WriteByte((byte) 10);
-              }
-              else
-                break;
-            }
-            stream.Flush();
-          }
-        }
-        entry.Size = new FileInfo(str1).Length;
-        str2 = str1;
-      }
-      string str3 = (string) null;
-      if (this.rootPath != null && entry.Name.StartsWith(this.rootPath))
-        str3 = entry.Name.Substring(this.rootPath.Length + 1);
-      if (this.pathPrefix != null)
-        str3 = str3 == null ? this.pathPrefix + "/" + entry.Name : this.pathPrefix + "/" + str3;
-      if (str3 != null)
-        entry.Name = str3;
-      this.tarOut.PutNextEntry(entry);
-      if (entry.IsDirectory)
-      {
-        if (!recurse)
-          return;
-        foreach (TarEntry directoryEntry in entry.GetDirectoryEntries())
-          this.InternalWriteEntry(directoryEntry, recurse);
-      }
-      else
-      {
-        using (Stream stream = (Stream) File.OpenRead(str2))
-        {
-          int num = 0;
-          byte[] buffer = new byte[32768];
-          while (true)
-          {
-            int count = stream.Read(buffer, 0, buffer.Length);
-            if (count > 0)
-            {
-              this.tarOut.Write(buffer, 0, count);
-              num += count;
-            }
-            else
-              break;
-          }
-        }
-        if (str1 != null && str1.Length > 0)
-          File.Delete(str1);
-        this.tarOut.CloseEntry();
-      }
-    }
-
-    protected virtual void Dispose(bool disposing)
-    {
-      if (this.isDisposed)
-        return;
-      this.isDisposed = true;
-      if (!disposing)
-        return;
-      if (this.tarOut != null)
-      {
-        this.tarOut.Flush();
-        this.tarOut.Close();
-      }
-      if (this.tarIn == null)
-        return;
-      this.tarIn.Close();
-    }
-
-    public virtual void Close()
-    {
-      this.Dispose(true);
-      GC.SuppressFinalize((object) this);
-    }
-
-    ~TarArchive() => this.Dispose(false);
-
-    void IDisposable.Dispose() => this.Close();
-
-    private static void EnsureDirectoryExists(string directoryName)
-    {
-      if (Directory.Exists(directoryName))
-        return;
-      try
-      {
-        Directory.CreateDirectory(directoryName);
-      }
-      catch (Exception ex)
-      {
-        throw new TarException("Exception creating directory '" + directoryName + "', " + ex.Message, ex);
-      }
-    }
-
-    private static bool IsBinary(string filename)
-    {
-      using (FileStream fileStream = File.OpenRead(filename))
-      {
-        int count = Math.Min(4096, (int) fileStream.Length);
-        byte[] buffer = new byte[count];
-        int num1 = fileStream.Read(buffer, 0, count);
-        for (int index = 0; index < num1; ++index)
-        {
-          byte num2 = buffer[index];
-          if (num2 < (byte) 8 || num2 > (byte) 13 && num2 < (byte) 32 || num2 == byte.MaxValue)
-            return true;
-        }
-      }
-      return false;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarBuffer.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarBuffer.cs
deleted file mode 100644
index 405dec4..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarBuffer.cs
+++ /dev/null
@@ -1,221 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarBuffer
-  {
-    public const int BlockSize = 512;
-    public const int DefaultBlockFactor = 20;
-    public const int DefaultRecordSize = 10240;
-    private Stream inputStream;
-    private Stream outputStream;
-    private byte[] recordBuffer;
-    private int currentBlockIndex;
-    private int currentRecordIndex;
-    private int recordSize = 10240;
-    private int blockFactor = 20;
-
-    public int RecordSize => this.recordSize;
-
-    [Obsolete("Use RecordSize property instead")]
-    public int GetRecordSize() => this.recordSize;
-
-    public int BlockFactor => this.blockFactor;
-
-    [Obsolete("Use BlockFactor property instead")]
-    public int GetBlockFactor() => this.blockFactor;
-
-    protected TarBuffer()
-    {
-    }
-
-    public static TarBuffer CreateInputTarBuffer(Stream inputStream)
-    {
-      return inputStream != null ? TarBuffer.CreateInputTarBuffer(inputStream, 20) : throw new ArgumentNullException(nameof (inputStream));
-    }
-
-    public static TarBuffer CreateInputTarBuffer(Stream inputStream, int blockFactor)
-    {
-      if (inputStream == null)
-        throw new ArgumentNullException(nameof (inputStream));
-      if (blockFactor <= 0)
-        throw new ArgumentOutOfRangeException(nameof (blockFactor), "Factor cannot be negative");
-      TarBuffer inputTarBuffer = new TarBuffer();
-      inputTarBuffer.inputStream = inputStream;
-      inputTarBuffer.outputStream = (Stream) null;
-      inputTarBuffer.Initialize(blockFactor);
-      return inputTarBuffer;
-    }
-
-    public static TarBuffer CreateOutputTarBuffer(Stream outputStream)
-    {
-      return outputStream != null ? TarBuffer.CreateOutputTarBuffer(outputStream, 20) : throw new ArgumentNullException(nameof (outputStream));
-    }
-
-    public static TarBuffer CreateOutputTarBuffer(Stream outputStream, int blockFactor)
-    {
-      if (outputStream == null)
-        throw new ArgumentNullException(nameof (outputStream));
-      if (blockFactor <= 0)
-        throw new ArgumentOutOfRangeException(nameof (blockFactor), "Factor cannot be negative");
-      TarBuffer outputTarBuffer = new TarBuffer();
-      outputTarBuffer.inputStream = (Stream) null;
-      outputTarBuffer.outputStream = outputStream;
-      outputTarBuffer.Initialize(blockFactor);
-      return outputTarBuffer;
-    }
-
-    private void Initialize(int blockFactor)
-    {
-      this.blockFactor = blockFactor;
-      this.recordSize = blockFactor * 512;
-      this.recordBuffer = new byte[this.RecordSize];
-      if (this.inputStream != null)
-      {
-        this.currentRecordIndex = -1;
-        this.currentBlockIndex = this.BlockFactor;
-      }
-      else
-      {
-        this.currentRecordIndex = 0;
-        this.currentBlockIndex = 0;
-      }
-    }
-
-    public bool IsEOFBlock(byte[] block)
-    {
-      if (block == null)
-        throw new ArgumentNullException(nameof (block));
-      if (block.Length != 512)
-        throw new ArgumentException("block length is invalid");
-      for (int index = 0; index < 512; ++index)
-      {
-        if (block[index] != (byte) 0)
-          return false;
-      }
-      return true;
-    }
-
-    public void SkipBlock()
-    {
-      if (this.inputStream == null)
-        throw new TarException("no input stream defined");
-      if (this.currentBlockIndex >= this.BlockFactor && !this.ReadRecord())
-        throw new TarException("Failed to read a record");
-      ++this.currentBlockIndex;
-    }
-
-    public byte[] ReadBlock()
-    {
-      if (this.inputStream == null)
-        throw new TarException("TarBuffer.ReadBlock - no input stream defined");
-      if (this.currentBlockIndex >= this.BlockFactor && !this.ReadRecord())
-        throw new TarException("Failed to read a record");
-      byte[] destinationArray = new byte[512];
-      Array.Copy((Array) this.recordBuffer, this.currentBlockIndex * 512, (Array) destinationArray, 0, 512);
-      ++this.currentBlockIndex;
-      return destinationArray;
-    }
-
-    private bool ReadRecord()
-    {
-      if (this.inputStream == null)
-        throw new TarException("no input stream stream defined");
-      this.currentBlockIndex = 0;
-      int offset = 0;
-      long num;
-      for (int recordSize = this.RecordSize; recordSize > 0; recordSize -= (int) num)
-      {
-        num = (long) this.inputStream.Read(this.recordBuffer, offset, recordSize);
-        if (num > 0L)
-          offset += (int) num;
-        else
-          break;
-      }
-      ++this.currentRecordIndex;
-      return true;
-    }
-
-    public int CurrentBlock => this.currentBlockIndex;
-
-    [Obsolete("Use CurrentBlock property instead")]
-    public int GetCurrentBlockNum() => this.currentBlockIndex;
-
-    public int CurrentRecord => this.currentRecordIndex;
-
-    [Obsolete("Use CurrentRecord property instead")]
-    public int GetCurrentRecordNum() => this.currentRecordIndex;
-
-    public void WriteBlock(byte[] block)
-    {
-      if (block == null)
-        throw new ArgumentNullException(nameof (block));
-      if (this.outputStream == null)
-        throw new TarException("TarBuffer.WriteBlock - no output stream defined");
-      if (block.Length != 512)
-        throw new TarException(string.Format("TarBuffer.WriteBlock - block to write has length '{0}' which is not the block size of '{1}'", (object) block.Length, (object) 512));
-      if (this.currentBlockIndex >= this.BlockFactor)
-        this.WriteRecord();
-      Array.Copy((Array) block, 0, (Array) this.recordBuffer, this.currentBlockIndex * 512, 512);
-      ++this.currentBlockIndex;
-    }
-
-    public void WriteBlock(byte[] buffer, int offset)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (this.outputStream == null)
-        throw new TarException("TarBuffer.WriteBlock - no output stream stream defined");
-      if (offset < 0 || offset >= buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      if (offset + 512 > buffer.Length)
-        throw new TarException(string.Format("TarBuffer.WriteBlock - record has length '{0}' with offset '{1}' which is less than the record size of '{2}'", (object) buffer.Length, (object) offset, (object) this.recordSize));
-      if (this.currentBlockIndex >= this.BlockFactor)
-        this.WriteRecord();
-      Array.Copy((Array) buffer, offset, (Array) this.recordBuffer, this.currentBlockIndex * 512, 512);
-      ++this.currentBlockIndex;
-    }
-
-    private void WriteRecord()
-    {
-      if (this.outputStream == null)
-        throw new TarException("TarBuffer.WriteRecord no output stream defined");
-      this.outputStream.Write(this.recordBuffer, 0, this.RecordSize);
-      this.outputStream.Flush();
-      this.currentBlockIndex = 0;
-      ++this.currentRecordIndex;
-    }
-
-    private void Flush()
-    {
-      if (this.outputStream == null)
-        throw new TarException("TarBuffer.Flush no output stream defined");
-      if (this.currentBlockIndex > 0)
-      {
-        int index = this.currentBlockIndex * 512;
-        Array.Clear((Array) this.recordBuffer, index, this.RecordSize - index);
-        this.WriteRecord();
-      }
-      this.outputStream.Flush();
-    }
-
-    public void Close()
-    {
-      if (this.outputStream != null)
-      {
-        this.Flush();
-        this.outputStream.Close();
-        this.outputStream = (Stream) null;
-      }
-      else
-      {
-        if (this.inputStream == null)
-          return;
-        this.inputStream.Close();
-        this.inputStream = (Stream) null;
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarEntry.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarEntry.cs
deleted file mode 100644
index ded914b..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarEntry.cs
+++ /dev/null
@@ -1,199 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarEntry : ICloneable
-  {
-    private string file;
-    private TarHeader header;
-
-    private TarEntry() => this.header = new TarHeader();
-
-    public TarEntry(byte[] headerBuffer)
-    {
-      this.header = new TarHeader();
-      this.header.ParseBuffer(headerBuffer);
-    }
-
-    public TarEntry(TarHeader header)
-    {
-      this.header = header != null ? (TarHeader) header.Clone() : throw new ArgumentNullException(nameof (header));
-    }
-
-    public object Clone()
-    {
-      return (object) new TarEntry()
-      {
-        file = this.file,
-        header = (TarHeader) this.header.Clone(),
-        Name = this.Name
-      };
-    }
-
-    public static TarEntry CreateTarEntry(string name)
-    {
-      TarEntry tarEntry = new TarEntry();
-      TarEntry.NameTarHeader(tarEntry.header, name);
-      return tarEntry;
-    }
-
-    public static TarEntry CreateEntryFromFile(string fileName)
-    {
-      TarEntry entryFromFile = new TarEntry();
-      entryFromFile.GetFileTarHeader(entryFromFile.header, fileName);
-      return entryFromFile;
-    }
-
-    public override bool Equals(object obj)
-    {
-      return obj is TarEntry tarEntry && this.Name.Equals(tarEntry.Name);
-    }
-
-    public override int GetHashCode() => this.Name.GetHashCode();
-
-    public bool IsDescendent(TarEntry toTest)
-    {
-      return toTest != null ? toTest.Name.StartsWith(this.Name) : throw new ArgumentNullException(nameof (toTest));
-    }
-
-    public TarHeader TarHeader => this.header;
-
-    public string Name
-    {
-      get => this.header.Name;
-      set => this.header.Name = value;
-    }
-
-    public int UserId
-    {
-      get => this.header.UserId;
-      set => this.header.UserId = value;
-    }
-
-    public int GroupId
-    {
-      get => this.header.GroupId;
-      set => this.header.GroupId = value;
-    }
-
-    public string UserName
-    {
-      get => this.header.UserName;
-      set => this.header.UserName = value;
-    }
-
-    public string GroupName
-    {
-      get => this.header.GroupName;
-      set => this.header.GroupName = value;
-    }
-
-    public void SetIds(int userId, int groupId)
-    {
-      this.UserId = userId;
-      this.GroupId = groupId;
-    }
-
-    public void SetNames(string userName, string groupName)
-    {
-      this.UserName = userName;
-      this.GroupName = groupName;
-    }
-
-    public DateTime ModTime
-    {
-      get => this.header.ModTime;
-      set => this.header.ModTime = value;
-    }
-
-    public string File => this.file;
-
-    public long Size
-    {
-      get => this.header.Size;
-      set => this.header.Size = value;
-    }
-
-    public bool IsDirectory
-    {
-      get
-      {
-        if (this.file != null)
-          return Directory.Exists(this.file);
-        return this.header != null && (this.header.TypeFlag == (byte) 53 || this.Name.EndsWith("/"));
-      }
-    }
-
-    public void GetFileTarHeader(TarHeader header, string file)
-    {
-      if (header == null)
-        throw new ArgumentNullException(nameof (header));
-      this.file = file != null ? file : throw new ArgumentNullException(nameof (file));
-      string str1 = file;
-      if (str1.IndexOf(Environment.CurrentDirectory) == 0)
-        str1 = str1.Substring(Environment.CurrentDirectory.Length);
-      string str2 = str1.Replace(Path.DirectorySeparatorChar, '/');
-      while (str2.StartsWith("/"))
-        str2 = str2.Substring(1);
-      header.LinkName = string.Empty;
-      header.Name = str2;
-      if (Directory.Exists(file))
-      {
-        header.Mode = 1003;
-        header.TypeFlag = (byte) 53;
-        if (header.Name.Length == 0 || header.Name[header.Name.Length - 1] != '/')
-          header.Name += "/";
-        header.Size = 0L;
-      }
-      else
-      {
-        header.Mode = 33216;
-        header.TypeFlag = (byte) 48;
-        header.Size = new FileInfo(file.Replace('/', Path.DirectorySeparatorChar)).Length;
-      }
-      header.ModTime = System.IO.File.GetLastWriteTime(file.Replace('/', Path.DirectorySeparatorChar)).ToUniversalTime();
-      header.DevMajor = 0;
-      header.DevMinor = 0;
-    }
-
-    public TarEntry[] GetDirectoryEntries()
-    {
-      if (this.file == null || !Directory.Exists(this.file))
-        return new TarEntry[0];
-      string[] fileSystemEntries = Directory.GetFileSystemEntries(this.file);
-      TarEntry[] directoryEntries = new TarEntry[fileSystemEntries.Length];
-      for (int index = 0; index < fileSystemEntries.Length; ++index)
-        directoryEntries[index] = TarEntry.CreateEntryFromFile(fileSystemEntries[index]);
-      return directoryEntries;
-    }
-
-    public void WriteEntryHeader(byte[] outBuffer) => this.header.WriteHeader(outBuffer);
-
-    public static void AdjustEntryName(byte[] buffer, string newName)
-    {
-      int offset = 0;
-      TarHeader.GetNameBytes(newName, buffer, offset, 100);
-    }
-
-    public static void NameTarHeader(TarHeader header, string name)
-    {
-      if (header == null)
-        throw new ArgumentNullException(nameof (header));
-      bool flag = name != null ? name.EndsWith("/") : throw new ArgumentNullException(nameof (name));
-      header.Name = name;
-      header.Mode = flag ? 1003 : 33216;
-      header.UserId = 0;
-      header.GroupId = 0;
-      header.Size = 0L;
-      header.ModTime = DateTime.UtcNow;
-      header.TypeFlag = flag ? (byte) 53 : (byte) 48;
-      header.LinkName = string.Empty;
-      header.UserName = string.Empty;
-      header.GroupName = string.Empty;
-      header.DevMajor = 0;
-      header.DevMinor = 0;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarException.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarException.cs
deleted file mode 100644
index 06ce49e..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-
-using System;
-using System.Runtime.Serialization;
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  [Serializable]
-  public class TarException : SharpZipBaseException
-  {
-    protected TarException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public TarException()
-    {
-    }
-
-    public TarException(string message)
-      : base(message)
-    {
-    }
-
-    public TarException(string message, Exception exception)
-      : base(message, exception)
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarHeader.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarHeader.cs
deleted file mode 100644
index 6f403e7..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarHeader.cs
+++ /dev/null
@@ -1,486 +0,0 @@
-
-using System;
-using System.Text;
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarHeader : ICloneable
-  {
-    public const int NAMELEN = 100;
-    public const int MODELEN = 8;
-    public const int UIDLEN = 8;
-    public const int GIDLEN = 8;
-    public const int CHKSUMLEN = 8;
-    public const int CHKSUMOFS = 148;
-    public const int SIZELEN = 12;
-    public const int MAGICLEN = 6;
-    public const int VERSIONLEN = 2;
-    public const int MODTIMELEN = 12;
-    public const int UNAMELEN = 32;
-    public const int GNAMELEN = 32;
-    public const int DEVLEN = 8;
-    public const byte LF_OLDNORM = 0;
-    public const byte LF_NORMAL = 48;
-    public const byte LF_LINK = 49;
-    public const byte LF_SYMLINK = 50;
-    public const byte LF_CHR = 51;
-    public const byte LF_BLK = 52;
-    public const byte LF_DIR = 53;
-    public const byte LF_FIFO = 54;
-    public const byte LF_CONTIG = 55;
-    public const byte LF_GHDR = 103;
-    public const byte LF_XHDR = 120;
-    public const byte LF_ACL = 65;
-    public const byte LF_GNU_DUMPDIR = 68;
-    public const byte LF_EXTATTR = 69;
-    public const byte LF_META = 73;
-    public const byte LF_GNU_LONGLINK = 75;
-    public const byte LF_GNU_LONGNAME = 76;
-    public const byte LF_GNU_MULTIVOL = 77;
-    public const byte LF_GNU_NAMES = 78;
-    public const byte LF_GNU_SPARSE = 83;
-    public const byte LF_GNU_VOLHDR = 86;
-    public const string TMAGIC = "ustar ";
-    public const string GNU_TMAGIC = "ustar  ";
-    private const long timeConversionFactor = 10000000;
-    private static readonly DateTime dateTime1970 = new DateTime(1970, 1, 1, 0, 0, 0, 0);
-    private string name;
-    private int mode;
-    private int userId;
-    private int groupId;
-    private long size;
-    private DateTime modTime;
-    private int checksum;
-    private bool isChecksumValid;
-    private byte typeFlag;
-    private string linkName;
-    private string magic;
-    private string version;
-    private string userName;
-    private string groupName;
-    private int devMajor;
-    private int devMinor;
-    internal static int userIdAsSet;
-    internal static int groupIdAsSet;
-    internal static string userNameAsSet;
-    internal static string groupNameAsSet = "None";
-    internal static int defaultUserId;
-    internal static int defaultGroupId;
-    internal static string defaultGroupName = "None";
-    internal static string defaultUser;
-
-    public TarHeader()
-    {
-      this.Magic = "ustar ";
-      this.Version = " ";
-      this.Name = "";
-      this.LinkName = "";
-      this.UserId = TarHeader.defaultUserId;
-      this.GroupId = TarHeader.defaultGroupId;
-      this.UserName = TarHeader.defaultUser;
-      this.GroupName = TarHeader.defaultGroupName;
-      this.Size = 0L;
-    }
-
-    public string Name
-    {
-      get => this.name;
-      set => this.name = value != null ? value : throw new ArgumentNullException(nameof (value));
-    }
-
-    [Obsolete("Use the Name property instead", true)]
-    public string GetName() => this.name;
-
-    public int Mode
-    {
-      get => this.mode;
-      set => this.mode = value;
-    }
-
-    public int UserId
-    {
-      get => this.userId;
-      set => this.userId = value;
-    }
-
-    public int GroupId
-    {
-      get => this.groupId;
-      set => this.groupId = value;
-    }
-
-    public long Size
-    {
-      get => this.size;
-      set
-      {
-        this.size = value >= 0L ? value : throw new ArgumentOutOfRangeException(nameof (value), "Cannot be less than zero");
-      }
-    }
-
-    public DateTime ModTime
-    {
-      get => this.modTime;
-      set
-      {
-        if (value < TarHeader.dateTime1970)
-          throw new ArgumentOutOfRangeException(nameof (value), "ModTime cannot be before Jan 1st 1970");
-        this.modTime = new DateTime(value.Year, value.Month, value.Day, value.Hour, value.Minute, value.Second);
-      }
-    }
-
-    public int Checksum => this.checksum;
-
-    public bool IsChecksumValid => this.isChecksumValid;
-
-    public byte TypeFlag
-    {
-      get => this.typeFlag;
-      set => this.typeFlag = value;
-    }
-
-    public string LinkName
-    {
-      get => this.linkName;
-      set
-      {
-        this.linkName = value != null ? value : throw new ArgumentNullException(nameof (value));
-      }
-    }
-
-    public string Magic
-    {
-      get => this.magic;
-      set => this.magic = value != null ? value : throw new ArgumentNullException(nameof (value));
-    }
-
-    public string Version
-    {
-      get => this.version;
-      set => this.version = value != null ? value : throw new ArgumentNullException(nameof (value));
-    }
-
-    public string UserName
-    {
-      get => this.userName;
-      set
-      {
-        if (value != null)
-        {
-          this.userName = value.Substring(0, Math.Min(32, value.Length));
-        }
-        else
-        {
-          string str = Environment.UserName;
-          if (str.Length > 32)
-            str = str.Substring(0, 32);
-          this.userName = str;
-        }
-      }
-    }
-
-    public string GroupName
-    {
-      get => this.groupName;
-      set
-      {
-        if (value == null)
-          this.groupName = "None";
-        else
-          this.groupName = value;
-      }
-    }
-
-    public int DevMajor
-    {
-      get => this.devMajor;
-      set => this.devMajor = value;
-    }
-
-    public int DevMinor
-    {
-      get => this.devMinor;
-      set => this.devMinor = value;
-    }
-
-    public object Clone() => this.MemberwiseClone();
-
-    public void ParseBuffer(byte[] header)
-    {
-      if (header == null)
-        throw new ArgumentNullException(nameof (header));
-      int offset1 = 0;
-      this.name = TarHeader.ParseName(header, offset1, 100).ToString();
-      int offset2 = offset1 + 100;
-      this.mode = (int) TarHeader.ParseOctal(header, offset2, 8);
-      int offset3 = offset2 + 8;
-      this.UserId = (int) TarHeader.ParseOctal(header, offset3, 8);
-      int offset4 = offset3 + 8;
-      this.GroupId = (int) TarHeader.ParseOctal(header, offset4, 8);
-      int offset5 = offset4 + 8;
-      this.Size = TarHeader.ParseOctal(header, offset5, 12);
-      int offset6 = offset5 + 12;
-      this.ModTime = TarHeader.GetDateTimeFromCTime(TarHeader.ParseOctal(header, offset6, 12));
-      int offset7 = offset6 + 12;
-      this.checksum = (int) TarHeader.ParseOctal(header, offset7, 8);
-      int num = offset7 + 8;
-      byte[] numArray = header;
-      int index = num;
-      int offset8 = index + 1;
-      this.TypeFlag = numArray[index];
-      this.LinkName = TarHeader.ParseName(header, offset8, 100).ToString();
-      int offset9 = offset8 + 100;
-      this.Magic = TarHeader.ParseName(header, offset9, 6).ToString();
-      int offset10 = offset9 + 6;
-      this.Version = TarHeader.ParseName(header, offset10, 2).ToString();
-      int offset11 = offset10 + 2;
-      this.UserName = TarHeader.ParseName(header, offset11, 32).ToString();
-      int offset12 = offset11 + 32;
-      this.GroupName = TarHeader.ParseName(header, offset12, 32).ToString();
-      int offset13 = offset12 + 32;
-      this.DevMajor = (int) TarHeader.ParseOctal(header, offset13, 8);
-      int offset14 = offset13 + 8;
-      this.DevMinor = (int) TarHeader.ParseOctal(header, offset14, 8);
-      this.isChecksumValid = this.Checksum == TarHeader.MakeCheckSum(header);
-    }
-
-    public void WriteHeader(byte[] outBuffer)
-    {
-      if (outBuffer == null)
-        throw new ArgumentNullException(nameof (outBuffer));
-      int offset1 = 0;
-      int nameBytes1 = TarHeader.GetNameBytes(this.Name, outBuffer, offset1, 100);
-      int octalBytes1 = TarHeader.GetOctalBytes((long) this.mode, outBuffer, nameBytes1, 8);
-      int octalBytes2 = TarHeader.GetOctalBytes((long) this.UserId, outBuffer, octalBytes1, 8);
-      int octalBytes3 = TarHeader.GetOctalBytes((long) this.GroupId, outBuffer, octalBytes2, 8);
-      int longOctalBytes1 = TarHeader.GetLongOctalBytes(this.Size, outBuffer, octalBytes3, 12);
-      int longOctalBytes2 = TarHeader.GetLongOctalBytes((long) TarHeader.GetCTime(this.ModTime), outBuffer, longOctalBytes1, 12);
-      int offset2 = longOctalBytes2;
-      for (int index = 0; index < 8; ++index)
-        outBuffer[longOctalBytes2++] = (byte) 32;
-      byte[] numArray = outBuffer;
-      int index1 = longOctalBytes2;
-      int offset3 = index1 + 1;
-      int typeFlag = (int) this.TypeFlag;
-      numArray[index1] = (byte) typeFlag;
-      int nameBytes2 = TarHeader.GetNameBytes(this.LinkName, outBuffer, offset3, 100);
-      int asciiBytes = TarHeader.GetAsciiBytes(this.Magic, 0, outBuffer, nameBytes2, 6);
-      int nameBytes3 = TarHeader.GetNameBytes(this.Version, outBuffer, asciiBytes, 2);
-      int nameBytes4 = TarHeader.GetNameBytes(this.UserName, outBuffer, nameBytes3, 32);
-      int offset4 = TarHeader.GetNameBytes(this.GroupName, outBuffer, nameBytes4, 32);
-      if (this.TypeFlag == (byte) 51 || this.TypeFlag == (byte) 52)
-      {
-        int octalBytes4 = TarHeader.GetOctalBytes((long) this.DevMajor, outBuffer, offset4, 8);
-        offset4 = TarHeader.GetOctalBytes((long) this.DevMinor, outBuffer, octalBytes4, 8);
-      }
-      while (offset4 < outBuffer.Length)
-        outBuffer[offset4++] = (byte) 0;
-      this.checksum = TarHeader.ComputeCheckSum(outBuffer);
-      TarHeader.GetCheckSumOctalBytes((long) this.checksum, outBuffer, offset2, 8);
-      this.isChecksumValid = true;
-    }
-
-    public override int GetHashCode() => this.Name.GetHashCode();
-
-    public override bool Equals(object obj)
-    {
-      return obj is TarHeader tarHeader && this.name == tarHeader.name && this.mode == tarHeader.mode && this.UserId == tarHeader.UserId && this.GroupId == tarHeader.GroupId && this.Size == tarHeader.Size && this.ModTime == tarHeader.ModTime && this.Checksum == tarHeader.Checksum && (int) this.TypeFlag == (int) tarHeader.TypeFlag && this.LinkName == tarHeader.LinkName && this.Magic == tarHeader.Magic && this.Version == tarHeader.Version && this.UserName == tarHeader.UserName && this.GroupName == tarHeader.GroupName && this.DevMajor == tarHeader.DevMajor && this.DevMinor == tarHeader.DevMinor;
-    }
-
-    internal static void SetValueDefaults(
-      int userId,
-      string userName,
-      int groupId,
-      string groupName)
-    {
-      TarHeader.defaultUserId = TarHeader.userIdAsSet = userId;
-      TarHeader.defaultUser = TarHeader.userNameAsSet = userName;
-      TarHeader.defaultGroupId = TarHeader.groupIdAsSet = groupId;
-      TarHeader.defaultGroupName = TarHeader.groupNameAsSet = groupName;
-    }
-
-    internal static void RestoreSetValues()
-    {
-      TarHeader.defaultUserId = TarHeader.userIdAsSet;
-      TarHeader.defaultUser = TarHeader.userNameAsSet;
-      TarHeader.defaultGroupId = TarHeader.groupIdAsSet;
-      TarHeader.defaultGroupName = TarHeader.groupNameAsSet;
-    }
-
-    public static long ParseOctal(byte[] header, int offset, int length)
-    {
-      if (header == null)
-        throw new NullReferenceException(nameof (header));
-      long octal = 0;
-      bool flag = true;
-      int num = offset + length;
-      for (int index = offset; index < num && header[index] != (byte) 0; ++index)
-      {
-        if (header[index] == (byte) 32 || header[index] == (byte) 48)
-        {
-          if (!flag)
-          {
-            if (header[index] == (byte) 32)
-              break;
-          }
-          else
-            continue;
-        }
-        flag = false;
-        octal = (octal << 3) + (long) ((int) header[index] - 48);
-      }
-      return octal;
-    }
-
-    public static StringBuilder ParseName(byte[] header, int offset, int length)
-    {
-      if (header == null)
-        throw new ArgumentNullException(nameof (header));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be less than zero");
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length), "Cannot be less than zero");
-      if (offset + length > header.Length)
-        throw new ArgumentException("Exceeds header size", nameof (length));
-      StringBuilder name = new StringBuilder(length);
-      for (int index = offset; index < offset + length && header[index] != (byte) 0; ++index)
-        name.Append((char) header[index]);
-      return name;
-    }
-
-    public static int GetNameBytes(
-      StringBuilder name,
-      int nameOffset,
-      byte[] buffer,
-      int bufferOffset,
-      int length)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      return TarHeader.GetNameBytes(name.ToString(), nameOffset, buffer, bufferOffset, length);
-    }
-
-    public static int GetNameBytes(
-      string name,
-      int nameOffset,
-      byte[] buffer,
-      int bufferOffset,
-      int length)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      int num;
-      for (num = 0; num < length - 1 && nameOffset + num < name.Length; ++num)
-        buffer[bufferOffset + num] = (byte) name[nameOffset + num];
-      for (; num < length; ++num)
-        buffer[bufferOffset + num] = (byte) 0;
-      return bufferOffset + length;
-    }
-
-    public static int GetNameBytes(StringBuilder name, byte[] buffer, int offset, int length)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      return TarHeader.GetNameBytes(name.ToString(), 0, buffer, offset, length);
-    }
-
-    public static int GetNameBytes(string name, byte[] buffer, int offset, int length)
-    {
-      if (name == null)
-        throw new ArgumentNullException(nameof (name));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      return TarHeader.GetNameBytes(name, 0, buffer, offset, length);
-    }
-
-    public static int GetAsciiBytes(
-      string toAdd,
-      int nameOffset,
-      byte[] buffer,
-      int bufferOffset,
-      int length)
-    {
-      if (toAdd == null)
-        throw new ArgumentNullException(nameof (toAdd));
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      for (int index = 0; index < length && nameOffset + index < toAdd.Length; ++index)
-        buffer[bufferOffset + index] = (byte) toAdd[nameOffset + index];
-      return bufferOffset + length;
-    }
-
-    public static int GetOctalBytes(long value, byte[] buffer, int offset, int length)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      int num1 = length - 1;
-      buffer[offset + num1] = (byte) 0;
-      int num2 = num1 - 1;
-      if (value > 0L)
-      {
-        for (long index = value; num2 >= 0 && index > 0L; --num2)
-        {
-          buffer[offset + num2] = (byte) (48U + (uint) (byte) ((ulong) index & 7UL));
-          index >>= 3;
-        }
-      }
-      for (; num2 >= 0; --num2)
-        buffer[offset + num2] = (byte) 48;
-      return offset + length;
-    }
-
-    public static int GetLongOctalBytes(long value, byte[] buffer, int offset, int length)
-    {
-      return TarHeader.GetOctalBytes(value, buffer, offset, length);
-    }
-
-    private static int GetCheckSumOctalBytes(long value, byte[] buffer, int offset, int length)
-    {
-      TarHeader.GetOctalBytes(value, buffer, offset, length - 1);
-      return offset + length;
-    }
-
-    private static int ComputeCheckSum(byte[] buffer)
-    {
-      int checkSum = 0;
-      for (int index = 0; index < buffer.Length; ++index)
-        checkSum += (int) buffer[index];
-      return checkSum;
-    }
-
-    private static int MakeCheckSum(byte[] buffer)
-    {
-      int num = 0;
-      for (int index = 0; index < 148; ++index)
-        num += (int) buffer[index];
-      for (int index = 0; index < 8; ++index)
-        num += 32;
-      for (int index = 156; index < buffer.Length; ++index)
-        num += (int) buffer[index];
-      return num;
-    }
-
-    private static int GetCTime(DateTime dateTime)
-    {
-      return (int) ((dateTime.Ticks - TarHeader.dateTime1970.Ticks) / 10000000L);
-    }
-
-    private static DateTime GetDateTimeFromCTime(long ticks)
-    {
-      try
-      {
-        return new DateTime(TarHeader.dateTime1970.Ticks + ticks * 10000000L);
-      }
-      catch (ArgumentOutOfRangeException ex)
-      {
-        return TarHeader.dateTime1970;
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarInputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarInputStream.cs
deleted file mode 100644
index 573c82d..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarInputStream.cs
+++ /dev/null
@@ -1,290 +0,0 @@
-
-using System;
-using System.IO;
-using System.Text;
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarInputStream : Stream
-  {
-    protected bool hasHitEOF;
-    protected long entrySize;
-    protected long entryOffset;
-    protected byte[] readBuffer;
-    protected TarBuffer buffer;
-    private TarEntry currentEntry;
-    protected TarInputStream.IEntryFactory entryFactory;
-    private Stream inputStream;
-
-    public TarInputStream(Stream inputStream)
-      : this(inputStream, 20)
-    {
-    }
-
-    public TarInputStream(Stream inputStream, int blockFactor)
-    {
-      this.inputStream = inputStream;
-      this.buffer = TarBuffer.CreateInputTarBuffer(inputStream, blockFactor);
-    }
-
-    public override bool CanRead => this.inputStream.CanRead;
-
-    public override bool CanSeek => false;
-
-    public override bool CanWrite => false;
-
-    public override long Length => this.inputStream.Length;
-
-    public override long Position
-    {
-      get => this.inputStream.Position;
-      set => throw new NotSupportedException("TarInputStream Seek not supported");
-    }
-
-    public override void Flush() => this.inputStream.Flush();
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("TarInputStream Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("TarInputStream SetLength not supported");
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("TarInputStream Write not supported");
-    }
-
-    public override void WriteByte(byte value)
-    {
-      throw new NotSupportedException("TarInputStream WriteByte not supported");
-    }
-
-    public override int ReadByte()
-    {
-      byte[] buffer = new byte[1];
-      return this.Read(buffer, 0, 1) <= 0 ? -1 : (int) buffer[0];
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      int num1 = 0;
-      if (this.entryOffset >= this.entrySize)
-        return 0;
-      long num2 = (long) count;
-      if (num2 + this.entryOffset > this.entrySize)
-        num2 = this.entrySize - this.entryOffset;
-      if (this.readBuffer != null)
-      {
-        int num3 = num2 > (long) this.readBuffer.Length ? this.readBuffer.Length : (int) num2;
-        Array.Copy((Array) this.readBuffer, 0, (Array) buffer, offset, num3);
-        if (num3 >= this.readBuffer.Length)
-        {
-          this.readBuffer = (byte[]) null;
-        }
-        else
-        {
-          int length = this.readBuffer.Length - num3;
-          byte[] destinationArray = new byte[length];
-          Array.Copy((Array) this.readBuffer, num3, (Array) destinationArray, 0, length);
-          this.readBuffer = destinationArray;
-        }
-        num1 += num3;
-        num2 -= (long) num3;
-        offset += num3;
-      }
-      while (num2 > 0L)
-      {
-        byte[] sourceArray = this.buffer.ReadBlock();
-        if (sourceArray == null)
-          throw new TarException("unexpected EOF with " + (object) num2 + " bytes unread");
-        int num4 = (int) num2;
-        int length = sourceArray.Length;
-        if (length > num4)
-        {
-          Array.Copy((Array) sourceArray, 0, (Array) buffer, offset, num4);
-          this.readBuffer = new byte[length - num4];
-          Array.Copy((Array) sourceArray, num4, (Array) this.readBuffer, 0, length - num4);
-        }
-        else
-        {
-          num4 = length;
-          Array.Copy((Array) sourceArray, 0, (Array) buffer, offset, length);
-        }
-        num1 += num4;
-        num2 -= (long) num4;
-        offset += num4;
-      }
-      this.entryOffset += (long) num1;
-      return num1;
-    }
-
-    public override void Close() => this.buffer.Close();
-
-    public void SetEntryFactory(TarInputStream.IEntryFactory factory)
-    {
-      this.entryFactory = factory;
-    }
-
-    public int RecordSize => this.buffer.RecordSize;
-
-    [Obsolete("Use RecordSize property instead")]
-    public int GetRecordSize() => this.buffer.RecordSize;
-
-    public long Available => this.entrySize - this.entryOffset;
-
-    public void Skip(long skipCount)
-    {
-      byte[] buffer = new byte[8192];
-      int num;
-      for (long index = skipCount; index > 0L; index -= (long) num)
-      {
-        int count = index > (long) buffer.Length ? buffer.Length : (int) index;
-        num = this.Read(buffer, 0, count);
-        if (num == -1)
-          break;
-      }
-    }
-
-    public bool IsMarkSupported => false;
-
-    public void Mark(int markLimit)
-    {
-    }
-
-    public void Reset()
-    {
-    }
-
-    public TarEntry GetNextEntry()
-    {
-      if (this.hasHitEOF)
-        return (TarEntry) null;
-      if (this.currentEntry != null)
-        this.SkipToNextEntry();
-      byte[] numArray1 = this.buffer.ReadBlock();
-      if (numArray1 == null)
-        this.hasHitEOF = true;
-      else if (this.buffer.IsEOFBlock(numArray1))
-        this.hasHitEOF = true;
-      if (this.hasHitEOF)
-      {
-        this.currentEntry = (TarEntry) null;
-      }
-      else
-      {
-        try
-        {
-          TarHeader tarHeader = new TarHeader();
-          tarHeader.ParseBuffer(numArray1);
-          if (!tarHeader.IsChecksumValid)
-            throw new TarException("Header checksum is invalid");
-          this.entryOffset = 0L;
-          this.entrySize = tarHeader.Size;
-          StringBuilder stringBuilder = (StringBuilder) null;
-          if (tarHeader.TypeFlag == (byte) 76)
-          {
-            byte[] numArray2 = new byte[512];
-            long entrySize = this.entrySize;
-            stringBuilder = new StringBuilder();
-            int length;
-            for (; entrySize > 0L; entrySize -= (long) length)
-            {
-              length = this.Read(numArray2, 0, entrySize > (long) numArray2.Length ? numArray2.Length : (int) entrySize);
-              if (length == -1)
-                throw new InvalidHeaderException("Failed to read long name entry");
-              stringBuilder.Append(TarHeader.ParseName(numArray2, 0, length).ToString());
-            }
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          else if (tarHeader.TypeFlag == (byte) 103)
-          {
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          else if (tarHeader.TypeFlag == (byte) 120)
-          {
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          else if (tarHeader.TypeFlag == (byte) 86)
-          {
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          else if (tarHeader.TypeFlag != (byte) 48 && tarHeader.TypeFlag != (byte) 0 && tarHeader.TypeFlag != (byte) 53)
-          {
-            this.SkipToNextEntry();
-            numArray1 = this.buffer.ReadBlock();
-          }
-          if (this.entryFactory == null)
-          {
-            this.currentEntry = new TarEntry(numArray1);
-            if (stringBuilder != null)
-              this.currentEntry.Name = stringBuilder.ToString();
-          }
-          else
-            this.currentEntry = this.entryFactory.CreateEntry(numArray1);
-          this.entryOffset = 0L;
-          this.entrySize = this.currentEntry.Size;
-        }
-        catch (InvalidHeaderException ex)
-        {
-          this.entrySize = 0L;
-          this.entryOffset = 0L;
-          this.currentEntry = (TarEntry) null;
-          throw new InvalidHeaderException(string.Format("Bad header in record {0} block {1} {2}", (object) this.buffer.CurrentRecord, (object) this.buffer.CurrentBlock, (object) ex.Message));
-        }
-      }
-      return this.currentEntry;
-    }
-
-    public void CopyEntryContents(Stream outputStream)
-    {
-      byte[] buffer = new byte[32768];
-      while (true)
-      {
-        int count = this.Read(buffer, 0, buffer.Length);
-        if (count > 0)
-          outputStream.Write(buffer, 0, count);
-        else
-          break;
-      }
-    }
-
-    private void SkipToNextEntry()
-    {
-      long skipCount = this.entrySize - this.entryOffset;
-      if (skipCount > 0L)
-        this.Skip(skipCount);
-      this.readBuffer = (byte[]) null;
-    }
-
-    public interface IEntryFactory
-    {
-      TarEntry CreateEntry(string name);
-
-      TarEntry CreateEntryFromFile(string fileName);
-
-      TarEntry CreateEntry(byte[] headerBuf);
-    }
-
-    public class EntryFactoryAdapter : TarInputStream.IEntryFactory
-    {
-      public TarEntry CreateEntry(string name) => TarEntry.CreateTarEntry(name);
-
-      public TarEntry CreateEntryFromFile(string fileName)
-      {
-        return TarEntry.CreateEntryFromFile(fileName);
-      }
-
-      public TarEntry CreateEntry(byte[] headerBuf) => new TarEntry(headerBuf);
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarOutputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarOutputStream.cs
deleted file mode 100644
index d5a8a4e..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Tar/TarOutputStream.cs
+++ /dev/null
@@ -1,191 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Tar
-{
-  public class TarOutputStream : Stream
-  {
-    private long currBytes;
-    private int assemblyBufferLength;
-    private bool isClosed;
-    protected long currSize;
-    protected byte[] blockBuffer;
-    protected byte[] assemblyBuffer;
-    protected TarBuffer buffer;
-    protected Stream outputStream;
-
-    public TarOutputStream(Stream outputStream)
-      : this(outputStream, 20)
-    {
-    }
-
-    public TarOutputStream(Stream outputStream, int blockFactor)
-    {
-      this.outputStream = outputStream != null ? outputStream : throw new ArgumentNullException(nameof (outputStream));
-      this.buffer = TarBuffer.CreateOutputTarBuffer(outputStream, blockFactor);
-      this.assemblyBuffer = new byte[512];
-      this.blockBuffer = new byte[512];
-    }
-
-    public override bool CanRead => this.outputStream.CanRead;
-
-    public override bool CanSeek => this.outputStream.CanSeek;
-
-    public override bool CanWrite => this.outputStream.CanWrite;
-
-    public override long Length => this.outputStream.Length;
-
-    public override long Position
-    {
-      get => this.outputStream.Position;
-      set => this.outputStream.Position = value;
-    }
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      return this.outputStream.Seek(offset, origin);
-    }
-
-    public override void SetLength(long value) => this.outputStream.SetLength(value);
-
-    public override int ReadByte() => this.outputStream.ReadByte();
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      return this.outputStream.Read(buffer, offset, count);
-    }
-
-    public override void Flush() => this.outputStream.Flush();
-
-    public void Finish()
-    {
-      if (this.IsEntryOpen)
-        this.CloseEntry();
-      this.WriteEofBlock();
-    }
-
-    public override void Close()
-    {
-      if (this.isClosed)
-        return;
-      this.isClosed = true;
-      this.Finish();
-      this.buffer.Close();
-    }
-
-    public int RecordSize => this.buffer.RecordSize;
-
-    [Obsolete("Use RecordSize property instead")]
-    public int GetRecordSize() => this.buffer.RecordSize;
-
-    private bool IsEntryOpen => this.currBytes < this.currSize;
-
-    public void PutNextEntry(TarEntry entry)
-    {
-      if (entry == null)
-        throw new ArgumentNullException(nameof (entry));
-      if (entry.TarHeader.Name.Length >= 100)
-      {
-        TarHeader tarHeader = new TarHeader()
-        {
-          TypeFlag = 76
-        };
-        tarHeader.Name += "././@LongLink";
-        tarHeader.UserId = 0;
-        tarHeader.GroupId = 0;
-        tarHeader.GroupName = "";
-        tarHeader.UserName = "";
-        tarHeader.LinkName = "";
-        tarHeader.Size = (long) entry.TarHeader.Name.Length;
-        tarHeader.WriteHeader(this.blockBuffer);
-        this.buffer.WriteBlock(this.blockBuffer);
-        int nameOffset = 0;
-        while (nameOffset < entry.TarHeader.Name.Length)
-        {
-          Array.Clear((Array) this.blockBuffer, 0, this.blockBuffer.Length);
-          TarHeader.GetAsciiBytes(entry.TarHeader.Name, nameOffset, this.blockBuffer, 0, 512);
-          nameOffset += 512;
-          this.buffer.WriteBlock(this.blockBuffer);
-        }
-      }
-      entry.WriteEntryHeader(this.blockBuffer);
-      this.buffer.WriteBlock(this.blockBuffer);
-      this.currBytes = 0L;
-      this.currSize = entry.IsDirectory ? 0L : entry.Size;
-    }
-
-    public void CloseEntry()
-    {
-      if (this.assemblyBufferLength > 0)
-      {
-        Array.Clear((Array) this.assemblyBuffer, this.assemblyBufferLength, this.assemblyBuffer.Length - this.assemblyBufferLength);
-        this.buffer.WriteBlock(this.assemblyBuffer);
-        this.currBytes += (long) this.assemblyBufferLength;
-        this.assemblyBufferLength = 0;
-      }
-      if (this.currBytes < this.currSize)
-        throw new TarException(string.Format("Entry closed at '{0}' before the '{1}' bytes specified in the header were written", (object) this.currBytes, (object) this.currSize));
-    }
-
-    public override void WriteByte(byte value)
-    {
-      this.Write(new byte[1]{ value }, 0, 1);
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be negative");
-      if (buffer.Length - offset < count)
-        throw new ArgumentException("offset and count combination is invalid");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be negative");
-      if (this.currBytes + (long) count > this.currSize)
-        throw new ArgumentOutOfRangeException(nameof (count), string.Format("request to write '{0}' bytes exceeds size in header of '{1}' bytes", (object) count, (object) this.currSize));
-      if (this.assemblyBufferLength > 0)
-      {
-        if (this.assemblyBufferLength + count >= this.blockBuffer.Length)
-        {
-          int length = this.blockBuffer.Length - this.assemblyBufferLength;
-          Array.Copy((Array) this.assemblyBuffer, 0, (Array) this.blockBuffer, 0, this.assemblyBufferLength);
-          Array.Copy((Array) buffer, offset, (Array) this.blockBuffer, this.assemblyBufferLength, length);
-          this.buffer.WriteBlock(this.blockBuffer);
-          this.currBytes += (long) this.blockBuffer.Length;
-          offset += length;
-          count -= length;
-          this.assemblyBufferLength = 0;
-        }
-        else
-        {
-          Array.Copy((Array) buffer, offset, (Array) this.assemblyBuffer, this.assemblyBufferLength, count);
-          offset += count;
-          this.assemblyBufferLength += count;
-          count -= count;
-        }
-      }
-      while (count > 0)
-      {
-        if (count < this.blockBuffer.Length)
-        {
-          Array.Copy((Array) buffer, offset, (Array) this.assemblyBuffer, this.assemblyBufferLength, count);
-          this.assemblyBufferLength += count;
-          break;
-        }
-        this.buffer.WriteBlock(buffer, offset);
-        int length = this.blockBuffer.Length;
-        this.currBytes += (long) length;
-        count -= length;
-        offset += length;
-      }
-    }
-
-    private void WriteEofBlock()
-    {
-      Array.Clear((Array) this.blockBuffer, 0, this.blockBuffer.Length);
-      this.buffer.WriteBlock(this.blockBuffer);
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/BaseArchiveStorage.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/BaseArchiveStorage.cs
deleted file mode 100644
index b723f77..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/BaseArchiveStorage.cs
+++ /dev/null
@@ -1,24 +0,0 @@
-
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public abstract class BaseArchiveStorage : IArchiveStorage
-  {
-    private FileUpdateMode updateMode_;
-
-    public BaseArchiveStorage(FileUpdateMode updateMode) => this.updateMode_ = updateMode;
-
-    public abstract Stream GetTemporaryOutput();
-
-    public abstract Stream ConvertTemporaryToFinal();
-
-    public abstract Stream MakeTemporaryCopy(Stream stream);
-
-    public abstract Stream OpenForDirectUpdate(Stream stream);
-
-    public abstract void Dispose();
-
-    public FileUpdateMode UpdateMode => this.updateMode_;
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflateStrategy.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflateStrategy.cs
deleted file mode 100644
index 5285d32..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflateStrategy.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public enum DeflateStrategy
-  {
-    Default,
-    Filtered,
-    HuffmanOnly,
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Deflater.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Deflater.cs
deleted file mode 100644
index d2705da..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Deflater.cs
+++ /dev/null
@@ -1,178 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class Deflater
-  {
-    public const int BEST_COMPRESSION = 9;
-    public const int BEST_SPEED = 1;
-    public const int DEFAULT_COMPRESSION = -1;
-    public const int NO_COMPRESSION = 0;
-    public const int DEFLATED = 8;
-    private const int IS_SETDICT = 1;
-    private const int IS_FLUSHING = 4;
-    private const int IS_FINISHING = 8;
-    private const int INIT_STATE = 0;
-    private const int SETDICT_STATE = 1;
-    private const int BUSY_STATE = 16;
-    private const int FLUSHING_STATE = 20;
-    private const int FINISHING_STATE = 28;
-    private const int FINISHED_STATE = 30;
-    private const int CLOSED_STATE = 127;
-    private int level;
-    private bool noZlibHeaderOrFooter;
-    private int state;
-    private long totalOut;
-    private DeflaterPending pending;
-    private DeflaterEngine engine;
-
-    public Deflater()
-      : this(-1, false)
-    {
-    }
-
-    public Deflater(int level)
-      : this(level, false)
-    {
-    }
-
-    public Deflater(int level, bool noZlibHeaderOrFooter)
-    {
-      if (level == -1)
-        level = 6;
-      else if (level < 0 || level > 9)
-        throw new ArgumentOutOfRangeException(nameof (level));
-      this.pending = new DeflaterPending();
-      this.engine = new DeflaterEngine(this.pending);
-      this.noZlibHeaderOrFooter = noZlibHeaderOrFooter;
-      this.SetStrategy(DeflateStrategy.Default);
-      this.SetLevel(level);
-      this.Reset();
-    }
-
-    public void Reset()
-    {
-      this.state = this.noZlibHeaderOrFooter ? 16 : 0;
-      this.totalOut = 0L;
-      this.pending.Reset();
-      this.engine.Reset();
-    }
-
-    public int Adler => this.engine.Adler;
-
-    public int TotalIn => this.engine.TotalIn;
-
-    public long TotalOut => this.totalOut;
-
-    public void Flush() => this.state |= 4;
-
-    public void Finish() => this.state |= 12;
-
-    public bool IsFinished => this.state == 30 && this.pending.IsFlushed;
-
-    public bool IsNeedingInput => this.engine.NeedsInput();
-
-    public void SetInput(byte[] input) => this.SetInput(input, 0, input.Length);
-
-    public void SetInput(byte[] input, int offset, int count)
-    {
-      if ((this.state & 8) != 0)
-        throw new InvalidOperationException("Finish() already called");
-      this.engine.SetInput(input, offset, count);
-    }
-
-    public void SetLevel(int level)
-    {
-      if (level == -1)
-        level = 6;
-      else if (level < 0 || level > 9)
-        throw new ArgumentOutOfRangeException(nameof (level));
-      if (this.level == level)
-        return;
-      this.level = level;
-      this.engine.SetLevel(level);
-    }
-
-    public int GetLevel() => this.level;
-
-    public void SetStrategy(DeflateStrategy strategy) => this.engine.Strategy = strategy;
-
-    public int Deflate(byte[] output) => this.Deflate(output, 0, output.Length);
-
-    public int Deflate(byte[] output, int offset, int length)
-    {
-      int num1 = length;
-      if (this.state == (int) sbyte.MaxValue)
-        throw new InvalidOperationException("Deflater closed");
-      if (this.state < 16)
-      {
-        int num2 = 30720;
-        int num3 = this.level - 1 >> 1;
-        if (num3 < 0 || num3 > 3)
-          num3 = 3;
-        int num4 = num2 | num3 << 6;
-        if ((this.state & 1) != 0)
-          num4 |= 32;
-        this.pending.WriteShortMSB(num4 + (31 - num4 % 31));
-        if ((this.state & 1) != 0)
-        {
-          int adler = this.engine.Adler;
-          this.engine.ResetAdler();
-          this.pending.WriteShortMSB(adler >> 16);
-          this.pending.WriteShortMSB(adler & (int) ushort.MaxValue);
-        }
-        this.state = 16 | this.state & 12;
-      }
-      while (true)
-      {
-        do
-        {
-          do
-          {
-            int num5 = this.pending.Flush(output, offset, length);
-            offset += num5;
-            this.totalOut += (long) num5;
-            length -= num5;
-            if (length == 0 || this.state == 30)
-              goto label_24;
-          }
-          while (this.engine.Deflate((this.state & 4) != 0, (this.state & 8) != 0));
-          if (this.state == 16)
-            return num1 - length;
-          if (this.state == 20)
-          {
-            if (this.level != 0)
-            {
-              for (int index = 8 + (-this.pending.BitCount & 7); index > 0; index -= 10)
-                this.pending.WriteBits(2, 10);
-            }
-            this.state = 16;
-          }
-        }
-        while (this.state != 28);
-        this.pending.AlignToByte();
-        if (!this.noZlibHeaderOrFooter)
-        {
-          int adler = this.engine.Adler;
-          this.pending.WriteShortMSB(adler >> 16);
-          this.pending.WriteShortMSB(adler & (int) ushort.MaxValue);
-        }
-        this.state = 30;
-      }
-label_24:
-      return num1 - length;
-    }
-
-    public void SetDictionary(byte[] dictionary)
-    {
-      this.SetDictionary(dictionary, 0, dictionary.Length);
-    }
-
-    public void SetDictionary(byte[] dictionary, int index, int count)
-    {
-      this.state = this.state == 0 ? 1 : throw new InvalidOperationException();
-      this.engine.SetDictionary(dictionary, index, count);
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterConstants.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterConstants.cs
deleted file mode 100644
index bd3c9fc..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterConstants.cs
+++ /dev/null
@@ -1,96 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class DeflaterConstants
-  {
-    public const bool DEBUGGING = false;
-    public const int STORED_BLOCK = 0;
-    public const int STATIC_TREES = 1;
-    public const int DYN_TREES = 2;
-    public const int PRESET_DICT = 32;
-    public const int DEFAULT_MEM_LEVEL = 8;
-    public const int MAX_MATCH = 258;
-    public const int MIN_MATCH = 3;
-    public const int MAX_WBITS = 15;
-    public const int WSIZE = 32768;
-    public const int WMASK = 32767;
-    public const int HASH_BITS = 15;
-    public const int HASH_SIZE = 32768;
-    public const int HASH_MASK = 32767;
-    public const int HASH_SHIFT = 5;
-    public const int MIN_LOOKAHEAD = 262;
-    public const int MAX_DIST = 32506;
-    public const int PENDING_BUF_SIZE = 65536;
-    public const int DEFLATE_STORED = 0;
-    public const int DEFLATE_FAST = 1;
-    public const int DEFLATE_SLOW = 2;
-    public static int MAX_BLOCK_SIZE = Math.Min((int) ushort.MaxValue, 65531);
-    public static int[] GOOD_LENGTH = new int[10]
-    {
-      0,
-      4,
-      4,
-      4,
-      4,
-      8,
-      8,
-      8,
-      32,
-      32
-    };
-    public static int[] MAX_LAZY = new int[10]
-    {
-      0,
-      4,
-      5,
-      6,
-      4,
-      16,
-      16,
-      32,
-      128,
-      258
-    };
-    public static int[] NICE_LENGTH = new int[10]
-    {
-      0,
-      8,
-      16,
-      32,
-      16,
-      32,
-      128,
-      128,
-      258,
-      258
-    };
-    public static int[] MAX_CHAIN = new int[10]
-    {
-      0,
-      4,
-      8,
-      32,
-      16,
-      32,
-      128,
-      256,
-      1024,
-      4096
-    };
-    public static int[] COMPR_FUNC = new int[10]
-    {
-      0,
-      1,
-      1,
-      1,
-      1,
-      2,
-      2,
-      2,
-      2,
-      2
-    };
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterEngine.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterEngine.cs
deleted file mode 100644
index aa44eed..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterEngine.cs
+++ /dev/null
@@ -1,426 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class DeflaterEngine : DeflaterConstants
-  {
-    private const int TooFar = 4096;
-    private int ins_h;
-    private short[] head;
-    private short[] prev;
-    private int matchStart;
-    private int matchLen;
-    private bool prevAvailable;
-    private int blockStart;
-    private int strstart;
-    private int lookahead;
-    private byte[] window;
-    private DeflateStrategy strategy;
-    private int max_chain;
-    private int max_lazy;
-    private int niceLength;
-    private int goodLength;
-    private int compressionFunction;
-    private byte[] inputBuf;
-    private int totalIn;
-    private int inputOff;
-    private int inputEnd;
-    private DeflaterPending pending;
-    private DeflaterHuffman huffman;
-    private Adler32 adler;
-
-    public DeflaterEngine(DeflaterPending pending)
-    {
-      this.pending = pending;
-      this.huffman = new DeflaterHuffman(pending);
-      this.adler = new Adler32();
-      this.window = new byte[65536];
-      this.head = new short[32768];
-      this.prev = new short[32768];
-      this.blockStart = this.strstart = 1;
-    }
-
-    public bool Deflate(bool flush, bool finish)
-    {
-      bool flag;
-      do
-      {
-        this.FillWindow();
-        bool flush1 = flush && this.inputOff == this.inputEnd;
-        switch (this.compressionFunction)
-        {
-          case 0:
-            flag = this.DeflateStored(flush1, finish);
-            break;
-          case 1:
-            flag = this.DeflateFast(flush1, finish);
-            break;
-          case 2:
-            flag = this.DeflateSlow(flush1, finish);
-            break;
-          default:
-            throw new InvalidOperationException("unknown compressionFunction");
-        }
-      }
-      while (this.pending.IsFlushed && flag);
-      return flag;
-    }
-
-    public void SetInput(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (this.inputOff < this.inputEnd)
-        throw new InvalidOperationException("Old input was not completely processed");
-      int num = offset + count;
-      if (offset > num || num > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      this.inputBuf = buffer;
-      this.inputOff = offset;
-      this.inputEnd = num;
-    }
-
-    public bool NeedsInput() => this.inputEnd == this.inputOff;
-
-    public void SetDictionary(byte[] buffer, int offset, int length)
-    {
-      this.adler.Update(buffer, offset, length);
-      if (length < 3)
-        return;
-      if (length > 32506)
-      {
-        offset += length - 32506;
-        length = 32506;
-      }
-      Array.Copy((Array) buffer, offset, (Array) this.window, this.strstart, length);
-      this.UpdateHash();
-      --length;
-      while (--length > 0)
-      {
-        this.InsertString();
-        ++this.strstart;
-      }
-      this.strstart += 2;
-      this.blockStart = this.strstart;
-    }
-
-    public void Reset()
-    {
-      this.huffman.Reset();
-      this.adler.Reset();
-      this.blockStart = this.strstart = 1;
-      this.lookahead = 0;
-      this.totalIn = 0;
-      this.prevAvailable = false;
-      this.matchLen = 2;
-      for (int index = 0; index < 32768; ++index)
-        this.head[index] = (short) 0;
-      for (int index = 0; index < 32768; ++index)
-        this.prev[index] = (short) 0;
-    }
-
-    public void ResetAdler() => this.adler.Reset();
-
-    public int Adler => (int) this.adler.Value;
-
-    public int TotalIn => this.totalIn;
-
-    public DeflateStrategy Strategy
-    {
-      get => this.strategy;
-      set => this.strategy = value;
-    }
-
-    public void SetLevel(int level)
-    {
-      this.goodLength = level >= 0 && level <= 9 ? DeflaterConstants.GOOD_LENGTH[level] : throw new ArgumentOutOfRangeException(nameof (level));
-      this.max_lazy = DeflaterConstants.MAX_LAZY[level];
-      this.niceLength = DeflaterConstants.NICE_LENGTH[level];
-      this.max_chain = DeflaterConstants.MAX_CHAIN[level];
-      if (DeflaterConstants.COMPR_FUNC[level] == this.compressionFunction)
-        return;
-      switch (this.compressionFunction)
-      {
-        case 0:
-          if (this.strstart > this.blockStart)
-          {
-            this.huffman.FlushStoredBlock(this.window, this.blockStart, this.strstart - this.blockStart, false);
-            this.blockStart = this.strstart;
-          }
-          this.UpdateHash();
-          break;
-        case 1:
-          if (this.strstart > this.blockStart)
-          {
-            this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, false);
-            this.blockStart = this.strstart;
-            break;
-          }
-          break;
-        case 2:
-          if (this.prevAvailable)
-            this.huffman.TallyLit((int) this.window[this.strstart - 1] & (int) byte.MaxValue);
-          if (this.strstart > this.blockStart)
-          {
-            this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, false);
-            this.blockStart = this.strstart;
-          }
-          this.prevAvailable = false;
-          this.matchLen = 2;
-          break;
-      }
-      this.compressionFunction = DeflaterConstants.COMPR_FUNC[level];
-    }
-
-    public void FillWindow()
-    {
-      if (this.strstart >= 65274)
-        this.SlideWindow();
-      int num;
-      for (; this.lookahead < 262 && this.inputOff < this.inputEnd; this.lookahead += num)
-      {
-        num = 65536 - this.lookahead - this.strstart;
-        if (num > this.inputEnd - this.inputOff)
-          num = this.inputEnd - this.inputOff;
-        Array.Copy((Array) this.inputBuf, this.inputOff, (Array) this.window, this.strstart + this.lookahead, num);
-        this.adler.Update(this.inputBuf, this.inputOff, num);
-        this.inputOff += num;
-        this.totalIn += num;
-      }
-      if (this.lookahead < 3)
-        return;
-      this.UpdateHash();
-    }
-
-    private void UpdateHash()
-    {
-      this.ins_h = (int) this.window[this.strstart] << 5 ^ (int) this.window[this.strstart + 1];
-    }
-
-    private int InsertString()
-    {
-      int index = (this.ins_h << 5 ^ (int) this.window[this.strstart + 2]) & (int) short.MaxValue;
-      short num;
-      this.prev[this.strstart & (int) short.MaxValue] = num = this.head[index];
-      this.head[index] = (short) this.strstart;
-      this.ins_h = index;
-      return (int) num & (int) ushort.MaxValue;
-    }
-
-    private void SlideWindow()
-    {
-      Array.Copy((Array) this.window, 32768, (Array) this.window, 0, 32768);
-      this.matchStart -= 32768;
-      this.strstart -= 32768;
-      this.blockStart -= 32768;
-      for (int index = 0; index < 32768; ++index)
-      {
-        int num = (int) this.head[index] & (int) ushort.MaxValue;
-        this.head[index] = num >= 32768 ? (short) (num - 32768) : (short) 0;
-      }
-      for (int index = 0; index < 32768; ++index)
-      {
-        int num = (int) this.prev[index] & (int) ushort.MaxValue;
-        this.prev[index] = num >= 32768 ? (short) (num - 32768) : (short) 0;
-      }
-    }
-
-    private bool FindLongestMatch(int curMatch)
-    {
-      int maxChain = this.max_chain;
-      int num1 = this.niceLength;
-      short[] prev = this.prev;
-      int strstart = this.strstart;
-      int index = this.strstart + this.matchLen;
-      int val1 = Math.Max(this.matchLen, 2);
-      int num2 = Math.Max(this.strstart - 32506, 0);
-      int num3 = this.strstart + 258 - 1;
-      byte num4 = this.window[index - 1];
-      byte num5 = this.window[index];
-      if (val1 >= this.goodLength)
-        maxChain >>= 2;
-      if (num1 > this.lookahead)
-        num1 = this.lookahead;
-      do
-      {
-        if ((int) this.window[curMatch + val1] == (int) num5 && (int) this.window[curMatch + val1 - 1] == (int) num4 && (int) this.window[curMatch] == (int) this.window[strstart] && (int) this.window[curMatch + 1] == (int) this.window[strstart + 1])
-        {
-          int num6 = curMatch + 2;
-          int num7 = strstart + 2;
-          int num8;
-          int num9;
-          int num10;
-          int num11;
-          int num12;
-          int num13;
-          int num14;
-          do
-            ;
-          while ((int) this.window[++num7] == (int) this.window[num8 = num6 + 1] && (int) this.window[++num7] == (int) this.window[num9 = num8 + 1] && (int) this.window[++num7] == (int) this.window[num10 = num9 + 1] && (int) this.window[++num7] == (int) this.window[num11 = num10 + 1] && (int) this.window[++num7] == (int) this.window[num12 = num11 + 1] && (int) this.window[++num7] == (int) this.window[num13 = num12 + 1] && (int) this.window[++num7] == (int) this.window[num14 = num13 + 1] && (int) this.window[++num7] == (int) this.window[num6 = num14 + 1] && num7 < num3);
-          if (num7 > index)
-          {
-            this.matchStart = curMatch;
-            index = num7;
-            val1 = num7 - this.strstart;
-            if (val1 < num1)
-            {
-              num4 = this.window[index - 1];
-              num5 = this.window[index];
-            }
-            else
-              break;
-          }
-          strstart = this.strstart;
-        }
-      }
-      while ((curMatch = (int) prev[curMatch & (int) short.MaxValue] & (int) ushort.MaxValue) > num2 && --maxChain != 0);
-      this.matchLen = Math.Min(val1, this.lookahead);
-      return this.matchLen >= 3;
-    }
-
-    private bool DeflateStored(bool flush, bool finish)
-    {
-      if (!flush && this.lookahead == 0)
-        return false;
-      this.strstart += this.lookahead;
-      this.lookahead = 0;
-      int storedLength = this.strstart - this.blockStart;
-      if (storedLength < DeflaterConstants.MAX_BLOCK_SIZE && (this.blockStart >= 32768 || storedLength < 32506) && !flush)
-        return true;
-      bool lastBlock = finish;
-      if (storedLength > DeflaterConstants.MAX_BLOCK_SIZE)
-      {
-        storedLength = DeflaterConstants.MAX_BLOCK_SIZE;
-        lastBlock = false;
-      }
-      this.huffman.FlushStoredBlock(this.window, this.blockStart, storedLength, lastBlock);
-      this.blockStart += storedLength;
-      return !lastBlock;
-    }
-
-    private bool DeflateFast(bool flush, bool finish)
-    {
-      if (this.lookahead < 262 && !flush)
-        return false;
-      while (this.lookahead >= 262 || flush)
-      {
-        if (this.lookahead == 0)
-        {
-          this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, finish);
-          this.blockStart = this.strstart;
-          return false;
-        }
-        if (this.strstart > 65274)
-          this.SlideWindow();
-        int curMatch;
-        if (this.lookahead >= 3 && (curMatch = this.InsertString()) != 0 && this.strategy != DeflateStrategy.HuffmanOnly && this.strstart - curMatch <= 32506 && this.FindLongestMatch(curMatch))
-        {
-          bool flag = this.huffman.TallyDist(this.strstart - this.matchStart, this.matchLen);
-          this.lookahead -= this.matchLen;
-          if (this.matchLen <= this.max_lazy && this.lookahead >= 3)
-          {
-            while (--this.matchLen > 0)
-            {
-              ++this.strstart;
-              this.InsertString();
-            }
-            ++this.strstart;
-          }
-          else
-          {
-            this.strstart += this.matchLen;
-            if (this.lookahead >= 2)
-              this.UpdateHash();
-          }
-          this.matchLen = 2;
-          if (!flag)
-            continue;
-        }
-        else
-        {
-          this.huffman.TallyLit((int) this.window[this.strstart] & (int) byte.MaxValue);
-          ++this.strstart;
-          --this.lookahead;
-        }
-        if (this.huffman.IsFull())
-        {
-          bool lastBlock = finish && this.lookahead == 0;
-          this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, lastBlock);
-          this.blockStart = this.strstart;
-          return !lastBlock;
-        }
-      }
-      return true;
-    }
-
-    private bool DeflateSlow(bool flush, bool finish)
-    {
-      if (this.lookahead < 262 && !flush)
-        return false;
-      while (this.lookahead >= 262 || flush)
-      {
-        if (this.lookahead == 0)
-        {
-          if (this.prevAvailable)
-            this.huffman.TallyLit((int) this.window[this.strstart - 1] & (int) byte.MaxValue);
-          this.prevAvailable = false;
-          this.huffman.FlushBlock(this.window, this.blockStart, this.strstart - this.blockStart, finish);
-          this.blockStart = this.strstart;
-          return false;
-        }
-        if (this.strstart >= 65274)
-          this.SlideWindow();
-        int matchStart = this.matchStart;
-        int matchLen = this.matchLen;
-        if (this.lookahead >= 3)
-        {
-          int curMatch = this.InsertString();
-          if (this.strategy != DeflateStrategy.HuffmanOnly && curMatch != 0 && this.strstart - curMatch <= 32506 && this.FindLongestMatch(curMatch) && this.matchLen <= 5 && (this.strategy == DeflateStrategy.Filtered || this.matchLen == 3 && this.strstart - this.matchStart > 4096))
-            this.matchLen = 2;
-        }
-        if (matchLen >= 3 && this.matchLen <= matchLen)
-        {
-          this.huffman.TallyDist(this.strstart - 1 - matchStart, matchLen);
-          int num = matchLen - 2;
-          do
-          {
-            ++this.strstart;
-            --this.lookahead;
-            if (this.lookahead >= 3)
-              this.InsertString();
-          }
-          while (--num > 0);
-          ++this.strstart;
-          --this.lookahead;
-          this.prevAvailable = false;
-          this.matchLen = 2;
-        }
-        else
-        {
-          if (this.prevAvailable)
-            this.huffman.TallyLit((int) this.window[this.strstart - 1] & (int) byte.MaxValue);
-          this.prevAvailable = true;
-          ++this.strstart;
-          --this.lookahead;
-        }
-        if (this.huffman.IsFull())
-        {
-          int storedLength = this.strstart - this.blockStart;
-          if (this.prevAvailable)
-            --storedLength;
-          bool lastBlock = finish && this.lookahead == 0 && !this.prevAvailable;
-          this.huffman.FlushBlock(this.window, this.blockStart, storedLength, lastBlock);
-          this.blockStart += storedLength;
-          return !lastBlock;
-        }
-      }
-      return true;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterHuffman.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterHuffman.cs
deleted file mode 100644
index 4147444..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterHuffman.cs
+++ /dev/null
@@ -1,582 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class DeflaterHuffman
-  {
-    private const int BUFSIZE = 16384;
-    private const int LITERAL_NUM = 286;
-    private const int DIST_NUM = 30;
-    private const int BITLEN_NUM = 19;
-    private const int REP_3_6 = 16;
-    private const int REP_3_10 = 17;
-    private const int REP_11_138 = 18;
-    private const int EOF_SYMBOL = 256;
-    private static readonly int[] BL_ORDER = new int[19]
-    {
-      16,
-      17,
-      18,
-      0,
-      8,
-      7,
-      9,
-      6,
-      10,
-      5,
-      11,
-      4,
-      12,
-      3,
-      13,
-      2,
-      14,
-      1,
-      15
-    };
-    private static readonly byte[] bit4Reverse = new byte[16]
-    {
-      (byte) 0,
-      (byte) 8,
-      (byte) 4,
-      (byte) 12,
-      (byte) 2,
-      (byte) 10,
-      (byte) 6,
-      (byte) 14,
-      (byte) 1,
-      (byte) 9,
-      (byte) 5,
-      (byte) 13,
-      (byte) 3,
-      (byte) 11,
-      (byte) 7,
-      (byte) 15
-    };
-    private static short[] staticLCodes = new short[286];
-    private static byte[] staticLLength = new byte[286];
-    private static short[] staticDCodes;
-    private static byte[] staticDLength;
-    public DeflaterPending pending;
-    private DeflaterHuffman.Tree literalTree;
-    private DeflaterHuffman.Tree distTree;
-    private DeflaterHuffman.Tree blTree;
-    private short[] d_buf;
-    private byte[] l_buf;
-    private int last_lit;
-    private int extra_bits;
-
-    static DeflaterHuffman()
-    {
-      int index1;
-      for (index1 = 0; index1 < 144; DeflaterHuffman.staticLLength[index1++] = (byte) 8)
-        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(48 + index1 << 8);
-      for (; index1 < 256; DeflaterHuffman.staticLLength[index1++] = (byte) 9)
-        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(256 + index1 << 7);
-      for (; index1 < 280; DeflaterHuffman.staticLLength[index1++] = (byte) 7)
-        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(index1 - 256 << 9);
-      for (; index1 < 286; DeflaterHuffman.staticLLength[index1++] = (byte) 8)
-        DeflaterHuffman.staticLCodes[index1] = DeflaterHuffman.BitReverse(index1 - 88 << 8);
-      DeflaterHuffman.staticDCodes = new short[30];
-      DeflaterHuffman.staticDLength = new byte[30];
-      for (int index2 = 0; index2 < 30; ++index2)
-      {
-        DeflaterHuffman.staticDCodes[index2] = DeflaterHuffman.BitReverse(index2 << 11);
-        DeflaterHuffman.staticDLength[index2] = (byte) 5;
-      }
-    }
-
-    public DeflaterHuffman(DeflaterPending pending)
-    {
-      this.pending = pending;
-      this.literalTree = new DeflaterHuffman.Tree(this, 286, 257, 15);
-      this.distTree = new DeflaterHuffman.Tree(this, 30, 1, 15);
-      this.blTree = new DeflaterHuffman.Tree(this, 19, 4, 7);
-      this.d_buf = new short[16384];
-      this.l_buf = new byte[16384];
-    }
-
-    public void Reset()
-    {
-      this.last_lit = 0;
-      this.extra_bits = 0;
-      this.literalTree.Reset();
-      this.distTree.Reset();
-      this.blTree.Reset();
-    }
-
-    public void SendAllTrees(int blTreeCodes)
-    {
-      this.blTree.BuildCodes();
-      this.literalTree.BuildCodes();
-      this.distTree.BuildCodes();
-      this.pending.WriteBits(this.literalTree.numCodes - 257, 5);
-      this.pending.WriteBits(this.distTree.numCodes - 1, 5);
-      this.pending.WriteBits(blTreeCodes - 4, 4);
-      for (int index = 0; index < blTreeCodes; ++index)
-        this.pending.WriteBits((int) this.blTree.length[DeflaterHuffman.BL_ORDER[index]], 3);
-      this.literalTree.WriteTree(this.blTree);
-      this.distTree.WriteTree(this.blTree);
-    }
-
-    public void CompressBlock()
-    {
-      for (int index = 0; index < this.last_lit; ++index)
-      {
-        int num1 = (int) this.l_buf[index] & (int) byte.MaxValue;
-        int num2 = (int) this.d_buf[index];
-        int distance = num2 - 1;
-        if (num2 != 0)
-        {
-          int code1 = DeflaterHuffman.Lcode(num1);
-          this.literalTree.WriteSymbol(code1);
-          int count1 = (code1 - 261) / 4;
-          if (count1 > 0 && count1 <= 5)
-            this.pending.WriteBits(num1 & (1 << count1) - 1, count1);
-          int code2 = DeflaterHuffman.Dcode(distance);
-          this.distTree.WriteSymbol(code2);
-          int count2 = code2 / 2 - 1;
-          if (count2 > 0)
-            this.pending.WriteBits(distance & (1 << count2) - 1, count2);
-        }
-        else
-          this.literalTree.WriteSymbol(num1);
-      }
-      this.literalTree.WriteSymbol(256);
-    }
-
-    public void FlushStoredBlock(
-      byte[] stored,
-      int storedOffset,
-      int storedLength,
-      bool lastBlock)
-    {
-      this.pending.WriteBits(lastBlock ? 1 : 0, 3);
-      this.pending.AlignToByte();
-      this.pending.WriteShort(storedLength);
-      this.pending.WriteShort(~storedLength);
-      this.pending.WriteBlock(stored, storedOffset, storedLength);
-      this.Reset();
-    }
-
-    public void FlushBlock(byte[] stored, int storedOffset, int storedLength, bool lastBlock)
-    {
-      ++this.literalTree.freqs[256];
-      this.literalTree.BuildTree();
-      this.distTree.BuildTree();
-      this.literalTree.CalcBLFreq(this.blTree);
-      this.distTree.CalcBLFreq(this.blTree);
-      this.blTree.BuildTree();
-      int blTreeCodes = 4;
-      for (int index = 18; index > blTreeCodes; --index)
-      {
-        if (this.blTree.length[DeflaterHuffman.BL_ORDER[index]] > (byte) 0)
-          blTreeCodes = index + 1;
-      }
-      int num = 14 + blTreeCodes * 3 + this.blTree.GetEncodedLength() + this.literalTree.GetEncodedLength() + this.distTree.GetEncodedLength() + this.extra_bits;
-      int extraBits = this.extra_bits;
-      for (int index = 0; index < 286; ++index)
-        extraBits += (int) this.literalTree.freqs[index] * (int) DeflaterHuffman.staticLLength[index];
-      for (int index = 0; index < 30; ++index)
-        extraBits += (int) this.distTree.freqs[index] * (int) DeflaterHuffman.staticDLength[index];
-      if (num >= extraBits)
-        num = extraBits;
-      if (storedOffset >= 0 && storedLength + 4 < num >> 3)
-        this.FlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
-      else if (num == extraBits)
-      {
-        this.pending.WriteBits(2 + (lastBlock ? 1 : 0), 3);
-        this.literalTree.SetStaticCodes(DeflaterHuffman.staticLCodes, DeflaterHuffman.staticLLength);
-        this.distTree.SetStaticCodes(DeflaterHuffman.staticDCodes, DeflaterHuffman.staticDLength);
-        this.CompressBlock();
-        this.Reset();
-      }
-      else
-      {
-        this.pending.WriteBits(4 + (lastBlock ? 1 : 0), 3);
-        this.SendAllTrees(blTreeCodes);
-        this.CompressBlock();
-        this.Reset();
-      }
-    }
-
-    public bool IsFull() => this.last_lit >= 16384;
-
-    public bool TallyLit(int literal)
-    {
-      this.d_buf[this.last_lit] = (short) 0;
-      this.l_buf[this.last_lit++] = (byte) literal;
-      ++this.literalTree.freqs[literal];
-      return this.IsFull();
-    }
-
-    public bool TallyDist(int distance, int length)
-    {
-      this.d_buf[this.last_lit] = (short) distance;
-      this.l_buf[this.last_lit++] = (byte) (length - 3);
-      int index1 = DeflaterHuffman.Lcode(length - 3);
-      ++this.literalTree.freqs[index1];
-      if (index1 >= 265 && index1 < 285)
-        this.extra_bits += (index1 - 261) / 4;
-      int index2 = DeflaterHuffman.Dcode(distance - 1);
-      ++this.distTree.freqs[index2];
-      if (index2 >= 4)
-        this.extra_bits += index2 / 2 - 1;
-      return this.IsFull();
-    }
-
-    public static short BitReverse(int toReverse)
-    {
-      return (short) ((int) DeflaterHuffman.bit4Reverse[toReverse & 15] << 12 | (int) DeflaterHuffman.bit4Reverse[toReverse >> 4 & 15] << 8 | (int) DeflaterHuffman.bit4Reverse[toReverse >> 8 & 15] << 4 | (int) DeflaterHuffman.bit4Reverse[toReverse >> 12]);
-    }
-
-    private static int Lcode(int length)
-    {
-      if (length == (int) byte.MaxValue)
-        return 285;
-      int num = 257;
-      for (; length >= 8; length >>= 1)
-        num += 4;
-      return num + length;
-    }
-
-    private static int Dcode(int distance)
-    {
-      int num = 0;
-      for (; distance >= 4; distance >>= 1)
-        num += 2;
-      return num + distance;
-    }
-
-    private class Tree
-    {
-      public short[] freqs;
-      public byte[] length;
-      public int minNumCodes;
-      public int numCodes;
-      private short[] codes;
-      private int[] bl_counts;
-      private int maxLength;
-      private DeflaterHuffman dh;
-
-      public Tree(DeflaterHuffman dh, int elems, int minCodes, int maxLength)
-      {
-        this.dh = dh;
-        this.minNumCodes = minCodes;
-        this.maxLength = maxLength;
-        this.freqs = new short[elems];
-        this.bl_counts = new int[maxLength];
-      }
-
-      public void Reset()
-      {
-        for (int index = 0; index < this.freqs.Length; ++index)
-          this.freqs[index] = (short) 0;
-        this.codes = (short[]) null;
-        this.length = (byte[]) null;
-      }
-
-      public void WriteSymbol(int code)
-      {
-        this.dh.pending.WriteBits((int) this.codes[code] & (int) ushort.MaxValue, (int) this.length[code]);
-      }
-
-      public void CheckEmpty()
-      {
-        bool flag = true;
-        for (int index = 0; index < this.freqs.Length; ++index)
-        {
-          if (this.freqs[index] != (short) 0)
-            flag = false;
-        }
-        if (!flag)
-          throw new SharpZipBaseException("!Empty");
-      }
-
-      public void SetStaticCodes(short[] staticCodes, byte[] staticLengths)
-      {
-        this.codes = staticCodes;
-        this.length = staticLengths;
-      }
-
-      public void BuildCodes()
-      {
-        int length = this.freqs.Length;
-        int[] numArray = new int[this.maxLength];
-        int num1 = 0;
-        this.codes = new short[this.freqs.Length];
-        for (int index = 0; index < this.maxLength; ++index)
-        {
-          numArray[index] = num1;
-          num1 += this.bl_counts[index] << 15 - index;
-        }
-        for (int index = 0; index < this.numCodes; ++index)
-        {
-          int num2 = (int) this.length[index];
-          if (num2 > 0)
-          {
-            this.codes[index] = DeflaterHuffman.BitReverse(numArray[num2 - 1]);
-            numArray[num2 - 1] += 1 << 16 - num2;
-          }
-        }
-      }
-
-      public void BuildTree()
-      {
-        int length = this.freqs.Length;
-        int[] numArray1 = new int[length];
-        int num1 = 0;
-        int num2 = 0;
-        for (int index1 = 0; index1 < length; ++index1)
-        {
-          int freq = (int) this.freqs[index1];
-          if (freq != 0)
-          {
-            int index2;
-            int index3;
-            for (index2 = num1++; index2 > 0 && (int) this.freqs[numArray1[index3 = (index2 - 1) / 2]] > freq; index2 = index3)
-              numArray1[index2] = numArray1[index3];
-            numArray1[index2] = index1;
-            num2 = index1;
-          }
-        }
-        int num3;
-        for (; num1 < 2; numArray1[num1++] = num3)
-        {
-          int num4;
-          if (num2 >= 2)
-            num4 = 0;
-          else
-            num2 = num4 = num2 + 1;
-          num3 = num4;
-        }
-        this.numCodes = Math.Max(num2 + 1, this.minNumCodes);
-        int num5 = num1;
-        int[] childs = new int[4 * num1 - 2];
-        int[] numArray2 = new int[2 * num1 - 1];
-        int num6 = num5;
-        for (int index4 = 0; index4 < num1; ++index4)
-        {
-          int index5 = numArray1[index4];
-          childs[2 * index4] = index5;
-          childs[2 * index4 + 1] = -1;
-          numArray2[index4] = (int) this.freqs[index5] << 8;
-          numArray1[index4] = index4;
-        }
-        do
-        {
-          int index6 = numArray1[0];
-          int index7 = numArray1[--num1];
-          int index8 = 0;
-          for (int index9 = 1; index9 < num1; index9 = index9 * 2 + 1)
-          {
-            if (index9 + 1 < num1 && numArray2[numArray1[index9]] > numArray2[numArray1[index9 + 1]])
-              ++index9;
-            numArray1[index8] = numArray1[index9];
-            index8 = index9;
-          }
-          int num7 = numArray2[index7];
-          int index10;
-          while ((index10 = index8) > 0 && numArray2[numArray1[index8 = (index10 - 1) / 2]] > num7)
-            numArray1[index10] = numArray1[index8];
-          numArray1[index10] = index7;
-          int index11 = numArray1[0];
-          int index12 = num6++;
-          childs[2 * index12] = index6;
-          childs[2 * index12 + 1] = index11;
-          int num8 = Math.Min(numArray2[index6] & (int) byte.MaxValue, numArray2[index11] & (int) byte.MaxValue);
-          int num9;
-          numArray2[index12] = num9 = numArray2[index6] + numArray2[index11] - num8 + 1;
-          int index13 = 0;
-          for (int index14 = 1; index14 < num1; index14 = index13 * 2 + 1)
-          {
-            if (index14 + 1 < num1 && numArray2[numArray1[index14]] > numArray2[numArray1[index14 + 1]])
-              ++index14;
-            numArray1[index13] = numArray1[index14];
-            index13 = index14;
-          }
-          int index15;
-          while ((index15 = index13) > 0 && numArray2[numArray1[index13 = (index15 - 1) / 2]] > num9)
-            numArray1[index15] = numArray1[index13];
-          numArray1[index15] = index12;
-        }
-        while (num1 > 1);
-        if (numArray1[0] != childs.Length / 2 - 1)
-          throw new SharpZipBaseException("Heap invariant violated");
-        this.BuildLength(childs);
-      }
-
-      public int GetEncodedLength()
-      {
-        int encodedLength = 0;
-        for (int index = 0; index < this.freqs.Length; ++index)
-          encodedLength += (int) this.freqs[index] * (int) this.length[index];
-        return encodedLength;
-      }
-
-      public void CalcBLFreq(DeflaterHuffman.Tree blTree)
-      {
-        int index1 = -1;
-        int index2 = 0;
-        while (index2 < this.numCodes)
-        {
-          int num1 = 1;
-          int index3 = (int) this.length[index2];
-          int num2;
-          int num3;
-          if (index3 == 0)
-          {
-            num2 = 138;
-            num3 = 3;
-          }
-          else
-          {
-            num2 = 6;
-            num3 = 3;
-            if (index1 != index3)
-            {
-              ++blTree.freqs[index3];
-              num1 = 0;
-            }
-          }
-          index1 = index3;
-          ++index2;
-          while (index2 < this.numCodes && index1 == (int) this.length[index2])
-          {
-            ++index2;
-            if (++num1 >= num2)
-              break;
-          }
-          if (num1 < num3)
-            blTree.freqs[index1] += (short) num1;
-          else if (index1 != 0)
-            ++blTree.freqs[16];
-          else if (num1 <= 10)
-            ++blTree.freqs[17];
-          else
-            ++blTree.freqs[18];
-        }
-      }
-
-      public void WriteTree(DeflaterHuffman.Tree blTree)
-      {
-        int code1 = -1;
-        int index = 0;
-        while (index < this.numCodes)
-        {
-          int num1 = 1;
-          int code2 = (int) this.length[index];
-          int num2;
-          int num3;
-          if (code2 == 0)
-          {
-            num2 = 138;
-            num3 = 3;
-          }
-          else
-          {
-            num2 = 6;
-            num3 = 3;
-            if (code1 != code2)
-            {
-              blTree.WriteSymbol(code2);
-              num1 = 0;
-            }
-          }
-          code1 = code2;
-          ++index;
-          while (index < this.numCodes && code1 == (int) this.length[index])
-          {
-            ++index;
-            if (++num1 >= num2)
-              break;
-          }
-          if (num1 < num3)
-          {
-            while (num1-- > 0)
-              blTree.WriteSymbol(code1);
-          }
-          else if (code1 != 0)
-          {
-            blTree.WriteSymbol(16);
-            this.dh.pending.WriteBits(num1 - 3, 2);
-          }
-          else if (num1 <= 10)
-          {
-            blTree.WriteSymbol(17);
-            this.dh.pending.WriteBits(num1 - 3, 3);
-          }
-          else
-          {
-            blTree.WriteSymbol(18);
-            this.dh.pending.WriteBits(num1 - 11, 7);
-          }
-        }
-      }
-
-      private void BuildLength(int[] childs)
-      {
-        this.length = new byte[this.freqs.Length];
-        int length = childs.Length / 2;
-        int num1 = (length + 1) / 2;
-        int num2 = 0;
-        for (int index = 0; index < this.maxLength; ++index)
-          this.bl_counts[index] = 0;
-        int[] numArray = new int[length];
-        numArray[length - 1] = 0;
-        for (int index = length - 1; index >= 0; --index)
-        {
-          if (childs[2 * index + 1] != -1)
-          {
-            int num3 = numArray[index] + 1;
-            if (num3 > this.maxLength)
-            {
-              num3 = this.maxLength;
-              ++num2;
-            }
-            numArray[childs[2 * index]] = numArray[childs[2 * index + 1]] = num3;
-          }
-          else
-          {
-            ++this.bl_counts[numArray[index] - 1];
-            this.length[childs[2 * index]] = (byte) numArray[index];
-          }
-        }
-        if (num2 == 0)
-          return;
-        int index1 = this.maxLength - 1;
-        do
-        {
-          do
-            ;
-          while (this.bl_counts[--index1] == 0);
-          do
-          {
-            --this.bl_counts[index1];
-            ++this.bl_counts[++index1];
-            num2 -= 1 << this.maxLength - 1 - index1;
-          }
-          while (num2 > 0 && index1 < this.maxLength - 1);
-        }
-        while (num2 > 0);
-        this.bl_counts[this.maxLength - 1] += num2;
-        this.bl_counts[this.maxLength - 2] -= num2;
-        int num4 = 2 * num1;
-        for (int maxLength = this.maxLength; maxLength != 0; --maxLength)
-        {
-          int blCount = this.bl_counts[maxLength - 1];
-          while (blCount > 0)
-          {
-            int index2 = 2 * childs[num4++];
-            if (childs[index2 + 1] == -1)
-            {
-              this.length[childs[index2]] = (byte) maxLength;
-              --blCount;
-            }
-          }
-        }
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterPending.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterPending.cs
deleted file mode 100644
index 91ce8e1..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/DeflaterPending.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class DeflaterPending : PendingBuffer
-  {
-    public DeflaterPending()
-      : base(65536)
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Inflater.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Inflater.cs
deleted file mode 100644
index 9ede1bc..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Inflater.cs
+++ /dev/null
@@ -1,504 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class Inflater
-  {
-    private const int DECODE_HEADER = 0;
-    private const int DECODE_DICT = 1;
-    private const int DECODE_BLOCKS = 2;
-    private const int DECODE_STORED_LEN1 = 3;
-    private const int DECODE_STORED_LEN2 = 4;
-    private const int DECODE_STORED = 5;
-    private const int DECODE_DYN_HEADER = 6;
-    private const int DECODE_HUFFMAN = 7;
-    private const int DECODE_HUFFMAN_LENBITS = 8;
-    private const int DECODE_HUFFMAN_DIST = 9;
-    private const int DECODE_HUFFMAN_DISTBITS = 10;
-    private const int DECODE_CHKSUM = 11;
-    private const int FINISHED = 12;
-    private static readonly int[] CPLENS = new int[29]
-    {
-      3,
-      4,
-      5,
-      6,
-      7,
-      8,
-      9,
-      10,
-      11,
-      13,
-      15,
-      17,
-      19,
-      23,
-      27,
-      31,
-      35,
-      43,
-      51,
-      59,
-      67,
-      83,
-      99,
-      115,
-      131,
-      163,
-      195,
-      227,
-      258
-    };
-    private static readonly int[] CPLEXT = new int[29]
-    {
-      0,
-      0,
-      0,
-      0,
-      0,
-      0,
-      0,
-      0,
-      1,
-      1,
-      1,
-      1,
-      2,
-      2,
-      2,
-      2,
-      3,
-      3,
-      3,
-      3,
-      4,
-      4,
-      4,
-      4,
-      5,
-      5,
-      5,
-      5,
-      0
-    };
-    private static readonly int[] CPDIST = new int[30]
-    {
-      1,
-      2,
-      3,
-      4,
-      5,
-      7,
-      9,
-      13,
-      17,
-      25,
-      33,
-      49,
-      65,
-      97,
-      129,
-      193,
-      257,
-      385,
-      513,
-      769,
-      1025,
-      1537,
-      2049,
-      3073,
-      4097,
-      6145,
-      8193,
-      12289,
-      16385,
-      24577
-    };
-    private static readonly int[] CPDEXT = new int[30]
-    {
-      0,
-      0,
-      0,
-      0,
-      1,
-      1,
-      2,
-      2,
-      3,
-      3,
-      4,
-      4,
-      5,
-      5,
-      6,
-      6,
-      7,
-      7,
-      8,
-      8,
-      9,
-      9,
-      10,
-      10,
-      11,
-      11,
-      12,
-      12,
-      13,
-      13
-    };
-    private int mode;
-    private int readAdler;
-    private int neededBits;
-    private int repLength;
-    private int repDist;
-    private int uncomprLen;
-    private bool isLastBlock;
-    private long totalOut;
-    private long totalIn;
-    private bool noHeader;
-    private StreamManipulator input;
-    private OutputWindow outputWindow;
-    private InflaterDynHeader dynHeader;
-    private InflaterHuffmanTree litlenTree;
-    private InflaterHuffmanTree distTree;
-    private Adler32 adler;
-
-    public Inflater()
-      : this(false)
-    {
-    }
-
-    public Inflater(bool noHeader)
-    {
-      this.noHeader = noHeader;
-      this.adler = new Adler32();
-      this.input = new StreamManipulator();
-      this.outputWindow = new OutputWindow();
-      this.mode = noHeader ? 2 : 0;
-    }
-
-    public void Reset()
-    {
-      this.mode = this.noHeader ? 2 : 0;
-      this.totalIn = 0L;
-      this.totalOut = 0L;
-      this.input.Reset();
-      this.outputWindow.Reset();
-      this.dynHeader = (InflaterDynHeader) null;
-      this.litlenTree = (InflaterHuffmanTree) null;
-      this.distTree = (InflaterHuffmanTree) null;
-      this.isLastBlock = false;
-      this.adler.Reset();
-    }
-
-    private bool DecodeHeader()
-    {
-      int num1 = this.input.PeekBits(16);
-      if (num1 < 0)
-        return false;
-      this.input.DropBits(16);
-      int num2 = (num1 << 8 | num1 >> 8) & (int) ushort.MaxValue;
-      if (num2 % 31 != 0)
-        throw new SharpZipBaseException("Header checksum illegal");
-      if ((num2 & 3840) != 2048)
-        throw new SharpZipBaseException("Compression Method unknown");
-      if ((num2 & 32) == 0)
-      {
-        this.mode = 2;
-      }
-      else
-      {
-        this.mode = 1;
-        this.neededBits = 32;
-      }
-      return true;
-    }
-
-    private bool DecodeDict()
-    {
-      for (; this.neededBits > 0; this.neededBits -= 8)
-      {
-        int num = this.input.PeekBits(8);
-        if (num < 0)
-          return false;
-        this.input.DropBits(8);
-        this.readAdler = this.readAdler << 8 | num;
-      }
-      return false;
-    }
-
-    private bool DecodeHuffman()
-    {
-      int freeSpace = this.outputWindow.GetFreeSpace();
-      while (freeSpace >= 258)
-      {
-        switch (this.mode)
-        {
-          case 7:
-            int symbol1;
-            while (((symbol1 = this.litlenTree.GetSymbol(this.input)) & -256) == 0)
-            {
-              this.outputWindow.Write(symbol1);
-              if (--freeSpace < 258)
-                return true;
-            }
-            if (symbol1 < 257)
-            {
-              if (symbol1 < 0)
-                return false;
-              this.distTree = (InflaterHuffmanTree) null;
-              this.litlenTree = (InflaterHuffmanTree) null;
-              this.mode = 2;
-              return true;
-            }
-            try
-            {
-              this.repLength = Inflater.CPLENS[symbol1 - 257];
-              this.neededBits = Inflater.CPLEXT[symbol1 - 257];
-              goto case 8;
-            }
-            catch (Exception ex)
-            {
-              throw new SharpZipBaseException("Illegal rep length code");
-            }
-          case 8:
-            if (this.neededBits > 0)
-            {
-              this.mode = 8;
-              int num = this.input.PeekBits(this.neededBits);
-              if (num < 0)
-                return false;
-              this.input.DropBits(this.neededBits);
-              this.repLength += num;
-            }
-            this.mode = 9;
-            goto case 9;
-          case 9:
-            int symbol2 = this.distTree.GetSymbol(this.input);
-            if (symbol2 < 0)
-              return false;
-            try
-            {
-              this.repDist = Inflater.CPDIST[symbol2];
-              this.neededBits = Inflater.CPDEXT[symbol2];
-              goto case 10;
-            }
-            catch (Exception ex)
-            {
-              throw new SharpZipBaseException("Illegal rep dist code");
-            }
-          case 10:
-            if (this.neededBits > 0)
-            {
-              this.mode = 10;
-              int num = this.input.PeekBits(this.neededBits);
-              if (num < 0)
-                return false;
-              this.input.DropBits(this.neededBits);
-              this.repDist += num;
-            }
-            this.outputWindow.Repeat(this.repLength, this.repDist);
-            freeSpace -= this.repLength;
-            this.mode = 7;
-            continue;
-          default:
-            throw new SharpZipBaseException("Inflater unknown mode");
-        }
-      }
-      return true;
-    }
-
-    private bool DecodeChksum()
-    {
-      for (; this.neededBits > 0; this.neededBits -= 8)
-      {
-        int num = this.input.PeekBits(8);
-        if (num < 0)
-          return false;
-        this.input.DropBits(8);
-        this.readAdler = this.readAdler << 8 | num;
-      }
-      if ((int) this.adler.Value != this.readAdler)
-        throw new SharpZipBaseException("Adler chksum doesn't match: " + (object) (int) this.adler.Value + " vs. " + (object) this.readAdler);
-      this.mode = 12;
-      return false;
-    }
-
-    private bool Decode()
-    {
-      switch (this.mode)
-      {
-        case 0:
-          return this.DecodeHeader();
-        case 1:
-          return this.DecodeDict();
-        case 2:
-          if (this.isLastBlock)
-          {
-            if (this.noHeader)
-            {
-              this.mode = 12;
-              return false;
-            }
-            this.input.SkipToByteBoundary();
-            this.neededBits = 32;
-            this.mode = 11;
-            return true;
-          }
-          int num1 = this.input.PeekBits(3);
-          if (num1 < 0)
-            return false;
-          this.input.DropBits(3);
-          if ((num1 & 1) != 0)
-            this.isLastBlock = true;
-          switch (num1 >> 1)
-          {
-            case 0:
-              this.input.SkipToByteBoundary();
-              this.mode = 3;
-              break;
-            case 1:
-              this.litlenTree = InflaterHuffmanTree.defLitLenTree;
-              this.distTree = InflaterHuffmanTree.defDistTree;
-              this.mode = 7;
-              break;
-            case 2:
-              this.dynHeader = new InflaterDynHeader();
-              this.mode = 6;
-              break;
-            default:
-              throw new SharpZipBaseException("Unknown block type " + (object) num1);
-          }
-          return true;
-        case 3:
-          if ((this.uncomprLen = this.input.PeekBits(16)) < 0)
-            return false;
-          this.input.DropBits(16);
-          this.mode = 4;
-          goto case 4;
-        case 4:
-          int num2 = this.input.PeekBits(16);
-          if (num2 < 0)
-            return false;
-          this.input.DropBits(16);
-          if (num2 != (this.uncomprLen ^ (int) ushort.MaxValue))
-            throw new SharpZipBaseException("broken uncompressed block");
-          this.mode = 5;
-          goto case 5;
-        case 5:
-          this.uncomprLen -= this.outputWindow.CopyStored(this.input, this.uncomprLen);
-          if (this.uncomprLen != 0)
-            return !this.input.IsNeedingInput;
-          this.mode = 2;
-          return true;
-        case 6:
-          if (!this.dynHeader.Decode(this.input))
-            return false;
-          this.litlenTree = this.dynHeader.BuildLitLenTree();
-          this.distTree = this.dynHeader.BuildDistTree();
-          this.mode = 7;
-          goto case 7;
-        case 7:
-        case 8:
-        case 9:
-        case 10:
-          return this.DecodeHuffman();
-        case 11:
-          return this.DecodeChksum();
-        case 12:
-          return false;
-        default:
-          throw new SharpZipBaseException("Inflater.Decode unknown mode");
-      }
-    }
-
-    public void SetDictionary(byte[] buffer) => this.SetDictionary(buffer, 0, buffer.Length);
-
-    public void SetDictionary(byte[] buffer, int index, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (index < 0)
-        throw new ArgumentOutOfRangeException(nameof (index));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (!this.IsNeedingDictionary)
-        throw new InvalidOperationException("Dictionary is not needed");
-      this.adler.Update(buffer, index, count);
-      if ((int) this.adler.Value != this.readAdler)
-        throw new SharpZipBaseException("Wrong adler checksum");
-      this.adler.Reset();
-      this.outputWindow.CopyDict(buffer, index, count);
-      this.mode = 2;
-    }
-
-    public void SetInput(byte[] buffer) => this.SetInput(buffer, 0, buffer.Length);
-
-    public void SetInput(byte[] buffer, int index, int count)
-    {
-      this.input.SetInput(buffer, index, count);
-      this.totalIn += (long) count;
-    }
-
-    public int Inflate(byte[] buffer)
-    {
-      return buffer != null ? this.Inflate(buffer, 0, buffer.Length) : throw new ArgumentNullException(nameof (buffer));
-    }
-
-    public int Inflate(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "count cannot be negative");
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "offset cannot be negative");
-      if (offset + count > buffer.Length)
-        throw new ArgumentException("count exceeds buffer bounds");
-      if (count == 0)
-      {
-        if (!this.IsFinished)
-          this.Decode();
-        return 0;
-      }
-      int num = 0;
-      do
-      {
-        if (this.mode != 11)
-        {
-          int count1 = this.outputWindow.CopyOutput(buffer, offset, count);
-          if (count1 > 0)
-          {
-            this.adler.Update(buffer, offset, count1);
-            offset += count1;
-            num += count1;
-            this.totalOut += (long) count1;
-            count -= count1;
-            if (count == 0)
-              return num;
-          }
-        }
-      }
-      while (this.Decode() || this.outputWindow.GetAvailable() > 0 && this.mode != 11);
-      return num;
-    }
-
-    public bool IsNeedingInput => this.input.IsNeedingInput;
-
-    public bool IsNeedingDictionary => this.mode == 1 && this.neededBits == 0;
-
-    public bool IsFinished => this.mode == 12 && this.outputWindow.GetAvailable() == 0;
-
-    public int Adler => !this.IsNeedingDictionary ? (int) this.adler.Value : this.readAdler;
-
-    public long TotalOut => this.totalOut;
-
-    public long TotalIn => this.totalIn - (long) this.RemainingInput;
-
-    public int RemainingInput => this.input.AvailableBytes;
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/InflaterDynHeader.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/InflaterDynHeader.cs
deleted file mode 100644
index cc9b054..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/InflaterDynHeader.cs
+++ /dev/null
@@ -1,197 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  internal class InflaterDynHeader
-  {
-    private const int LNUM = 0;
-    private const int DNUM = 1;
-    private const int BLNUM = 2;
-    private const int BLLENS = 3;
-    private const int LENS = 4;
-    private const int REPS = 5;
-    private static readonly int[] repMin = new int[3]
-    {
-      3,
-      3,
-      11
-    };
-    private static readonly int[] repBits = new int[3]
-    {
-      2,
-      3,
-      7
-    };
-    private static readonly int[] BL_ORDER = new int[19]
-    {
-      16,
-      17,
-      18,
-      0,
-      8,
-      7,
-      9,
-      6,
-      10,
-      5,
-      11,
-      4,
-      12,
-      3,
-      13,
-      2,
-      14,
-      1,
-      15
-    };
-    private byte[] blLens;
-    private byte[] litdistLens;
-    private InflaterHuffmanTree blTree;
-    private int mode;
-    private int lnum;
-    private int dnum;
-    private int blnum;
-    private int num;
-    private int repSymbol;
-    private byte lastLen;
-    private int ptr;
-
-    public bool Decode(StreamManipulator input)
-    {
-      while (true)
-      {
-        switch (this.mode)
-        {
-          case 0:
-            this.lnum = input.PeekBits(5);
-            if (this.lnum >= 0)
-            {
-              this.lnum += 257;
-              input.DropBits(5);
-              this.mode = 1;
-              goto case 1;
-            }
-            else
-              goto label_2;
-          case 1:
-            this.dnum = input.PeekBits(5);
-            if (this.dnum >= 0)
-            {
-              ++this.dnum;
-              input.DropBits(5);
-              this.num = this.lnum + this.dnum;
-              this.litdistLens = new byte[this.num];
-              this.mode = 2;
-              goto case 2;
-            }
-            else
-              goto label_5;
-          case 2:
-            this.blnum = input.PeekBits(4);
-            if (this.blnum >= 0)
-            {
-              this.blnum += 4;
-              input.DropBits(4);
-              this.blLens = new byte[19];
-              this.ptr = 0;
-              this.mode = 3;
-              goto case 3;
-            }
-            else
-              goto label_8;
-          case 3:
-            for (; this.ptr < this.blnum; ++this.ptr)
-            {
-              int num = input.PeekBits(3);
-              if (num < 0)
-                return false;
-              input.DropBits(3);
-              this.blLens[InflaterDynHeader.BL_ORDER[this.ptr]] = (byte) num;
-            }
-            this.blTree = new InflaterHuffmanTree(this.blLens);
-            this.blLens = (byte[]) null;
-            this.ptr = 0;
-            this.mode = 4;
-            goto case 4;
-          case 4:
-            int symbol;
-            while (((symbol = this.blTree.GetSymbol(input)) & -16) == 0)
-            {
-              this.litdistLens[this.ptr++] = this.lastLen = (byte) symbol;
-              if (this.ptr == this.num)
-                return true;
-            }
-            if (symbol >= 0)
-            {
-              if (symbol >= 17)
-                this.lastLen = (byte) 0;
-              else if (this.ptr == 0)
-                goto label_23;
-              this.repSymbol = symbol - 16;
-              this.mode = 5;
-              goto case 5;
-            }
-            else
-              goto label_19;
-          case 5:
-            int repBit = InflaterDynHeader.repBits[this.repSymbol];
-            int num1 = input.PeekBits(repBit);
-            if (num1 >= 0)
-            {
-              input.DropBits(repBit);
-              int num2 = num1 + InflaterDynHeader.repMin[this.repSymbol];
-              if (this.ptr + num2 <= this.num)
-              {
-                while (num2-- > 0)
-                  this.litdistLens[this.ptr++] = this.lastLen;
-                if (this.ptr != this.num)
-                {
-                  this.mode = 4;
-                  continue;
-                }
-                goto label_32;
-              }
-              else
-                goto label_28;
-            }
-            else
-              goto label_26;
-          default:
-            continue;
-        }
-      }
-label_2:
-      return false;
-label_5:
-      return false;
-label_8:
-      return false;
-label_19:
-      return false;
-label_23:
-      throw new SharpZipBaseException();
-label_26:
-      return false;
-label_28:
-      throw new SharpZipBaseException();
-label_32:
-      return true;
-    }
-
-    public InflaterHuffmanTree BuildLitLenTree()
-    {
-      byte[] numArray = new byte[this.lnum];
-      Array.Copy((Array) this.litdistLens, 0, (Array) numArray, 0, this.lnum);
-      return new InflaterHuffmanTree(numArray);
-    }
-
-    public InflaterHuffmanTree BuildDistTree()
-    {
-      byte[] numArray = new byte[this.dnum];
-      Array.Copy((Array) this.litdistLens, this.lnum, (Array) numArray, 0, this.dnum);
-      return new InflaterHuffmanTree(numArray);
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs
deleted file mode 100644
index 41b0b4e..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/InflaterHuffmanTree.cs
+++ /dev/null
@@ -1,147 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class InflaterHuffmanTree
-  {
-    private const int MAX_BITLEN = 15;
-    private short[] tree;
-    public static InflaterHuffmanTree defLitLenTree;
-    public static InflaterHuffmanTree defDistTree;
-
-    static InflaterHuffmanTree()
-    {
-      try
-      {
-        byte[] codeLengths1 = new byte[288];
-        int num1 = 0;
-        while (num1 < 144)
-          codeLengths1[num1++] = (byte) 8;
-        while (num1 < 256)
-          codeLengths1[num1++] = (byte) 9;
-        while (num1 < 280)
-          codeLengths1[num1++] = (byte) 7;
-        while (num1 < 288)
-          codeLengths1[num1++] = (byte) 8;
-        InflaterHuffmanTree.defLitLenTree = new InflaterHuffmanTree(codeLengths1);
-        byte[] codeLengths2 = new byte[32];
-        int num2 = 0;
-        while (num2 < 32)
-          codeLengths2[num2++] = (byte) 5;
-        InflaterHuffmanTree.defDistTree = new InflaterHuffmanTree(codeLengths2);
-      }
-      catch (Exception ex)
-      {
-        throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");
-      }
-    }
-
-    public InflaterHuffmanTree(byte[] codeLengths) => this.BuildTree(codeLengths);
-
-    private void BuildTree(byte[] codeLengths)
-    {
-      int[] numArray1 = new int[16];
-      int[] numArray2 = new int[16];
-      for (int index = 0; index < codeLengths.Length; ++index)
-      {
-        int codeLength = (int) codeLengths[index];
-        if (codeLength > 0)
-          ++numArray1[codeLength];
-      }
-      int num1 = 0;
-      int length = 512;
-      for (int index = 1; index <= 15; ++index)
-      {
-        numArray2[index] = num1;
-        num1 += numArray1[index] << 16 - index;
-        if (index >= 10)
-        {
-          int num2 = numArray2[index] & 130944;
-          int num3 = num1 & 130944;
-          length += num3 - num2 >> 16 - index;
-        }
-      }
-      this.tree = new short[length];
-      int num4 = 512;
-      for (int index = 15; index >= 10; --index)
-      {
-        int num5 = num1 & 130944;
-        num1 -= numArray1[index] << 16 - index;
-        for (int toReverse = num1 & 130944; toReverse < num5; toReverse += 128)
-        {
-          this.tree[(int) DeflaterHuffman.BitReverse(toReverse)] = (short) (-num4 << 4 | index);
-          num4 += 1 << index - 9;
-        }
-      }
-      for (int index1 = 0; index1 < codeLengths.Length; ++index1)
-      {
-        int codeLength = (int) codeLengths[index1];
-        if (codeLength != 0)
-        {
-          int toReverse = numArray2[codeLength];
-          int index2 = (int) DeflaterHuffman.BitReverse(toReverse);
-          if (codeLength <= 9)
-          {
-            do
-            {
-              this.tree[index2] = (short) (index1 << 4 | codeLength);
-              index2 += 1 << codeLength;
-            }
-            while (index2 < 512);
-          }
-          else
-          {
-            int num6 = (int) this.tree[index2 & 511];
-            int num7 = 1 << (num6 & 15);
-            int num8 = -(num6 >> 4);
-            do
-            {
-              this.tree[num8 | index2 >> 9] = (short) (index1 << 4 | codeLength);
-              index2 += 1 << codeLength;
-            }
-            while (index2 < num7);
-          }
-          numArray2[codeLength] = toReverse + (1 << 16 - codeLength);
-        }
-      }
-    }
-
-    public int GetSymbol(StreamManipulator input)
-    {
-      int index;
-      if ((index = input.PeekBits(9)) >= 0)
-      {
-        int num1;
-        if ((num1 = (int) this.tree[index]) >= 0)
-        {
-          input.DropBits(num1 & 15);
-          return num1 >> 4;
-        }
-        int num2 = -(num1 >> 4);
-        int bitCount = num1 & 15;
-        int num3;
-        if ((num3 = input.PeekBits(bitCount)) >= 0)
-        {
-          int num4 = (int) this.tree[num2 | num3 >> 9];
-          input.DropBits(num4 & 15);
-          return num4 >> 4;
-        }
-        int availableBits = input.AvailableBits;
-        int num5 = input.PeekBits(availableBits);
-        int num6 = (int) this.tree[num2 | num5 >> 9];
-        if ((num6 & 15) > availableBits)
-          return -1;
-        input.DropBits(num6 & 15);
-        return num6 >> 4;
-      }
-      int availableBits1 = input.AvailableBits;
-      int num = (int) this.tree[input.PeekBits(availableBits1)];
-      if (num < 0 || (num & 15) > availableBits1)
-        return -1;
-      input.DropBits(num & 15);
-      return num >> 4;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/PendingBuffer.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/PendingBuffer.cs
deleted file mode 100644
index 8912628..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/PendingBuffer.cs
+++ /dev/null
@@ -1,111 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression
-{
-  public class PendingBuffer
-  {
-    private byte[] buffer_;
-    private int start;
-    private int end;
-    private uint bits;
-    private int bitCount;
-
-    public PendingBuffer()
-      : this(4096)
-    {
-    }
-
-    public PendingBuffer(int bufferSize) => this.buffer_ = new byte[bufferSize];
-
-    public void Reset() => this.start = this.end = this.bitCount = 0;
-
-    public void WriteByte(int value) => this.buffer_[this.end++] = (byte) value;
-
-    public void WriteShort(int value)
-    {
-      this.buffer_[this.end++] = (byte) value;
-      this.buffer_[this.end++] = (byte) (value >> 8);
-    }
-
-    public void WriteInt(int value)
-    {
-      this.buffer_[this.end++] = (byte) value;
-      this.buffer_[this.end++] = (byte) (value >> 8);
-      this.buffer_[this.end++] = (byte) (value >> 16);
-      this.buffer_[this.end++] = (byte) (value >> 24);
-    }
-
-    public void WriteBlock(byte[] block, int offset, int length)
-    {
-      Array.Copy((Array) block, offset, (Array) this.buffer_, this.end, length);
-      this.end += length;
-    }
-
-    public int BitCount => this.bitCount;
-
-    public void AlignToByte()
-    {
-      if (this.bitCount > 0)
-      {
-        this.buffer_[this.end++] = (byte) this.bits;
-        if (this.bitCount > 8)
-          this.buffer_[this.end++] = (byte) (this.bits >> 8);
-      }
-      this.bits = 0U;
-      this.bitCount = 0;
-    }
-
-    public void WriteBits(int b, int count)
-    {
-      this.bits |= (uint) (b << this.bitCount);
-      this.bitCount += count;
-      if (this.bitCount < 16)
-        return;
-      this.buffer_[this.end++] = (byte) this.bits;
-      this.buffer_[this.end++] = (byte) (this.bits >> 8);
-      this.bits >>= 16;
-      this.bitCount -= 16;
-    }
-
-    public void WriteShortMSB(int s)
-    {
-      this.buffer_[this.end++] = (byte) (s >> 8);
-      this.buffer_[this.end++] = (byte) s;
-    }
-
-    public bool IsFlushed => this.end == 0;
-
-    public int Flush(byte[] output, int offset, int length)
-    {
-      if (this.bitCount >= 8)
-      {
-        this.buffer_[this.end++] = (byte) this.bits;
-        this.bits >>= 8;
-        this.bitCount -= 8;
-      }
-      if (length > this.end - this.start)
-      {
-        length = this.end - this.start;
-        Array.Copy((Array) this.buffer_, this.start, (Array) output, offset, length);
-        this.start = 0;
-        this.end = 0;
-      }
-      else
-      {
-        Array.Copy((Array) this.buffer_, this.start, (Array) output, offset, length);
-        this.start += length;
-      }
-      return length;
-    }
-
-    public byte[] ToByteArray()
-    {
-      byte[] destinationArray = new byte[this.end - this.start];
-      Array.Copy((Array) this.buffer_, this.start, (Array) destinationArray, 0, destinationArray.Length);
-      this.start = 0;
-      this.end = 0;
-      return destinationArray;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs
deleted file mode 100644
index 5eca555..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/DeflaterOutputStream.cs
+++ /dev/null
@@ -1,221 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class DeflaterOutputStream : Stream
-  {
-    private string password;
-    private uint[] keys;
-    private byte[] buffer_;
-    protected Deflater def;
-    protected Stream baseOutputStream;
-    private bool isClosed;
-    private bool isStreamOwner = true;
-
-    public DeflaterOutputStream(Stream baseOutputStream)
-      : this(baseOutputStream, new Deflater(), 512)
-    {
-    }
-
-    public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater)
-      : this(baseOutputStream, deflater, 512)
-    {
-    }
-
-    public DeflaterOutputStream(Stream baseOutputStream, Deflater deflater, int bufferSize)
-    {
-      if (baseOutputStream == null)
-        throw new ArgumentNullException(nameof (baseOutputStream));
-      if (!baseOutputStream.CanWrite)
-        throw new ArgumentException("Must support writing", nameof (baseOutputStream));
-      if (deflater == null)
-        throw new ArgumentNullException(nameof (deflater));
-      if (bufferSize <= 0)
-        throw new ArgumentOutOfRangeException(nameof (bufferSize));
-      this.baseOutputStream = baseOutputStream;
-      this.buffer_ = new byte[bufferSize];
-      this.def = deflater;
-    }
-
-    public virtual void Finish()
-    {
-      this.def.Finish();
-      while (!this.def.IsFinished)
-      {
-        int num = this.def.Deflate(this.buffer_, 0, this.buffer_.Length);
-        if (num > 0)
-        {
-          if (this.keys != null)
-            this.EncryptBlock(this.buffer_, 0, num);
-          this.baseOutputStream.Write(this.buffer_, 0, num);
-        }
-        else
-          break;
-      }
-      if (!this.def.IsFinished)
-        throw new SharpZipBaseException("Can't deflate all input?");
-      this.baseOutputStream.Flush();
-      this.keys = (uint[]) null;
-    }
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public bool CanPatchEntries => this.baseOutputStream.CanSeek;
-
-    public string Password
-    {
-      get => this.password;
-      set
-      {
-        if (value != null && value.Length == 0)
-          this.password = (string) null;
-        else
-          this.password = value;
-      }
-    }
-
-    protected byte EncryptByte()
-    {
-      uint num = (uint) ((int) this.keys[2] & (int) ushort.MaxValue | 2);
-      return (byte) (num * (num ^ 1U) >> 8);
-    }
-
-    protected void EncryptBlock(byte[] buffer, int offset, int length)
-    {
-      for (int index = offset; index < offset + length; ++index)
-      {
-        byte ch = buffer[index];
-        buffer[index] ^= this.EncryptByte();
-        this.UpdateKeys(ch);
-      }
-    }
-
-    protected void InitializePassword(string password)
-    {
-      this.keys = new uint[3]
-      {
-        305419896U,
-        591751049U,
-        878082192U
-      };
-      foreach (byte ch in ZipConstants.ConvertToArray(password))
-        this.UpdateKeys(ch);
-    }
-
-    protected void UpdateKeys(byte ch)
-    {
-      this.keys[0] = Crc32.ComputeCrc32(this.keys[0], ch);
-      this.keys[1] = this.keys[1] + (uint) (byte) this.keys[0];
-      this.keys[1] = (uint) ((int) this.keys[1] * 134775813 + 1);
-      this.keys[2] = Crc32.ComputeCrc32(this.keys[2], (byte) (this.keys[1] >> 24));
-    }
-
-    protected void Deflate()
-    {
-      while (!this.def.IsNeedingInput)
-      {
-        int num = this.def.Deflate(this.buffer_, 0, this.buffer_.Length);
-        if (num > 0)
-        {
-          if (this.keys != null)
-            this.EncryptBlock(this.buffer_, 0, num);
-          this.baseOutputStream.Write(this.buffer_, 0, num);
-        }
-        else
-          break;
-      }
-      if (!this.def.IsNeedingInput)
-        throw new SharpZipBaseException("DeflaterOutputStream can't deflate all input?");
-    }
-
-    public override bool CanRead => false;
-
-    public override bool CanSeek => false;
-
-    public override bool CanWrite => this.baseOutputStream.CanWrite;
-
-    public override long Length => this.baseOutputStream.Length;
-
-    public override long Position
-    {
-      get => this.baseOutputStream.Position;
-      set => throw new NotSupportedException("Position property not supported");
-    }
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("DeflaterOutputStream Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("DeflaterOutputStream SetLength not supported");
-    }
-
-    public override int ReadByte()
-    {
-      throw new NotSupportedException("DeflaterOutputStream ReadByte not supported");
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("DeflaterOutputStream Read not supported");
-    }
-
-    public override IAsyncResult BeginRead(
-      byte[] buffer,
-      int offset,
-      int count,
-      AsyncCallback callback,
-      object state)
-    {
-      throw new NotSupportedException("DeflaterOutputStream BeginRead not currently supported");
-    }
-
-    public override IAsyncResult BeginWrite(
-      byte[] buffer,
-      int offset,
-      int count,
-      AsyncCallback callback,
-      object state)
-    {
-      throw new NotSupportedException("BeginWrite is not supported");
-    }
-
-    public override void Flush()
-    {
-      this.def.Flush();
-      this.Deflate();
-      this.baseOutputStream.Flush();
-    }
-
-    public override void Close()
-    {
-      if (this.isClosed)
-        return;
-      this.isClosed = true;
-      this.Finish();
-      if (!this.isStreamOwner)
-        return;
-      this.baseOutputStream.Close();
-    }
-
-    public override void WriteByte(byte value)
-    {
-      this.Write(new byte[1]{ value }, 0, 1);
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      this.def.SetInput(buffer, offset, count);
-      this.Deflate();
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputBuffer.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputBuffer.cs
deleted file mode 100644
index 823effd..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputBuffer.cs
+++ /dev/null
@@ -1,167 +0,0 @@
-
-using System;
-using System.IO;
-using System.Security.Cryptography;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class InflaterInputBuffer
-  {
-    private int rawLength;
-    private byte[] rawData;
-    private int clearTextLength;
-    private byte[] clearText;
-    private byte[] internalClearText;
-    private int available;
-    private ICryptoTransform cryptoTransform;
-    private Stream inputStream;
-
-    public InflaterInputBuffer(Stream stream)
-      : this(stream, 4096)
-    {
-    }
-
-    public InflaterInputBuffer(Stream stream, int bufferSize)
-    {
-      this.inputStream = stream;
-      if (bufferSize < 1024)
-        bufferSize = 1024;
-      this.rawData = new byte[bufferSize];
-      this.clearText = this.rawData;
-    }
-
-    public int RawLength => this.rawLength;
-
-    public byte[] RawData => this.rawData;
-
-    public int ClearTextLength => this.clearTextLength;
-
-    public byte[] ClearText => this.clearText;
-
-    public int Available
-    {
-      get => this.available;
-      set => this.available = value;
-    }
-
-    public void SetInflaterInput(Inflater inflater)
-    {
-      if (this.available <= 0)
-        return;
-      inflater.SetInput(this.clearText, this.clearTextLength - this.available, this.available);
-      this.available = 0;
-    }
-
-    public void Fill()
-    {
-      this.rawLength = 0;
-      int num;
-      for (int length = this.rawData.Length; length > 0; length -= num)
-      {
-        num = this.inputStream.Read(this.rawData, this.rawLength, length);
-        if (num <= 0)
-        {
-          if (this.rawLength == 0)
-            throw new SharpZipBaseException("Unexpected EOF");
-          break;
-        }
-        this.rawLength += num;
-      }
-      this.clearTextLength = this.cryptoTransform == null ? this.rawLength : this.cryptoTransform.TransformBlock(this.rawData, 0, this.rawLength, this.clearText, 0);
-      this.available = this.clearTextLength;
-    }
-
-    public int ReadRawBuffer(byte[] buffer) => this.ReadRawBuffer(buffer, 0, buffer.Length);
-
-    public int ReadRawBuffer(byte[] outBuffer, int offset, int length)
-    {
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length));
-      int destinationIndex = offset;
-      int val1 = length;
-      while (val1 > 0)
-      {
-        if (this.available <= 0)
-        {
-          this.Fill();
-          if (this.available <= 0)
-            return 0;
-        }
-        int length1 = Math.Min(val1, this.available);
-        Array.Copy((Array) this.rawData, this.rawLength - this.available, (Array) outBuffer, destinationIndex, length1);
-        destinationIndex += length1;
-        val1 -= length1;
-        this.available -= length1;
-      }
-      return length;
-    }
-
-    public int ReadClearTextBuffer(byte[] outBuffer, int offset, int length)
-    {
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length));
-      int destinationIndex = offset;
-      int val1 = length;
-      while (val1 > 0)
-      {
-        if (this.available <= 0)
-        {
-          this.Fill();
-          if (this.available <= 0)
-            return 0;
-        }
-        int length1 = Math.Min(val1, this.available);
-        Array.Copy((Array) this.clearText, this.clearTextLength - this.available, (Array) outBuffer, destinationIndex, length1);
-        destinationIndex += length1;
-        val1 -= length1;
-        this.available -= length1;
-      }
-      return length;
-    }
-
-    public int ReadLeByte()
-    {
-      if (this.available <= 0)
-      {
-        this.Fill();
-        if (this.available <= 0)
-          throw new ZipException("EOF in header");
-      }
-      byte num = (byte) ((uint) this.rawData[this.rawLength - this.available] & (uint) byte.MaxValue);
-      --this.available;
-      return (int) num;
-    }
-
-    public int ReadLeShort() => this.ReadLeByte() | this.ReadLeByte() << 8;
-
-    public int ReadLeInt() => this.ReadLeShort() | this.ReadLeShort() << 16;
-
-    public long ReadLeLong() => (long) (uint) this.ReadLeInt() | (long) this.ReadLeInt() << 32;
-
-    public ICryptoTransform CryptoTransform
-    {
-      set
-      {
-        this.cryptoTransform = value;
-        if (this.cryptoTransform != null)
-        {
-          if (this.rawData == this.clearText)
-          {
-            if (this.internalClearText == null)
-              this.internalClearText = new byte[4096];
-            this.clearText = this.internalClearText;
-          }
-          this.clearTextLength = this.rawLength;
-          if (this.available <= 0)
-            return;
-          this.cryptoTransform.TransformBlock(this.rawData, this.rawLength - this.available, this.available, this.clearText, this.rawLength - this.available);
-        }
-        else
-        {
-          this.clearText = this.rawData;
-          this.clearTextLength = this.rawLength;
-        }
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs
deleted file mode 100644
index f6cc81f..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/InflaterInputStream.cs
+++ /dev/null
@@ -1,153 +0,0 @@
-
-using System;
-using System.IO;
-using System.Security.Cryptography;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class InflaterInputStream : Stream
-  {
-    protected Inflater inf;
-    protected InflaterInputBuffer inputBuffer;
-    protected Stream baseInputStream;
-    protected long csize;
-    private bool isClosed;
-    private bool isStreamOwner = true;
-
-    public InflaterInputStream(Stream baseInputStream)
-      : this(baseInputStream, new Inflater(), 4096)
-    {
-    }
-
-    public InflaterInputStream(Stream baseInputStream, Inflater inf)
-      : this(baseInputStream, inf, 4096)
-    {
-    }
-
-    public InflaterInputStream(Stream baseInputStream, Inflater inflater, int bufferSize)
-    {
-      if (baseInputStream == null)
-        throw new ArgumentNullException(nameof (baseInputStream));
-      if (inflater == null)
-        throw new ArgumentNullException(nameof (inflater));
-      if (bufferSize <= 0)
-        throw new ArgumentOutOfRangeException(nameof (bufferSize));
-      this.baseInputStream = baseInputStream;
-      this.inf = inflater;
-      this.inputBuffer = new InflaterInputBuffer(baseInputStream, bufferSize);
-    }
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public long Skip(long count)
-    {
-      if (count < 0L)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if (this.baseInputStream.CanSeek)
-      {
-        this.baseInputStream.Seek(count, SeekOrigin.Current);
-        return count;
-      }
-      int length = 2048;
-      if (count < (long) length)
-        length = (int) count;
-      byte[] buffer = new byte[length];
-      return (long) this.baseInputStream.Read(buffer, 0, buffer.Length);
-    }
-
-    protected void StopDecrypting() => this.inputBuffer.CryptoTransform = (ICryptoTransform) null;
-
-    public virtual int Available => !this.inf.IsFinished ? 1 : 0;
-
-    protected void Fill()
-    {
-      this.inputBuffer.Fill();
-      this.inputBuffer.SetInflaterInput(this.inf);
-    }
-
-    public override bool CanRead => this.baseInputStream.CanRead;
-
-    public override bool CanSeek => false;
-
-    public override bool CanWrite => false;
-
-    public override long Length => (long) this.inputBuffer.RawLength;
-
-    public override long Position
-    {
-      get => this.baseInputStream.Position;
-      set => throw new NotSupportedException("InflaterInputStream Position not supported");
-    }
-
-    public override void Flush() => this.baseInputStream.Flush();
-
-    public override long Seek(long offset, SeekOrigin origin)
-    {
-      throw new NotSupportedException("Seek not supported");
-    }
-
-    public override void SetLength(long value)
-    {
-      throw new NotSupportedException("InflaterInputStream SetLength not supported");
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      throw new NotSupportedException("InflaterInputStream Write not supported");
-    }
-
-    public override void WriteByte(byte value)
-    {
-      throw new NotSupportedException("InflaterInputStream WriteByte not supported");
-    }
-
-    public override IAsyncResult BeginWrite(
-      byte[] buffer,
-      int offset,
-      int count,
-      AsyncCallback callback,
-      object state)
-    {
-      throw new NotSupportedException("InflaterInputStream BeginWrite not supported");
-    }
-
-    public override void Close()
-    {
-      if (this.isClosed)
-        return;
-      this.isClosed = true;
-      if (!this.isStreamOwner)
-        return;
-      this.baseInputStream.Close();
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (this.inf.IsNeedingDictionary)
-        throw new SharpZipBaseException("Need a dictionary");
-      int count1 = count;
-      int num;
-      do
-      {
-        num = this.inf.Inflate(buffer, offset, count1);
-        offset += num;
-        count1 -= num;
-        if (count1 != 0 && !this.inf.IsFinished)
-        {
-          if (this.inf.IsNeedingInput)
-            this.Fill();
-        }
-        else
-          goto label_8;
-      }
-      while (num != 0);
-      throw new ZipException("Dont know what to do");
-label_8:
-      return count - count1;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs
deleted file mode 100644
index 1654c08..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/OutputWindow.cs
+++ /dev/null
@@ -1,116 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class OutputWindow
-  {
-    private const int WindowSize = 32768;
-    private const int WindowMask = 32767;
-    private byte[] window = new byte[32768];
-    private int windowEnd;
-    private int windowFilled;
-
-    public void Write(int value)
-    {
-      if (this.windowFilled++ == 32768)
-        throw new InvalidOperationException("Window full");
-      this.window[this.windowEnd++] = (byte) value;
-      this.windowEnd &= (int) short.MaxValue;
-    }
-
-    private void SlowRepeat(int repStart, int length, int distance)
-    {
-      while (length-- > 0)
-      {
-        this.window[this.windowEnd++] = this.window[repStart++];
-        this.windowEnd &= (int) short.MaxValue;
-        repStart &= (int) short.MaxValue;
-      }
-    }
-
-    public void Repeat(int length, int distance)
-    {
-      if ((this.windowFilled += length) > 32768)
-        throw new InvalidOperationException("Window full");
-      int num1 = this.windowEnd - distance & (int) short.MaxValue;
-      int num2 = 32768 - length;
-      if (num1 <= num2 && this.windowEnd < num2)
-      {
-        if (length <= distance)
-        {
-          Array.Copy((Array) this.window, num1, (Array) this.window, this.windowEnd, length);
-          this.windowEnd += length;
-        }
-        else
-        {
-          while (length-- > 0)
-            this.window[this.windowEnd++] = this.window[num1++];
-        }
-      }
-      else
-        this.SlowRepeat(num1, length, distance);
-    }
-
-    public int CopyStored(StreamManipulator input, int length)
-    {
-      length = Math.Min(Math.Min(length, 32768 - this.windowFilled), input.AvailableBytes);
-      int length1 = 32768 - this.windowEnd;
-      int num;
-      if (length > length1)
-      {
-        num = input.CopyBytes(this.window, this.windowEnd, length1);
-        if (num == length1)
-          num += input.CopyBytes(this.window, 0, length - length1);
-      }
-      else
-        num = input.CopyBytes(this.window, this.windowEnd, length);
-      this.windowEnd = this.windowEnd + num & (int) short.MaxValue;
-      this.windowFilled += num;
-      return num;
-    }
-
-    public void CopyDict(byte[] dictionary, int offset, int length)
-    {
-      if (dictionary == null)
-        throw new ArgumentNullException(nameof (dictionary));
-      if (this.windowFilled > 0)
-        throw new InvalidOperationException();
-      if (length > 32768)
-      {
-        offset += length - 32768;
-        length = 32768;
-      }
-      Array.Copy((Array) dictionary, offset, (Array) this.window, 0, length);
-      this.windowEnd = length & (int) short.MaxValue;
-    }
-
-    public int GetFreeSpace() => 32768 - this.windowFilled;
-
-    public int GetAvailable() => this.windowFilled;
-
-    public int CopyOutput(byte[] output, int offset, int len)
-    {
-      int num1 = this.windowEnd;
-      if (len > this.windowFilled)
-        len = this.windowFilled;
-      else
-        num1 = this.windowEnd - this.windowFilled + len & (int) short.MaxValue;
-      int num2 = len;
-      int length = len - num1;
-      if (length > 0)
-      {
-        Array.Copy((Array) this.window, 32768 - length, (Array) output, offset, length);
-        offset += length;
-        len = num1;
-      }
-      Array.Copy((Array) this.window, num1 - len, (Array) output, offset, len);
-      this.windowFilled -= num2;
-      if (this.windowFilled < 0)
-        throw new InvalidOperationException();
-      return num2;
-    }
-
-    public void Reset() => this.windowFilled = this.windowEnd = 0;
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs
deleted file mode 100644
index 43c5123..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/Compression/Streams/StreamManipulator.cs
+++ /dev/null
@@ -1,111 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip.Compression.Streams
-{
-  public class StreamManipulator
-  {
-    private byte[] window_;
-    private int windowStart_;
-    private int windowEnd_;
-    private uint buffer_;
-    private int bitsInBuffer_;
-
-    public int PeekBits(int bitCount)
-    {
-      if (this.bitsInBuffer_ < bitCount)
-      {
-        if (this.windowStart_ == this.windowEnd_)
-          return -1;
-        this.buffer_ |= (uint) (((int) this.window_[this.windowStart_++] & (int) byte.MaxValue | ((int) this.window_[this.windowStart_++] & (int) byte.MaxValue) << 8) << this.bitsInBuffer_);
-        this.bitsInBuffer_ += 16;
-      }
-      return (int) ((long) this.buffer_ & (long) ((1 << bitCount) - 1));
-    }
-
-    public void DropBits(int bitCount)
-    {
-      this.buffer_ >>= bitCount;
-      this.bitsInBuffer_ -= bitCount;
-    }
-
-    public int GetBits(int bitCount)
-    {
-      int bits = this.PeekBits(bitCount);
-      if (bits >= 0)
-        this.DropBits(bitCount);
-      return bits;
-    }
-
-    public int AvailableBits => this.bitsInBuffer_;
-
-    public int AvailableBytes => this.windowEnd_ - this.windowStart_ + (this.bitsInBuffer_ >> 3);
-
-    public void SkipToByteBoundary()
-    {
-      this.buffer_ >>= this.bitsInBuffer_ & 7;
-      this.bitsInBuffer_ &= -8;
-    }
-
-    public bool IsNeedingInput => this.windowStart_ == this.windowEnd_;
-
-    public int CopyBytes(byte[] output, int offset, int length)
-    {
-      if (length < 0)
-        throw new ArgumentOutOfRangeException(nameof (length));
-      if ((this.bitsInBuffer_ & 7) != 0)
-        throw new InvalidOperationException("Bit buffer is not byte aligned!");
-      int num1 = 0;
-      while (this.bitsInBuffer_ > 0 && length > 0)
-      {
-        output[offset++] = (byte) this.buffer_;
-        this.buffer_ >>= 8;
-        this.bitsInBuffer_ -= 8;
-        --length;
-        ++num1;
-      }
-      if (length == 0)
-        return num1;
-      int num2 = this.windowEnd_ - this.windowStart_;
-      if (length > num2)
-        length = num2;
-      Array.Copy((Array) this.window_, this.windowStart_, (Array) output, offset, length);
-      this.windowStart_ += length;
-      if ((this.windowStart_ - this.windowEnd_ & 1) != 0)
-      {
-        this.buffer_ = (uint) this.window_[this.windowStart_++] & (uint) byte.MaxValue;
-        this.bitsInBuffer_ = 8;
-      }
-      return num1 + length;
-    }
-
-    public void Reset()
-    {
-      this.buffer_ = 0U;
-      this.windowStart_ = this.windowEnd_ = this.bitsInBuffer_ = 0;
-    }
-
-    public void SetInput(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be negative");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be negative");
-      if (this.windowStart_ < this.windowEnd_)
-        throw new InvalidOperationException("Old input was not completely processed");
-      int num = offset + count;
-      if (offset > num || num > buffer.Length)
-        throw new ArgumentOutOfRangeException(nameof (count));
-      if ((count & 1) != 0)
-      {
-        this.buffer_ |= (uint) (((int) buffer[offset++] & (int) byte.MaxValue) << this.bitsInBuffer_);
-        this.bitsInBuffer_ += 8;
-      }
-      this.window_ = buffer;
-      this.windowStart_ = offset;
-      this.windowEnd_ = num;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/CompressionMethod.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/CompressionMethod.cs
deleted file mode 100644
index e0dd9e1..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/CompressionMethod.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum CompressionMethod
-  {
-    Stored = 0,
-    Deflated = 8,
-    Deflate64 = 9,
-    BZip2 = 11, // 0x0000000B
-    WinZipAES = 99, // 0x00000063
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/DiskArchiveStorage.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/DiskArchiveStorage.cs
deleted file mode 100644
index 2e294a2..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/DiskArchiveStorage.cs
+++ /dev/null
@@ -1,134 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class DiskArchiveStorage : BaseArchiveStorage
-  {
-    private Stream temporaryStream_;
-    private string fileName_;
-    private string temporaryName_;
-
-    public DiskArchiveStorage(ZipFile file, FileUpdateMode updateMode)
-      : base(updateMode)
-    {
-      this.fileName_ = file.Name != null ? file.Name : throw new ZipException("Cant handle non file archives");
-    }
-
-    public DiskArchiveStorage(ZipFile file)
-      : this(file, FileUpdateMode.Safe)
-    {
-    }
-
-    public override Stream GetTemporaryOutput()
-    {
-      if (this.temporaryName_ != null)
-      {
-        this.temporaryName_ = this.GetTempFileName(this.temporaryName_, true);
-        this.temporaryStream_ = (Stream) File.OpenWrite(this.temporaryName_);
-      }
-      else
-      {
-        this.temporaryName_ = Path.GetTempFileName();
-        this.temporaryStream_ = (Stream) File.OpenWrite(this.temporaryName_);
-      }
-      return this.temporaryStream_;
-    }
-
-    public override Stream ConvertTemporaryToFinal()
-    {
-      if (this.temporaryStream_ == null)
-        throw new ZipException("No temporary stream has been created");
-      Stream stream = (Stream) null;
-      string tempFileName = this.GetTempFileName(this.fileName_, false);
-      bool flag = false;
-      try
-      {
-        this.temporaryStream_.Close();
-        File.Move(this.fileName_, tempFileName);
-        File.Move(this.temporaryName_, this.fileName_);
-        flag = true;
-        File.Delete(tempFileName);
-        return (Stream) File.OpenRead(this.fileName_);
-      }
-      catch (Exception ex)
-      {
-        stream = (Stream) null;
-        if (!flag)
-        {
-          File.Move(tempFileName, this.fileName_);
-          File.Delete(this.temporaryName_);
-        }
-        throw;
-      }
-    }
-
-    public override Stream MakeTemporaryCopy(Stream stream)
-    {
-      stream.Close();
-      this.temporaryName_ = this.GetTempFileName(this.fileName_, true);
-      File.Copy(this.fileName_, this.temporaryName_, true);
-      this.temporaryStream_ = (Stream) new FileStream(this.temporaryName_, FileMode.Open, FileAccess.ReadWrite);
-      return this.temporaryStream_;
-    }
-
-    public override Stream OpenForDirectUpdate(Stream current)
-    {
-      Stream stream;
-      if (current == null || !current.CanWrite)
-      {
-        current?.Close();
-        stream = (Stream) new FileStream(this.fileName_, FileMode.Open, FileAccess.ReadWrite);
-      }
-      else
-        stream = current;
-      return stream;
-    }
-
-    public override void Dispose()
-    {
-      if (this.temporaryStream_ == null)
-        return;
-      this.temporaryStream_.Close();
-    }
-
-    private string GetTempFileName(string original, bool makeTempFile)
-    {
-      string tempFileName = (string) null;
-      if (original == null)
-      {
-        tempFileName = Path.GetTempFileName();
-      }
-      else
-      {
-        int num = 0;
-        int second = DateTime.Now.Second;
-        while (tempFileName == null)
-        {
-          ++num;
-          string path = string.Format("{0}.{1}{2}.tmp", (object) original, (object) second, (object) num);
-          if (!File.Exists(path))
-          {
-            if (makeTempFile)
-            {
-              try
-              {
-                using (File.Create(path))
-                  ;
-                tempFileName = path;
-              }
-              catch
-              {
-                second = DateTime.Now.Second;
-              }
-            }
-            else
-              tempFileName = path;
-          }
-        }
-      }
-      return tempFileName;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/DynamicDiskDataSource.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/DynamicDiskDataSource.cs
deleted file mode 100644
index b032f39..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/DynamicDiskDataSource.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  internal class DynamicDiskDataSource : IDynamicDataSource
-  {
-    public Stream GetSource(ZipEntry entry, string name)
-    {
-      Stream source = (Stream) null;
-      if (name != null)
-        source = (Stream) File.OpenRead(name);
-      return source;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/EncryptionAlgorithm.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/EncryptionAlgorithm.cs
deleted file mode 100644
index 9eac2d2..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/EncryptionAlgorithm.cs
+++ /dev/null
@@ -1,21 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum EncryptionAlgorithm
-  {
-    None = 0,
-    PkzipClassic = 1,
-    Des = 26113, // 0x00006601
-    RC2 = 26114, // 0x00006602
-    TripleDes168 = 26115, // 0x00006603
-    TripleDes112 = 26121, // 0x00006609
-    Aes128 = 26126, // 0x0000660E
-    Aes192 = 26127, // 0x0000660F
-    Aes256 = 26128, // 0x00006610
-    RC2Corrected = 26370, // 0x00006702
-    Blowfish = 26400, // 0x00006720
-    Twofish = 26401, // 0x00006721
-    RC4 = 26625, // 0x00006801
-    Unknown = 65535, // 0x0000FFFF
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FastZip.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FastZip.cs
deleted file mode 100644
index c741db3..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FastZip.cs
+++ /dev/null
@@ -1,293 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Core;
-using System;
-using System.Collections;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class FastZip
-  {
-    private bool continueRunning_;
-    private byte[] buffer_;
-    private ZipOutputStream outputStream_;
-    private ZipFile zipFile_;
-    private string targetDirectory_;
-    private string sourceDirectory_;
-    private NameFilter fileFilter_;
-    private NameFilter directoryFilter_;
-    private FastZip.Overwrite overwrite_;
-    private FastZip.ConfirmOverwriteDelegate confirmDelegate_;
-    private bool restoreDateTimeOnExtract_;
-    private bool restoreAttributesOnExtract_;
-    private bool createEmptyDirectories_;
-    private FastZipEvents events_;
-    private IEntryFactory entryFactory_ = (IEntryFactory) new ZipEntryFactory();
-    private string password_;
-
-    public FastZip()
-    {
-    }
-
-    public FastZip(FastZipEvents events) => this.events_ = events;
-
-    public bool CreateEmptyDirectories
-    {
-      get => this.createEmptyDirectories_;
-      set => this.createEmptyDirectories_ = value;
-    }
-
-    public string Password
-    {
-      get => this.password_;
-      set => this.password_ = value;
-    }
-
-    public INameTransform NameTransform
-    {
-      get => this.entryFactory_.NameTransform;
-      set => this.entryFactory_.NameTransform = value;
-    }
-
-    public IEntryFactory EntryFactory
-    {
-      get => this.entryFactory_;
-      set
-      {
-        if (value == null)
-          this.entryFactory_ = (IEntryFactory) new ZipEntryFactory();
-        else
-          this.entryFactory_ = value;
-      }
-    }
-
-    public bool RestoreDateTimeOnExtract
-    {
-      get => this.restoreDateTimeOnExtract_;
-      set => this.restoreDateTimeOnExtract_ = value;
-    }
-
-    public bool RestoreAttributesOnExtract
-    {
-      get => this.restoreAttributesOnExtract_;
-      set => this.restoreAttributesOnExtract_ = value;
-    }
-
-    public void CreateZip(
-      string zipFileName,
-      string sourceDirectory,
-      bool recurse,
-      string fileFilter,
-      string directoryFilter)
-    {
-      this.CreateZip((Stream) File.Create(zipFileName), sourceDirectory, recurse, fileFilter, directoryFilter);
-    }
-
-    public void CreateZip(
-      string zipFileName,
-      string sourceDirectory,
-      bool recurse,
-      string fileFilter)
-    {
-      this.CreateZip((Stream) File.Create(zipFileName), sourceDirectory, recurse, fileFilter, (string) null);
-    }
-
-    public void CreateZip(
-      Stream outputStream,
-      string sourceDirectory,
-      bool recurse,
-      string fileFilter,
-      string directoryFilter)
-    {
-      this.NameTransform = (INameTransform) new ZipNameTransform(sourceDirectory);
-      this.sourceDirectory_ = sourceDirectory;
-      using (this.outputStream_ = new ZipOutputStream(outputStream))
-      {
-        if (this.password_ != null)
-          this.outputStream_.Password = this.password_;
-        FileSystemScanner fileSystemScanner = new FileSystemScanner(fileFilter, directoryFilter);
-        fileSystemScanner.ProcessFile += new ProcessFileDelegate(this.ProcessFile);
-        if (this.CreateEmptyDirectories)
-          fileSystemScanner.ProcessDirectory += new ProcessDirectoryDelegate(this.ProcessDirectory);
-        if (this.events_ != null)
-        {
-          if (this.events_.FileFailure != null)
-            fileSystemScanner.FileFailure += this.events_.FileFailure;
-          if (this.events_.DirectoryFailure != null)
-            fileSystemScanner.DirectoryFailure += this.events_.DirectoryFailure;
-        }
-        fileSystemScanner.Scan(sourceDirectory, recurse);
-      }
-    }
-
-    public void ExtractZip(string zipFileName, string targetDirectory, string fileFilter)
-    {
-      this.ExtractZip(zipFileName, targetDirectory, FastZip.Overwrite.Always, (FastZip.ConfirmOverwriteDelegate) null, fileFilter, (string) null, this.restoreDateTimeOnExtract_);
-    }
-
-    public void ExtractZip(
-      string zipFileName,
-      string targetDirectory,
-      FastZip.Overwrite overwrite,
-      FastZip.ConfirmOverwriteDelegate confirmDelegate,
-      string fileFilter,
-      string directoryFilter,
-      bool restoreDateTime)
-    {
-      if (overwrite == FastZip.Overwrite.Prompt && confirmDelegate == null)
-        throw new ArgumentNullException(nameof (confirmDelegate));
-      this.continueRunning_ = true;
-      this.overwrite_ = overwrite;
-      this.confirmDelegate_ = confirmDelegate;
-      this.targetDirectory_ = targetDirectory;
-      this.fileFilter_ = new NameFilter(fileFilter);
-      this.directoryFilter_ = new NameFilter(directoryFilter);
-      this.restoreDateTimeOnExtract_ = restoreDateTime;
-      using (this.zipFile_ = new ZipFile(zipFileName))
-      {
-        if (this.password_ != null)
-          this.zipFile_.Password = this.password_;
-        IEnumerator enumerator = this.zipFile_.GetEnumerator();
-        while (this.continueRunning_ && enumerator.MoveNext())
-        {
-          ZipEntry current = (ZipEntry) enumerator.Current;
-          if (current.IsFile)
-          {
-            if (this.directoryFilter_.IsMatch(Path.GetDirectoryName(current.Name)) && this.fileFilter_.IsMatch(current.Name))
-              this.ExtractEntry(current);
-          }
-          else if (current.IsDirectory && this.directoryFilter_.IsMatch(current.Name) && this.CreateEmptyDirectories)
-            this.ExtractEntry(current);
-        }
-      }
-    }
-
-    private void ProcessDirectory(object sender, DirectoryEventArgs e)
-    {
-      if (e.HasMatchingFiles || !this.CreateEmptyDirectories)
-        return;
-      if (this.events_ != null)
-        this.events_.OnProcessDirectory(e.Name, e.HasMatchingFiles);
-      if (!e.ContinueRunning || !(e.Name != this.sourceDirectory_))
-        return;
-      this.outputStream_.PutNextEntry(this.entryFactory_.MakeDirectoryEntry(e.Name));
-    }
-
-    private void ProcessFile(object sender, ScanEventArgs e)
-    {
-      if (this.events_ != null && this.events_.ProcessFile != null)
-        this.events_.ProcessFile(sender, e);
-      if (!e.ContinueRunning)
-        return;
-      this.outputStream_.PutNextEntry(this.entryFactory_.MakeFileEntry(e.Name));
-      this.AddFileContents(e.Name);
-    }
-
-    private void AddFileContents(string name)
-    {
-      if (this.buffer_ == null)
-        this.buffer_ = new byte[4096];
-      using (FileStream source = File.OpenRead(name))
-        StreamUtils.Copy((Stream) source, (Stream) this.outputStream_, this.buffer_);
-    }
-
-    private void ExtractFileEntry(ZipEntry entry, string targetName)
-    {
-      bool flag = true;
-      if (this.overwrite_ != FastZip.Overwrite.Always && File.Exists(targetName))
-        flag = this.overwrite_ == FastZip.Overwrite.Prompt && this.confirmDelegate_ != null && this.confirmDelegate_(targetName);
-      if (!flag)
-        return;
-      if (this.events_ != null)
-        this.continueRunning_ = this.events_.OnProcessFile(entry.Name);
-      if (!this.continueRunning_)
-        return;
-      try
-      {
-        using (FileStream destination = File.Create(targetName))
-        {
-          if (this.buffer_ == null)
-            this.buffer_ = new byte[4096];
-          StreamUtils.Copy(this.zipFile_.GetInputStream(entry), (Stream) destination, this.buffer_);
-        }
-        if (this.restoreDateTimeOnExtract_)
-          File.SetLastWriteTime(targetName, entry.DateTime);
-        if (!this.RestoreAttributesOnExtract || !entry.IsDOSEntry || entry.ExternalFileAttributes == -1)
-          return;
-        FileAttributes fileAttributes = (FileAttributes) (entry.ExternalFileAttributes & 163);
-        File.SetAttributes(targetName, fileAttributes);
-      }
-      catch (Exception ex)
-      {
-        if (this.events_ != null)
-          this.continueRunning_ = this.events_.OnFileFailure(targetName, ex);
-        else
-          this.continueRunning_ = false;
-      }
-    }
-
-    private void ExtractEntry(ZipEntry entry)
-    {
-      bool flag = false;
-      string str1 = entry.Name;
-      if (entry.IsFile)
-        flag = FastZip.NameIsValid(str1) && entry.IsCompressionMethodSupported();
-      else if (entry.IsDirectory)
-        flag = FastZip.NameIsValid(str1);
-      string path = (string) null;
-      string str2 = (string) null;
-      if (flag)
-      {
-        if (Path.IsPathRooted(str1))
-        {
-          string pathRoot = Path.GetPathRoot(str1);
-          str1 = str1.Substring(pathRoot.Length);
-        }
-        if (str1.Length > 0)
-        {
-          str2 = Path.Combine(this.targetDirectory_, str1);
-          path = !entry.IsDirectory ? Path.GetDirectoryName(Path.GetFullPath(str2)) : str2;
-        }
-        else
-          flag = false;
-      }
-      if (flag && !Directory.Exists(path))
-      {
-        if (entry.IsDirectory)
-        {
-          if (!this.CreateEmptyDirectories)
-            goto label_16;
-        }
-        try
-        {
-          Directory.CreateDirectory(path);
-        }
-        catch (Exception ex)
-        {
-          flag = false;
-          this.continueRunning_ = this.events_ != null && (!entry.IsDirectory ? this.events_.OnFileFailure(str2, ex) : this.events_.OnDirectoryFailure(str2, ex));
-        }
-      }
-label_16:
-      if (!flag || !entry.IsFile)
-        return;
-      this.ExtractFileEntry(entry, str2);
-    }
-
-    private static int MakeExternalAttributes(FileInfo info) => (int) info.Attributes;
-
-    private static bool NameIsValid(string name)
-    {
-      return name != null && name.Length > 0 && name.IndexOfAny(Path.GetInvalidPathChars()) < 0;
-    }
-
-    public enum Overwrite
-    {
-      Prompt,
-      Never,
-      Always,
-    }
-
-    public delegate bool ConfirmOverwriteDelegate(string fileName);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FastZipEvents.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FastZipEvents.cs
deleted file mode 100644
index a0b160c..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FastZipEvents.cs
+++ /dev/null
@@ -1,62 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Core;
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class FastZipEvents
-  {
-    public ProcessDirectoryDelegate ProcessDirectory;
-    public ProcessFileDelegate ProcessFile;
-    public DirectoryFailureDelegate DirectoryFailure;
-    public FileFailureDelegate FileFailure;
-
-    public bool OnDirectoryFailure(string directory, Exception e)
-    {
-      bool flag = false;
-      if (this.DirectoryFailure != null)
-      {
-        ScanFailureEventArgs e1 = new ScanFailureEventArgs(directory, e);
-        this.DirectoryFailure((object) this, e1);
-        flag = e1.ContinueRunning;
-      }
-      return flag;
-    }
-
-    public bool OnFileFailure(string file, Exception e)
-    {
-      bool flag = false;
-      if (this.FileFailure != null)
-      {
-        ScanFailureEventArgs e1 = new ScanFailureEventArgs(file, e);
-        this.FileFailure((object) this, e1);
-        flag = e1.ContinueRunning;
-      }
-      return flag;
-    }
-
-    public bool OnProcessFile(string file)
-    {
-      bool flag = true;
-      if (this.ProcessFile != null)
-      {
-        ScanEventArgs e = new ScanEventArgs(file);
-        this.ProcessFile((object) this, e);
-        flag = e.ContinueRunning;
-      }
-      return flag;
-    }
-
-    public bool OnProcessDirectory(string directory, bool hasMatchingFiles)
-    {
-      bool flag = true;
-      if (this.ProcessDirectory != null)
-      {
-        DirectoryEventArgs e = new DirectoryEventArgs(directory, hasMatchingFiles);
-        this.ProcessDirectory((object) this, e);
-        flag = e.ContinueRunning;
-      }
-      return flag;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FileUpdateMode.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FileUpdateMode.cs
deleted file mode 100644
index 6118c70..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/FileUpdateMode.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum FileUpdateMode
-  {
-    Safe,
-    Direct,
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/GeneralBitFlags.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/GeneralBitFlags.cs
deleted file mode 100644
index ae781d0..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/GeneralBitFlags.cs
+++ /dev/null
@@ -1,25 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  [Flags]
-  public enum GeneralBitFlags
-  {
-    Encrypted = 1,
-    Method = 6,
-    Descriptor = 8,
-    ReservedPKware4 = 16, // 0x00000010
-    Patched = 32, // 0x00000020
-    StrongEncryption = 64, // 0x00000040
-    Unused7 = 128, // 0x00000080
-    Unused8 = 256, // 0x00000100
-    Unused9 = 512, // 0x00000200
-    Unused10 = 1024, // 0x00000400
-    UnicodeText = 2048, // 0x00000800
-    EnhancedCompress = 4096, // 0x00001000
-    HeaderMasked = 8192, // 0x00002000
-    ReservedPkware14 = 16384, // 0x00004000
-    ReservedPkware15 = 32768, // 0x00008000
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/HostSystemID.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/HostSystemID.cs
deleted file mode 100644
index 247d965..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/HostSystemID.cs
+++ /dev/null
@@ -1,28 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum HostSystemID
-  {
-    Msdos = 0,
-    Amiga = 1,
-    OpenVms = 2,
-    Unix = 3,
-    VMCms = 4,
-    AtariST = 5,
-    OS2 = 6,
-    Macintosh = 7,
-    ZSystem = 8,
-    Cpm = 9,
-    WindowsNT = 10, // 0x0000000A
-    MVS = 11, // 0x0000000B
-    Vse = 12, // 0x0000000C
-    AcornRisc = 13, // 0x0000000D
-    Vfat = 14, // 0x0000000E
-    AlternateMvs = 15, // 0x0000000F
-    BeOS = 16, // 0x00000010
-    Tandem = 17, // 0x00000011
-    OS400 = 18, // 0x00000012
-    OSX = 19, // 0x00000013
-    WinZipAES = 99, // 0x00000063
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IArchiveStorage.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IArchiveStorage.cs
deleted file mode 100644
index 4b22faf..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IArchiveStorage.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public interface IArchiveStorage
-  {
-    FileUpdateMode UpdateMode { get; }
-
-    Stream GetTemporaryOutput();
-
-    Stream ConvertTemporaryToFinal();
-
-    Stream MakeTemporaryCopy(Stream stream);
-
-    Stream OpenForDirectUpdate(Stream stream);
-
-    void Dispose();
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IDynamicDataSource.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IDynamicDataSource.cs
deleted file mode 100644
index f56a4c0..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IDynamicDataSource.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public interface IDynamicDataSource
-  {
-    Stream GetSource(ZipEntry entry, string name);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IEntryFactory.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IEntryFactory.cs
deleted file mode 100644
index 00f6c34..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IEntryFactory.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Core;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public interface IEntryFactory
-  {
-    ZipEntry MakeFileEntry(string fileName);
-
-    ZipEntry MakeDirectoryEntry(string directoryName);
-
-    INameTransform NameTransform { get; set; }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IStaticDataSource.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IStaticDataSource.cs
deleted file mode 100644
index 996e787..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/IStaticDataSource.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public interface IStaticDataSource
-  {
-    Stream GetSource();
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/KeysRequiredEventArgs.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/KeysRequiredEventArgs.cs
deleted file mode 100644
index e1bc12e..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/KeysRequiredEventArgs.cs
+++ /dev/null
@@ -1,27 +0,0 @@
-
-using System;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class KeysRequiredEventArgs : EventArgs
-  {
-    private string fileName;
-    private byte[] key;
-
-    public KeysRequiredEventArgs(string name) => this.fileName = name;
-
-    public KeysRequiredEventArgs(string name, byte[] keyValue)
-    {
-      this.fileName = name;
-      this.key = keyValue;
-    }
-
-    public string FileName => this.fileName;
-
-    public byte[] Key
-    {
-      get => this.key;
-      set => this.key = value;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/MemoryArchiveStorage.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/MemoryArchiveStorage.cs
deleted file mode 100644
index 9cb10d1..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/MemoryArchiveStorage.cs
+++ /dev/null
@@ -1,69 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Core;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class MemoryArchiveStorage : BaseArchiveStorage
-  {
-    private MemoryStream temporaryStream_;
-    private MemoryStream finalStream_;
-
-    public MemoryArchiveStorage()
-      : base(FileUpdateMode.Direct)
-    {
-    }
-
-    public MemoryArchiveStorage(FileUpdateMode updateMode)
-      : base(updateMode)
-    {
-    }
-
-    public MemoryStream FinalStream => this.finalStream_;
-
-    public override Stream GetTemporaryOutput()
-    {
-      this.temporaryStream_ = new MemoryStream();
-      return (Stream) this.temporaryStream_;
-    }
-
-    public override Stream ConvertTemporaryToFinal()
-    {
-      this.finalStream_ = this.temporaryStream_ != null ? new MemoryStream(this.temporaryStream_.ToArray()) : throw new ZipException("No temporary stream has been created");
-      return (Stream) this.finalStream_;
-    }
-
-    public override Stream MakeTemporaryCopy(Stream stream)
-    {
-      this.temporaryStream_ = new MemoryStream();
-      stream.Position = 0L;
-      StreamUtils.Copy(stream, (Stream) this.temporaryStream_, new byte[4096]);
-      return (Stream) this.temporaryStream_;
-    }
-
-    public override Stream OpenForDirectUpdate(Stream stream)
-    {
-      Stream destination;
-      if (stream == null || !stream.CanWrite)
-      {
-        destination = (Stream) new MemoryStream();
-        if (stream != null)
-        {
-          stream.Position = 0L;
-          StreamUtils.Copy(stream, destination, new byte[4096]);
-          stream.Close();
-        }
-      }
-      else
-        destination = stream;
-      return destination;
-    }
-
-    public override void Dispose()
-    {
-      if (this.temporaryStream_ == null)
-        return;
-      this.temporaryStream_.Close();
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/StaticDiskDataSource.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/StaticDiskDataSource.cs
deleted file mode 100644
index e6592da..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/StaticDiskDataSource.cs
+++ /dev/null
@@ -1,14 +0,0 @@
-
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  internal class StaticDiskDataSource : IStaticDataSource
-  {
-    private string fileName_;
-
-    public StaticDiskDataSource(string fileName) => this.fileName_ = fileName;
-
-    public Stream GetSource() => (Stream) File.OpenRead(this.fileName_);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestOperation.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestOperation.cs
deleted file mode 100644
index b4c3137..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestOperation.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum TestOperation
-  {
-    Initialising,
-    EntryHeader,
-    EntryData,
-    EntryComplete,
-    MiscellaneousTests,
-    Complete,
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestStatus.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestStatus.cs
deleted file mode 100644
index 735ebc1..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestStatus.cs
+++ /dev/null
@@ -1,44 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class TestStatus
-  {
-    private ZipFile file_;
-    private ZipEntry entry_;
-    private bool entryValid_;
-    private int errorCount_;
-    private long bytesTested_;
-    private TestOperation operation_;
-
-    public TestStatus(ZipFile file) => this.file_ = file;
-
-    public TestOperation Operation => this.operation_;
-
-    public ZipFile File => this.file_;
-
-    public ZipEntry Entry => this.entry_;
-
-    public int ErrorCount => this.errorCount_;
-
-    public long BytesTested => this.bytesTested_;
-
-    public bool EntryValid => this.entryValid_;
-
-    internal void AddError()
-    {
-      ++this.errorCount_;
-      this.entryValid_ = false;
-    }
-
-    internal void SetOperation(TestOperation operation) => this.operation_ = operation;
-
-    internal void SetEntry(ZipEntry entry)
-    {
-      this.entry_ = entry;
-      this.entryValid_ = true;
-      this.bytesTested_ = 0L;
-    }
-
-    internal void SetBytesTested(long value) => this.bytesTested_ = value;
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestStrategy.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestStrategy.cs
deleted file mode 100644
index 4068976..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/TestStrategy.cs
+++ /dev/null
@@ -1,9 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum TestStrategy
-  {
-    FindFirstError,
-    FindAllErrors,
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/UseZip64.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/UseZip64.cs
deleted file mode 100644
index 8b1c44c..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/UseZip64.cs
+++ /dev/null
@@ -1,10 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public enum UseZip64
-  {
-    Off,
-    On,
-    Dynamic,
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipConstants.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipConstants.cs
deleted file mode 100644
index c75327f..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipConstants.cs
+++ /dev/null
@@ -1,107 +0,0 @@
-
-using System;
-using System.Text;
-using System.Threading;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public sealed class ZipConstants
-  {
-    public const int VersionMadeBy = 45;
-    [Obsolete("Use VersionMadeBy instead")]
-    public const int VERSION_MADE_BY = 45;
-    public const int VersionStrongEncryption = 50;
-    [Obsolete("Use VersionStrongEncryption instead")]
-    public const int VERSION_STRONG_ENCRYPTION = 50;
-    public const int VersionZip64 = 45;
-    public const int LocalHeaderBaseSize = 30;
-    [Obsolete("Use LocalHeaderBaseSize instead")]
-    public const int LOCHDR = 30;
-    public const int Zip64DataDescriptorSize = 24;
-    public const int DataDescriptorSize = 16;
-    [Obsolete("Use DataDescriptorSize instead")]
-    public const int EXTHDR = 16;
-    public const int CentralHeaderBaseSize = 46;
-    [Obsolete("Use CentralHeaderBaseSize instead")]
-    public const int CENHDR = 46;
-    public const int EndOfCentralRecordBaseSize = 22;
-    [Obsolete("Use EndOfCentralRecordBaseSize instead")]
-    public const int ENDHDR = 22;
-    public const int CryptoHeaderSize = 12;
-    [Obsolete("Use CryptoHeaderSize instead")]
-    public const int CRYPTO_HEADER_SIZE = 12;
-    public const int LocalHeaderSignature = 67324752;
-    [Obsolete("Use LocalHeaderSignature instead")]
-    public const int LOCSIG = 67324752;
-    public const int SpanningSignature = 134695760;
-    [Obsolete("Use SpanningSignature instead")]
-    public const int SPANNINGSIG = 134695760;
-    public const int SpanningTempSignature = 808471376;
-    [Obsolete("Use SpanningTempSignature instead")]
-    public const int SPANTEMPSIG = 808471376;
-    public const int DataDescriptorSignature = 134695760;
-    [Obsolete("Use DataDescriptorSignature instead")]
-    public const int EXTSIG = 134695760;
-    [Obsolete("Use CentralHeaderSignature instead")]
-    public const int CENSIG = 33639248;
-    public const int CentralHeaderSignature = 33639248;
-    public const int Zip64CentralFileHeaderSignature = 101075792;
-    [Obsolete("Use Zip64CentralFileHeaderSignature instead")]
-    public const int CENSIG64 = 101075792;
-    public const int Zip64CentralDirLocatorSignature = 117853008;
-    public const int ArchiveExtraDataSignature = 117853008;
-    public const int CentralHeaderDigitalSignature = 84233040;
-    [Obsolete("Use CentralHeaderDigitalSignaure instead")]
-    public const int CENDIGITALSIG = 84233040;
-    public const int EndOfCentralDirectorySignature = 101010256;
-    [Obsolete("Use EndOfCentralDirectorySignature instead")]
-    public const int ENDSIG = 101010256;
-    private static int defaultCodePage = Thread.CurrentThread.CurrentCulture.TextInfo.OEMCodePage;
-
-    public static int DefaultCodePage
-    {
-      get => ZipConstants.defaultCodePage;
-      set => ZipConstants.defaultCodePage = value;
-    }
-
-    public static string ConvertToString(byte[] data, int count)
-    {
-      return data == null ? string.Empty : Encoding.GetEncoding(ZipConstants.DefaultCodePage).GetString(data, 0, count);
-    }
-
-    public static string ConvertToString(byte[] data)
-    {
-      return data == null ? string.Empty : ZipConstants.ConvertToString(data, data.Length);
-    }
-
-    public static string ConvertToStringExt(int flags, byte[] data, int count)
-    {
-      if (data == null)
-        return string.Empty;
-      return (flags & 2048) != 0 ? Encoding.UTF8.GetString(data, 0, count) : ZipConstants.ConvertToString(data, count);
-    }
-
-    public static string ConvertToStringExt(int flags, byte[] data)
-    {
-      if (data == null)
-        return string.Empty;
-      return (flags & 2048) != 0 ? Encoding.UTF8.GetString(data, 0, data.Length) : ZipConstants.ConvertToString(data, data.Length);
-    }
-
-    public static byte[] ConvertToArray(string str)
-    {
-      return str == null ? new byte[0] : Encoding.GetEncoding(ZipConstants.DefaultCodePage).GetBytes(str);
-    }
-
-    public static byte[] ConvertToArray(int flags, string str)
-    {
-      if (str == null)
-        return new byte[0];
-      return (flags & 2048) != 0 ? Encoding.UTF8.GetBytes(str) : ZipConstants.ConvertToArray(str);
-    }
-
-    private ZipConstants()
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipEntry.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipEntry.cs
deleted file mode 100644
index de505c3..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipEntry.cs
+++ /dev/null
@@ -1,399 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipEntry : ICloneable
-  {
-    private ZipEntry.Known known;
-    private int externalFileAttributes = -1;
-    private ushort versionMadeBy;
-    private string name;
-    private ulong size;
-    private ulong compressedSize;
-    private ushort versionToExtract;
-    private uint crc;
-    private uint dosTime;
-    private CompressionMethod method = CompressionMethod.Deflated;
-    private byte[] extra;
-    private string comment;
-    private int flags;
-    private long zipFileIndex = -1;
-    private long offset;
-    private bool forceZip64_;
-    private byte cryptoCheckValue_;
-
-    public ZipEntry(string name)
-      : this(name, 0, 45, CompressionMethod.Deflated)
-    {
-    }
-
-    internal ZipEntry(string name, int versionRequiredToExtract)
-      : this(name, versionRequiredToExtract, 45, CompressionMethod.Deflated)
-    {
-    }
-
-    internal ZipEntry(
-      string name,
-      int versionRequiredToExtract,
-      int madeByInfo,
-      CompressionMethod method)
-    {
-      if (name == null)
-        throw new ArgumentNullException("ZipEntry name");
-      if (name.Length > (int) ushort.MaxValue)
-        throw new ArgumentException("Name is too long", nameof (name));
-      if (versionRequiredToExtract != 0 && versionRequiredToExtract < 10)
-        throw new ArgumentOutOfRangeException(nameof (versionRequiredToExtract));
-      this.DateTime = DateTime.Now;
-      this.name = name;
-      this.versionMadeBy = (ushort) madeByInfo;
-      this.versionToExtract = (ushort) versionRequiredToExtract;
-      this.method = method;
-    }
-
-    [Obsolete("Use Clone instead")]
-    public ZipEntry(ZipEntry entry)
-    {
-      this.known = entry != null ? entry.known : throw new ArgumentNullException(nameof (entry));
-      this.name = entry.name;
-      this.size = entry.size;
-      this.compressedSize = entry.compressedSize;
-      this.crc = entry.crc;
-      this.dosTime = entry.dosTime;
-      this.method = entry.method;
-      this.comment = entry.comment;
-      this.versionToExtract = entry.versionToExtract;
-      this.versionMadeBy = entry.versionMadeBy;
-      this.externalFileAttributes = entry.externalFileAttributes;
-      this.flags = entry.flags;
-      this.zipFileIndex = entry.zipFileIndex;
-      this.offset = entry.offset;
-      this.forceZip64_ = entry.forceZip64_;
-      if (entry.extra == null)
-        return;
-      this.extra = new byte[entry.extra.Length];
-      Array.Copy((Array) entry.extra, 0, (Array) this.extra, 0, entry.extra.Length);
-    }
-
-    public bool HasCrc => (this.known & ZipEntry.Known.Crc) != ZipEntry.Known.None;
-
-    public bool IsCrypted
-    {
-      get => (this.flags & 1) != 0;
-      set
-      {
-        if (value)
-          this.flags |= 1;
-        else
-          this.flags &= -2;
-      }
-    }
-
-    public bool IsUnicodeText
-    {
-      get => (this.flags & 2048) != 0;
-      set
-      {
-        if (value)
-          this.flags |= 2048;
-        else
-          this.flags &= -2049;
-      }
-    }
-
-    internal byte CryptoCheckValue
-    {
-      get => this.cryptoCheckValue_;
-      set => this.cryptoCheckValue_ = value;
-    }
-
-    public int Flags
-    {
-      get => this.flags;
-      set => this.flags = value;
-    }
-
-    public long ZipFileIndex
-    {
-      get => this.zipFileIndex;
-      set => this.zipFileIndex = value;
-    }
-
-    public long Offset
-    {
-      get => this.offset;
-      set => this.offset = value;
-    }
-
-    public int ExternalFileAttributes
-    {
-      get
-      {
-        return (this.known & ZipEntry.Known.ExternalAttributes) == ZipEntry.Known.None ? -1 : this.externalFileAttributes;
-      }
-      set
-      {
-        this.externalFileAttributes = value;
-        this.known |= ZipEntry.Known.ExternalAttributes;
-      }
-    }
-
-    public int VersionMadeBy => (int) this.versionMadeBy & (int) byte.MaxValue;
-
-    public bool IsDOSEntry => this.HostSystem == 0 || this.HostSystem == 10;
-
-    private bool HasDosAttributes(int attributes)
-    {
-      bool flag = false;
-      if ((this.known & ZipEntry.Known.ExternalAttributes) != ZipEntry.Known.None && (this.HostSystem == 0 || this.HostSystem == 10) && (this.ExternalFileAttributes & attributes) == attributes)
-        flag = true;
-      return flag;
-    }
-
-    public int HostSystem
-    {
-      get => (int) this.versionMadeBy >> 8 & (int) byte.MaxValue;
-      set
-      {
-        this.versionMadeBy &= (ushort) byte.MaxValue;
-        this.versionMadeBy |= (ushort) ((value & (int) byte.MaxValue) << 8);
-      }
-    }
-
-    public int Version
-    {
-      get
-      {
-        if (this.versionToExtract != (ushort) 0)
-          return (int) this.versionToExtract;
-        int version = 10;
-        if (this.CentralHeaderRequiresZip64)
-          version = 45;
-        else if (CompressionMethod.Deflated == this.method)
-          version = 20;
-        else if (this.IsDirectory)
-          version = 20;
-        else if (this.IsCrypted)
-          version = 20;
-        else if (this.HasDosAttributes(8))
-          version = 11;
-        return version;
-      }
-    }
-
-    public bool CanDecompress
-    {
-      get
-      {
-        return this.Version <= 45 && (this.Version == 10 || this.Version == 11 || this.Version == 20 || this.Version == 45) && this.IsCompressionMethodSupported();
-      }
-    }
-
-    public void ForceZip64() => this.forceZip64_ = true;
-
-    public bool IsZip64Forced() => this.forceZip64_;
-
-    public bool LocalHeaderRequiresZip64
-    {
-      get
-      {
-        bool headerRequiresZip64 = this.forceZip64_;
-        if (!headerRequiresZip64)
-        {
-          ulong compressedSize = this.compressedSize;
-          if (this.versionToExtract == (ushort) 0 && this.IsCrypted)
-            compressedSize += 12UL;
-          headerRequiresZip64 = (this.size >= (ulong) uint.MaxValue || compressedSize >= (ulong) uint.MaxValue) && (this.versionToExtract == (ushort) 0 || this.versionToExtract >= (ushort) 45);
-        }
-        return headerRequiresZip64;
-      }
-    }
-
-    public bool CentralHeaderRequiresZip64
-    {
-      get => this.LocalHeaderRequiresZip64 || this.offset >= (long) uint.MaxValue;
-    }
-
-    public long DosTime
-    {
-      get => (this.known & ZipEntry.Known.Time) == ZipEntry.Known.None ? 0L : (long) this.dosTime;
-      set
-      {
-        this.dosTime = (uint) value;
-        this.known |= ZipEntry.Known.Time;
-      }
-    }
-
-    public DateTime DateTime
-    {
-      get
-      {
-        return this.dosTime == 0U ? DateTime.Now : new DateTime(((int) (this.dosTime >> 25) & (int) sbyte.MaxValue) + 1980, (int) (this.dosTime >> 21 & 15U), (int) (this.dosTime >> 16 & 31U), (int) (this.dosTime >> 11 & 31U), (int) (this.dosTime >> 5 & 63U), 2 * ((int) this.dosTime & 31));
-      }
-      set
-      {
-        this.DosTime = (long) (uint) ((value.Year - 1980 & (int) sbyte.MaxValue) << 25 | value.Month << 21 | value.Day << 16 | value.Hour << 11 | value.Minute << 5 | value.Second >>> 1);
-      }
-    }
-
-    public string Name => this.name;
-
-    public long Size
-    {
-      get => (this.known & ZipEntry.Known.Size) == ZipEntry.Known.None ? -1L : (long) this.size;
-      set
-      {
-        this.size = (ulong) value;
-        this.known |= ZipEntry.Known.Size;
-      }
-    }
-
-    public long CompressedSize
-    {
-      get
-      {
-        return (this.known & ZipEntry.Known.CompressedSize) == ZipEntry.Known.None ? -1L : (long) this.compressedSize;
-      }
-      set
-      {
-        this.compressedSize = (ulong) value;
-        this.known |= ZipEntry.Known.CompressedSize;
-      }
-    }
-
-    public long Crc
-    {
-      get
-      {
-        return (this.known & ZipEntry.Known.Crc) == ZipEntry.Known.None ? -1L : (long) this.crc & (long) uint.MaxValue;
-      }
-      set
-      {
-        this.crc = ((long) this.crc & -4294967296L) == 0L ? (uint) value : throw new ArgumentOutOfRangeException(nameof (value));
-        this.known |= ZipEntry.Known.Crc;
-      }
-    }
-
-    public CompressionMethod CompressionMethod
-    {
-      get => this.method;
-      set
-      {
-        this.method = ZipEntry.IsCompressionMethodSupported(value) ? value : throw new NotSupportedException("Compression method not supported");
-      }
-    }
-
-    public byte[] ExtraData
-    {
-      get => this.extra;
-      set
-      {
-        if (value == null)
-        {
-          this.extra = (byte[]) null;
-        }
-        else
-        {
-          this.extra = value.Length <= (int) ushort.MaxValue ? new byte[value.Length] : throw new ArgumentOutOfRangeException(nameof (value));
-          Array.Copy((Array) value, 0, (Array) this.extra, 0, value.Length);
-        }
-      }
-    }
-
-    internal void ProcessExtraData(bool localHeader)
-    {
-      ZipExtraData zipExtraData = new ZipExtraData(this.extra);
-      if (zipExtraData.Find(1))
-      {
-        if (((int) this.versionToExtract & (int) byte.MaxValue) < 45)
-          throw new ZipException("Zip64 Extended information found but version is not valid");
-        this.forceZip64_ = true;
-        if (zipExtraData.ValueLength < 4)
-          throw new ZipException("Extra data extended Zip64 information length is invalid");
-        if (localHeader || this.size == (ulong) uint.MaxValue)
-          this.size = (ulong) zipExtraData.ReadLong();
-        if (localHeader || this.compressedSize == (ulong) uint.MaxValue)
-          this.compressedSize = (ulong) zipExtraData.ReadLong();
-        if (!localHeader && this.offset == (long) uint.MaxValue)
-          this.offset = zipExtraData.ReadLong();
-      }
-      else if (((int) this.versionToExtract & (int) byte.MaxValue) >= 45 && (this.size == (ulong) uint.MaxValue || this.compressedSize == (ulong) uint.MaxValue))
-        throw new ZipException("Zip64 Extended information required but is missing.");
-      if (!zipExtraData.Find(21589))
-        return;
-      int valueLength = zipExtraData.ValueLength;
-      if ((zipExtraData.ReadByte() & 1) == 0 || valueLength < 5)
-        return;
-      int seconds = zipExtraData.ReadInt();
-      this.DateTime = (new DateTime(1970, 1, 1, 0, 0, 0).ToUniversalTime() + new TimeSpan(0, 0, 0, seconds, 0)).ToLocalTime();
-    }
-
-    public string Comment
-    {
-      get => this.comment;
-      set
-      {
-        this.comment = value == null || value.Length <= (int) ushort.MaxValue ? value : throw new ArgumentOutOfRangeException(nameof (value), "cannot exceed 65535");
-      }
-    }
-
-    public bool IsDirectory
-    {
-      get
-      {
-        int length = this.name.Length;
-        return length > 0 && (this.name[length - 1] == '/' || this.name[length - 1] == '\\') || this.HasDosAttributes(16);
-      }
-    }
-
-    public bool IsFile => !this.IsDirectory && !this.HasDosAttributes(8);
-
-    public bool IsCompressionMethodSupported()
-    {
-      return ZipEntry.IsCompressionMethodSupported(this.CompressionMethod);
-    }
-
-    public object Clone()
-    {
-      ZipEntry zipEntry = (ZipEntry) this.MemberwiseClone();
-      if (this.extra != null)
-      {
-        zipEntry.extra = new byte[this.extra.Length];
-        Array.Copy((Array) this.extra, 0, (Array) zipEntry.extra, 0, this.extra.Length);
-      }
-      return (object) zipEntry;
-    }
-
-    public override string ToString() => this.name;
-
-    public static bool IsCompressionMethodSupported(CompressionMethod method)
-    {
-      return method == CompressionMethod.Deflated || method == CompressionMethod.Stored;
-    }
-
-    public static string CleanName(string name)
-    {
-      if (name == null)
-        return string.Empty;
-      if (Path.IsPathRooted(name))
-        name = name.Substring(Path.GetPathRoot(name).Length);
-      name = name.Replace("\\", "/");
-      while (name.Length > 0 && name[0] == '/')
-        name = name.Remove(0, 1);
-      return name;
-    }
-
-    [System.Flags]
-    private enum Known : byte
-    {
-      None = 0,
-      Size = 1,
-      CompressedSize = 2,
-      Crc = 4,
-      Time = 8,
-      ExternalAttributes = 16, // 0x10
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipEntryFactory.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipEntryFactory.cs
deleted file mode 100644
index 2083183..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipEntryFactory.cs
+++ /dev/null
@@ -1,148 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Core;
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  internal class ZipEntryFactory : IEntryFactory
-  {
-    private INameTransform nameTransform_;
-    private DateTime fixedDateTime_ = DateTime.Now;
-    private ZipEntryFactory.TimeSetting timeSetting_;
-    private int getAttributes_ = -1;
-    private int setAttributes_;
-
-    public ZipEntryFactory() => this.nameTransform_ = (INameTransform) new ZipNameTransform();
-
-    public ZipEntryFactory(ZipEntryFactory.TimeSetting timeSetting)
-    {
-      this.timeSetting_ = timeSetting;
-      this.nameTransform_ = (INameTransform) new ZipNameTransform();
-    }
-
-    public ZipEntryFactory(DateTime time)
-    {
-      this.timeSetting_ = ZipEntryFactory.TimeSetting.Fixed;
-      this.FixedDateTime = time;
-      this.nameTransform_ = (INameTransform) new ZipNameTransform();
-    }
-
-    public INameTransform NameTransform
-    {
-      get => this.nameTransform_;
-      set
-      {
-        if (value == null)
-          this.nameTransform_ = (INameTransform) new ZipNameTransform();
-        else
-          this.nameTransform_ = value;
-      }
-    }
-
-    public ZipEntryFactory.TimeSetting Setting
-    {
-      get => this.timeSetting_;
-      set => this.timeSetting_ = value;
-    }
-
-    public DateTime FixedDateTime
-    {
-      get => this.fixedDateTime_;
-      set
-      {
-        this.fixedDateTime_ = value.Year >= 1970 ? value : throw new ArgumentException("Value is too old to be valid", nameof (value));
-      }
-    }
-
-    public int GetAttributes
-    {
-      get => this.getAttributes_;
-      set => this.getAttributes_ = value;
-    }
-
-    public int SetAttributes
-    {
-      get => this.setAttributes_;
-      set => this.setAttributes_ = value;
-    }
-
-    public ZipEntry MakeFileEntry(string fileName)
-    {
-      FileInfo fileInfo = new FileInfo(fileName);
-      ZipEntry zipEntry = new ZipEntry(this.nameTransform_.TransformFile(fileName));
-      zipEntry.Size = fileInfo.Length;
-      int num = (int) (fileInfo.Attributes & (FileAttributes) this.getAttributes_ | (FileAttributes) this.setAttributes_);
-      zipEntry.ExternalFileAttributes = num;
-      switch (this.timeSetting_)
-      {
-        case ZipEntryFactory.TimeSetting.LastWriteTime:
-          zipEntry.DateTime = fileInfo.LastWriteTime;
-          break;
-        case ZipEntryFactory.TimeSetting.LastWriteTimeUtc:
-          zipEntry.DateTime = fileInfo.LastWriteTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.CreateTime:
-          zipEntry.DateTime = fileInfo.CreationTime;
-          break;
-        case ZipEntryFactory.TimeSetting.CreateTimeUtc:
-          zipEntry.DateTime = fileInfo.CreationTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.LastAccessTime:
-          zipEntry.DateTime = fileInfo.LastAccessTime;
-          break;
-        case ZipEntryFactory.TimeSetting.LastAccessTimeUtc:
-          zipEntry.DateTime = fileInfo.LastAccessTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.Fixed:
-          zipEntry.DateTime = this.fixedDateTime_;
-          break;
-      }
-      zipEntry.DateTime = fileInfo.LastWriteTime;
-      return zipEntry;
-    }
-
-    public ZipEntry MakeDirectoryEntry(string directoryName)
-    {
-      DirectoryInfo directoryInfo = new DirectoryInfo(directoryName);
-      ZipEntry zipEntry = new ZipEntry(this.nameTransform_.TransformDirectory(directoryName));
-      zipEntry.ExternalFileAttributes = (int) (directoryInfo.Attributes & (FileAttributes) this.getAttributes_ | (FileAttributes) this.setAttributes_);
-      switch (this.timeSetting_)
-      {
-        case ZipEntryFactory.TimeSetting.LastWriteTime:
-          zipEntry.DateTime = directoryInfo.LastWriteTime;
-          break;
-        case ZipEntryFactory.TimeSetting.LastWriteTimeUtc:
-          zipEntry.DateTime = directoryInfo.LastWriteTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.CreateTime:
-          zipEntry.DateTime = directoryInfo.CreationTime;
-          break;
-        case ZipEntryFactory.TimeSetting.CreateTimeUtc:
-          zipEntry.DateTime = directoryInfo.CreationTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.LastAccessTime:
-          zipEntry.DateTime = directoryInfo.LastAccessTime;
-          break;
-        case ZipEntryFactory.TimeSetting.LastAccessTimeUtc:
-          zipEntry.DateTime = directoryInfo.LastAccessTimeUtc;
-          break;
-        case ZipEntryFactory.TimeSetting.Fixed:
-          zipEntry.DateTime = this.fixedDateTime_;
-          break;
-      }
-      return zipEntry;
-    }
-
-    public enum TimeSetting
-    {
-      LastWriteTime,
-      LastWriteTimeUtc,
-      CreateTime,
-      CreateTimeUtc,
-      LastAccessTime,
-      LastAccessTimeUtc,
-      Fixed,
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipException.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipException.cs
deleted file mode 100644
index dc71dcf..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipException.cs
+++ /dev/null
@@ -1,29 +0,0 @@
-
-using System;
-using System.Runtime.Serialization;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  [Serializable]
-  public class ZipException : SharpZipBaseException
-  {
-    protected ZipException(SerializationInfo info, StreamingContext context)
-      : base(info, context)
-    {
-    }
-
-    public ZipException()
-    {
-    }
-
-    public ZipException(string message)
-      : base(message)
-    {
-    }
-
-    public ZipException(string message, Exception exception)
-      : base(message, exception)
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipExtraData.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipExtraData.cs
deleted file mode 100644
index 241cd23..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipExtraData.cs
+++ /dev/null
@@ -1,230 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public sealed class ZipExtraData : IDisposable
-  {
-    private int index_;
-    private int readValueStart_;
-    private int readValueLength_;
-    private MemoryStream newEntry_;
-    private byte[] data_;
-
-    public ZipExtraData() => this.Clear();
-
-    public ZipExtraData(byte[] data)
-    {
-      if (data == null)
-        this.data_ = new byte[0];
-      else
-        this.data_ = data;
-    }
-
-    public byte[] GetEntryData()
-    {
-      if (this.Length > (int) ushort.MaxValue)
-        throw new ZipException("Data exceeds maximum length");
-      return (byte[]) this.data_.Clone();
-    }
-
-    public void Clear()
-    {
-      if (this.data_ != null && this.data_.Length == 0)
-        return;
-      this.data_ = new byte[0];
-    }
-
-    public int Length => this.data_.Length;
-
-    public Stream GetStreamForTag(int tag)
-    {
-      Stream streamForTag = (Stream) null;
-      if (this.Find(tag))
-        streamForTag = (Stream) new MemoryStream(this.data_, this.index_, this.readValueLength_, false);
-      return streamForTag;
-    }
-
-    public int ValueLength => this.readValueLength_;
-
-    public int CurrentReadIndex => this.index_;
-
-    public int UnreadCount
-    {
-      get
-      {
-        if (this.readValueStart_ > this.data_.Length || this.readValueStart_ < 4)
-          throw new ZipException("Find must be called before calling a Read method");
-        return this.readValueStart_ + this.readValueLength_ - this.index_;
-      }
-    }
-
-    public bool Find(int headerID)
-    {
-      this.readValueStart_ = this.data_.Length;
-      this.readValueLength_ = 0;
-      this.index_ = 0;
-      int num1 = this.readValueStart_;
-      int num2 = headerID - 1;
-      while (num2 != headerID && this.index_ < this.data_.Length - 3)
-      {
-        num2 = this.ReadShortInternal();
-        num1 = this.ReadShortInternal();
-        if (num2 != headerID)
-          this.index_ += num1;
-      }
-      bool flag = num2 == headerID && this.index_ + num1 <= this.data_.Length;
-      if (flag)
-      {
-        this.readValueStart_ = this.index_;
-        this.readValueLength_ = num1;
-      }
-      return flag;
-    }
-
-    public void AddEntry(int headerID, byte[] fieldData)
-    {
-      if (headerID > (int) ushort.MaxValue || headerID < 0)
-        throw new ArgumentOutOfRangeException(nameof (headerID));
-      int length1 = fieldData == null ? 0 : fieldData.Length;
-      if (length1 > (int) ushort.MaxValue)
-        throw new ArgumentOutOfRangeException(nameof (fieldData), "exceeds maximum length");
-      int length2 = this.data_.Length + length1 + 4;
-      if (this.Find(headerID))
-        length2 -= this.ValueLength + 4;
-      if (length2 > (int) ushort.MaxValue)
-        throw new ZipException("Data exceeds maximum length");
-      this.Delete(headerID);
-      byte[] numArray = new byte[length2];
-      this.data_.CopyTo((Array) numArray, 0);
-      int length3 = this.data_.Length;
-      this.data_ = numArray;
-      this.SetShort(ref length3, headerID);
-      this.SetShort(ref length3, length1);
-      fieldData?.CopyTo((Array) numArray, length3);
-    }
-
-    private void SetShort(ref int index, int source)
-    {
-      this.data_[index] = (byte) source;
-      this.data_[index + 1] = (byte) (source >> 8);
-      index += 2;
-    }
-
-    public void StartNewEntry() => this.newEntry_ = new MemoryStream();
-
-    public void AddNewEntry(int headerID)
-    {
-      byte[] array = this.newEntry_.ToArray();
-      this.newEntry_ = (MemoryStream) null;
-      this.AddEntry(headerID, array);
-    }
-
-    public void AddData(byte data) => this.newEntry_.WriteByte(data);
-
-    public void AddData(byte[] data)
-    {
-      if (data == null)
-        throw new ArgumentNullException(nameof (data));
-      this.newEntry_.Write(data, 0, data.Length);
-    }
-
-    public void AddLeShort(int toAdd)
-    {
-      this.newEntry_.WriteByte((byte) toAdd);
-      this.newEntry_.WriteByte((byte) (toAdd >> 8));
-    }
-
-    public void AddLeInt(int toAdd)
-    {
-      this.AddLeShort((int) (short) toAdd);
-      this.AddLeShort((int) (short) (toAdd >> 16));
-    }
-
-    public void AddLeLong(long toAdd)
-    {
-      this.AddLeInt((int) (toAdd & (long) uint.MaxValue));
-      this.AddLeInt((int) (toAdd >> 32));
-    }
-
-    public bool Delete(int headerID)
-    {
-      bool flag = false;
-      if (this.Find(headerID))
-      {
-        flag = true;
-        int num = this.readValueStart_ - 4;
-        byte[] destinationArray = new byte[this.data_.Length - (this.ValueLength + 4)];
-        Array.Copy((Array) this.data_, 0, (Array) destinationArray, 0, num);
-        int sourceIndex = num + this.ValueLength + 4;
-        Array.Copy((Array) this.data_, sourceIndex, (Array) destinationArray, num, this.data_.Length - sourceIndex);
-        this.data_ = destinationArray;
-      }
-      return flag;
-    }
-
-    public long ReadLong()
-    {
-      this.ReadCheck(8);
-      return (long) this.ReadInt() & (long) uint.MaxValue | (long) this.ReadInt() << 32;
-    }
-
-    public int ReadInt()
-    {
-      this.ReadCheck(4);
-      int num = (int) this.data_[this.index_] + ((int) this.data_[this.index_ + 1] << 8) + ((int) this.data_[this.index_ + 2] << 16) + ((int) this.data_[this.index_ + 3] << 24);
-      this.index_ += 4;
-      return num;
-    }
-
-    public int ReadShort()
-    {
-      this.ReadCheck(2);
-      int num = (int) this.data_[this.index_] + ((int) this.data_[this.index_ + 1] << 8);
-      this.index_ += 2;
-      return num;
-    }
-
-    public int ReadByte()
-    {
-      int num = -1;
-      if (this.index_ < this.data_.Length && this.readValueStart_ + this.readValueLength_ > this.index_)
-      {
-        num = (int) this.data_[this.index_];
-        ++this.index_;
-      }
-      return num;
-    }
-
-    public void Skip(int amount)
-    {
-      this.ReadCheck(amount);
-      this.index_ += amount;
-    }
-
-    private void ReadCheck(int length)
-    {
-      if (this.readValueStart_ > this.data_.Length || this.readValueStart_ < 4)
-        throw new ZipException("Find must be called before calling a Read method");
-      if (this.index_ > this.readValueStart_ + this.readValueLength_ - length)
-        throw new ZipException("End of extra data");
-    }
-
-    private int ReadShortInternal()
-    {
-      if (this.index_ > this.data_.Length - 2)
-        throw new ZipException("End of extra data");
-      int num = (int) this.data_[this.index_] + ((int) this.data_[this.index_ + 1] << 8);
-      this.index_ += 2;
-      return num;
-    }
-
-    public void Dispose()
-    {
-      if (this.newEntry_ == null)
-        return;
-      this.newEntry_.Close();
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipFile.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipFile.cs
deleted file mode 100644
index 4272242..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipFile.cs
+++ /dev/null
@@ -1,1851 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Core;
-using ICSharpCode.SharpZipLib.Encryption;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.Collections;
-using System.Globalization;
-using System.IO;
-using System.Runtime.CompilerServices;
-using System.Security.Cryptography;
-using System.Text;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipFile : IEnumerable, IDisposable
-  {
-    private const int DefaultBufferSize = 4096;
-    public ZipFile.KeysRequiredEventHandler KeysRequired;
-    private bool isDisposed_;
-    private string name_;
-    private string comment_;
-    private Stream baseStream_;
-    private bool isStreamOwner;
-    private long offsetOfFirstEntry;
-    private ZipEntry[] entries_;
-    private byte[] key;
-    private bool isNewArchive_;
-    private UseZip64 useZip64_;
-    private ArrayList updates_;
-    private IArchiveStorage archiveStorage_;
-    private IDynamicDataSource updateDataSource_;
-    private bool contentsEdited_;
-    private int bufferSize_ = 4096;
-    private byte[] copyBuffer_;
-    private ZipFile.ZipString newComment_;
-    private bool commentEdited_;
-    private INameTransform updateNameTransform_ = (INameTransform) new ZipNameTransform();
-    private string tempDirectory_ = string.Empty;
-
-    private void OnKeysRequired(string fileName)
-    {
-      if (this.KeysRequired == null)
-        return;
-      KeysRequiredEventArgs e = new KeysRequiredEventArgs(fileName, this.key);
-      this.KeysRequired((object) this, e);
-      this.key = e.Key;
-    }
-
-    private byte[] Key
-    {
-      get => this.key;
-      set => this.key = value;
-    }
-
-    public string Password
-    {
-      set
-      {
-        if (value == null || value.Length == 0)
-          this.key = (byte[]) null;
-        else
-          this.key = PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(value));
-      }
-    }
-
-    private bool HaveKeys => this.key != null;
-
-    public ZipFile(string name)
-    {
-      this.name_ = name;
-      this.baseStream_ = (Stream) File.OpenRead(name);
-      this.isStreamOwner = true;
-      try
-      {
-        this.ReadEntries();
-      }
-      catch
-      {
-        this.DisposeInternal(true);
-        throw;
-      }
-    }
-
-    public ZipFile(FileStream file)
-    {
-      if (file == null)
-        throw new ArgumentNullException(nameof (file));
-      this.baseStream_ = file.CanSeek ? (Stream) file : throw new ArgumentException("Stream is not seekable", nameof (file));
-      this.name_ = file.Name;
-      this.isStreamOwner = true;
-      try
-      {
-        this.ReadEntries();
-      }
-      catch
-      {
-        this.DisposeInternal(true);
-        throw;
-      }
-    }
-
-    public ZipFile(Stream stream)
-    {
-      if (stream == null)
-        throw new ArgumentNullException(nameof (stream));
-      this.baseStream_ = stream.CanSeek ? stream : throw new ArgumentException("Stream is not seekable", nameof (stream));
-      this.isStreamOwner = true;
-      if (this.baseStream_.Length > 0L)
-      {
-        try
-        {
-          this.ReadEntries();
-        }
-        catch
-        {
-          this.DisposeInternal(true);
-          throw;
-        }
-      }
-      else
-      {
-        this.entries_ = new ZipEntry[0];
-        this.isNewArchive_ = true;
-      }
-    }
-
-    internal ZipFile()
-    {
-      this.entries_ = new ZipEntry[0];
-      this.isNewArchive_ = true;
-    }
-
-    ~ZipFile() => this.Dispose(false);
-
-    public void Close()
-    {
-      this.DisposeInternal(true);
-      GC.SuppressFinalize((object) this);
-    }
-
-    public static ZipFile Create(string fileName)
-    {
-      FileStream fileStream = fileName != null ? File.Create(fileName) : throw new ArgumentNullException(nameof (fileName));
-      return new ZipFile()
-      {
-        name_ = fileName,
-        baseStream_ = (Stream) fileStream,
-        isStreamOwner = true
-      };
-    }
-
-    public static ZipFile Create(Stream outStream)
-    {
-      if (outStream == null)
-        throw new ArgumentNullException(nameof (outStream));
-      if (!outStream.CanWrite)
-        throw new ArgumentException("Stream is not writeable", nameof (outStream));
-      return outStream.CanSeek ? new ZipFile()
-      {
-        baseStream_ = outStream
-      } : throw new ArgumentException("Stream is not seekable", nameof (outStream));
-    }
-
-    public bool IsStreamOwner
-    {
-      get => this.isStreamOwner;
-      set => this.isStreamOwner = value;
-    }
-
-    public bool IsEmbeddedArchive => this.offsetOfFirstEntry > 0L;
-
-    public bool IsNewArchive => this.isNewArchive_;
-
-    public string ZipFileComment => this.comment_;
-
-    public string Name => this.name_;
-
-    [Obsolete("Use the Count property instead")]
-    public int Size
-    {
-      get
-      {
-        return this.entries_ != null ? this.entries_.Length : throw new InvalidOperationException("ZipFile is closed");
-      }
-    }
-
-    public long Count
-    {
-      get
-      {
-        return this.entries_ != null ? (long) this.entries_.Length : throw new InvalidOperationException("ZipFile is closed");
-      }
-    }
-
-    [IndexerName("EntryByIndex")]
-    public ZipEntry this[int index] => (ZipEntry) this.entries_[index].Clone();
-
-    public IEnumerator GetEnumerator()
-    {
-      return this.entries_ != null ? (IEnumerator) new ZipFile.ZipEntryEnumerator(this.entries_) : throw new InvalidOperationException("ZipFile has closed");
-    }
-
-    public int FindEntry(string name, bool ignoreCase)
-    {
-      if (this.entries_ == null)
-        throw new InvalidOperationException("ZipFile has been closed");
-      for (int entry = 0; entry < this.entries_.Length; ++entry)
-      {
-        if (string.Compare(name, this.entries_[entry].Name, ignoreCase, CultureInfo.InvariantCulture) == 0)
-          return entry;
-      }
-      return -1;
-    }
-
-    public ZipEntry GetEntry(string name)
-    {
-      if (this.entries_ == null)
-        throw new InvalidOperationException("ZipFile has been closed");
-      int entry = this.FindEntry(name, true);
-      return entry < 0 ? (ZipEntry) null : (ZipEntry) this.entries_[entry].Clone();
-    }
-
-    public Stream GetInputStream(ZipEntry entry)
-    {
-      if (entry == null)
-        throw new ArgumentNullException(nameof (entry));
-      if (this.entries_ == null)
-        throw new InvalidOperationException("ZipFile has closed");
-      long entryIndex = entry.ZipFileIndex;
-      if (entryIndex < 0L || entryIndex >= (long) this.entries_.Length || this.entries_[entryIndex].Name != entry.Name)
-      {
-        entryIndex = (long) this.FindEntry(entry.Name, true);
-        if (entryIndex < 0L)
-          throw new ZipException("Entry cannot be found");
-      }
-      return this.GetInputStream(entryIndex);
-    }
-
-    public Stream GetInputStream(long entryIndex)
-    {
-      long start = this.entries_ != null ? this.LocateEntry(this.entries_[entryIndex]) : throw new InvalidOperationException("ZipFile is not open");
-      CompressionMethod compressionMethod = this.entries_[entryIndex].CompressionMethod;
-      Stream inputStream = (Stream) new ZipFile.PartialInputStream(this.baseStream_, start, this.entries_[entryIndex].CompressedSize);
-      if (this.entries_[entryIndex].IsCrypted)
-      {
-        inputStream = this.CreateAndInitDecryptionStream(inputStream, this.entries_[entryIndex]);
-        if (inputStream == null)
-          throw new ZipException("Unable to decrypt this entry");
-      }
-      switch (compressionMethod)
-      {
-        case CompressionMethod.Stored:
-          return inputStream;
-        case CompressionMethod.Deflated:
-          inputStream = (Stream) new InflaterInputStream(inputStream, new Inflater(true));
-          goto case CompressionMethod.Stored;
-        default:
-          throw new ZipException("Unsupported compression method " + (object) compressionMethod);
-      }
-    }
-
-    public bool TestArchive(bool testData)
-    {
-      return this.TestArchive(testData, TestStrategy.FindFirstError, (ZipTestResultHandler) null);
-    }
-
-    public bool TestArchive(
-      bool testData,
-      TestStrategy strategy,
-      ZipTestResultHandler resultHandler)
-    {
-      TestStatus status = new TestStatus(this);
-      if (resultHandler != null)
-        resultHandler(status, (string) null);
-      ZipFile.HeaderTest tests = testData ? ZipFile.HeaderTest.Extract | ZipFile.HeaderTest.Header : ZipFile.HeaderTest.Header;
-      bool flag = true;
-      try
-      {
-        for (int index = 0; flag && (long) index < this.Count; ++index)
-        {
-          if (resultHandler != null)
-          {
-            status.SetEntry(this[index]);
-            status.SetOperation(TestOperation.EntryHeader);
-            resultHandler(status, (string) null);
-          }
-          try
-          {
-            this.TestLocalHeader(this[index], tests);
-          }
-          catch (ZipException ex)
-          {
-            status.AddError();
-            if (resultHandler != null)
-              resultHandler(status, string.Format("Exception during test - '{0}'", (object) ex.Message));
-            if (strategy == TestStrategy.FindFirstError)
-              flag = false;
-          }
-          if (flag && testData && this[index].IsFile)
-          {
-            if (resultHandler != null)
-            {
-              status.SetOperation(TestOperation.EntryData);
-              resultHandler(status, (string) null);
-            }
-            Stream inputStream = this.GetInputStream(this[index]);
-            Crc32 crc32 = new Crc32();
-            byte[] buffer = new byte[4096];
-            long num = 0;
-            int count;
-            while ((count = inputStream.Read(buffer, 0, buffer.Length)) > 0)
-            {
-              crc32.Update(buffer, 0, count);
-              if (resultHandler != null)
-              {
-                num += (long) count;
-                status.SetBytesTested(num);
-                resultHandler(status, (string) null);
-              }
-            }
-            if (this[index].Crc != crc32.Value)
-            {
-              status.AddError();
-              if (resultHandler != null)
-                resultHandler(status, "CRC mismatch");
-              if (strategy == TestStrategy.FindFirstError)
-                flag = false;
-            }
-          }
-          if (resultHandler != null)
-          {
-            status.SetOperation(TestOperation.EntryComplete);
-            resultHandler(status, (string) null);
-          }
-        }
-        if (resultHandler != null)
-        {
-          status.SetOperation(TestOperation.MiscellaneousTests);
-          resultHandler(status, (string) null);
-        }
-      }
-      catch (Exception ex)
-      {
-        status.AddError();
-        if (resultHandler != null)
-          resultHandler(status, string.Format("Exception during test - '{0}'", (object) ex.Message));
-      }
-      if (resultHandler != null)
-      {
-        status.SetOperation(TestOperation.Complete);
-        status.SetEntry((ZipEntry) null);
-        resultHandler(status, (string) null);
-      }
-      return status.ErrorCount == 0;
-    }
-
-    private long TestLocalHeader(ZipEntry entry, ZipFile.HeaderTest tests)
-    {
-      lock (this.baseStream_)
-      {
-        bool flag1 = (tests & ZipFile.HeaderTest.Header) != (ZipFile.HeaderTest) 0;
-        bool flag2 = (tests & ZipFile.HeaderTest.Extract) != (ZipFile.HeaderTest) 0;
-        this.baseStream_.Seek(this.offsetOfFirstEntry + entry.Offset, SeekOrigin.Begin);
-        if (this.ReadLEUint() != 67324752U)
-          throw new ZipException(string.Format("Wrong local header signature @{0:X}", (object) (this.offsetOfFirstEntry + entry.Offset)));
-        short num1 = (short) this.ReadLEUshort();
-        short flags = (short) this.ReadLEUshort();
-        short num2 = (short) this.ReadLEUshort();
-        short num3 = (short) this.ReadLEUshort();
-        short num4 = (short) this.ReadLEUshort();
-        uint num5 = this.ReadLEUint();
-        long num6 = (long) this.ReadLEUint();
-        long num7 = (long) this.ReadLEUint();
-        int length1 = (int) this.ReadLEUshort();
-        int length2 = (int) this.ReadLEUshort();
-        byte[] numArray1 = new byte[length1];
-        StreamUtils.ReadFully(this.baseStream_, numArray1);
-        byte[] numArray2 = new byte[length2];
-        StreamUtils.ReadFully(this.baseStream_, numArray2);
-        ZipExtraData zipExtraData = new ZipExtraData(numArray2);
-        if (zipExtraData.Find(1))
-        {
-          if (num1 < (short) 45)
-            throw new ZipException(string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough", (object) ((int) num1 / 10), (object) ((int) num1 % 10)));
-          num7 = (uint) num7 == uint.MaxValue || (uint) num6 == uint.MaxValue ? zipExtraData.ReadLong() : throw new ZipException("Entry sizes not correct for Zip64");
-          num6 = zipExtraData.ReadLong();
-        }
-        else if (num1 >= (short) 45 && ((uint) num7 == uint.MaxValue || (uint) num6 == uint.MaxValue))
-          throw new ZipException("Required Zip64 extended information missing");
-        if (flag2 && entry.IsFile)
-        {
-          if (!entry.IsCompressionMethodSupported())
-            throw new ZipException("Compression method not supported");
-          if (num1 > (short) 45 || num1 > (short) 20 && num1 < (short) 45)
-            throw new ZipException(string.Format("Version required to extract this entry not supported ({0})", (object) num1));
-          if (((int) flags & 12384) != 0)
-            throw new ZipException("The library does not support the zip version required to extract this entry");
-        }
-        if (flag1)
-        {
-          if (num1 <= (short) 63 && num1 != (short) 10 && num1 != (short) 11 && num1 != (short) 20 && num1 != (short) 21 && num1 != (short) 25 && num1 != (short) 27 && num1 != (short) 45 && num1 != (short) 46 && num1 != (short) 50 && num1 != (short) 51 && num1 != (short) 52 && num1 != (short) 61 && num1 != (short) 62 && num1 != (short) 63)
-            throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})", (object) num1));
-          if (((int) flags & 49168) != 0)
-            throw new ZipException("Reserved bit flags cannot be set.");
-          if (((int) flags & 1) != 0 && num1 < (short) 20)
-            throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})", (object) num1));
-          if (((int) flags & 64) != 0)
-          {
-            if (((int) flags & 1) == 0)
-              throw new ZipException("Strong encryption flag set but encryption flag is not set");
-            if (num1 < (short) 50)
-              throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})", (object) num1));
-          }
-          if (((int) flags & 32) != 0 && num1 < (short) 27)
-            throw new ZipException(string.Format("Patched data requires higher version than ({0})", (object) num1));
-          if ((int) flags != entry.Flags)
-            throw new ZipException("Central header/local header flags mismatch");
-          if (entry.CompressionMethod != (CompressionMethod) num2)
-            throw new ZipException("Central header/local header compression method mismatch");
-          if (((int) flags & 64) != 0 && num1 < (short) 62)
-            throw new ZipException("Strong encryption flag set but version not high enough");
-          if (((int) flags & 8192) != 0 && (num3 != (short) 0 || num4 != (short) 0))
-            throw new ZipException("Header masked set but date/time values non-zero");
-          if (((int) flags & 8) == 0 && (int) num5 != (int) (uint) entry.Crc)
-            throw new ZipException("Central header/local header crc mismatch");
-          if (num7 == 0L && num6 == 0L && num5 != 0U)
-            throw new ZipException("Invalid CRC for empty entry");
-          if (entry.Name.Length > length1)
-            throw new ZipException("File name length mismatch");
-          string stringExt = ZipConstants.ConvertToStringExt((int) flags, numArray1);
-          if (stringExt != entry.Name)
-            throw new ZipException("Central header and local header file name mismatch");
-          if (entry.IsDirectory && (num6 != 0L || num7 != 0L))
-            throw new ZipException("Directory cannot have size");
-          if (!ZipNameTransform.IsValidName(stringExt, true))
-            throw new ZipException("Name is invalid");
-        }
-        if (((int) flags & 8) == 0 || num7 != 0L || num6 != 0L)
-        {
-          if (num7 != entry.Size)
-            throw new ZipException(string.Format("Size mismatch between central header({0}) and local header({1})", (object) entry.Size, (object) num7));
-          if (num6 != entry.CompressedSize)
-            throw new ZipException(string.Format("Compressed size mismatch between central header({0}) and local header({1})", (object) entry.CompressedSize, (object) num6));
-        }
-        int num8 = length1 + length2;
-        return this.offsetOfFirstEntry + entry.Offset + 30L + (long) num8;
-      }
-    }
-
-    public INameTransform NameTransform
-    {
-      get => this.updateNameTransform_;
-      set => this.updateNameTransform_ = value;
-    }
-
-    public int BufferSize
-    {
-      get => this.bufferSize_;
-      set
-      {
-        if (value < 1024)
-          throw new ArgumentOutOfRangeException(nameof (value), "cannot be below 1024");
-        if (this.bufferSize_ == value)
-          return;
-        this.bufferSize_ = value;
-        this.copyBuffer_ = (byte[]) null;
-      }
-    }
-
-    public bool IsUpdating => this.updates_ != null;
-
-    public UseZip64 UseZip64
-    {
-      get => this.useZip64_;
-      set => this.useZip64_ = value;
-    }
-
-    public void BeginUpdate(IArchiveStorage archiveStorage, IDynamicDataSource dataSource)
-    {
-      if (this.IsEmbeddedArchive)
-        throw new ZipException("Cannot update embedded/SFX archives");
-      if (archiveStorage == null)
-        throw new ArgumentNullException(nameof (archiveStorage));
-      if (dataSource == null)
-        throw new ArgumentNullException(nameof (dataSource));
-      this.archiveStorage_ = archiveStorage;
-      this.updateDataSource_ = dataSource;
-      if (this.entries_ != null)
-      {
-        this.updates_ = new ArrayList(this.entries_.Length);
-        foreach (ZipEntry entry in this.entries_)
-          this.updates_.Add((object) new ZipFile.ZipUpdate(entry));
-      }
-      else
-        this.updates_ = new ArrayList();
-      this.contentsEdited_ = false;
-      this.commentEdited_ = false;
-      this.newComment_ = (ZipFile.ZipString) null;
-    }
-
-    public void BeginUpdate(IArchiveStorage archiveStorage)
-    {
-      this.BeginUpdate(archiveStorage, (IDynamicDataSource) new DynamicDiskDataSource());
-    }
-
-    public void BeginUpdate()
-    {
-      if (this.Name == null)
-        this.BeginUpdate((IArchiveStorage) new MemoryArchiveStorage(), (IDynamicDataSource) new DynamicDiskDataSource());
-      else
-        this.BeginUpdate((IArchiveStorage) new DiskArchiveStorage(this), (IDynamicDataSource) new DynamicDiskDataSource());
-    }
-
-    public void CommitUpdate()
-    {
-      this.CheckUpdating();
-      if (this.contentsEdited_)
-        this.RunUpdates();
-      else if (this.commentEdited_)
-        this.UpdateCommentOnly();
-      else if (this.entries_ != null && this.entries_.Length == 0)
-      {
-        byte[] comment = this.newComment_ != null ? this.newComment_.RawComment : ZipConstants.ConvertToArray(this.comment_);
-        using (ZipHelperStream zipHelperStream = new ZipHelperStream(this.baseStream_))
-          zipHelperStream.WriteEndOfCentralDirectory(0L, 0L, 0L, comment);
-      }
-      this.PostUpdateCleanup();
-    }
-
-    public void AbortUpdate()
-    {
-      this.updates_ = (ArrayList) null;
-      this.PostUpdateCleanup();
-    }
-
-    public void SetComment(string comment)
-    {
-      this.CheckUpdating();
-      this.newComment_ = new ZipFile.ZipString(comment);
-      if (this.newComment_.RawLength > (int) ushort.MaxValue)
-      {
-        this.newComment_ = (ZipFile.ZipString) null;
-        throw new ZipException("Comment length exceeds maximum - 65535");
-      }
-      this.commentEdited_ = true;
-    }
-
-    public void Add(string fileName, CompressionMethod compressionMethod, bool useUnicodeText)
-    {
-      if (fileName == null)
-        throw new ArgumentNullException(nameof (fileName));
-      if (!ZipEntry.IsCompressionMethodSupported(compressionMethod))
-        throw new ZipException("Compression method not supported");
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      string transformedFileName = this.GetTransformedFileName(fileName);
-      int existingUpdate = this.FindExistingUpdate(transformedFileName);
-      if (existingUpdate >= 0)
-        this.updates_.RemoveAt(existingUpdate);
-      this.updates_.Add((object) new ZipFile.ZipUpdate(fileName, transformedFileName, compressionMethod)
-      {
-        Entry = {
-          IsUnicodeText = useUnicodeText
-        }
-      });
-    }
-
-    public void Add(string fileName, CompressionMethod compressionMethod)
-    {
-      if (fileName == null)
-        throw new ArgumentNullException(nameof (fileName));
-      if (!ZipEntry.IsCompressionMethodSupported(compressionMethod))
-        throw new ZipException("Compression method not supported");
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      string transformedFileName = this.GetTransformedFileName(fileName);
-      int existingUpdate = this.FindExistingUpdate(transformedFileName);
-      if (existingUpdate >= 0)
-        this.updates_.RemoveAt(existingUpdate);
-      this.updates_.Add((object) new ZipFile.ZipUpdate(fileName, transformedFileName, compressionMethod));
-    }
-
-    public void Add(string fileName)
-    {
-      if (fileName == null)
-        throw new ArgumentNullException(nameof (fileName));
-      this.CheckUpdating();
-      this.Add(fileName, CompressionMethod.Deflated);
-    }
-
-    public void Add(IStaticDataSource dataSource, string entryName)
-    {
-      if (dataSource == null)
-        throw new ArgumentNullException(nameof (dataSource));
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      this.updates_.Add((object) new ZipFile.ZipUpdate(dataSource, this.GetTransformedFileName(entryName), CompressionMethod.Deflated));
-    }
-
-    public void Add(
-      IStaticDataSource dataSource,
-      string entryName,
-      CompressionMethod compressionMethod)
-    {
-      if (dataSource == null)
-        throw new ArgumentNullException(nameof (dataSource));
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      this.updates_.Add((object) new ZipFile.ZipUpdate(dataSource, this.GetTransformedFileName(entryName), compressionMethod));
-    }
-
-    public void Add(
-      IStaticDataSource dataSource,
-      string entryName,
-      CompressionMethod compressionMethod,
-      bool useUnicodeText)
-    {
-      if (dataSource == null)
-        throw new ArgumentNullException(nameof (dataSource));
-      this.CheckUpdating();
-      this.contentsEdited_ = true;
-      this.updates_.Add((object) new ZipFile.ZipUpdate(dataSource, this.GetTransformedFileName(entryName), compressionMethod)
-      {
-        Entry = {
-          IsUnicodeText = useUnicodeText
-        }
-      });
-    }
-
-    public void Add(ZipEntry entry)
-    {
-      if (entry == null)
-        throw new ArgumentNullException(nameof (entry));
-      this.CheckUpdating();
-      if (entry.Size != 0L || entry.CompressedSize != 0L)
-        throw new ZipException("Entry cannot have any data");
-      this.contentsEdited_ = true;
-      this.updates_.Add((object) new ZipFile.ZipUpdate(ZipFile.UpdateCommand.Add, entry));
-    }
-
-    public void AddDirectory(string directoryName)
-    {
-      if (directoryName == null)
-        throw new ArgumentNullException(nameof (directoryName));
-      this.CheckUpdating();
-      this.updates_.Add((object) new ZipFile.ZipUpdate(ZipFile.UpdateCommand.Add, new ZipEntry(this.GetTransformedDirectoryName(directoryName))
-      {
-        ExternalFileAttributes = 16
-      }));
-    }
-
-    public bool Delete(string fileName)
-    {
-      this.CheckUpdating();
-      int existingUpdate = this.FindExistingUpdate(fileName);
-      if (existingUpdate < 0)
-        throw new ZipException("Cannot find entry to delete");
-      bool flag = true;
-      this.contentsEdited_ = true;
-      this.updates_.RemoveAt(existingUpdate);
-      return flag;
-    }
-
-    public void Delete(ZipEntry entry)
-    {
-      this.CheckUpdating();
-      int existingUpdate = this.FindExistingUpdate(entry);
-      if (existingUpdate < 0)
-        throw new ZipException("Cannot find entry to delete");
-      this.contentsEdited_ = true;
-      this.updates_.RemoveAt(existingUpdate);
-    }
-
-    private void WriteLEShort(int value)
-    {
-      this.baseStream_.WriteByte((byte) (value & (int) byte.MaxValue));
-      this.baseStream_.WriteByte((byte) (value >> 8 & (int) byte.MaxValue));
-    }
-
-    private void WriteLEUshort(ushort value)
-    {
-      this.baseStream_.WriteByte((byte) ((uint) value & (uint) byte.MaxValue));
-      this.baseStream_.WriteByte((byte) ((uint) value >> 8));
-    }
-
-    private void WriteLEInt(int value)
-    {
-      this.WriteLEShort(value);
-      this.WriteLEShort(value >> 16);
-    }
-
-    private void WriteLEUint(uint value)
-    {
-      this.WriteLEUshort((ushort) (value & (uint) ushort.MaxValue));
-      this.WriteLEUshort((ushort) (value >> 16));
-    }
-
-    private void WriteLeLong(long value)
-    {
-      this.WriteLEInt((int) (value & (long) uint.MaxValue));
-      this.WriteLEInt((int) (value >> 32));
-    }
-
-    private void WriteLEUlong(ulong value)
-    {
-      this.WriteLEUint((uint) (value & (ulong) uint.MaxValue));
-      this.WriteLEUint((uint) (value >> 32));
-    }
-
-    private void WriteLocalEntryHeader(ZipFile.ZipUpdate update)
-    {
-      ZipEntry outEntry = update.OutEntry;
-      outEntry.Offset = this.baseStream_.Position;
-      if (update.Command != ZipFile.UpdateCommand.Copy)
-      {
-        if (outEntry.CompressionMethod == CompressionMethod.Deflated)
-        {
-          if (outEntry.Size == 0L)
-          {
-            outEntry.CompressedSize = outEntry.Size;
-            outEntry.Crc = 0L;
-            outEntry.CompressionMethod = CompressionMethod.Stored;
-          }
-        }
-        else if (outEntry.CompressionMethod == CompressionMethod.Stored)
-          outEntry.Flags &= -9;
-        if (this.HaveKeys)
-        {
-          outEntry.IsCrypted = true;
-          if (outEntry.Crc < 0L)
-            outEntry.Flags |= 8;
-        }
-        else
-          outEntry.IsCrypted = false;
-        switch (this.useZip64_)
-        {
-          case UseZip64.On:
-            outEntry.ForceZip64();
-            break;
-          case UseZip64.Dynamic:
-            if (outEntry.Size < 0L)
-            {
-              outEntry.ForceZip64();
-              break;
-            }
-            break;
-        }
-      }
-      this.WriteLEInt(67324752);
-      this.WriteLEShort(outEntry.Version);
-      this.WriteLEShort(outEntry.Flags);
-      this.WriteLEShort((int) (byte) outEntry.CompressionMethod);
-      this.WriteLEInt((int) outEntry.DosTime);
-      if (!outEntry.HasCrc)
-      {
-        update.CrcPatchOffset = this.baseStream_.Position;
-        this.WriteLEInt(0);
-      }
-      else
-        this.WriteLEInt((int) outEntry.Crc);
-      if (outEntry.LocalHeaderRequiresZip64)
-      {
-        this.WriteLEInt(-1);
-        this.WriteLEInt(-1);
-      }
-      else
-      {
-        if (outEntry.CompressedSize < 0L || outEntry.Size < 0L)
-          update.SizePatchOffset = this.baseStream_.Position;
-        this.WriteLEInt((int) outEntry.CompressedSize);
-        this.WriteLEInt((int) outEntry.Size);
-      }
-      byte[] array = ZipConstants.ConvertToArray(outEntry.Flags, outEntry.Name);
-      if (array.Length > (int) ushort.MaxValue)
-        throw new ZipException("Entry name too long.");
-      ZipExtraData zipExtraData = new ZipExtraData(outEntry.ExtraData);
-      if (outEntry.LocalHeaderRequiresZip64)
-      {
-        zipExtraData.StartNewEntry();
-        zipExtraData.AddLeLong(outEntry.Size);
-        zipExtraData.AddLeLong(outEntry.CompressedSize);
-        zipExtraData.AddNewEntry(1);
-      }
-      else
-        zipExtraData.Delete(1);
-      outEntry.ExtraData = zipExtraData.GetEntryData();
-      this.WriteLEShort(array.Length);
-      this.WriteLEShort(outEntry.ExtraData.Length);
-      if (array.Length > 0)
-        this.baseStream_.Write(array, 0, array.Length);
-      if (outEntry.LocalHeaderRequiresZip64)
-      {
-        if (!zipExtraData.Find(1))
-          throw new ZipException("Internal error cannot find extra data");
-        update.SizePatchOffset = this.baseStream_.Position + (long) zipExtraData.CurrentReadIndex;
-      }
-      if (outEntry.ExtraData.Length <= 0)
-        return;
-      this.baseStream_.Write(outEntry.ExtraData, 0, outEntry.ExtraData.Length);
-    }
-
-    private int WriteCentralDirectoryHeader(ZipEntry entry)
-    {
-      if (entry.CompressedSize < 0L)
-        throw new ZipException("Attempt to write central directory entry with unknown csize");
-      if (entry.Size < 0L)
-        throw new ZipException("Attempt to write central directory entry with unknown size");
-      if (entry.Crc < 0L)
-        throw new ZipException("Attempt to write central directory entry with unknown crc");
-      this.WriteLEInt(33639248);
-      this.WriteLEShort(45);
-      this.WriteLEShort(entry.Version);
-      this.WriteLEShort(entry.Flags);
-      this.WriteLEShort((int) (byte) entry.CompressionMethod);
-      this.WriteLEInt((int) entry.DosTime);
-      this.WriteLEInt((int) entry.Crc);
-      if (entry.IsZip64Forced() || entry.CompressedSize >= (long) uint.MaxValue)
-        this.WriteLEInt(-1);
-      else
-        this.WriteLEInt((int) (entry.CompressedSize & (long) uint.MaxValue));
-      if (entry.IsZip64Forced() || entry.Size >= (long) uint.MaxValue)
-        this.WriteLEInt(-1);
-      else
-        this.WriteLEInt((int) entry.Size);
-      byte[] array = ZipConstants.ConvertToArray(entry.Flags, entry.Name);
-      if (array.Length > (int) ushort.MaxValue)
-        throw new ZipException("Entry name is too long.");
-      this.WriteLEShort(array.Length);
-      ZipExtraData zipExtraData = new ZipExtraData(entry.ExtraData);
-      if (entry.CentralHeaderRequiresZip64)
-      {
-        zipExtraData.StartNewEntry();
-        if (entry.Size >= (long) uint.MaxValue || this.useZip64_ == UseZip64.On)
-          zipExtraData.AddLeLong(entry.Size);
-        if (entry.CompressedSize >= (long) uint.MaxValue || this.useZip64_ == UseZip64.On)
-          zipExtraData.AddLeLong(entry.CompressedSize);
-        if (entry.Offset >= (long) uint.MaxValue)
-          zipExtraData.AddLeLong(entry.Offset);
-        zipExtraData.AddNewEntry(1);
-      }
-      else
-        zipExtraData.Delete(1);
-      byte[] entryData = zipExtraData.GetEntryData();
-      this.WriteLEShort(entryData.Length);
-      this.WriteLEShort(entry.Comment != null ? entry.Comment.Length : 0);
-      this.WriteLEShort(0);
-      this.WriteLEShort(0);
-      if (entry.ExternalFileAttributes != -1)
-        this.WriteLEInt(entry.ExternalFileAttributes);
-      else if (entry.IsDirectory)
-        this.WriteLEUint(16U);
-      else
-        this.WriteLEUint(0U);
-      if (entry.Offset >= (long) uint.MaxValue)
-        this.WriteLEUint(uint.MaxValue);
-      else
-        this.WriteLEUint((uint) (int) entry.Offset);
-      if (array.Length > 0)
-        this.baseStream_.Write(array, 0, array.Length);
-      if (entryData.Length > 0)
-        this.baseStream_.Write(entryData, 0, entryData.Length);
-      byte[] buffer = entry.Comment != null ? Encoding.ASCII.GetBytes(entry.Comment) : new byte[0];
-      if (buffer.Length > 0)
-        this.baseStream_.Write(buffer, 0, buffer.Length);
-      return 46 + array.Length + entryData.Length + buffer.Length;
-    }
-
-    private void PostUpdateCleanup()
-    {
-      if (this.archiveStorage_ != null)
-      {
-        this.archiveStorage_.Dispose();
-        this.archiveStorage_ = (IArchiveStorage) null;
-      }
-      this.updateDataSource_ = (IDynamicDataSource) null;
-    }
-
-    private string GetTransformedFileName(string name)
-    {
-      return this.updateNameTransform_ == null ? name : this.updateNameTransform_.TransformFile(name);
-    }
-
-    private string GetTransformedDirectoryName(string name)
-    {
-      return this.updateNameTransform_ == null ? name : this.updateNameTransform_.TransformDirectory(name);
-    }
-
-    private byte[] GetBuffer()
-    {
-      if (this.copyBuffer_ == null)
-        this.copyBuffer_ = new byte[this.bufferSize_];
-      return this.copyBuffer_;
-    }
-
-    private void CopyDescriptorBytes(ZipFile.ZipUpdate update, Stream dest, Stream source)
-    {
-      int descriptorSize = this.GetDescriptorSize(update);
-      if (descriptorSize <= 0)
-        return;
-      byte[] buffer = this.GetBuffer();
-      int count1;
-      for (; descriptorSize > 0; descriptorSize -= count1)
-      {
-        int count2 = Math.Min(buffer.Length, descriptorSize);
-        count1 = source.Read(buffer, 0, count2);
-        if (count1 <= 0)
-          throw new ZipException("Unxpected end of stream");
-        dest.Write(buffer, 0, count1);
-      }
-    }
-
-    private void CopyBytes(
-      ZipFile.ZipUpdate update,
-      Stream destination,
-      Stream source,
-      long bytesToCopy,
-      bool updateCrc)
-    {
-      if (destination == source)
-        throw new InvalidOperationException("Destination and source are the same");
-      Crc32 crc32 = new Crc32();
-      byte[] buffer = this.GetBuffer();
-      long num1 = bytesToCopy;
-      long num2 = 0;
-      int count1;
-      do
-      {
-        int count2 = buffer.Length;
-        if (bytesToCopy < (long) count2)
-          count2 = (int) bytesToCopy;
-        count1 = source.Read(buffer, 0, count2);
-        if (count1 > 0)
-        {
-          if (updateCrc)
-            crc32.Update(buffer, 0, count1);
-          destination.Write(buffer, 0, count1);
-          bytesToCopy -= (long) count1;
-          num2 += (long) count1;
-        }
-      }
-      while (count1 > 0 && bytesToCopy > 0L);
-      if (num2 != num1)
-        throw new ZipException(string.Format("Failed to copy bytes expected {0} read {1}", (object) num1, (object) num2));
-      if (!updateCrc)
-        return;
-      update.OutEntry.Crc = crc32.Value;
-    }
-
-    private int GetDescriptorSize(ZipFile.ZipUpdate update)
-    {
-      int descriptorSize = 0;
-      if ((update.Entry.Flags & 8) != 0)
-      {
-        descriptorSize = 12;
-        if (update.Entry.LocalHeaderRequiresZip64)
-          descriptorSize = 20;
-      }
-      return descriptorSize;
-    }
-
-    private void CopyDescriptorBytesDirect(
-      ZipFile.ZipUpdate update,
-      Stream stream,
-      ref long destinationPosition,
-      long sourcePosition)
-    {
-      int descriptorSize = this.GetDescriptorSize(update);
-      while (descriptorSize > 0)
-      {
-        int count1 = descriptorSize;
-        byte[] buffer = this.GetBuffer();
-        stream.Position = sourcePosition;
-        int count2 = stream.Read(buffer, 0, count1);
-        if (count2 <= 0)
-          throw new ZipException("Unxpected end of stream");
-        stream.Position = destinationPosition;
-        stream.Write(buffer, 0, count2);
-        descriptorSize -= count2;
-        destinationPosition += (long) count2;
-        sourcePosition += (long) count2;
-      }
-    }
-
-    private void CopyEntryDataDirect(
-      ZipFile.ZipUpdate update,
-      Stream stream,
-      bool updateCrc,
-      ref long destinationPosition,
-      ref long sourcePosition)
-    {
-      long compressedSize = update.Entry.CompressedSize;
-      Crc32 crc32 = new Crc32();
-      byte[] buffer = this.GetBuffer();
-      long num1 = compressedSize;
-      long num2 = 0;
-      int count1;
-      do
-      {
-        int count2 = buffer.Length;
-        if (compressedSize < (long) count2)
-          count2 = (int) compressedSize;
-        stream.Position = sourcePosition;
-        count1 = stream.Read(buffer, 0, count2);
-        if (count1 > 0)
-        {
-          if (updateCrc)
-            crc32.Update(buffer, 0, count1);
-          stream.Position = destinationPosition;
-          stream.Write(buffer, 0, count1);
-          destinationPosition += (long) count1;
-          sourcePosition += (long) count1;
-          compressedSize -= (long) count1;
-          num2 += (long) count1;
-        }
-      }
-      while (count1 > 0 && compressedSize > 0L);
-      if (num2 != num1)
-        throw new ZipException(string.Format("Failed to copy bytes expected {0} read {1}", (object) num1, (object) num2));
-      if (!updateCrc)
-        return;
-      update.OutEntry.Crc = crc32.Value;
-    }
-
-    private int FindExistingUpdate(ZipEntry entry)
-    {
-      int existingUpdate = -1;
-      string transformedFileName = this.GetTransformedFileName(entry.Name);
-      for (int index = 0; index < this.updates_.Count; ++index)
-      {
-        ZipFile.ZipUpdate update = (ZipFile.ZipUpdate) this.updates_[index];
-        if (update.Entry.ZipFileIndex == entry.ZipFileIndex && string.Compare(transformedFileName, update.Entry.Name, true, CultureInfo.InvariantCulture) == 0)
-        {
-          existingUpdate = index;
-          break;
-        }
-      }
-      return existingUpdate;
-    }
-
-    private int FindExistingUpdate(string fileName)
-    {
-      int existingUpdate = -1;
-      string transformedFileName = this.GetTransformedFileName(fileName);
-      for (int index = 0; index < this.updates_.Count; ++index)
-      {
-        if (string.Compare(transformedFileName, ((ZipFile.ZipUpdate) this.updates_[index]).Entry.Name, true, CultureInfo.InvariantCulture) == 0)
-        {
-          existingUpdate = index;
-          break;
-        }
-      }
-      return existingUpdate;
-    }
-
-    private Stream GetOutputStream(ZipEntry entry)
-    {
-      Stream stream = this.baseStream_;
-      if (entry.IsCrypted)
-        stream = this.CreateAndInitEncryptionStream(stream, entry);
-      switch (entry.CompressionMethod)
-      {
-        case CompressionMethod.Stored:
-          return (Stream) new ZipFile.UncompressedStream(stream);
-        case CompressionMethod.Deflated:
-          return (Stream) new DeflaterOutputStream(stream, new Deflater(9, true))
-          {
-            IsStreamOwner = false
-          };
-        default:
-          throw new ZipException("Unknown compression method " + (object) entry.CompressionMethod);
-      }
-    }
-
-    private void AddEntry(ZipFile workFile, ZipFile.ZipUpdate update)
-    {
-      long num = 0;
-      Stream source = (Stream) null;
-      if (update.Entry.IsFile)
-        source = update.GetSource() ?? this.updateDataSource_.GetSource(update.Entry, update.Filename);
-      if (source != null)
-      {
-        using (source)
-        {
-          long length = source.Length;
-          if (update.OutEntry.Size < 0L)
-            update.OutEntry.Size = length;
-          else if (update.OutEntry.Size != length)
-            throw new ZipException("Entry size/stream size mismatch");
-          workFile.WriteLocalEntryHeader(update);
-          num = workFile.baseStream_.Position;
-          using (Stream outputStream = workFile.GetOutputStream(update.OutEntry))
-            this.CopyBytes(update, outputStream, source, length, true);
-        }
-      }
-      else
-      {
-        workFile.WriteLocalEntryHeader(update);
-        num = workFile.baseStream_.Position;
-      }
-      long position = workFile.baseStream_.Position;
-      update.OutEntry.CompressedSize = position - num;
-    }
-
-    private void ModifyEntry(ZipFile workFile, ZipFile.ZipUpdate update)
-    {
-      workFile.WriteLocalEntryHeader(update);
-      long position1 = workFile.baseStream_.Position;
-      if (update.Entry.IsFile && update.Filename != null)
-      {
-        using (Stream outputStream = workFile.GetOutputStream(update.OutEntry))
-        {
-          using (Stream inputStream = this.GetInputStream(update.Entry))
-            this.CopyBytes(update, outputStream, inputStream, inputStream.Length, true);
-        }
-      }
-      long position2 = workFile.baseStream_.Position;
-      update.Entry.CompressedSize = position2 - position1;
-    }
-
-    private void CopyEntryDirect(
-      ZipFile workFile,
-      ZipFile.ZipUpdate update,
-      ref long destinationPosition)
-    {
-      bool flag = false;
-      if (update.Entry.Offset == destinationPosition)
-        flag = true;
-      if (!flag)
-      {
-        this.baseStream_.Position = destinationPosition;
-        workFile.WriteLocalEntryHeader(update);
-        destinationPosition = this.baseStream_.Position;
-      }
-      long offset = update.Entry.Offset + 26L;
-      this.baseStream_.Seek(offset, SeekOrigin.Begin);
-      long sourcePosition = this.baseStream_.Position + (long) this.ReadLEUshort() + (long) this.ReadLEUshort();
-      if (flag)
-      {
-        destinationPosition += sourcePosition - offset + 26L + update.Entry.CompressedSize + (long) this.GetDescriptorSize(update);
-      }
-      else
-      {
-        if (update.Entry.CompressedSize > 0L)
-          this.CopyEntryDataDirect(update, this.baseStream_, false, ref destinationPosition, ref sourcePosition);
-        this.CopyDescriptorBytesDirect(update, this.baseStream_, ref destinationPosition, sourcePosition);
-      }
-    }
-
-    private void CopyEntry(ZipFile workFile, ZipFile.ZipUpdate update)
-    {
-      workFile.WriteLocalEntryHeader(update);
-      if (update.Entry.CompressedSize > 0L)
-      {
-        this.baseStream_.Seek(update.Entry.Offset + 26L, SeekOrigin.Begin);
-        this.baseStream_.Seek((long) ((uint) this.ReadLEUshort() + (uint) this.ReadLEUshort()), SeekOrigin.Current);
-        this.CopyBytes(update, workFile.baseStream_, this.baseStream_, update.Entry.CompressedSize, false);
-      }
-      this.CopyDescriptorBytes(update, workFile.baseStream_, this.baseStream_);
-    }
-
-    private void Reopen(Stream source)
-    {
-      if (source == null)
-        throw new ZipException("Failed to reopen archive - no source");
-      this.isNewArchive_ = false;
-      this.baseStream_ = source;
-      this.ReadEntries();
-    }
-
-    private void Reopen()
-    {
-      if (this.Name == null)
-        throw new InvalidOperationException("Name is not known cannot Reopen");
-      this.Reopen((Stream) File.OpenRead(this.Name));
-    }
-
-    private void UpdateCommentOnly()
-    {
-      long length = this.baseStream_.Length;
-      ZipHelperStream zipHelperStream;
-      if (this.archiveStorage_.UpdateMode == FileUpdateMode.Safe)
-      {
-        zipHelperStream = new ZipHelperStream(this.archiveStorage_.MakeTemporaryCopy(this.baseStream_));
-        zipHelperStream.IsStreamOwner = true;
-        this.baseStream_.Close();
-        this.baseStream_ = (Stream) null;
-      }
-      else if (this.archiveStorage_.UpdateMode == FileUpdateMode.Direct)
-      {
-        this.baseStream_ = this.archiveStorage_.OpenForDirectUpdate(this.baseStream_);
-        zipHelperStream = new ZipHelperStream(this.baseStream_);
-      }
-      else
-      {
-        this.baseStream_.Close();
-        this.baseStream_ = (Stream) null;
-        zipHelperStream = new ZipHelperStream(this.Name);
-      }
-      using (zipHelperStream)
-      {
-        if (zipHelperStream.LocateBlockWithSignature(101010256, length, 22, (int) ushort.MaxValue) < 0L)
-          throw new ZipException("Cannot find central directory");
-        zipHelperStream.Position += 16L;
-        byte[] rawComment = this.newComment_.RawComment;
-        zipHelperStream.WriteLEShort(rawComment.Length);
-        zipHelperStream.Write(rawComment, 0, rawComment.Length);
-        zipHelperStream.SetLength(zipHelperStream.Position);
-      }
-      if (this.archiveStorage_.UpdateMode == FileUpdateMode.Safe)
-        this.Reopen(this.archiveStorage_.ConvertTemporaryToFinal());
-      else
-        this.ReadEntries();
-    }
-
-    private void RunUpdates()
-    {
-      long sizeEntries = 0;
-      long num = 0;
-      bool flag1 = true;
-      bool flag2 = false;
-      long destinationPosition = 0;
-      ZipFile workFile;
-      if (this.IsNewArchive)
-      {
-        workFile = this;
-        workFile.baseStream_.Position = 0L;
-        flag2 = true;
-      }
-      else if (this.archiveStorage_.UpdateMode == FileUpdateMode.Direct)
-      {
-        workFile = this;
-        workFile.baseStream_.Position = 0L;
-        flag2 = true;
-        this.updates_.Sort((IComparer) new ZipFile.UpdateComparer());
-      }
-      else
-      {
-        workFile = ZipFile.Create(this.archiveStorage_.GetTemporaryOutput());
-        workFile.UseZip64 = this.UseZip64;
-        if (this.key != null)
-          workFile.key = (byte[]) this.key.Clone();
-      }
-      try
-      {
-        foreach (ZipFile.ZipUpdate update in this.updates_)
-        {
-          switch (update.Command)
-          {
-            case ZipFile.UpdateCommand.Copy:
-              if (flag2)
-              {
-                this.CopyEntryDirect(workFile, update, ref destinationPosition);
-                continue;
-              }
-              this.CopyEntry(workFile, update);
-              continue;
-            case ZipFile.UpdateCommand.Modify:
-              this.ModifyEntry(workFile, update);
-              continue;
-            case ZipFile.UpdateCommand.Add:
-              if (!this.IsNewArchive && flag2)
-                workFile.baseStream_.Position = destinationPosition;
-              this.AddEntry(workFile, update);
-              if (flag2)
-              {
-                destinationPosition = workFile.baseStream_.Position;
-                continue;
-              }
-              continue;
-            default:
-              continue;
-          }
-        }
-        if (!this.IsNewArchive && flag2)
-          workFile.baseStream_.Position = destinationPosition;
-        long position = workFile.baseStream_.Position;
-        foreach (ZipFile.ZipUpdate update in this.updates_)
-          sizeEntries += (long) workFile.WriteCentralDirectoryHeader(update.OutEntry);
-        byte[] comment = this.newComment_ != null ? this.newComment_.RawComment : ZipConstants.ConvertToArray(this.comment_);
-        using (ZipHelperStream zipHelperStream = new ZipHelperStream(workFile.baseStream_))
-          zipHelperStream.WriteEndOfCentralDirectory((long) this.updates_.Count, sizeEntries, position, comment);
-        num = workFile.baseStream_.Position;
-        foreach (ZipFile.ZipUpdate update in this.updates_)
-        {
-          if (update.CrcPatchOffset > 0L && update.OutEntry.CompressedSize > 0L)
-          {
-            workFile.baseStream_.Position = update.CrcPatchOffset;
-            workFile.WriteLEInt((int) update.OutEntry.Crc);
-          }
-          if (update.SizePatchOffset > 0L)
-          {
-            workFile.baseStream_.Position = update.SizePatchOffset;
-            if (update.OutEntry.LocalHeaderRequiresZip64)
-            {
-              workFile.WriteLeLong(update.OutEntry.Size);
-              workFile.WriteLeLong(update.OutEntry.CompressedSize);
-            }
-            else
-            {
-              workFile.WriteLEInt((int) update.OutEntry.CompressedSize);
-              workFile.WriteLEInt((int) update.OutEntry.Size);
-            }
-          }
-        }
-      }
-      catch (Exception ex)
-      {
-        flag1 = false;
-      }
-      finally
-      {
-        if (flag2)
-        {
-          if (flag1)
-          {
-            workFile.baseStream_.Flush();
-            workFile.baseStream_.SetLength(num);
-          }
-        }
-        else
-          workFile.Close();
-      }
-      if (flag1)
-      {
-        if (flag2)
-        {
-          this.isNewArchive_ = false;
-          workFile.baseStream_.Flush();
-          this.ReadEntries();
-        }
-        else
-        {
-          this.baseStream_.Close();
-          this.Reopen(this.archiveStorage_.ConvertTemporaryToFinal());
-        }
-      }
-      else
-      {
-        workFile.Close();
-        if (flag2 || workFile.Name == null)
-          return;
-        File.Delete(workFile.Name);
-      }
-    }
-
-    private void CheckUpdating()
-    {
-      if (this.updates_ == null)
-        throw new ZipException("Cannot update until BeginUpdate has been called");
-    }
-
-    void IDisposable.Dispose() => this.Close();
-
-    private void DisposeInternal(bool disposing)
-    {
-      if (this.isDisposed_)
-        return;
-      this.isDisposed_ = true;
-      this.entries_ = (ZipEntry[]) null;
-      if (!this.IsStreamOwner || this.baseStream_ == null)
-        return;
-      lock (this.baseStream_)
-        this.baseStream_.Close();
-    }
-
-    protected virtual void Dispose(bool disposing) => this.DisposeInternal(disposing);
-
-    private ushort ReadLEUshort()
-    {
-      int num1 = this.baseStream_.ReadByte();
-      if (num1 < 0)
-        throw new EndOfStreamException("End of stream");
-      int num2 = this.baseStream_.ReadByte();
-      if (num2 < 0)
-        throw new EndOfStreamException("End of stream");
-      return (ushort) ((uint) (ushort) num1 | (uint) (ushort) (num2 << 8));
-    }
-
-    private uint ReadLEUint() => (uint) this.ReadLEUshort() | (uint) this.ReadLEUshort() << 16;
-
-    private ulong ReadLEUlong() => (ulong) this.ReadLEUint() | (ulong) this.ReadLEUint() << 32;
-
-    private long LocateBlockWithSignature(
-      int signature,
-      long endLocation,
-      int minimumBlockSize,
-      int maximumVariableData)
-    {
-      using (ZipHelperStream zipHelperStream = new ZipHelperStream(this.baseStream_))
-        return zipHelperStream.LocateBlockWithSignature(signature, endLocation, minimumBlockSize, maximumVariableData);
-    }
-
-    private void ReadEntries()
-    {
-      long endLocation = this.baseStream_.CanSeek ? this.LocateBlockWithSignature(101010256, this.baseStream_.Length, 22, (int) ushort.MaxValue) : throw new ZipException("ZipFile stream must be seekable");
-      if (endLocation < 0L)
-        throw new ZipException("Cannot find central directory");
-      ushort num1 = this.ReadLEUshort();
-      ushort num2 = this.ReadLEUshort();
-      ulong length1 = (ulong) this.ReadLEUshort();
-      ulong num3 = (ulong) this.ReadLEUshort();
-      ulong num4 = (ulong) this.ReadLEUint();
-      long num5 = (long) this.ReadLEUint();
-      uint length2 = (uint) this.ReadLEUshort();
-      if (length2 > 0U)
-      {
-        byte[] numArray = new byte[(IntPtr) length2];
-        StreamUtils.ReadFully(this.baseStream_, numArray);
-        this.comment_ = ZipConstants.ConvertToString(numArray);
-      }
-      else
-        this.comment_ = string.Empty;
-      bool flag = false;
-      if (num1 == ushort.MaxValue || num2 == ushort.MaxValue || length1 == (ulong) ushort.MaxValue || num3 == (ulong) ushort.MaxValue || num4 == (ulong) uint.MaxValue || num5 == (long) uint.MaxValue)
-      {
-        flag = true;
-        if (this.LocateBlockWithSignature(117853008, endLocation, 0, 4096) < 0L)
-          throw new ZipException("Cannot find Zip64 locator");
-        int num6 = (int) this.ReadLEUint();
-        ulong num7 = this.ReadLEUlong();
-        int num8 = (int) this.ReadLEUint();
-        this.baseStream_.Position = (long) num7;
-        if (this.ReadLEUint() != 101075792U)
-          throw new ZipException(string.Format("Invalid Zip64 Central directory signature at {0:X}", (object) num7));
-        long num9 = (long) this.ReadLEUlong();
-        int num10 = (int) this.ReadLEUshort();
-        int num11 = (int) this.ReadLEUshort();
-        int num12 = (int) this.ReadLEUint();
-        int num13 = (int) this.ReadLEUint();
-        length1 = this.ReadLEUlong();
-        this.ReadLEUlong();
-        num4 = this.ReadLEUlong();
-        num5 = (long) this.ReadLEUlong();
-      }
-      this.entries_ = new ZipEntry[length1];
-      if (!flag && num5 < endLocation - (4L + (long) num4))
-      {
-        this.offsetOfFirstEntry = endLocation - (4L + (long) num4 + num5);
-        if (this.offsetOfFirstEntry <= 0L)
-          throw new ZipException("Invalid embedded zip archive");
-      }
-      this.baseStream_.Seek(this.offsetOfFirstEntry + num5, SeekOrigin.Begin);
-      for (ulong index = 0; index < length1; ++index)
-      {
-        if (this.ReadLEUint() != 33639248U)
-          throw new ZipException("Wrong Central Directory signature");
-        int madeByInfo = (int) this.ReadLEUshort();
-        int versionRequiredToExtract = (int) this.ReadLEUshort();
-        int flags = (int) this.ReadLEUshort();
-        int method = (int) this.ReadLEUshort();
-        uint num14 = this.ReadLEUint();
-        uint num15 = this.ReadLEUint();
-        long num16 = (long) this.ReadLEUint();
-        long num17 = (long) this.ReadLEUint();
-        int num18 = (int) this.ReadLEUshort();
-        int length3 = (int) this.ReadLEUshort();
-        int num19 = (int) this.ReadLEUshort();
-        int num20 = (int) this.ReadLEUshort();
-        int num21 = (int) this.ReadLEUshort();
-        uint num22 = this.ReadLEUint();
-        long num23 = (long) this.ReadLEUint();
-        byte[] numArray = new byte[Math.Max(num18, num19)];
-        StreamUtils.ReadFully(this.baseStream_, numArray, 0, num18);
-        ZipEntry zipEntry = new ZipEntry(ZipConstants.ConvertToStringExt(flags, numArray, num18), versionRequiredToExtract, madeByInfo, (CompressionMethod) method);
-        zipEntry.Crc = (long) num15 & (long) uint.MaxValue;
-        zipEntry.Size = num17 & (long) uint.MaxValue;
-        zipEntry.CompressedSize = num16 & (long) uint.MaxValue;
-        zipEntry.Flags = flags;
-        zipEntry.DosTime = (long) num14;
-        zipEntry.ZipFileIndex = (long) index;
-        zipEntry.Offset = num23;
-        zipEntry.ExternalFileAttributes = (int) num22;
-        zipEntry.CryptoCheckValue = (flags & 8) != 0 ? (byte) (num14 >> 8 & (uint) byte.MaxValue) : (byte) (num15 >> 24);
-        if (length3 > 0)
-        {
-          byte[] buffer = new byte[length3];
-          StreamUtils.ReadFully(this.baseStream_, buffer);
-          zipEntry.ExtraData = buffer;
-        }
-        zipEntry.ProcessExtraData(false);
-        if (num19 > 0)
-        {
-          StreamUtils.ReadFully(this.baseStream_, numArray, 0, num19);
-          zipEntry.Comment = ZipConstants.ConvertToStringExt(flags, numArray, num19);
-        }
-        this.entries_[index] = zipEntry;
-      }
-    }
-
-    private long LocateEntry(ZipEntry entry)
-    {
-      return this.TestLocalHeader(entry, ZipFile.HeaderTest.Extract);
-    }
-
-    private Stream CreateAndInitDecryptionStream(Stream baseStream, ZipEntry entry)
-    {
-      if (entry.Version >= 50 && (entry.Flags & 64) != 0)
-        throw new ZipException("Decryption method not supported");
-      PkzipClassicManaged pkzipClassicManaged = new PkzipClassicManaged();
-      this.OnKeysRequired(entry.Name);
-      if (!this.HaveKeys)
-        throw new ZipException("No password available for encrypted stream");
-      CryptoStream classicCryptoStream = new CryptoStream(baseStream, pkzipClassicManaged.CreateDecryptor(this.key, (byte[]) null), CryptoStreamMode.Read);
-      ZipFile.CheckClassicPassword(classicCryptoStream, entry);
-      return (Stream) classicCryptoStream;
-    }
-
-    private Stream CreateAndInitEncryptionStream(Stream baseStream, ZipEntry entry)
-    {
-      CryptoStream encryptionStream = (CryptoStream) null;
-      if (entry.Version < 50 || (entry.Flags & 64) == 0)
-      {
-        PkzipClassicManaged pkzipClassicManaged = new PkzipClassicManaged();
-        this.OnKeysRequired(entry.Name);
-        if (!this.HaveKeys)
-          throw new ZipException("No password available for encrypted stream");
-        encryptionStream = new CryptoStream((Stream) new ZipFile.UncompressedStream(baseStream), pkzipClassicManaged.CreateEncryptor(this.key, (byte[]) null), CryptoStreamMode.Write);
-        if (entry.Crc < 0L || (entry.Flags & 8) != 0)
-          ZipFile.WriteEncryptionHeader((Stream) encryptionStream, entry.DosTime << 16);
-        else
-          ZipFile.WriteEncryptionHeader((Stream) encryptionStream, entry.Crc);
-      }
-      return (Stream) encryptionStream;
-    }
-
-    private static void CheckClassicPassword(CryptoStream classicCryptoStream, ZipEntry entry)
-    {
-      byte[] buffer = new byte[12];
-      StreamUtils.ReadFully((Stream) classicCryptoStream, buffer);
-      if ((int) buffer[11] != (int) entry.CryptoCheckValue)
-        throw new ZipException("Invalid password");
-    }
-
-    private static void WriteEncryptionHeader(Stream stream, long crcValue)
-    {
-      byte[] buffer = new byte[12];
-      new Random().NextBytes(buffer);
-      buffer[11] = (byte) (crcValue >> 24);
-      stream.Write(buffer, 0, buffer.Length);
-    }
-
-    public delegate void KeysRequiredEventHandler(object sender, KeysRequiredEventArgs e);
-
-    [Flags]
-    private enum HeaderTest
-    {
-      Extract = 1,
-      Header = 2,
-    }
-
-    private enum UpdateCommand
-    {
-      Copy,
-      Modify,
-      Add,
-    }
-
-    private class UpdateComparer : IComparer
-    {
-      public int Compare(object x, object y)
-      {
-        ZipFile.ZipUpdate zipUpdate1 = x as ZipFile.ZipUpdate;
-        ZipFile.ZipUpdate zipUpdate2 = y as ZipFile.ZipUpdate;
-        int num1 = (zipUpdate1.Command == ZipFile.UpdateCommand.Copy || zipUpdate1.Command == ZipFile.UpdateCommand.Modify ? 0 : 1) - (zipUpdate2.Command == ZipFile.UpdateCommand.Copy || zipUpdate2.Command == ZipFile.UpdateCommand.Modify ? 0 : 1);
-        if (num1 == 0)
-        {
-          long num2 = zipUpdate1.Entry.Offset - zipUpdate2.Entry.Offset;
-          num1 = num2 >= 0L ? (num2 != 0L ? 1 : 0) : -1;
-        }
-        return num1;
-      }
-    }
-
-    private class ZipUpdate
-    {
-      private ZipEntry entry_;
-      private ZipEntry outEntry_;
-      private ZipFile.UpdateCommand command_;
-      private IStaticDataSource dataSource_;
-      private string filename_;
-      private long sizePatchOffset_ = -1;
-      private long crcPatchOffset_ = -1;
-
-      public ZipUpdate(string fileName, string entryName, CompressionMethod compressionMethod)
-      {
-        this.command_ = ZipFile.UpdateCommand.Add;
-        this.entry_ = new ZipEntry(entryName);
-        this.entry_.CompressionMethod = compressionMethod;
-        this.filename_ = fileName;
-      }
-
-      public ZipUpdate(string fileName, string entryName)
-      {
-        this.command_ = ZipFile.UpdateCommand.Add;
-        this.entry_ = new ZipEntry(entryName);
-        this.filename_ = fileName;
-      }
-
-      public ZipUpdate(
-        IStaticDataSource dataSource,
-        string entryName,
-        CompressionMethod compressionMethod)
-      {
-        this.command_ = ZipFile.UpdateCommand.Add;
-        this.entry_ = new ZipEntry(entryName);
-        this.entry_.CompressionMethod = compressionMethod;
-        this.dataSource_ = dataSource;
-      }
-
-      public ZipUpdate(ZipEntry original, ZipEntry updated)
-      {
-        throw new ZipException("Modify not currently supported");
-      }
-
-      public ZipUpdate(ZipFile.UpdateCommand command, ZipEntry entry)
-      {
-        this.command_ = command;
-        this.entry_ = (ZipEntry) entry.Clone();
-      }
-
-      public ZipUpdate(ZipEntry entry)
-        : this(ZipFile.UpdateCommand.Copy, entry)
-      {
-      }
-
-      public ZipEntry Entry => this.entry_;
-
-      public ZipEntry OutEntry
-      {
-        get
-        {
-          if (this.outEntry_ == null)
-            this.outEntry_ = (ZipEntry) this.entry_.Clone();
-          return this.outEntry_;
-        }
-      }
-
-      public ZipFile.UpdateCommand Command => this.command_;
-
-      public string Filename => this.filename_;
-
-      public long SizePatchOffset
-      {
-        get => this.sizePatchOffset_;
-        set => this.sizePatchOffset_ = value;
-      }
-
-      public long CrcPatchOffset
-      {
-        get => this.crcPatchOffset_;
-        set => this.crcPatchOffset_ = value;
-      }
-
-      public Stream GetSource()
-      {
-        Stream source = (Stream) null;
-        if (this.dataSource_ != null)
-          source = this.dataSource_.GetSource();
-        return source;
-      }
-    }
-
-    private class ZipString
-    {
-      private string comment_;
-      private byte[] rawComment_;
-      private bool isSourceString_;
-
-      public ZipString(string comment)
-      {
-        this.comment_ = comment;
-        this.isSourceString_ = true;
-      }
-
-      public ZipString(byte[] rawString) => this.rawComment_ = rawString;
-
-      public bool IsSourceString => this.isSourceString_;
-
-      public int RawLength
-      {
-        get
-        {
-          this.MakeBytesAvailable();
-          return this.rawComment_.Length;
-        }
-      }
-
-      public byte[] RawComment
-      {
-        get
-        {
-          this.MakeBytesAvailable();
-          return (byte[]) this.rawComment_.Clone();
-        }
-      }
-
-      public void Reset()
-      {
-        if (this.isSourceString_)
-          this.rawComment_ = (byte[]) null;
-        else
-          this.comment_ = (string) null;
-      }
-
-      private void MakeTextAvailable()
-      {
-        if (this.comment_ != null)
-          return;
-        this.comment_ = ZipConstants.ConvertToString(this.rawComment_);
-      }
-
-      private void MakeBytesAvailable()
-      {
-        if (this.rawComment_ != null)
-          return;
-        this.rawComment_ = ZipConstants.ConvertToArray(this.comment_);
-      }
-
-      public static implicit operator string(ZipFile.ZipString zipString)
-      {
-        zipString.MakeTextAvailable();
-        return zipString.comment_;
-      }
-    }
-
-    private class ZipEntryEnumerator : IEnumerator
-    {
-      private ZipEntry[] array;
-      private int index = -1;
-
-      public ZipEntryEnumerator(ZipEntry[] entries) => this.array = entries;
-
-      public object Current => (object) this.array[this.index];
-
-      public void Reset() => this.index = -1;
-
-      public bool MoveNext() => ++this.index < this.array.Length;
-    }
-
-    private class UncompressedStream : Stream
-    {
-      private Stream baseStream_;
-
-      public UncompressedStream(Stream baseStream) => this.baseStream_ = baseStream;
-
-      public override void Close()
-      {
-      }
-
-      public override bool CanRead => false;
-
-      public override void Flush() => this.baseStream_.Flush();
-
-      public override bool CanWrite => this.baseStream_.CanWrite;
-
-      public override bool CanSeek => false;
-
-      public override long Length => 0;
-
-      public override long Position
-      {
-        get => this.baseStream_.Position;
-        set
-        {
-        }
-      }
-
-      public override int Read(byte[] buffer, int offset, int count) => 0;
-
-      public override long Seek(long offset, SeekOrigin origin) => 0;
-
-      public override void SetLength(long value)
-      {
-      }
-
-      public override void Write(byte[] buffer, int offset, int count)
-      {
-        this.baseStream_.Write(buffer, offset, count);
-      }
-    }
-
-    private class PartialInputStream : InflaterInputStream
-    {
-      private Stream baseStream_;
-      private long filepos_;
-      private long end_;
-
-      public PartialInputStream(Stream baseStream, long start, long length)
-        : base(baseStream)
-      {
-        this.baseStream_ = baseStream;
-        this.filepos_ = start;
-        this.end_ = start + length;
-      }
-
-      public long SkipBytes(long count)
-      {
-        if (count < 0L)
-          throw new ArgumentOutOfRangeException(nameof (count), "is less than zero");
-        if (count > this.end_ - this.filepos_)
-          count = this.end_ - this.filepos_;
-        this.filepos_ += count;
-        return count;
-      }
-
-      public override int Available
-      {
-        get
-        {
-          long num = this.end_ - this.filepos_;
-          return num > (long) int.MaxValue ? int.MaxValue : (int) num;
-        }
-      }
-
-      public override int ReadByte()
-      {
-        if (this.filepos_ == this.end_)
-          return -1;
-        lock (this.baseStream_)
-        {
-          this.baseStream_.Seek(this.filepos_++, SeekOrigin.Begin);
-          return this.baseStream_.ReadByte();
-        }
-      }
-
-      public override void Close()
-      {
-      }
-
-      public override int Read(byte[] buffer, int offset, int count)
-      {
-        if ((long) count > this.end_ - this.filepos_)
-        {
-          count = (int) (this.end_ - this.filepos_);
-          if (count == 0)
-            return 0;
-        }
-        lock (this.baseStream_)
-        {
-          this.baseStream_.Seek(this.filepos_, SeekOrigin.Begin);
-          int num = this.baseStream_.Read(buffer, offset, count);
-          if (num > 0)
-            this.filepos_ += (long) num;
-          return num;
-        }
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipHelperStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipHelperStream.cs
deleted file mode 100644
index 0a2aadb..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipHelperStream.cs
+++ /dev/null
@@ -1,189 +0,0 @@
-
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  internal class ZipHelperStream : Stream
-  {
-    private bool isOwner_;
-    private Stream stream_;
-
-    public ZipHelperStream(string name)
-    {
-      this.stream_ = (Stream) new FileStream(name, FileMode.Open, FileAccess.ReadWrite);
-      this.isOwner_ = true;
-    }
-
-    public ZipHelperStream(Stream stream) => this.stream_ = stream;
-
-    public bool IsStreamOwner
-    {
-      get => this.isOwner_;
-      set => this.isOwner_ = value;
-    }
-
-    public override bool CanRead => this.stream_.CanRead;
-
-    public override bool CanSeek => this.stream_.CanSeek;
-
-    public override bool CanTimeout => this.stream_.CanTimeout;
-
-    public override long Length => this.stream_.Length;
-
-    public override long Position
-    {
-      get => this.stream_.Position;
-      set => this.stream_.Position = value;
-    }
-
-    public override bool CanWrite => this.stream_.CanWrite;
-
-    public override void Flush() => this.stream_.Flush();
-
-    public override long Seek(long offset, SeekOrigin origin) => this.stream_.Seek(offset, origin);
-
-    public override void SetLength(long value) => this.stream_.SetLength(value);
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      return this.stream_.Read(buffer, offset, count);
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      this.stream_.Write(buffer, offset, count);
-    }
-
-    public long LocateBlockWithSignature(
-      int signature,
-      long endLocation,
-      int minimumBlockSize,
-      int maximumVariableData)
-    {
-      long num1 = endLocation - (long) minimumBlockSize;
-      if (num1 < 0L)
-        return -1;
-      long num2 = Math.Max(num1 - (long) maximumVariableData, 0L);
-      while (num1 >= num2)
-      {
-        this.Seek(num1--, SeekOrigin.Begin);
-        if (this.ReadLEInt() == signature)
-          return this.Position;
-      }
-      return -1;
-    }
-
-    public void WriteZip64EndOfCentralDirectory(
-      long noOfEntries,
-      long sizeEntries,
-      long centralDirOffset)
-    {
-      long position = this.stream_.Position;
-      this.WriteLEInt(101075792);
-      this.WriteLELong(44L);
-      this.WriteLEShort(45);
-      this.WriteLEShort(45);
-      this.WriteLEInt(0);
-      this.WriteLEInt(0);
-      this.WriteLELong(noOfEntries);
-      this.WriteLELong(noOfEntries);
-      this.WriteLELong(sizeEntries);
-      this.WriteLELong(centralDirOffset);
-      this.WriteLEInt(117853008);
-      this.WriteLEInt(0);
-      this.WriteLELong(position);
-      this.WriteLEInt(1);
-    }
-
-    public void WriteEndOfCentralDirectory(
-      long noOfEntries,
-      long sizeEntries,
-      long startOfCentralDirectory,
-      byte[] comment)
-    {
-      if (noOfEntries >= (long) ushort.MaxValue || startOfCentralDirectory >= (long) uint.MaxValue || sizeEntries >= (long) uint.MaxValue)
-        this.WriteZip64EndOfCentralDirectory(noOfEntries, sizeEntries, startOfCentralDirectory);
-      this.WriteLEInt(101010256);
-      this.WriteLEShort(0);
-      this.WriteLEShort(0);
-      if (noOfEntries >= (long) ushort.MaxValue)
-      {
-        this.WriteLEUshort(ushort.MaxValue);
-        this.WriteLEUshort(ushort.MaxValue);
-      }
-      else
-      {
-        this.WriteLEShort((int) (short) noOfEntries);
-        this.WriteLEShort((int) (short) noOfEntries);
-      }
-      if (sizeEntries >= (long) uint.MaxValue)
-        this.WriteLEUint(uint.MaxValue);
-      else
-        this.WriteLEInt((int) sizeEntries);
-      if (startOfCentralDirectory >= (long) uint.MaxValue)
-        this.WriteLEUint(uint.MaxValue);
-      else
-        this.WriteLEInt((int) startOfCentralDirectory);
-      int length = comment != null ? comment.Length : 0;
-      if (length > (int) ushort.MaxValue)
-        throw new ZipException(string.Format("Comment length({0}) is too long", (object) length));
-      this.WriteLEShort(length);
-      if (length <= 0)
-        return;
-      this.Write(comment, 0, comment.Length);
-    }
-
-    public int ReadLEShort() => this.stream_.ReadByte() | this.stream_.ReadByte() << 8;
-
-    public int ReadLEInt() => this.ReadLEShort() | this.ReadLEShort() << 16;
-
-    public long ReadLELong() => (long) (uint) this.ReadLEInt() | (long) this.ReadLEInt() << 32;
-
-    public void WriteLEShort(int value)
-    {
-      this.stream_.WriteByte((byte) (value & (int) byte.MaxValue));
-      this.stream_.WriteByte((byte) (value >> 8 & (int) byte.MaxValue));
-    }
-
-    public void WriteLEUshort(ushort value)
-    {
-      this.stream_.WriteByte((byte) ((uint) value & (uint) byte.MaxValue));
-      this.stream_.WriteByte((byte) ((uint) value >> 8));
-    }
-
-    public void WriteLEInt(int value)
-    {
-      this.WriteLEShort(value);
-      this.WriteLEShort(value >> 16);
-    }
-
-    public void WriteLEUint(uint value)
-    {
-      this.WriteLEUshort((ushort) (value & (uint) ushort.MaxValue));
-      this.WriteLEUshort((ushort) (value >> 16));
-    }
-
-    public void WriteLELong(long value)
-    {
-      this.WriteLEInt((int) value);
-      this.WriteLEInt((int) (value >> 32));
-    }
-
-    public void WriteLEUlong(ulong value)
-    {
-      this.WriteLEUint((uint) (value & (ulong) uint.MaxValue));
-      this.WriteLEUint((uint) (value >> 32));
-    }
-
-    public override void Close()
-    {
-      Stream stream = this.stream_;
-      this.stream_ = (Stream) null;
-      if (!this.isOwner_ || stream == null)
-        return;
-      this.isOwner_ = false;
-      stream.Close();
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipInputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipInputStream.cs
deleted file mode 100644
index 8516c7d..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipInputStream.cs
+++ /dev/null
@@ -1,299 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Encryption;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.IO;
-using System.Security.Cryptography;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipInputStream : InflaterInputStream
-  {
-    private ZipInputStream.ReaderDelegate internalReader;
-    private Crc32 crc = new Crc32();
-    private ZipEntry entry;
-    private long size;
-    private int method;
-    private int flags;
-    private string password;
-
-    public ZipInputStream(Stream baseInputStream)
-      : base(baseInputStream, new Inflater(true))
-    {
-      this.internalReader = new ZipInputStream.ReaderDelegate(this.ReadingNotAvailable);
-    }
-
-    public string Password
-    {
-      get => this.password;
-      set => this.password = value;
-    }
-
-    public bool CanDecompressEntry => this.entry != null && this.entry.CanDecompress;
-
-    public ZipEntry GetNextEntry()
-    {
-      if (this.crc == null)
-        throw new InvalidOperationException("Closed.");
-      if (this.entry != null)
-        this.CloseEntry();
-      int num1 = this.inputBuffer.ReadLeInt();
-      if (num1 == 33639248 || num1 == 101010256 || num1 == 84233040 || num1 == 117853008 || num1 == 101075792)
-      {
-        this.Close();
-        return (ZipEntry) null;
-      }
-      if (num1 == 808471376 || num1 == 134695760)
-        num1 = this.inputBuffer.ReadLeInt();
-      if (num1 != 67324752)
-        throw new ZipException("Wrong Local header signature: 0x" + string.Format("{0:X}", (object) num1));
-      short versionRequiredToExtract = (short) this.inputBuffer.ReadLeShort();
-      this.flags = this.inputBuffer.ReadLeShort();
-      this.method = this.inputBuffer.ReadLeShort();
-      uint num2 = (uint) this.inputBuffer.ReadLeInt();
-      int num3 = this.inputBuffer.ReadLeInt();
-      this.csize = (long) this.inputBuffer.ReadLeInt();
-      this.size = (long) this.inputBuffer.ReadLeInt();
-      int length1 = this.inputBuffer.ReadLeShort();
-      int length2 = this.inputBuffer.ReadLeShort();
-      bool flag = (this.flags & 1) == 1;
-      byte[] numArray = new byte[length1];
-      this.inputBuffer.ReadRawBuffer(numArray);
-      this.entry = new ZipEntry(ZipConstants.ConvertToStringExt(this.flags, numArray), (int) versionRequiredToExtract);
-      this.entry.Flags = this.flags;
-      this.entry.CompressionMethod = (CompressionMethod) this.method;
-      if ((this.flags & 8) == 0)
-      {
-        this.entry.Crc = (long) num3 & (long) uint.MaxValue;
-        this.entry.Size = this.size & (long) uint.MaxValue;
-        this.entry.CompressedSize = this.csize & (long) uint.MaxValue;
-        this.entry.CryptoCheckValue = (byte) (num3 >> 24 & (int) byte.MaxValue);
-      }
-      else
-      {
-        if (num3 != 0)
-          this.entry.Crc = (long) num3 & (long) uint.MaxValue;
-        if (this.size != 0L)
-          this.entry.Size = this.size & (long) uint.MaxValue;
-        if (this.csize != 0L)
-          this.entry.CompressedSize = this.csize & (long) uint.MaxValue;
-        this.entry.CryptoCheckValue = (byte) (num2 >> 8 & (uint) byte.MaxValue);
-      }
-      this.entry.DosTime = (long) num2;
-      if (length2 > 0)
-      {
-        byte[] buffer = new byte[length2];
-        this.inputBuffer.ReadRawBuffer(buffer);
-        this.entry.ExtraData = buffer;
-      }
-      this.entry.ProcessExtraData(true);
-      if (this.entry.CompressedSize >= 0L)
-        this.csize = this.entry.CompressedSize;
-      if (this.entry.Size >= 0L)
-        this.size = this.entry.Size;
-      if (this.method == 0 && (!flag && this.csize != this.size || flag && this.csize - 12L != this.size))
-        throw new ZipException("Stored, but compressed != uncompressed");
-      this.internalReader = !this.entry.IsCompressionMethodSupported() ? new ZipInputStream.ReaderDelegate(this.ReadingNotSupported) : new ZipInputStream.ReaderDelegate(this.InitialRead);
-      return this.entry;
-    }
-
-    private void ReadDataDescriptor()
-    {
-      if (this.inputBuffer.ReadLeInt() != 134695760)
-        throw new ZipException("Data descriptor signature not found");
-      this.entry.Crc = (long) this.inputBuffer.ReadLeInt() & (long) uint.MaxValue;
-      if (this.entry.LocalHeaderRequiresZip64)
-      {
-        this.csize = this.inputBuffer.ReadLeLong();
-        this.size = this.inputBuffer.ReadLeLong();
-      }
-      else
-      {
-        this.csize = (long) this.inputBuffer.ReadLeInt();
-        this.size = (long) this.inputBuffer.ReadLeInt();
-      }
-      this.entry.CompressedSize = this.csize;
-      this.entry.Size = this.size;
-    }
-
-    private void CompleteCloseEntry(bool testCrc)
-    {
-      this.StopDecrypting();
-      if ((this.flags & 8) != 0)
-        this.ReadDataDescriptor();
-      this.size = 0L;
-      if (testCrc && (this.crc.Value & (long) uint.MaxValue) != this.entry.Crc && this.entry.Crc != -1L)
-        throw new ZipException("CRC mismatch");
-      this.crc.Reset();
-      if (this.method == 8)
-        this.inf.Reset();
-      this.entry = (ZipEntry) null;
-    }
-
-    public void CloseEntry()
-    {
-      if (this.crc == null)
-        throw new InvalidOperationException("Closed");
-      if (this.entry == null)
-        return;
-      if (this.method == 8)
-      {
-        if ((this.flags & 8) != 0)
-        {
-          byte[] buffer = new byte[2048];
-          do
-            ;
-          while (this.Read(buffer, 0, buffer.Length) > 0);
-          return;
-        }
-        this.csize -= this.inf.TotalIn;
-        this.inputBuffer.Available += this.inf.RemainingInput;
-      }
-      if ((long) this.inputBuffer.Available > this.csize && this.csize >= 0L)
-      {
-        this.inputBuffer.Available = (int) ((long) this.inputBuffer.Available - this.csize);
-      }
-      else
-      {
-        this.csize -= (long) this.inputBuffer.Available;
-        this.inputBuffer.Available = 0;
-        int num;
-        ZipInputStream zipInputStream;
-        for (; this.csize != 0L; zipInputStream.csize -= (long) num)
-        {
-          num = (int) this.Skip(this.csize & (long) uint.MaxValue);
-          if (num <= 0)
-            throw new ZipException("Zip archive ends early.");
-          zipInputStream = this;
-        }
-      }
-      this.CompleteCloseEntry(false);
-    }
-
-    public override int Available => this.entry == null ? 0 : 1;
-
-    public override long Length
-    {
-      get
-      {
-        if (this.entry == null)
-          throw new InvalidOperationException("No current entry");
-        return this.entry.Size >= 0L ? this.entry.Size : throw new ZipException("Length not available for the current entry");
-      }
-    }
-
-    public override int ReadByte()
-    {
-      byte[] buffer = new byte[1];
-      return this.Read(buffer, 0, 1) <= 0 ? -1 : (int) buffer[0] & (int) byte.MaxValue;
-    }
-
-    private int ReadingNotAvailable(byte[] destination, int offset, int count)
-    {
-      throw new InvalidOperationException("Unable to read from this stream");
-    }
-
-    private int ReadingNotSupported(byte[] destination, int offset, int count)
-    {
-      throw new ZipException("The compression method for this entry is not supported");
-    }
-
-    private int InitialRead(byte[] destination, int offset, int count)
-    {
-      if (!this.CanDecompressEntry)
-        throw new ZipException("Library cannot extract this entry. Version required is (" + this.entry.Version.ToString() + ")");
-      if (this.entry.IsCrypted)
-      {
-        this.inputBuffer.CryptoTransform = this.password != null ? new PkzipClassicManaged().CreateDecryptor(PkzipClassic.GenerateKeys(ZipConstants.ConvertToArray(this.password)), (byte[]) null) : throw new ZipException("No password set.");
-        byte[] outBuffer = new byte[12];
-        this.inputBuffer.ReadClearTextBuffer(outBuffer, 0, 12);
-        if ((int) outBuffer[11] != (int) this.entry.CryptoCheckValue)
-          throw new ZipException("Invalid password");
-        if (this.csize >= 12L)
-          this.csize -= 12L;
-      }
-      else
-        this.inputBuffer.CryptoTransform = (ICryptoTransform) null;
-      if (this.method == 8 && this.inputBuffer.Available > 0)
-        this.inputBuffer.SetInflaterInput(this.inf);
-      this.internalReader = new ZipInputStream.ReaderDelegate(this.BodyRead);
-      return this.BodyRead(destination, offset, count);
-    }
-
-    public override int Read(byte[] buffer, int offset, int count)
-    {
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be negative");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be negative");
-      if (buffer.Length - offset < count)
-        throw new ArgumentException("Invalid offset/count combination");
-      return this.internalReader(buffer, offset, count);
-    }
-
-    private int BodyRead(byte[] buffer, int offset, int count)
-    {
-      if (this.crc == null)
-        throw new InvalidOperationException("Closed");
-      if (this.entry == null || count <= 0)
-        return 0;
-      if (offset + count > buffer.Length)
-        throw new ArgumentException("Offset + count exceeds buffer size");
-      bool flag = false;
-      switch (this.method)
-      {
-        case 0:
-          if ((long) count > this.csize && this.csize >= 0L)
-            count = (int) this.csize;
-          if (count > 0)
-          {
-            count = this.inputBuffer.ReadClearTextBuffer(buffer, offset, count);
-            if (count > 0)
-            {
-              this.csize -= (long) count;
-              this.size -= (long) count;
-            }
-          }
-          if (this.csize == 0L)
-          {
-            flag = true;
-            break;
-          }
-          if (count < 0)
-            throw new ZipException("EOF in stored block");
-          break;
-        case 8:
-          count = base.Read(buffer, offset, count);
-          if (count <= 0)
-          {
-            this.inputBuffer.Available = this.inf.IsFinished ? this.inf.RemainingInput : throw new ZipException("Inflater not finished!");
-            if ((this.flags & 8) == 0 && (this.inf.TotalIn != this.csize || this.inf.TotalOut != this.size))
-              throw new ZipException("Size mismatch: " + (object) this.csize + ";" + (object) this.size + " <-> " + (object) this.inf.TotalIn + ";" + (object) this.inf.TotalOut);
-            this.inf.Reset();
-            flag = true;
-            break;
-          }
-          break;
-      }
-      if (count > 0)
-        this.crc.Update(buffer, offset, count);
-      if (flag)
-        this.CompleteCloseEntry(true);
-      return count;
-    }
-
-    public override void Close()
-    {
-      this.internalReader = new ZipInputStream.ReaderDelegate(this.ReadingNotAvailable);
-      this.crc = (Crc32) null;
-      this.entry = (ZipEntry) null;
-      base.Close();
-    }
-
-    private delegate int ReaderDelegate(byte[] b, int offset, int length);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipNameTransform.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipNameTransform.cs
deleted file mode 100644
index 4d8ed2f..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipNameTransform.cs
+++ /dev/null
@@ -1,90 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Core;
-using System;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipNameTransform : INameTransform
-  {
-    private string trimPrefix_;
-    private static readonly char[] InvalidEntryChars;
-    private static readonly char[] InvalidEntryCharsRelaxed;
-
-    public ZipNameTransform()
-    {
-    }
-
-    public ZipNameTransform(string trimPrefix) => this.TrimPrefix = trimPrefix;
-
-    static ZipNameTransform()
-    {
-      char[] invalidPathChars = Path.GetInvalidPathChars();
-      int length1 = invalidPathChars.Length + 2;
-      ZipNameTransform.InvalidEntryCharsRelaxed = new char[length1];
-      Array.Copy((Array) invalidPathChars, 0, (Array) ZipNameTransform.InvalidEntryCharsRelaxed, 0, invalidPathChars.Length);
-      ZipNameTransform.InvalidEntryCharsRelaxed[length1 - 1] = '*';
-      ZipNameTransform.InvalidEntryCharsRelaxed[length1 - 2] = '?';
-      int length2 = invalidPathChars.Length + 4;
-      ZipNameTransform.InvalidEntryChars = new char[length2];
-      Array.Copy((Array) invalidPathChars, 0, (Array) ZipNameTransform.InvalidEntryChars, 0, invalidPathChars.Length);
-      ZipNameTransform.InvalidEntryChars[length2 - 1] = ':';
-      ZipNameTransform.InvalidEntryChars[length2 - 2] = '\\';
-      ZipNameTransform.InvalidEntryChars[length2 - 3] = '*';
-      ZipNameTransform.InvalidEntryChars[length2 - 4] = '?';
-    }
-
-    public string TransformDirectory(string name)
-    {
-      name = this.TransformFile(name);
-      if (name.Length <= 0)
-        throw new ZipException("Cannot have an empty directory name");
-      if (!name.EndsWith("/"))
-        name += "/";
-      return name;
-    }
-
-    public string TransformFile(string name)
-    {
-      if (name != null)
-      {
-        string lower = name.ToLower();
-        if (this.trimPrefix_ != null && lower.IndexOf(this.trimPrefix_) == 0)
-          name = name.Substring(this.trimPrefix_.Length);
-        if (Path.IsPathRooted(name))
-          name = name.Substring(Path.GetPathRoot(name).Length);
-        name = name.Replace("\\", "/");
-        while (name.Length > 0 && name[0] == '/')
-          name = name.Remove(0, 1);
-      }
-      else
-        name = string.Empty;
-      return name;
-    }
-
-    public string TrimPrefix
-    {
-      get => this.trimPrefix_;
-      set
-      {
-        this.trimPrefix_ = value;
-        if (this.trimPrefix_ == null)
-          return;
-        this.trimPrefix_ = this.trimPrefix_.ToLower();
-      }
-    }
-
-    public static bool IsValidName(string name, bool relaxed)
-    {
-      bool flag = name != null;
-      if (flag)
-        flag = !relaxed ? name.IndexOfAny(ZipNameTransform.InvalidEntryChars) < 0 && name.IndexOf('/') != 0 : name.IndexOfAny(ZipNameTransform.InvalidEntryCharsRelaxed) < 0;
-      return flag;
-    }
-
-    public static bool IsValidName(string name)
-    {
-      return name != null && name.IndexOfAny(ZipNameTransform.InvalidEntryChars) < 0 && name.IndexOf('/') != 0;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipOutputStream.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipOutputStream.cs
deleted file mode 100644
index f2994a4..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipOutputStream.cs
+++ /dev/null
@@ -1,406 +0,0 @@
-
-using ICSharpCode.SharpZipLib.Checksums;
-using ICSharpCode.SharpZipLib.Zip.Compression;
-using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
-using System;
-using System.Collections;
-using System.IO;
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public class ZipOutputStream(Stream baseOutputStream) : DeflaterOutputStream(baseOutputStream, new Deflater(-1, true))
-  {
-    private ArrayList entries = new ArrayList();
-    private Crc32 crc = new Crc32();
-    private ZipEntry curEntry;
-    private int defaultCompressionLevel = -1;
-    private CompressionMethod curMethod = CompressionMethod.Deflated;
-    private long size;
-    private long offset;
-    private byte[] zipComment = new byte[0];
-    private bool patchEntryHeader;
-    private long crcPatchPos = -1;
-    private long sizePatchPos = -1;
-    private UseZip64 useZip64_ = UseZip64.Dynamic;
-
-    public bool IsFinished => this.entries == null;
-
-    public void SetComment(string comment)
-    {
-      byte[] array = ZipConstants.ConvertToArray(comment);
-      this.zipComment = array.Length <= (int) ushort.MaxValue ? array : throw new ArgumentOutOfRangeException(nameof (comment));
-    }
-
-    public void SetLevel(int level)
-    {
-      this.defaultCompressionLevel = level;
-      this.def.SetLevel(level);
-    }
-
-    public int GetLevel() => this.def.GetLevel();
-
-    public UseZip64 UseZip64
-    {
-      get => this.useZip64_;
-      set => this.useZip64_ = value;
-    }
-
-    private void WriteLeShort(int value)
-    {
-      this.baseOutputStream.WriteByte((byte) (value & (int) byte.MaxValue));
-      this.baseOutputStream.WriteByte((byte) (value >> 8 & (int) byte.MaxValue));
-    }
-
-    private void WriteLeInt(int value)
-    {
-      this.WriteLeShort(value);
-      this.WriteLeShort(value >> 16);
-    }
-
-    private void WriteLeLong(long value)
-    {
-      this.WriteLeInt((int) value);
-      this.WriteLeInt((int) (value >> 32));
-    }
-
-    public void PutNextEntry(ZipEntry entry)
-    {
-      if (entry == null)
-        throw new ArgumentNullException(nameof (entry));
-      if (this.entries == null)
-        throw new InvalidOperationException("ZipOutputStream was finished");
-      if (this.curEntry != null)
-        this.CloseEntry();
-      if (this.entries.Count == int.MaxValue)
-        throw new ZipException("Too many entries for Zip file");
-      CompressionMethod compressionMethod = entry.CompressionMethod;
-      int level = this.defaultCompressionLevel;
-      entry.Flags &= 2048;
-      this.patchEntryHeader = false;
-      bool flag = true;
-      if (compressionMethod == CompressionMethod.Stored)
-      {
-        entry.Flags &= -9;
-        if (entry.CompressedSize >= 0L)
-        {
-          if (entry.Size < 0L)
-            entry.Size = entry.CompressedSize;
-          else if (entry.Size != entry.CompressedSize)
-            throw new ZipException("Method STORED, but compressed size != size");
-        }
-        else if (entry.Size >= 0L)
-          entry.CompressedSize = entry.Size;
-        if (entry.Size < 0L || entry.Crc < 0L)
-        {
-          if (this.CanPatchEntries)
-          {
-            flag = false;
-          }
-          else
-          {
-            compressionMethod = CompressionMethod.Deflated;
-            level = 0;
-          }
-        }
-      }
-      if (compressionMethod == CompressionMethod.Deflated)
-      {
-        if (entry.Size == 0L)
-        {
-          entry.CompressedSize = entry.Size;
-          entry.Crc = 0L;
-          compressionMethod = CompressionMethod.Stored;
-        }
-        else if (entry.CompressedSize < 0L || entry.Size < 0L || entry.Crc < 0L)
-          flag = false;
-      }
-      if (!flag)
-      {
-        if (!this.CanPatchEntries)
-          entry.Flags |= 8;
-        else
-          this.patchEntryHeader = true;
-      }
-      if (this.Password != null)
-      {
-        entry.IsCrypted = true;
-        if (entry.Crc < 0L)
-          entry.Flags |= 8;
-      }
-      entry.Offset = this.offset;
-      entry.CompressionMethod = compressionMethod;
-      this.curMethod = compressionMethod;
-      this.sizePatchPos = -1L;
-      if (this.useZip64_ == UseZip64.On || entry.Size < 0L && this.useZip64_ == UseZip64.Dynamic)
-        entry.ForceZip64();
-      this.WriteLeInt(67324752);
-      this.WriteLeShort(entry.Version);
-      this.WriteLeShort(entry.Flags);
-      this.WriteLeShort((int) (byte) compressionMethod);
-      this.WriteLeInt((int) entry.DosTime);
-      if (flag)
-      {
-        this.WriteLeInt((int) entry.Crc);
-        if (entry.LocalHeaderRequiresZip64)
-        {
-          this.WriteLeInt(-1);
-          this.WriteLeInt(-1);
-        }
-        else
-        {
-          this.WriteLeInt(entry.IsCrypted ? (int) entry.CompressedSize + 12 : (int) entry.CompressedSize);
-          this.WriteLeInt((int) entry.Size);
-        }
-      }
-      else
-      {
-        if (this.patchEntryHeader)
-          this.crcPatchPos = this.baseOutputStream.Position;
-        this.WriteLeInt(0);
-        if (this.patchEntryHeader)
-          this.sizePatchPos = this.baseOutputStream.Position;
-        if (entry.LocalHeaderRequiresZip64 && this.patchEntryHeader)
-        {
-          this.WriteLeInt(-1);
-          this.WriteLeInt(-1);
-        }
-        else
-        {
-          this.WriteLeInt(0);
-          this.WriteLeInt(0);
-        }
-      }
-      byte[] array = ZipConstants.ConvertToArray(entry.Flags, entry.Name);
-      if (array.Length > (int) ushort.MaxValue)
-        throw new ZipException("Entry name too long.");
-      ZipExtraData zipExtraData = new ZipExtraData(entry.ExtraData);
-      if (entry.LocalHeaderRequiresZip64 && (flag || this.patchEntryHeader))
-      {
-        zipExtraData.StartNewEntry();
-        if (flag)
-        {
-          zipExtraData.AddLeLong(entry.Size);
-          zipExtraData.AddLeLong(entry.CompressedSize);
-        }
-        else
-        {
-          zipExtraData.AddLeLong(-1L);
-          zipExtraData.AddLeLong(-1L);
-        }
-        zipExtraData.AddNewEntry(1);
-        if (!zipExtraData.Find(1))
-          throw new ZipException("Internal error cant find extra data");
-        if (this.patchEntryHeader)
-          this.sizePatchPos = (long) zipExtraData.CurrentReadIndex;
-      }
-      else
-        zipExtraData.Delete(1);
-      byte[] entryData = zipExtraData.GetEntryData();
-      this.WriteLeShort(array.Length);
-      this.WriteLeShort(entryData.Length);
-      if (array.Length > 0)
-        this.baseOutputStream.Write(array, 0, array.Length);
-      if (entry.LocalHeaderRequiresZip64 && this.patchEntryHeader)
-        this.sizePatchPos += this.baseOutputStream.Position;
-      if (entryData.Length > 0)
-        this.baseOutputStream.Write(entryData, 0, entryData.Length);
-      this.offset += (long) (30 + array.Length + entryData.Length);
-      this.curEntry = entry;
-      this.crc.Reset();
-      if (compressionMethod == CompressionMethod.Deflated)
-      {
-        this.def.Reset();
-        this.def.SetLevel(level);
-      }
-      this.size = 0L;
-      if (!entry.IsCrypted)
-        return;
-      if (entry.Crc < 0L)
-        this.WriteEncryptionHeader(entry.DosTime << 16);
-      else
-        this.WriteEncryptionHeader(entry.Crc);
-    }
-
-    public void CloseEntry()
-    {
-      if (this.curEntry == null)
-        throw new InvalidOperationException("No open entry");
-      if (this.curMethod == CompressionMethod.Deflated)
-        base.Finish();
-      long num = this.curMethod == CompressionMethod.Deflated ? this.def.TotalOut : this.size;
-      if (this.curEntry.Size < 0L)
-        this.curEntry.Size = this.size;
-      else if (this.curEntry.Size != this.size)
-        throw new ZipException("size was " + (object) this.size + ", but I expected " + (object) this.curEntry.Size);
-      if (this.curEntry.CompressedSize < 0L)
-        this.curEntry.CompressedSize = num;
-      else if (this.curEntry.CompressedSize != num)
-        throw new ZipException("compressed size was " + (object) num + ", but I expected " + (object) this.curEntry.CompressedSize);
-      if (this.curEntry.Crc < 0L)
-        this.curEntry.Crc = this.crc.Value;
-      else if (this.curEntry.Crc != this.crc.Value)
-        throw new ZipException("crc was " + (object) this.crc.Value + ", but I expected " + (object) this.curEntry.Crc);
-      this.offset += num;
-      if (this.curEntry.IsCrypted)
-        this.curEntry.CompressedSize += 12L;
-      if (this.patchEntryHeader)
-      {
-        this.patchEntryHeader = false;
-        long position = this.baseOutputStream.Position;
-        this.baseOutputStream.Seek(this.crcPatchPos, SeekOrigin.Begin);
-        this.WriteLeInt((int) this.curEntry.Crc);
-        if (this.curEntry.LocalHeaderRequiresZip64)
-        {
-          if (this.sizePatchPos == -1L)
-            throw new ZipException("Entry requires zip64 but this has been turned off");
-          this.baseOutputStream.Seek(this.sizePatchPos, SeekOrigin.Begin);
-          this.WriteLeLong(this.curEntry.Size);
-          this.WriteLeLong(this.curEntry.CompressedSize);
-        }
-        else
-        {
-          this.WriteLeInt((int) this.curEntry.CompressedSize);
-          this.WriteLeInt((int) this.curEntry.Size);
-        }
-        this.baseOutputStream.Seek(position, SeekOrigin.Begin);
-      }
-      if ((this.curEntry.Flags & 8) != 0)
-      {
-        this.WriteLeInt(134695760);
-        this.WriteLeInt((int) this.curEntry.Crc);
-        if (this.curEntry.LocalHeaderRequiresZip64)
-        {
-          this.WriteLeLong(this.curEntry.CompressedSize);
-          this.WriteLeLong(this.curEntry.Size);
-          this.offset += 24L;
-        }
-        else
-        {
-          this.WriteLeInt((int) this.curEntry.CompressedSize);
-          this.WriteLeInt((int) this.curEntry.Size);
-          this.offset += 16L;
-        }
-      }
-      this.entries.Add((object) this.curEntry);
-      this.curEntry = (ZipEntry) null;
-    }
-
-    private void WriteEncryptionHeader(long crcValue)
-    {
-      this.offset += 12L;
-      this.InitializePassword(this.Password);
-      byte[] buffer = new byte[12];
-      new Random().NextBytes(buffer);
-      buffer[11] = (byte) (crcValue >> 24);
-      this.EncryptBlock(buffer, 0, buffer.Length);
-      this.baseOutputStream.Write(buffer, 0, buffer.Length);
-    }
-
-    public override void Write(byte[] buffer, int offset, int count)
-    {
-      if (this.curEntry == null)
-        throw new InvalidOperationException("No open entry.");
-      if (buffer == null)
-        throw new ArgumentNullException(nameof (buffer));
-      if (offset < 0)
-        throw new ArgumentOutOfRangeException(nameof (offset), "Cannot be negative");
-      if (count < 0)
-        throw new ArgumentOutOfRangeException(nameof (count), "Cannot be negative");
-      if (buffer.Length - offset < count)
-        throw new ArgumentException("Invalid offset/count combination");
-      this.crc.Update(buffer, offset, count);
-      this.size += (long) count;
-      switch (this.curMethod)
-      {
-        case CompressionMethod.Stored:
-          if (this.Password != null)
-          {
-            byte[] numArray = new byte[count];
-            Array.Copy((Array) buffer, offset, (Array) numArray, 0, count);
-            this.EncryptBlock(numArray, 0, count);
-            this.baseOutputStream.Write(numArray, offset, count);
-            break;
-          }
-          this.baseOutputStream.Write(buffer, offset, count);
-          break;
-        case CompressionMethod.Deflated:
-          base.Write(buffer, offset, count);
-          break;
-      }
-    }
-
-    public override void Finish()
-    {
-      if (this.entries == null)
-        return;
-      if (this.curEntry != null)
-        this.CloseEntry();
-      long count = (long) this.entries.Count;
-      long sizeEntries = 0;
-      foreach (ZipEntry entry in this.entries)
-      {
-        this.WriteLeInt(33639248);
-        this.WriteLeShort(45);
-        this.WriteLeShort(entry.Version);
-        this.WriteLeShort(entry.Flags);
-        this.WriteLeShort((int) (short) entry.CompressionMethod);
-        this.WriteLeInt((int) entry.DosTime);
-        this.WriteLeInt((int) entry.Crc);
-        if (entry.IsZip64Forced() || entry.CompressedSize >= (long) uint.MaxValue)
-          this.WriteLeInt(-1);
-        else
-          this.WriteLeInt((int) entry.CompressedSize);
-        if (entry.IsZip64Forced() || entry.Size >= (long) uint.MaxValue)
-          this.WriteLeInt(-1);
-        else
-          this.WriteLeInt((int) entry.Size);
-        byte[] array = ZipConstants.ConvertToArray(entry.Flags, entry.Name);
-        if (array.Length > (int) ushort.MaxValue)
-          throw new ZipException("Name too long.");
-        ZipExtraData zipExtraData = new ZipExtraData(entry.ExtraData);
-        if (entry.CentralHeaderRequiresZip64)
-        {
-          zipExtraData.StartNewEntry();
-          if (entry.IsZip64Forced() || entry.Size >= (long) uint.MaxValue)
-            zipExtraData.AddLeLong(entry.Size);
-          if (entry.IsZip64Forced() || entry.CompressedSize >= (long) uint.MaxValue)
-            zipExtraData.AddLeLong(entry.CompressedSize);
-          if (entry.Offset >= (long) uint.MaxValue)
-            zipExtraData.AddLeLong(entry.Offset);
-          zipExtraData.AddNewEntry(1);
-        }
-        else
-          zipExtraData.Delete(1);
-        byte[] entryData = zipExtraData.GetEntryData();
-        byte[] buffer = entry.Comment != null ? ZipConstants.ConvertToArray(entry.Flags, entry.Comment) : new byte[0];
-        if (buffer.Length > (int) ushort.MaxValue)
-          throw new ZipException("Comment too long.");
-        this.WriteLeShort(array.Length);
-        this.WriteLeShort(entryData.Length);
-        this.WriteLeShort(buffer.Length);
-        this.WriteLeShort(0);
-        this.WriteLeShort(0);
-        if (entry.ExternalFileAttributes != -1)
-          this.WriteLeInt(entry.ExternalFileAttributes);
-        else if (entry.IsDirectory)
-          this.WriteLeInt(16);
-        else
-          this.WriteLeInt(0);
-        if (entry.Offset >= (long) uint.MaxValue)
-          this.WriteLeInt(-1);
-        else
-          this.WriteLeInt((int) entry.Offset);
-        if (array.Length > 0)
-          this.baseOutputStream.Write(array, 0, array.Length);
-        if (entryData.Length > 0)
-          this.baseOutputStream.Write(entryData, 0, entryData.Length);
-        if (buffer.Length > 0)
-          this.baseOutputStream.Write(buffer, 0, buffer.Length);
-        sizeEntries += (long) (46 + array.Length + entryData.Length + buffer.Length);
-      }
-      using (ZipHelperStream zipHelperStream = new ZipHelperStream(this.baseOutputStream))
-        zipHelperStream.WriteEndOfCentralDirectory(count, sizeEntries, this.offset, this.zipComment);
-      this.entries = (ArrayList) null;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipTestResultHandler.cs b/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipTestResultHandler.cs
deleted file mode 100644
index ef03e94..0000000
--- a/Redbox.HAL.Component.Model/ICSharpCode/SharpZipLib/Zip/ZipTestResultHandler.cs
+++ /dev/null
@@ -1,5 +0,0 @@
-
-namespace ICSharpCode.SharpZipLib.Zip
-{
-  public delegate void ZipTestResultHandler(TestStatus status, string message);
-}
diff --git a/Redbox.HAL.Component.Model/LzmaAlone/Properties/Settings.cs b/Redbox.HAL.Component.Model/LzmaAlone/Properties/Settings.cs
deleted file mode 100644
index d22791f..0000000
--- a/Redbox.HAL.Component.Model/LzmaAlone/Properties/Settings.cs
+++ /dev/null
@@ -1,37 +0,0 @@
-
-using System.Configuration;
-using System.Runtime.InteropServices;
-using System.Threading;
-
-namespace LzmaAlone.Properties
-{
-  [ComVisible(true)]
-  public class Settings : ApplicationSettingsBase
-  {
-    private static Settings m_Value;
-    private static object m_SyncObject = new object();
-
-    public static Settings Value
-    {
-      get
-      {
-        if (Settings.m_Value == null)
-        {
-          Monitor.Enter(Settings.m_SyncObject);
-          if (Settings.m_Value == null)
-          {
-            try
-            {
-              Settings.m_Value = new Settings();
-            }
-            finally
-            {
-              Monitor.Exit(Settings.m_SyncObject);
-            }
-          }
-        }
-        return Settings.m_Value;
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/Redbox.HAL.Component.Model.csproj b/Redbox.HAL.Component.Model/Redbox.HAL.Component.Model.csproj
index a822b19..fc599d0 100644
--- a/Redbox.HAL.Component.Model/Redbox.HAL.Component.Model.csproj
+++ b/Redbox.HAL.Component.Model/Redbox.HAL.Component.Model.csproj
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="3.5" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="Current" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <!--Project was exported from assembly: U:\2024_11_07_kiosk2_fresh\Program Files\Redbox\halservice\bin\Redbox.HAL.Component.Model.dll-->
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
@@ -10,6 +10,11 @@
     <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <ApplicationVersion>1.13.0.27</ApplicationVersion>
     <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <UpgradeBackupLocation>
+    </UpgradeBackupLocation>
+    <OldToolsVersion>3.5</OldToolsVersion>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <PlatformTarget>AnyCPU</PlatformTarget>
@@ -31,6 +36,12 @@
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
   <ItemGroup>
+    <Reference Include="ICSharpCode.SharpZipLib, Version=0.86.0.518, Culture=neutral, PublicKeyToken=1b03e6acf1164f73, processorArchitecture=MSIL">
+      <HintPath>packages\SharpZipLib.0.86.0\lib\20\ICSharpCode.SharpZipLib.dll</HintPath>
+    </Reference>
+    <Reference Include="SevenZip, Version=19.0.0.0, Culture=neutral, processorArchitecture=MSIL">
+      <HintPath>packages\SevenZip.19.0.0\lib\net20\SevenZip.dll</HintPath>
+    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core" />
     <Reference Include="System.Data" />
@@ -259,122 +270,11 @@
     <Compile Include="Redbox\HAL\Component\Model\Attributes\UsageAttribute.cs" />
     <Compile Include="Redbox\HAL\Component\Model\Attributes\ValidValueListProviderAttribute.cs" />
     <Compile Include="Redbox\HAL\Component\Model\Attributes\XmlConfigurationAttribute.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\SharpZipBaseException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2Constants.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2Exception.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Checksums\IChecksum.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Checksums\Adler32.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Checksums\Crc32.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Checksums\StrangeCRC.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ScanEventArgs.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\DirectoryEventArgs.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ScanFailureEventArgs.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ProcessDirectoryDelegate.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ProcessFileDelegate.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\DirectoryFailureDelegate.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\FileFailureDelegate.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\FileSystemScanner.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\INameTransform.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\IScanFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\NameFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\PathFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\ExtendedPathFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\NameAndSizeFilter.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Core\StreamUtils.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassicCryptoBase.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassicEncryptCryptoTransform.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassicDecryptCryptoTransform.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Encryption\PkzipClassicManaged.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\GZip\GZipConstants.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\GZip\GZipException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\GZip\GZipInputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\GZip\GZipOutputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\FastZipEvents.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\FastZip.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\IEntryFactory.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\UseZip64.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\CompressionMethod.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\EncryptionAlgorithm.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\GeneralBitFlags.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipConstants.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\HostSystemID.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipEntry.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipEntryFactory.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\KeysRequiredEventArgs.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\TestStrategy.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\TestOperation.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\TestStatus.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipTestResultHandler.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\FileUpdateMode.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipFile.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\IStaticDataSource.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\IDynamicDataSource.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\StaticDiskDataSource.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\DynamicDiskDataSource.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\IArchiveStorage.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\BaseArchiveStorage.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\DiskArchiveStorage.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\MemoryArchiveStorage.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipNameTransform.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflaterConstants.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflateStrategy.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\DeflaterPending.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputBuffer.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\OutputWindow.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\InvalidHeaderException.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\ProgressMessageHandler.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarArchive.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarBuffer.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarEntry.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarHeader.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarInputStream.cs" />
-    <Compile Include="ICSharpCode\SharpZipLib\Tar\TarOutputStream.cs" />
-    <Compile Include="SevenZip\ICoder.cs" />
-    <Compile Include="SevenZip\ISetCoderProperties.cs" />
-    <Compile Include="SevenZip\IWriteCoderProperties.cs" />
-    <Compile Include="SevenZip\CRC.cs" />
-    <Compile Include="SevenZip\ISetDecoderProperties.cs" />
-    <Compile Include="SevenZip\DataErrorException.cs" />
-    <Compile Include="SevenZip\InvalidParamException.cs" />
-    <Compile Include="SevenZip\ICodeProgress.cs" />
-    <Compile Include="SevenZip\CoderPropID.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\BitEncoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\BitDecoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\Encoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\Decoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\BitTreeEncoder.cs" />
-    <Compile Include="SevenZip\Compression\RangeCoder\BitTreeDecoder.cs" />
     <Compile Include="SevenZip\Compression\LZMA\SevenZipHelper.cs" />
-    <Compile Include="SevenZip\Compression\LZMA\Encoder.cs" />
-    <Compile Include="SevenZip\Compression\LZMA\Base.cs" />
-    <Compile Include="SevenZip\Compression\LZMA\Decoder.cs" />
-    <Compile Include="SevenZip\Compression\LZ\InWindow.cs" />
-    <Compile Include="SevenZip\Compression\LZ\OutWindow.cs" />
-    <Compile Include="SevenZip\Compression\LZ\IInWindowStream.cs" />
-    <Compile Include="SevenZip\Compression\LZ\IMatchFinder.cs" />
-    <Compile Include="SevenZip\Compression\LZ\BinTree.cs" />
-    <Compile Include="LzmaAlone\Properties\Settings.cs" />
     <Compile Include="AssemblyInfo.cs" />
   </ItemGroup>
+  <ItemGroup>
+    <None Include="packages.config" />
+  </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
 </Project>
\ No newline at end of file
diff --git a/Redbox.HAL.Component.Model/Redbox.HAL.Component.Model.sln b/Redbox.HAL.Component.Model/Redbox.HAL.Component.Model.sln
index 55a3c4a..e167df6 100644
--- a/Redbox.HAL.Component.Model/Redbox.HAL.Component.Model.sln
+++ b/Redbox.HAL.Component.Model/Redbox.HAL.Component.Model.sln
@@ -1,6 +1,7 @@
-
-Microsoft Visual Studio Solution File, Format Version 10.00
-# Visual Studio 2008
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 17
+VisualStudioVersion = 17.10.35122.118
+MinimumVisualStudioVersion = 10.0.40219.1
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Redbox.HAL.Component.Model", "Redbox.HAL.Component.Model.csproj", "{6E955432-A773-4226-9B8D-F223778AF028}"
 EndProject
 Global
@@ -17,4 +18,7 @@ Global
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
 	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {18437693-9271-46CB-A65D-D968B0A72362}
+	EndGlobalSection
 EndGlobal
diff --git a/Redbox.HAL.Component.Model/SevenZip/CRC.cs b/Redbox.HAL.Component.Model/SevenZip/CRC.cs
deleted file mode 100644
index b305d81..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/CRC.cs
+++ /dev/null
@@ -1,56 +0,0 @@
-
-using System;
-using System.Runtime.InteropServices;
-
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public class CRC
-  {
-    public static readonly uint[] Table = new uint[256];
-    private uint _value = uint.MaxValue;
-
-    static CRC()
-    {
-      for (uint index1 = 0; index1 < 256U; ++index1)
-      {
-        uint num = index1;
-        for (int index2 = 0; index2 < 8; ++index2)
-        {
-          if (((int) num & 1) != 0)
-            num = num >> 1 ^ 3988292384U;
-          else
-            num >>= 1;
-        }
-        CRC.Table[(IntPtr) index1] = num;
-      }
-    }
-
-    public void Init() => this._value = uint.MaxValue;
-
-    public void UpdateByte(byte b)
-    {
-      this._value = CRC.Table[(int) (byte) this._value ^ (int) b] ^ this._value >> 8;
-    }
-
-    public void Update(byte[] data, uint offset, uint size)
-    {
-      for (uint index = 0; index < size; ++index)
-        this._value = CRC.Table[(int) (byte) this._value ^ (int) data[(IntPtr) (offset + index)]] ^ this._value >> 8;
-    }
-
-    public uint GetDigest() => this._value ^ uint.MaxValue;
-
-    private static uint CalculateDigest(byte[] data, uint offset, uint size)
-    {
-      CRC crc = new CRC();
-      crc.Update(data, offset, size);
-      return crc.GetDigest();
-    }
-
-    private static bool VerifyDigest(uint digest, byte[] data, uint offset, uint size)
-    {
-      return (int) CRC.CalculateDigest(data, offset, size) == (int) digest;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/CoderPropID.cs b/Redbox.HAL.Component.Model/SevenZip/CoderPropID.cs
deleted file mode 100644
index 79d28c9..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/CoderPropID.cs
+++ /dev/null
@@ -1,22 +0,0 @@
-
-using System.Runtime.InteropServices;
-
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public enum CoderPropID
-  {
-    DictionarySize = 1024, // 0x00000400
-    UsedMemorySize = 1025, // 0x00000401
-    Order = 1026, // 0x00000402
-    PosStateBits = 1088, // 0x00000440
-    LitContextBits = 1089, // 0x00000441
-    LitPosBits = 1090, // 0x00000442
-    NumFastBytes = 1104, // 0x00000450
-    MatchFinder = 1105, // 0x00000451
-    NumPasses = 1120, // 0x00000460
-    Algorithm = 1136, // 0x00000470
-    MultiThread = 1152, // 0x00000480
-    EndMarker = 1168, // 0x00000490
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/BinTree.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/BinTree.cs
deleted file mode 100644
index 9eaca39..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/BinTree.cs
+++ /dev/null
@@ -1,370 +0,0 @@
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace SevenZip.Compression.LZ
-{
-  [ComVisible(true)]
-  public class BinTree : InWindow, IMatchFinder, IInWindowStream
-  {
-    private const uint kHash2Size = 1024;
-    private const uint kHash3Size = 65536;
-    private const uint kBT2HashSize = 65536;
-    private const uint kStartMaxLen = 1;
-    private const uint kHash3Offset = 1024;
-    private const uint kEmptyHashValue = 0;
-    private const uint kMaxValForNormalize = 2147483647;
-    private uint _cyclicBufferPos;
-    private uint _cyclicBufferSize;
-    private uint _matchMaxLen;
-    private uint[] _son;
-    private uint[] _hash;
-    private uint _cutValue = (uint) byte.MaxValue;
-    private uint _hashMask;
-    private uint _hashSizeSum;
-    private bool HASH_ARRAY = true;
-    private uint kNumHashDirectBytes;
-    private uint kMinMatchCheck = 4;
-    private uint kFixHashSize = 66560;
-
-    public void SetType(int numHashBytes)
-    {
-      this.HASH_ARRAY = numHashBytes > 2;
-      if (this.HASH_ARRAY)
-      {
-        this.kNumHashDirectBytes = 0U;
-        this.kMinMatchCheck = 4U;
-        this.kFixHashSize = 66560U;
-      }
-      else
-      {
-        this.kNumHashDirectBytes = 2U;
-        this.kMinMatchCheck = 3U;
-        this.kFixHashSize = 0U;
-      }
-    }
-
-    public new void SetStream(Stream stream) => base.SetStream(stream);
-
-    public new void ReleaseStream() => base.ReleaseStream();
-
-    public new void Init()
-    {
-      base.Init();
-      for (uint index = 0; index < this._hashSizeSum; ++index)
-        this._hash[(IntPtr) index] = 0U;
-      this._cyclicBufferPos = 0U;
-      this.ReduceOffsets(-1);
-    }
-
-    public new void MovePos()
-    {
-      if (++this._cyclicBufferPos >= this._cyclicBufferSize)
-        this._cyclicBufferPos = 0U;
-      base.MovePos();
-      if (this._pos != (uint) int.MaxValue)
-        return;
-      this.Normalize();
-    }
-
-    public new byte GetIndexByte(int index) => base.GetIndexByte(index);
-
-    public new uint GetMatchLen(int index, uint distance, uint limit)
-    {
-      return base.GetMatchLen(index, distance, limit);
-    }
-
-    public new uint GetNumAvailableBytes() => base.GetNumAvailableBytes();
-
-    public void Create(
-      uint historySize,
-      uint keepAddBufferBefore,
-      uint matchMaxLen,
-      uint keepAddBufferAfter)
-    {
-      if (historySize > 2147483391U)
-        throw new Exception();
-      this._cutValue = 16U + (matchMaxLen >> 1);
-      uint keepSizeReserv = (historySize + keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2U + 256U;
-      this.Create(historySize + keepAddBufferBefore, matchMaxLen + keepAddBufferAfter, keepSizeReserv);
-      this._matchMaxLen = matchMaxLen;
-      uint num1 = historySize + 1U;
-      if ((int) this._cyclicBufferSize != (int) num1)
-        this._son = new uint[(IntPtr) ((this._cyclicBufferSize = num1) * 2U)];
-      uint num2 = 65536;
-      if (this.HASH_ARRAY)
-      {
-        uint num3 = historySize - 1U;
-        uint num4 = num3 | num3 >> 1;
-        uint num5 = num4 | num4 >> 2;
-        uint num6 = num5 | num5 >> 4;
-        uint num7 = (num6 | num6 >> 8) >> 1 | (uint) ushort.MaxValue;
-        if (num7 > 16777216U)
-          num7 >>= 1;
-        this._hashMask = num7;
-        num2 = num7 + 1U + this.kFixHashSize;
-      }
-      if ((int) num2 == (int) this._hashSizeSum)
-        return;
-      this._hash = new uint[(IntPtr) (this._hashSizeSum = num2)];
-    }
-
-    public uint GetMatches(uint[] distances)
-    {
-      uint num1;
-      if (this._pos + this._matchMaxLen <= this._streamPos)
-      {
-        num1 = this._matchMaxLen;
-      }
-      else
-      {
-        num1 = this._streamPos - this._pos;
-        if (num1 < this.kMinMatchCheck)
-        {
-          this.MovePos();
-          return 0;
-        }
-      }
-      uint matches = 0;
-      uint num2 = this._pos > this._cyclicBufferSize ? this._pos - this._cyclicBufferSize : 0U;
-      uint index1 = this._bufferOffset + this._pos;
-      uint num3 = 1;
-      uint index2 = 0;
-      uint num4 = 0;
-      uint num5;
-      if (this.HASH_ARRAY)
-      {
-        uint num6 = CRC.Table[(int) this._bufferBase[(IntPtr) index1]] ^ (uint) this._bufferBase[(IntPtr) (index1 + 1U)];
-        index2 = num6 & 1023U;
-        uint num7 = num6 ^ (uint) this._bufferBase[(IntPtr) (index1 + 2U)] << 8;
-        num4 = num7 & (uint) ushort.MaxValue;
-        num5 = (num7 ^ CRC.Table[(int) this._bufferBase[(IntPtr) (index1 + 3U)]] << 5) & this._hashMask;
-      }
-      else
-        num5 = (uint) this._bufferBase[(IntPtr) index1] ^ (uint) this._bufferBase[(IntPtr) (index1 + 1U)] << 8;
-      uint num8 = this._hash[(IntPtr) (this.kFixHashSize + num5)];
-      if (this.HASH_ARRAY)
-      {
-        uint num9 = this._hash[(IntPtr) index2];
-        uint num10 = this._hash[(IntPtr) (1024U + num4)];
-        this._hash[(IntPtr) index2] = this._pos;
-        this._hash[(IntPtr) (1024U + num4)] = this._pos;
-        if (num9 > num2 && (int) this._bufferBase[(IntPtr) (this._bufferOffset + num9)] == (int) this._bufferBase[(IntPtr) index1])
-        {
-          uint[] numArray1 = distances;
-          int num11 = (int) matches;
-          uint num12 = (uint) (num11 + 1);
-          uint index3 = (uint) num11;
-          int num13;
-          num3 = (uint) (num13 = 2);
-          numArray1[(IntPtr) index3] = (uint) num13;
-          uint[] numArray2 = distances;
-          int num14 = (int) num12;
-          matches = (uint) (num14 + 1);
-          uint index4 = (uint) num14;
-          int num15 = (int) this._pos - (int) num9 - 1;
-          numArray2[(IntPtr) index4] = (uint) num15;
-        }
-        if (num10 > num2 && (int) this._bufferBase[(IntPtr) (this._bufferOffset + num10)] == (int) this._bufferBase[(IntPtr) index1])
-        {
-          if ((int) num10 == (int) num9)
-            matches -= 2U;
-          uint[] numArray3 = distances;
-          int num16 = (int) matches;
-          uint num17 = (uint) (num16 + 1);
-          uint index5 = (uint) num16;
-          int num18;
-          num3 = (uint) (num18 = 3);
-          numArray3[(IntPtr) index5] = (uint) num18;
-          uint[] numArray4 = distances;
-          int num19 = (int) num17;
-          matches = (uint) (num19 + 1);
-          uint index6 = (uint) num19;
-          int num20 = (int) this._pos - (int) num10 - 1;
-          numArray4[(IntPtr) index6] = (uint) num20;
-          num9 = num10;
-        }
-        if (matches != 0U && (int) num9 == (int) num8)
-        {
-          matches -= 2U;
-          num3 = 1U;
-        }
-      }
-      this._hash[(IntPtr) (this.kFixHashSize + num5)] = this._pos;
-      uint index7 = (uint) (((int) this._cyclicBufferPos << 1) + 1);
-      uint index8 = this._cyclicBufferPos << 1;
-      uint val2;
-      uint val1 = val2 = this.kNumHashDirectBytes;
-      if (this.kNumHashDirectBytes != 0U && num8 > num2 && (int) this._bufferBase[(IntPtr) (this._bufferOffset + num8 + this.kNumHashDirectBytes)] != (int) this._bufferBase[(IntPtr) (index1 + this.kNumHashDirectBytes)])
-      {
-        uint[] numArray5 = distances;
-        int num21 = (int) matches;
-        uint num22 = (uint) (num21 + 1);
-        uint index9 = (uint) num21;
-        int numHashDirectBytes;
-        num3 = (uint) (numHashDirectBytes = (int) this.kNumHashDirectBytes);
-        numArray5[(IntPtr) index9] = (uint) numHashDirectBytes;
-        uint[] numArray6 = distances;
-        int num23 = (int) num22;
-        matches = (uint) (num23 + 1);
-        uint index10 = (uint) num23;
-        int num24 = (int) this._pos - (int) num8 - 1;
-        numArray6[(IntPtr) index10] = (uint) num24;
-      }
-      uint cutValue = this._cutValue;
-      while (num8 > num2 && cutValue-- != 0U)
-      {
-        uint num25 = this._pos - num8;
-        uint index11 = (uint) ((num25 <= this._cyclicBufferPos ? (int) this._cyclicBufferPos - (int) num25 : (int) this._cyclicBufferPos - (int) num25 + (int) this._cyclicBufferSize) << 1);
-        uint num26 = this._bufferOffset + num8;
-        uint num27 = Math.Min(val1, val2);
-        if ((int) this._bufferBase[(IntPtr) (num26 + num27)] == (int) this._bufferBase[(IntPtr) (index1 + num27)])
-        {
-          do
-            ;
-          while ((int) ++num27 != (int) num1 && (int) this._bufferBase[(IntPtr) (num26 + num27)] == (int) this._bufferBase[(IntPtr) (index1 + num27)]);
-          if (num3 < num27)
-          {
-            uint[] numArray7 = distances;
-            int num28 = (int) matches;
-            uint num29 = (uint) (num28 + 1);
-            uint index12 = (uint) num28;
-            int num30;
-            num3 = (uint) (num30 = (int) num27);
-            numArray7[(IntPtr) index12] = (uint) num30;
-            uint[] numArray8 = distances;
-            int num31 = (int) num29;
-            matches = (uint) (num31 + 1);
-            uint index13 = (uint) num31;
-            int num32 = (int) num25 - 1;
-            numArray8[(IntPtr) index13] = (uint) num32;
-            if ((int) num27 == (int) num1)
-            {
-              this._son[(IntPtr) index8] = this._son[(IntPtr) index11];
-              this._son[(IntPtr) index7] = this._son[(IntPtr) (index11 + 1U)];
-              goto label_29;
-            }
-          }
-        }
-        if ((int) this._bufferBase[(IntPtr) (num26 + num27)] < (int) this._bufferBase[(IntPtr) (index1 + num27)])
-        {
-          this._son[(IntPtr) index8] = num8;
-          index8 = index11 + 1U;
-          num8 = this._son[(IntPtr) index8];
-          val2 = num27;
-        }
-        else
-        {
-          this._son[(IntPtr) index7] = num8;
-          index7 = index11;
-          num8 = this._son[(IntPtr) index7];
-          val1 = num27;
-        }
-      }
-      this._son[(IntPtr) index7] = this._son[(IntPtr) index8] = 0U;
-label_29:
-      this.MovePos();
-      return matches;
-    }
-
-    public void Skip(uint num)
-    {
-      do
-      {
-        uint num1;
-        if (this._pos + this._matchMaxLen <= this._streamPos)
-        {
-          num1 = this._matchMaxLen;
-        }
-        else
-        {
-          num1 = this._streamPos - this._pos;
-          if (num1 < this.kMinMatchCheck)
-          {
-            this.MovePos();
-            goto label_19;
-          }
-        }
-        uint num2 = this._pos > this._cyclicBufferSize ? this._pos - this._cyclicBufferSize : 0U;
-        uint index1 = this._bufferOffset + this._pos;
-        uint num3;
-        if (this.HASH_ARRAY)
-        {
-          uint num4 = CRC.Table[(int) this._bufferBase[(IntPtr) index1]] ^ (uint) this._bufferBase[(IntPtr) (index1 + 1U)];
-          this._hash[(IntPtr) (num4 & 1023U)] = this._pos;
-          uint num5 = num4 ^ (uint) this._bufferBase[(IntPtr) (index1 + 2U)] << 8;
-          this._hash[(IntPtr) (1024U + (num5 & (uint) ushort.MaxValue))] = this._pos;
-          num3 = (num5 ^ CRC.Table[(int) this._bufferBase[(IntPtr) (index1 + 3U)]] << 5) & this._hashMask;
-        }
-        else
-          num3 = (uint) this._bufferBase[(IntPtr) index1] ^ (uint) this._bufferBase[(IntPtr) (index1 + 1U)] << 8;
-        uint num6 = this._hash[(IntPtr) (this.kFixHashSize + num3)];
-        this._hash[(IntPtr) (this.kFixHashSize + num3)] = this._pos;
-        uint index2 = (uint) (((int) this._cyclicBufferPos << 1) + 1);
-        uint index3 = this._cyclicBufferPos << 1;
-        uint val2;
-        uint val1 = val2 = this.kNumHashDirectBytes;
-        uint cutValue = this._cutValue;
-        while (num6 > num2 && cutValue-- != 0U)
-        {
-          uint num7 = this._pos - num6;
-          uint index4 = (uint) ((num7 <= this._cyclicBufferPos ? (int) this._cyclicBufferPos - (int) num7 : (int) this._cyclicBufferPos - (int) num7 + (int) this._cyclicBufferSize) << 1);
-          uint num8 = this._bufferOffset + num6;
-          uint num9 = Math.Min(val1, val2);
-          if ((int) this._bufferBase[(IntPtr) (num8 + num9)] == (int) this._bufferBase[(IntPtr) (index1 + num9)])
-          {
-            do
-              ;
-            while ((int) ++num9 != (int) num1 && (int) this._bufferBase[(IntPtr) (num8 + num9)] == (int) this._bufferBase[(IntPtr) (index1 + num9)]);
-            if ((int) num9 == (int) num1)
-            {
-              this._son[(IntPtr) index3] = this._son[(IntPtr) index4];
-              this._son[(IntPtr) index2] = this._son[(IntPtr) (index4 + 1U)];
-              goto label_18;
-            }
-          }
-          if ((int) this._bufferBase[(IntPtr) (num8 + num9)] < (int) this._bufferBase[(IntPtr) (index1 + num9)])
-          {
-            this._son[(IntPtr) index3] = num6;
-            index3 = index4 + 1U;
-            num6 = this._son[(IntPtr) index3];
-            val2 = num9;
-          }
-          else
-          {
-            this._son[(IntPtr) index2] = num6;
-            index2 = index4;
-            num6 = this._son[(IntPtr) index2];
-            val1 = num9;
-          }
-        }
-        this._son[(IntPtr) index2] = this._son[(IntPtr) index3] = 0U;
-label_18:
-        this.MovePos();
-label_19:;
-      }
-      while (--num != 0U);
-    }
-
-    private void NormalizeLinks(uint[] items, uint numItems, uint subValue)
-    {
-      for (uint index = 0; index < numItems; ++index)
-      {
-        uint num1 = items[(IntPtr) index];
-        uint num2 = num1 > subValue ? num1 - subValue : 0U;
-        items[(IntPtr) index] = num2;
-      }
-    }
-
-    private void Normalize()
-    {
-      uint subValue = this._pos - this._cyclicBufferSize;
-      this.NormalizeLinks(this._son, this._cyclicBufferSize * 2U, subValue);
-      this.NormalizeLinks(this._hash, this._hashSizeSum, subValue);
-      this.ReduceOffsets((int) subValue);
-    }
-
-    public void SetCutValue(uint cutValue) => this._cutValue = cutValue;
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/IInWindowStream.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/IInWindowStream.cs
deleted file mode 100644
index 8e72aba..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/IInWindowStream.cs
+++ /dev/null
@@ -1,20 +0,0 @@
-
-using System.IO;
-
-namespace SevenZip.Compression.LZ
-{
-  internal interface IInWindowStream
-  {
-    void SetStream(Stream inStream);
-
-    void Init();
-
-    void ReleaseStream();
-
-    byte GetIndexByte(int index);
-
-    uint GetMatchLen(int index, uint distance, uint limit);
-
-    uint GetNumAvailableBytes();
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/IMatchFinder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/IMatchFinder.cs
deleted file mode 100644
index 5c1c0dc..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/IMatchFinder.cs
+++ /dev/null
@@ -1,16 +0,0 @@
-
-namespace SevenZip.Compression.LZ
-{
-  internal interface IMatchFinder : IInWindowStream
-  {
-    void Create(
-      uint historySize,
-      uint keepAddBufferBefore,
-      uint matchMaxLen,
-      uint keepAddBufferAfter);
-
-    uint GetMatches(uint[] distances);
-
-    void Skip(uint num);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/InWindow.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/InWindow.cs
deleted file mode 100644
index fedf358..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/InWindow.cs
+++ /dev/null
@@ -1,127 +0,0 @@
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace SevenZip.Compression.LZ
-{
-  [ComVisible(true)]
-  public class InWindow
-  {
-    public byte[] _bufferBase;
-    private Stream _stream;
-    private uint _posLimit;
-    private bool _streamEndWasReached;
-    private uint _pointerToLastSafePosition;
-    public uint _bufferOffset;
-    public uint _blockSize;
-    public uint _pos;
-    private uint _keepSizeBefore;
-    private uint _keepSizeAfter;
-    public uint _streamPos;
-
-    public void MoveBlock()
-    {
-      uint num1 = this._bufferOffset + this._pos - this._keepSizeBefore;
-      if (num1 > 0U)
-        --num1;
-      uint num2 = this._bufferOffset + this._streamPos - num1;
-      for (uint index = 0; index < num2; ++index)
-        this._bufferBase[(IntPtr) index] = this._bufferBase[(IntPtr) (num1 + index)];
-      this._bufferOffset -= num1;
-    }
-
-    public virtual void ReadBlock()
-    {
-      if (this._streamEndWasReached)
-        return;
-      while (true)
-      {
-        do
-        {
-          int count = -(int) this._bufferOffset + (int) this._blockSize - (int) this._streamPos;
-          if (count == 0)
-            return;
-          int num = this._stream.Read(this._bufferBase, (int) this._bufferOffset + (int) this._streamPos, count);
-          if (num == 0)
-          {
-            this._posLimit = this._streamPos;
-            if (this._bufferOffset + this._posLimit > this._pointerToLastSafePosition)
-              this._posLimit = this._pointerToLastSafePosition - this._bufferOffset;
-            this._streamEndWasReached = true;
-            return;
-          }
-          this._streamPos += (uint) num;
-        }
-        while (this._streamPos < this._pos + this._keepSizeAfter);
-        this._posLimit = this._streamPos - this._keepSizeAfter;
-      }
-    }
-
-    private void Free() => this._bufferBase = (byte[]) null;
-
-    public void Create(uint keepSizeBefore, uint keepSizeAfter, uint keepSizeReserv)
-    {
-      this._keepSizeBefore = keepSizeBefore;
-      this._keepSizeAfter = keepSizeAfter;
-      uint num = keepSizeBefore + keepSizeAfter + keepSizeReserv;
-      if (this._bufferBase == null || (int) this._blockSize != (int) num)
-      {
-        this.Free();
-        this._blockSize = num;
-        this._bufferBase = new byte[(IntPtr) this._blockSize];
-      }
-      this._pointerToLastSafePosition = this._blockSize - keepSizeAfter;
-    }
-
-    public void SetStream(Stream stream) => this._stream = stream;
-
-    public void ReleaseStream() => this._stream = (Stream) null;
-
-    public void Init()
-    {
-      this._bufferOffset = 0U;
-      this._pos = 0U;
-      this._streamPos = 0U;
-      this._streamEndWasReached = false;
-      this.ReadBlock();
-    }
-
-    public void MovePos()
-    {
-      ++this._pos;
-      if (this._pos <= this._posLimit)
-        return;
-      if (this._bufferOffset + this._pos > this._pointerToLastSafePosition)
-        this.MoveBlock();
-      this.ReadBlock();
-    }
-
-    public byte GetIndexByte(int index)
-    {
-      return this._bufferBase[(long) (this._bufferOffset + this._pos) + (long) index];
-    }
-
-    public uint GetMatchLen(int index, uint distance, uint limit)
-    {
-      if (this._streamEndWasReached && (long) this._pos + (long) index + (long) limit > (long) this._streamPos)
-        limit = this._streamPos - (uint) ((ulong) this._pos + (ulong) index);
-      ++distance;
-      uint num = (uint) ((int) this._bufferOffset + (int) this._pos + index);
-      uint matchLen = 0;
-      while (matchLen < limit && (int) this._bufferBase[(IntPtr) (num + matchLen)] == (int) this._bufferBase[(IntPtr) (num + matchLen - distance)])
-        ++matchLen;
-      return matchLen;
-    }
-
-    public uint GetNumAvailableBytes() => this._streamPos - this._pos;
-
-    public void ReduceOffsets(int subValue)
-    {
-      this._bufferOffset += (uint) subValue;
-      this._posLimit -= (uint) subValue;
-      this._pos -= (uint) subValue;
-      this._streamPos -= (uint) subValue;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/OutWindow.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/OutWindow.cs
deleted file mode 100644
index 83d929e..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/LZ/OutWindow.cs
+++ /dev/null
@@ -1,86 +0,0 @@
-
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace SevenZip.Compression.LZ
-{
-  [ComVisible(true)]
-  public class OutWindow
-  {
-    private byte[] _buffer;
-    private uint _pos;
-    private uint _windowSize;
-    private uint _streamPos;
-    private Stream _stream;
-
-    public void Create(uint windowSize)
-    {
-      if ((int) this._windowSize != (int) windowSize)
-        this._buffer = new byte[(IntPtr) windowSize];
-      this._windowSize = windowSize;
-      this._pos = 0U;
-      this._streamPos = 0U;
-    }
-
-    public void Init(Stream stream, bool solid)
-    {
-      this.ReleaseStream();
-      this._stream = stream;
-      if (solid)
-        return;
-      this._streamPos = 0U;
-      this._pos = 0U;
-    }
-
-    public void Init(Stream stream) => this.Init(stream, false);
-
-    public void ReleaseStream()
-    {
-      this.Flush();
-      this._stream = (Stream) null;
-    }
-
-    public void Flush()
-    {
-      uint count = this._pos - this._streamPos;
-      if (count == 0U)
-        return;
-      this._stream.Write(this._buffer, (int) this._streamPos, (int) count);
-      if (this._pos >= this._windowSize)
-        this._pos = 0U;
-      this._streamPos = this._pos;
-    }
-
-    public void CopyBlock(uint distance, uint len)
-    {
-      uint num = (uint) ((int) this._pos - (int) distance - 1);
-      if (num >= this._windowSize)
-        num += this._windowSize;
-      for (; len > 0U; --len)
-      {
-        if (num >= this._windowSize)
-          num = 0U;
-        this._buffer[(IntPtr) this._pos++] = this._buffer[(IntPtr) num++];
-        if (this._pos >= this._windowSize)
-          this.Flush();
-      }
-    }
-
-    public void PutByte(byte b)
-    {
-      this._buffer[(IntPtr) this._pos++] = b;
-      if (this._pos < this._windowSize)
-        return;
-      this.Flush();
-    }
-
-    public byte GetByte(uint distance)
-    {
-      uint index = (uint) ((int) this._pos - (int) distance - 1);
-      if (index >= this._windowSize)
-        index += this._windowSize;
-      return this._buffer[(IntPtr) index];
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Base.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Base.cs
deleted file mode 100644
index 92f06aa..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Base.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-
-namespace SevenZip.Compression.LZMA
-{
-  internal abstract class Base
-  {
-    public const uint kNumRepDistances = 4;
-    public const uint kNumStates = 12;
-    public const int kNumPosSlotBits = 6;
-    public const int kDicLogSizeMin = 0;
-    public const int kNumLenToPosStatesBits = 2;
-    public const uint kNumLenToPosStates = 4;
-    public const uint kMatchMinLen = 2;
-    public const int kNumAlignBits = 4;
-    public const uint kAlignTableSize = 16;
-    public const uint kAlignMask = 15;
-    public const uint kStartPosModelIndex = 4;
-    public const uint kEndPosModelIndex = 14;
-    public const uint kNumPosModels = 10;
-    public const uint kNumFullDistances = 128;
-    public const uint kNumLitPosStatesBitsEncodingMax = 4;
-    public const uint kNumLitContextBitsMax = 8;
-    public const int kNumPosStatesBitsMax = 4;
-    public const uint kNumPosStatesMax = 16;
-    public const int kNumPosStatesBitsEncodingMax = 4;
-    public const uint kNumPosStatesEncodingMax = 16;
-    public const int kNumLowLenBits = 3;
-    public const int kNumMidLenBits = 3;
-    public const int kNumHighLenBits = 8;
-    public const uint kNumLowLenSymbols = 8;
-    public const uint kNumMidLenSymbols = 8;
-    public const uint kNumLenSymbols = 272;
-    public const uint kMatchMaxLen = 273;
-
-    public static uint GetLenToPosState(uint len)
-    {
-      len -= 2U;
-      return len < 4U ? len : 3U;
-    }
-
-    public struct State
-    {
-      public uint Index;
-
-      public void Init() => this.Index = 0U;
-
-      public void UpdateChar()
-      {
-        if (this.Index < 4U)
-          this.Index = 0U;
-        else if (this.Index < 10U)
-          this.Index -= 3U;
-        else
-          this.Index -= 6U;
-      }
-
-      public void UpdateMatch() => this.Index = this.Index < 7U ? 7U : 10U;
-
-      public void UpdateRep() => this.Index = this.Index < 7U ? 8U : 11U;
-
-      public void UpdateShortRep() => this.Index = this.Index < 7U ? 9U : 11U;
-
-      public bool IsCharState() => this.Index < 7U;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Decoder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Decoder.cs
deleted file mode 100644
index 203f4bf..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Decoder.cs
+++ /dev/null
@@ -1,349 +0,0 @@
-
-using SevenZip.Compression.LZ;
-using SevenZip.Compression.RangeCoder;
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace SevenZip.Compression.LZMA
-{
-  [ComVisible(true)]
-  public class Decoder : ICoder, ISetDecoderProperties
-  {
-    private OutWindow m_OutWindow = new OutWindow();
-    private SevenZip.Compression.RangeCoder.Decoder m_RangeDecoder = new SevenZip.Compression.RangeCoder.Decoder();
-    private BitDecoder[] m_IsMatchDecoders = new BitDecoder[new IntPtr(192)];
-    private BitDecoder[] m_IsRepDecoders = new BitDecoder[new IntPtr(12)];
-    private BitDecoder[] m_IsRepG0Decoders = new BitDecoder[new IntPtr(12)];
-    private BitDecoder[] m_IsRepG1Decoders = new BitDecoder[new IntPtr(12)];
-    private BitDecoder[] m_IsRepG2Decoders = new BitDecoder[new IntPtr(12)];
-    private BitDecoder[] m_IsRep0LongDecoders = new BitDecoder[new IntPtr(192)];
-    private BitTreeDecoder[] m_PosSlotDecoder = new BitTreeDecoder[new IntPtr(4)];
-    private BitDecoder[] m_PosDecoders = new BitDecoder[new IntPtr(114)];
-    private BitTreeDecoder m_PosAlignDecoder = new BitTreeDecoder(4);
-    private Decoder.LenDecoder m_LenDecoder = new Decoder.LenDecoder();
-    private Decoder.LenDecoder m_RepLenDecoder = new Decoder.LenDecoder();
-    private Decoder.LiteralDecoder m_LiteralDecoder = new Decoder.LiteralDecoder();
-    private uint m_DictionarySize;
-    private uint m_DictionarySizeCheck;
-    private uint m_PosStateMask;
-
-    public Decoder()
-    {
-      this.m_DictionarySize = uint.MaxValue;
-      for (int index = 0; index < 4; ++index)
-        this.m_PosSlotDecoder[index] = new BitTreeDecoder(6);
-    }
-
-    private void SetDictionarySize(uint dictionarySize)
-    {
-      if ((int) this.m_DictionarySize == (int) dictionarySize)
-        return;
-      this.m_DictionarySize = dictionarySize;
-      this.m_DictionarySizeCheck = Math.Max(this.m_DictionarySize, 1U);
-      this.m_OutWindow.Create(Math.Max(this.m_DictionarySizeCheck, 4096U));
-    }
-
-    private void SetLiteralProperties(int lp, int lc)
-    {
-      if (lp > 8)
-        throw new InvalidParamException();
-      if (lc > 8)
-        throw new InvalidParamException();
-      this.m_LiteralDecoder.Create(lp, lc);
-    }
-
-    private void SetPosBitsProperties(int pb)
-    {
-      if (pb > 4)
-        throw new InvalidParamException();
-      uint numPosStates = (uint) (1 << pb);
-      this.m_LenDecoder.Create(numPosStates);
-      this.m_RepLenDecoder.Create(numPosStates);
-      this.m_PosStateMask = numPosStates - 1U;
-    }
-
-    private void Init(Stream inStream, Stream outStream)
-    {
-      this.m_RangeDecoder.Init(inStream);
-      this.m_OutWindow.Init(outStream);
-      for (uint index1 = 0; index1 < 12U; ++index1)
-      {
-        for (uint index2 = 0; index2 <= this.m_PosStateMask; ++index2)
-        {
-          uint index3 = (index1 << 4) + index2;
-          this.m_IsMatchDecoders[(IntPtr) index3].Init();
-          this.m_IsRep0LongDecoders[(IntPtr) index3].Init();
-        }
-        this.m_IsRepDecoders[(IntPtr) index1].Init();
-        this.m_IsRepG0Decoders[(IntPtr) index1].Init();
-        this.m_IsRepG1Decoders[(IntPtr) index1].Init();
-        this.m_IsRepG2Decoders[(IntPtr) index1].Init();
-      }
-      this.m_LiteralDecoder.Init();
-      for (uint index = 0; index < 4U; ++index)
-        this.m_PosSlotDecoder[(IntPtr) index].Init();
-      for (uint index = 0; index < 114U; ++index)
-        this.m_PosDecoders[(IntPtr) index].Init();
-      this.m_LenDecoder.Init();
-      this.m_RepLenDecoder.Init();
-      this.m_PosAlignDecoder.Init();
-    }
-
-    public void Code(
-      Stream inStream,
-      Stream outStream,
-      long inSize,
-      long outSize,
-      ICodeProgress progress)
-    {
-      this.Init(inStream, outStream);
-      Base.State state = new Base.State();
-      state.Init();
-      uint distance = 0;
-      uint num1 = 0;
-      uint num2 = 0;
-      uint num3 = 0;
-      ulong pos = 0;
-      ulong num4 = (ulong) outSize;
-      if (pos < num4)
-      {
-        if (this.m_IsMatchDecoders[(IntPtr) (state.Index << 4)].Decode(this.m_RangeDecoder) != 0U)
-          throw new DataErrorException();
-        state.UpdateChar();
-        this.m_OutWindow.PutByte(this.m_LiteralDecoder.DecodeNormal(this.m_RangeDecoder, 0U, (byte) 0));
-        ++pos;
-      }
-      while (pos < num4)
-      {
-        uint posState = (uint) pos & this.m_PosStateMask;
-        if (this.m_IsMatchDecoders[(IntPtr) ((state.Index << 4) + posState)].Decode(this.m_RangeDecoder) == 0U)
-        {
-          byte prevByte = this.m_OutWindow.GetByte(0U);
-          this.m_OutWindow.PutByte(state.IsCharState() ? this.m_LiteralDecoder.DecodeNormal(this.m_RangeDecoder, (uint) pos, prevByte) : this.m_LiteralDecoder.DecodeWithMatchByte(this.m_RangeDecoder, (uint) pos, prevByte, this.m_OutWindow.GetByte(distance)));
-          state.UpdateChar();
-          ++pos;
-        }
-        else
-        {
-          uint len;
-          if (this.m_IsRepDecoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 1U)
-          {
-            if (this.m_IsRepG0Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
-            {
-              if (this.m_IsRep0LongDecoders[(IntPtr) ((state.Index << 4) + posState)].Decode(this.m_RangeDecoder) == 0U)
-              {
-                state.UpdateShortRep();
-                this.m_OutWindow.PutByte(this.m_OutWindow.GetByte(distance));
-                ++pos;
-                continue;
-              }
-            }
-            else
-            {
-              uint num5;
-              if (this.m_IsRepG1Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
-              {
-                num5 = num1;
-              }
-              else
-              {
-                if (this.m_IsRepG2Decoders[(IntPtr) state.Index].Decode(this.m_RangeDecoder) == 0U)
-                {
-                  num5 = num2;
-                }
-                else
-                {
-                  num5 = num3;
-                  num3 = num2;
-                }
-                num2 = num1;
-              }
-              num1 = distance;
-              distance = num5;
-            }
-            len = this.m_RepLenDecoder.Decode(this.m_RangeDecoder, posState) + 2U;
-            state.UpdateRep();
-          }
-          else
-          {
-            num3 = num2;
-            num2 = num1;
-            num1 = distance;
-            len = 2U + this.m_LenDecoder.Decode(this.m_RangeDecoder, posState);
-            state.UpdateMatch();
-            uint num6 = this.m_PosSlotDecoder[(IntPtr) Base.GetLenToPosState(len)].Decode(this.m_RangeDecoder);
-            if (num6 >= 4U)
-            {
-              int NumBitLevels = (int) (num6 >> 1) - 1;
-              uint num7 = (uint) ((2 | (int) num6 & 1) << NumBitLevels);
-              distance = num6 >= 14U ? num7 + (this.m_RangeDecoder.DecodeDirectBits(NumBitLevels - 4) << 4) + this.m_PosAlignDecoder.ReverseDecode(this.m_RangeDecoder) : num7 + BitTreeDecoder.ReverseDecode(this.m_PosDecoders, (uint) ((int) num7 - (int) num6 - 1), this.m_RangeDecoder, NumBitLevels);
-            }
-            else
-              distance = num6;
-          }
-          if ((ulong) distance >= pos || distance >= this.m_DictionarySizeCheck)
-          {
-            if (distance != uint.MaxValue)
-              throw new DataErrorException();
-            break;
-          }
-          this.m_OutWindow.CopyBlock(distance, len);
-          pos += (ulong) len;
-        }
-      }
-      this.m_OutWindow.Flush();
-      this.m_OutWindow.ReleaseStream();
-      this.m_RangeDecoder.ReleaseStream();
-    }
-
-    public void SetDecoderProperties(byte[] properties)
-    {
-      if (properties.Length < 5)
-        throw new InvalidParamException();
-      int lc = (int) properties[0] % 9;
-      int num = (int) properties[0] / 9;
-      int lp = num % 5;
-      int pb = num / 5;
-      if (pb > 4)
-        throw new InvalidParamException();
-      uint dictionarySize = 0;
-      for (int index = 0; index < 4; ++index)
-        dictionarySize += (uint) properties[1 + index] << index * 8;
-      this.SetDictionarySize(dictionarySize);
-      this.SetLiteralProperties(lp, lc);
-      this.SetPosBitsProperties(pb);
-    }
-
-    private class LenDecoder
-    {
-      private BitDecoder m_Choice = new BitDecoder();
-      private BitDecoder m_Choice2 = new BitDecoder();
-      private BitTreeDecoder[] m_LowCoder = new BitTreeDecoder[new IntPtr(16)];
-      private BitTreeDecoder[] m_MidCoder = new BitTreeDecoder[new IntPtr(16)];
-      private BitTreeDecoder m_HighCoder = new BitTreeDecoder(8);
-      private uint m_NumPosStates;
-
-      public void Create(uint numPosStates)
-      {
-        for (uint numPosStates1 = this.m_NumPosStates; numPosStates1 < numPosStates; ++numPosStates1)
-        {
-          this.m_LowCoder[(IntPtr) numPosStates1] = new BitTreeDecoder(3);
-          this.m_MidCoder[(IntPtr) numPosStates1] = new BitTreeDecoder(3);
-        }
-        this.m_NumPosStates = numPosStates;
-      }
-
-      public void Init()
-      {
-        this.m_Choice.Init();
-        for (uint index = 0; index < this.m_NumPosStates; ++index)
-        {
-          this.m_LowCoder[(IntPtr) index].Init();
-          this.m_MidCoder[(IntPtr) index].Init();
-        }
-        this.m_Choice2.Init();
-        this.m_HighCoder.Init();
-      }
-
-      public uint Decode(SevenZip.Compression.RangeCoder.Decoder rangeDecoder, uint posState)
-      {
-        if (this.m_Choice.Decode(rangeDecoder) == 0U)
-          return this.m_LowCoder[(IntPtr) posState].Decode(rangeDecoder);
-        uint num = 8;
-        return this.m_Choice2.Decode(rangeDecoder) != 0U ? num + 8U + this.m_HighCoder.Decode(rangeDecoder) : num + this.m_MidCoder[(IntPtr) posState].Decode(rangeDecoder);
-      }
-    }
-
-    private class LiteralDecoder
-    {
-      private Decoder.LiteralDecoder.Decoder2[] m_Coders;
-      private int m_NumPrevBits;
-      private int m_NumPosBits;
-      private uint m_PosMask;
-
-      public void Create(int numPosBits, int numPrevBits)
-      {
-        if (this.m_Coders != null && this.m_NumPrevBits == numPrevBits && this.m_NumPosBits == numPosBits)
-          return;
-        this.m_NumPosBits = numPosBits;
-        this.m_PosMask = (uint) ((1 << numPosBits) - 1);
-        this.m_NumPrevBits = numPrevBits;
-        uint length = (uint) (1 << this.m_NumPrevBits + this.m_NumPosBits);
-        this.m_Coders = new Decoder.LiteralDecoder.Decoder2[(IntPtr) length];
-        for (uint index = 0; index < length; ++index)
-          this.m_Coders[(IntPtr) index].Create();
-      }
-
-      public void Init()
-      {
-        uint num = (uint) (1 << this.m_NumPrevBits + this.m_NumPosBits);
-        for (uint index = 0; index < num; ++index)
-          this.m_Coders[(IntPtr) index].Init();
-      }
-
-      private uint GetState(uint pos, byte prevByte)
-      {
-        return (uint) ((((int) pos & (int) this.m_PosMask) << this.m_NumPrevBits) + ((int) prevByte >> 8 - this.m_NumPrevBits));
-      }
-
-      public byte DecodeNormal(SevenZip.Compression.RangeCoder.Decoder rangeDecoder, uint pos, byte prevByte)
-      {
-        return this.m_Coders[(IntPtr) this.GetState(pos, prevByte)].DecodeNormal(rangeDecoder);
-      }
-
-      public byte DecodeWithMatchByte(
-        SevenZip.Compression.RangeCoder.Decoder rangeDecoder,
-        uint pos,
-        byte prevByte,
-        byte matchByte)
-      {
-        return this.m_Coders[(IntPtr) this.GetState(pos, prevByte)].DecodeWithMatchByte(rangeDecoder, matchByte);
-      }
-
-      private struct Decoder2
-      {
-        private BitDecoder[] m_Decoders;
-
-        public void Create() => this.m_Decoders = new BitDecoder[768];
-
-        public void Init()
-        {
-          for (int index = 0; index < 768; ++index)
-            this.m_Decoders[index].Init();
-        }
-
-        public byte DecodeNormal(SevenZip.Compression.RangeCoder.Decoder rangeDecoder)
-        {
-          uint index = 1;
-          do
-          {
-            index = index << 1 | this.m_Decoders[(IntPtr) index].Decode(rangeDecoder);
-          }
-          while (index < 256U);
-          return (byte) index;
-        }
-
-        public byte DecodeWithMatchByte(SevenZip.Compression.RangeCoder.Decoder rangeDecoder, byte matchByte)
-        {
-          uint index = 1;
-          do
-          {
-            uint num1 = (uint) ((int) matchByte >> 7 & 1);
-            matchByte <<= 1;
-            uint num2 = this.m_Decoders[(IntPtr) ((uint) (1 + (int) num1 << 8) + index)].Decode(rangeDecoder);
-            index = index << 1 | num2;
-            if ((int) num1 != (int) num2)
-            {
-              while (index < 256U)
-                index = index << 1 | this.m_Decoders[(IntPtr) index].Decode(rangeDecoder);
-              break;
-            }
-          }
-          while (index < 256U);
-          return (byte) index;
-        }
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Encoder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Encoder.cs
deleted file mode 100644
index d2f4c20..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/LZMA/Encoder.cs
+++ /dev/null
@@ -1,1336 +0,0 @@
-
-using SevenZip.Compression.LZ;
-using SevenZip.Compression.RangeCoder;
-using System;
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace SevenZip.Compression.LZMA
-{
-  [ComVisible(true)]
-  public class Encoder : ICoder, ISetCoderProperties, IWriteCoderProperties
-  {
-    private const uint kIfinityPrice = 268435455;
-    private const int kDefaultDictionaryLogSize = 22;
-    private const uint kNumFastBytesDefault = 32;
-    private const uint kNumLenSpecSymbols = 16;
-    private const uint kNumOpts = 4096;
-    private const int kPropSize = 5;
-    private static byte[] g_FastPos = new byte[2048];
-    private Base.State _state = new Base.State();
-    private byte _previousByte;
-    private uint[] _repDistances = new uint[new IntPtr(4)];
-    private Encoder.Optimal[] _optimum = new Encoder.Optimal[new IntPtr(4096)];
-    private IMatchFinder _matchFinder;
-    private SevenZip.Compression.RangeCoder.Encoder _rangeEncoder = new SevenZip.Compression.RangeCoder.Encoder();
-    private BitEncoder[] _isMatch = new BitEncoder[new IntPtr(192)];
-    private BitEncoder[] _isRep = new BitEncoder[new IntPtr(12)];
-    private BitEncoder[] _isRepG0 = new BitEncoder[new IntPtr(12)];
-    private BitEncoder[] _isRepG1 = new BitEncoder[new IntPtr(12)];
-    private BitEncoder[] _isRepG2 = new BitEncoder[new IntPtr(12)];
-    private BitEncoder[] _isRep0Long = new BitEncoder[new IntPtr(192)];
-    private BitTreeEncoder[] _posSlotEncoder = new BitTreeEncoder[new IntPtr(4)];
-    private BitEncoder[] _posEncoders = new BitEncoder[new IntPtr(114)];
-    private BitTreeEncoder _posAlignEncoder = new BitTreeEncoder(4);
-    private Encoder.LenPriceTableEncoder _lenEncoder = new Encoder.LenPriceTableEncoder();
-    private Encoder.LenPriceTableEncoder _repMatchLenEncoder = new Encoder.LenPriceTableEncoder();
-    private Encoder.LiteralEncoder _literalEncoder = new Encoder.LiteralEncoder();
-    private uint[] _matchDistances = new uint[new IntPtr(548)];
-    private uint _numFastBytes = 32;
-    private uint _longestMatchLength;
-    private uint _numDistancePairs;
-    private uint _additionalOffset;
-    private uint _optimumEndIndex;
-    private uint _optimumCurrentIndex;
-    private bool _longestMatchWasFound;
-    private uint[] _posSlotPrices = new uint[256];
-    private uint[] _distancesPrices = new uint[new IntPtr(512)];
-    private uint[] _alignPrices = new uint[new IntPtr(16)];
-    private uint _alignPriceCount;
-    private uint _distTableSize = 44;
-    private int _posStateBits = 2;
-    private uint _posStateMask = 3;
-    private int _numLiteralPosStateBits;
-    private int _numLiteralContextBits = 3;
-    private uint _dictionarySize = 4194304;
-    private uint _dictionarySizePrev = uint.MaxValue;
-    private uint _numFastBytesPrev = uint.MaxValue;
-    private long nowPos64;
-    private bool _finished;
-    private Stream _inStream;
-    private Encoder.EMatchFinderType _matchFinderType = Encoder.EMatchFinderType.BT4;
-    private bool _writeEndMark;
-    private bool _needReleaseMFStream;
-    private uint[] reps = new uint[new IntPtr(4)];
-    private uint[] repLens = new uint[new IntPtr(4)];
-    private byte[] properties = new byte[5];
-    private uint[] tempPrices = new uint[new IntPtr(128)];
-    private uint _matchPriceCount;
-    private static string[] kMatchFinderIDs = new string[2]
-    {
-      "BT2",
-      "BT4"
-    };
-
-    static Encoder()
-    {
-      int index1 = 2;
-      Encoder.g_FastPos[0] = (byte) 0;
-      Encoder.g_FastPos[1] = (byte) 1;
-      for (byte index2 = 2; index2 < (byte) 22; ++index2)
-      {
-        uint num1 = (uint) (1 << ((int) index2 >> 1) - 1);
-        uint num2 = 0;
-        while (num2 < num1)
-        {
-          Encoder.g_FastPos[index1] = index2;
-          ++num2;
-          ++index1;
-        }
-      }
-    }
-
-    private static uint GetPosSlot(uint pos)
-    {
-      if (pos < 2048U)
-        return (uint) Encoder.g_FastPos[(IntPtr) pos];
-      return pos < 2097152U ? (uint) Encoder.g_FastPos[(IntPtr) (pos >> 10)] + 20U : (uint) Encoder.g_FastPos[(IntPtr) (pos >> 20)] + 40U;
-    }
-
-    private static uint GetPosSlot2(uint pos)
-    {
-      if (pos < 131072U)
-        return (uint) Encoder.g_FastPos[(IntPtr) (pos >> 6)] + 12U;
-      return pos < 134217728U ? (uint) Encoder.g_FastPos[(IntPtr) (pos >> 16)] + 32U : (uint) Encoder.g_FastPos[(IntPtr) (pos >> 26)] + 52U;
-    }
-
-    private void BaseInit()
-    {
-      this._state.Init();
-      this._previousByte = (byte) 0;
-      for (uint index = 0; index < 4U; ++index)
-        this._repDistances[(IntPtr) index] = 0U;
-    }
-
-    private void Create()
-    {
-      if (this._matchFinder == null)
-      {
-        BinTree binTree = new BinTree();
-        int numHashBytes = 4;
-        if (this._matchFinderType == Encoder.EMatchFinderType.BT2)
-          numHashBytes = 2;
-        binTree.SetType(numHashBytes);
-        this._matchFinder = (IMatchFinder) binTree;
-      }
-      this._literalEncoder.Create(this._numLiteralPosStateBits, this._numLiteralContextBits);
-      if ((int) this._dictionarySize == (int) this._dictionarySizePrev && (int) this._numFastBytesPrev == (int) this._numFastBytes)
-        return;
-      this._matchFinder.Create(this._dictionarySize, 4096U, this._numFastBytes, 274U);
-      this._dictionarySizePrev = this._dictionarySize;
-      this._numFastBytesPrev = this._numFastBytes;
-    }
-
-    public Encoder()
-    {
-      for (int index = 0; index < 4096; ++index)
-        this._optimum[index] = new Encoder.Optimal();
-      for (int index = 0; index < 4; ++index)
-        this._posSlotEncoder[index] = new BitTreeEncoder(6);
-    }
-
-    private void SetWriteEndMarkerMode(bool writeEndMarker) => this._writeEndMark = writeEndMarker;
-
-    private void Init()
-    {
-      this.BaseInit();
-      this._rangeEncoder.Init();
-      for (uint index1 = 0; index1 < 12U; ++index1)
-      {
-        for (uint index2 = 0; index2 <= this._posStateMask; ++index2)
-        {
-          uint index3 = (index1 << 4) + index2;
-          this._isMatch[(IntPtr) index3].Init();
-          this._isRep0Long[(IntPtr) index3].Init();
-        }
-        this._isRep[(IntPtr) index1].Init();
-        this._isRepG0[(IntPtr) index1].Init();
-        this._isRepG1[(IntPtr) index1].Init();
-        this._isRepG2[(IntPtr) index1].Init();
-      }
-      this._literalEncoder.Init();
-      for (uint index = 0; index < 4U; ++index)
-        this._posSlotEncoder[(IntPtr) index].Init();
-      for (uint index = 0; index < 114U; ++index)
-        this._posEncoders[(IntPtr) index].Init();
-      this._lenEncoder.Init((uint) (1 << this._posStateBits));
-      this._repMatchLenEncoder.Init((uint) (1 << this._posStateBits));
-      this._posAlignEncoder.Init();
-      this._longestMatchWasFound = false;
-      this._optimumEndIndex = 0U;
-      this._optimumCurrentIndex = 0U;
-      this._additionalOffset = 0U;
-    }
-
-    private void ReadMatchDistances(out uint lenRes, out uint numDistancePairs)
-    {
-      lenRes = 0U;
-      numDistancePairs = this._matchFinder.GetMatches(this._matchDistances);
-      if (numDistancePairs > 0U)
-      {
-        lenRes = this._matchDistances[(IntPtr) (numDistancePairs - 2U)];
-        if ((int) lenRes == (int) this._numFastBytes)
-          lenRes += this._matchFinder.GetMatchLen((int) lenRes - 1, this._matchDistances[(IntPtr) (numDistancePairs - 1U)], 273U - lenRes);
-      }
-      ++this._additionalOffset;
-    }
-
-    private void MovePos(uint num)
-    {
-      if (num <= 0U)
-        return;
-      this._matchFinder.Skip(num);
-      this._additionalOffset += num;
-    }
-
-    private uint GetRepLen1Price(Base.State state, uint posState)
-    {
-      return this._isRepG0[(IntPtr) state.Index].GetPrice0() + this._isRep0Long[(IntPtr) ((state.Index << 4) + posState)].GetPrice0();
-    }
-
-    private uint GetPureRepPrice(uint repIndex, Base.State state, uint posState)
-    {
-      uint pureRepPrice;
-      if (repIndex == 0U)
-      {
-        pureRepPrice = this._isRepG0[(IntPtr) state.Index].GetPrice0() + this._isRep0Long[(IntPtr) ((state.Index << 4) + posState)].GetPrice1();
-      }
-      else
-      {
-        uint price1 = this._isRepG0[(IntPtr) state.Index].GetPrice1();
-        pureRepPrice = repIndex != 1U ? price1 + this._isRepG1[(IntPtr) state.Index].GetPrice1() + this._isRepG2[(IntPtr) state.Index].GetPrice(repIndex - 2U) : price1 + this._isRepG1[(IntPtr) state.Index].GetPrice0();
-      }
-      return pureRepPrice;
-    }
-
-    private uint GetRepPrice(uint repIndex, uint len, Base.State state, uint posState)
-    {
-      return this._repMatchLenEncoder.GetPrice(len - 2U, posState) + this.GetPureRepPrice(repIndex, state, posState);
-    }
-
-    private uint GetPosLenPrice(uint pos, uint len, uint posState)
-    {
-      uint lenToPosState = Base.GetLenToPosState(len);
-      return (pos >= 128U ? this._posSlotPrices[(IntPtr) ((lenToPosState << 6) + Encoder.GetPosSlot2(pos))] + this._alignPrices[(IntPtr) (pos & 15U)] : this._distancesPrices[(IntPtr) (lenToPosState * 128U + pos)]) + this._lenEncoder.GetPrice(len - 2U, posState);
-    }
-
-    private uint Backward(out uint backRes, uint cur)
-    {
-      this._optimumEndIndex = cur;
-      uint posPrev = this._optimum[(IntPtr) cur].PosPrev;
-      uint backPrev = this._optimum[(IntPtr) cur].BackPrev;
-      do
-      {
-        if (this._optimum[(IntPtr) cur].Prev1IsChar)
-        {
-          this._optimum[(IntPtr) posPrev].MakeAsChar();
-          this._optimum[(IntPtr) posPrev].PosPrev = posPrev - 1U;
-          if (this._optimum[(IntPtr) cur].Prev2)
-          {
-            this._optimum[(IntPtr) (posPrev - 1U)].Prev1IsChar = false;
-            this._optimum[(IntPtr) (posPrev - 1U)].PosPrev = this._optimum[(IntPtr) cur].PosPrev2;
-            this._optimum[(IntPtr) (posPrev - 1U)].BackPrev = this._optimum[(IntPtr) cur].BackPrev2;
-          }
-        }
-        uint index = posPrev;
-        uint num = backPrev;
-        backPrev = this._optimum[(IntPtr) index].BackPrev;
-        posPrev = this._optimum[(IntPtr) index].PosPrev;
-        this._optimum[(IntPtr) index].BackPrev = num;
-        this._optimum[(IntPtr) index].PosPrev = cur;
-        cur = index;
-      }
-      while (cur > 0U);
-      backRes = this._optimum[0].BackPrev;
-      this._optimumCurrentIndex = this._optimum[0].PosPrev;
-      return this._optimumCurrentIndex;
-    }
-
-    private uint GetOptimum(uint position, out uint backRes)
-    {
-      if ((int) this._optimumEndIndex != (int) this._optimumCurrentIndex)
-      {
-        uint optimum = this._optimum[(IntPtr) this._optimumCurrentIndex].PosPrev - this._optimumCurrentIndex;
-        backRes = this._optimum[(IntPtr) this._optimumCurrentIndex].BackPrev;
-        this._optimumCurrentIndex = this._optimum[(IntPtr) this._optimumCurrentIndex].PosPrev;
-        return optimum;
-      }
-      this._optimumCurrentIndex = this._optimumEndIndex = 0U;
-      uint lenRes1;
-      uint numDistancePairs;
-      if (!this._longestMatchWasFound)
-      {
-        this.ReadMatchDistances(out lenRes1, out numDistancePairs);
-      }
-      else
-      {
-        lenRes1 = this._longestMatchLength;
-        numDistancePairs = this._numDistancePairs;
-        this._longestMatchWasFound = false;
-      }
-      uint num1 = this._matchFinder.GetNumAvailableBytes() + 1U;
-      if (num1 < 2U)
-      {
-        backRes = uint.MaxValue;
-        return 1;
-      }
-      if (num1 > 273U)
-        ;
-      uint index1 = 0;
-      for (uint index2 = 0; index2 < 4U; ++index2)
-      {
-        this.reps[(IntPtr) index2] = this._repDistances[(IntPtr) index2];
-        this.repLens[(IntPtr) index2] = this._matchFinder.GetMatchLen(-1, this.reps[(IntPtr) index2], 273U);
-        if (this.repLens[(IntPtr) index2] > this.repLens[(IntPtr) index1])
-          index1 = index2;
-      }
-      if (this.repLens[(IntPtr) index1] >= this._numFastBytes)
-      {
-        backRes = index1;
-        uint repLen = this.repLens[(IntPtr) index1];
-        this.MovePos(repLen - 1U);
-        return repLen;
-      }
-      if (lenRes1 >= this._numFastBytes)
-      {
-        backRes = this._matchDistances[(IntPtr) (numDistancePairs - 1U)] + 4U;
-        this.MovePos(lenRes1 - 1U);
-        return lenRes1;
-      }
-      byte indexByte1 = this._matchFinder.GetIndexByte(-1);
-      byte indexByte2 = this._matchFinder.GetIndexByte(-(int) this._repDistances[0] - 1 - 1);
-      if (lenRes1 < 2U && (int) indexByte1 != (int) indexByte2 && this.repLens[(IntPtr) index1] < 2U)
-      {
-        backRes = uint.MaxValue;
-        return 1;
-      }
-      this._optimum[0].State = this._state;
-      uint posState1 = position & this._posStateMask;
-      Encoder.Optimal optimal1 = this._optimum[1];
-      int price0 = (int) this._isMatch[(IntPtr) ((this._state.Index << 4) + posState1)].GetPrice0();
-      Encoder.LiteralEncoder.Encoder2 subCoder = this._literalEncoder.GetSubCoder(position, this._previousByte);
-      int price1 = (int) subCoder.GetPrice(!this._state.IsCharState(), indexByte2, indexByte1);
-      int num2 = price0 + price1;
-      optimal1.Price = (uint) num2;
-      this._optimum[1].MakeAsChar();
-      uint price1_1 = this._isMatch[(IntPtr) ((this._state.Index << 4) + posState1)].GetPrice1();
-      uint num3 = price1_1 + this._isRep[(IntPtr) this._state.Index].GetPrice1();
-      if ((int) indexByte2 == (int) indexByte1)
-      {
-        uint num4 = num3 + this.GetRepLen1Price(this._state, posState1);
-        if (num4 < this._optimum[1].Price)
-        {
-          this._optimum[1].Price = num4;
-          this._optimum[1].MakeAsShortRep();
-        }
-      }
-      uint num5 = lenRes1 >= this.repLens[(IntPtr) index1] ? lenRes1 : this.repLens[(IntPtr) index1];
-      if (num5 < 2U)
-      {
-        backRes = this._optimum[1].BackPrev;
-        return 1;
-      }
-      this._optimum[1].PosPrev = 0U;
-      this._optimum[0].Backs0 = this.reps[0];
-      this._optimum[0].Backs1 = this.reps[1];
-      this._optimum[0].Backs2 = this.reps[2];
-      this._optimum[0].Backs3 = this.reps[3];
-      uint num6 = num5;
-      do
-      {
-        this._optimum[(IntPtr) num6--].Price = 268435455U;
-      }
-      while (num6 >= 2U);
-      for (uint repIndex = 0; repIndex < 4U; ++repIndex)
-      {
-        uint repLen = this.repLens[(IntPtr) repIndex];
-        if (repLen >= 2U)
-        {
-          uint num7 = num3 + this.GetPureRepPrice(repIndex, this._state, posState1);
-          do
-          {
-            uint num8 = num7 + this._repMatchLenEncoder.GetPrice(repLen - 2U, posState1);
-            Encoder.Optimal optimal2 = this._optimum[(IntPtr) repLen];
-            if (num8 < optimal2.Price)
-            {
-              optimal2.Price = num8;
-              optimal2.PosPrev = 0U;
-              optimal2.BackPrev = repIndex;
-              optimal2.Prev1IsChar = false;
-            }
-          }
-          while (--repLen >= 2U);
-        }
-      }
-      uint num9 = price1_1 + this._isRep[(IntPtr) this._state.Index].GetPrice0();
-      uint len = this.repLens[0] >= 2U ? this.repLens[0] + 1U : 2U;
-      if (len <= lenRes1)
-      {
-        uint index3 = 0;
-        while (len > this._matchDistances[(IntPtr) index3])
-          index3 += 2U;
-        while (true)
-        {
-          uint matchDistance = this._matchDistances[(IntPtr) (index3 + 1U)];
-          uint num10 = num9 + this.GetPosLenPrice(matchDistance, len, posState1);
-          Encoder.Optimal optimal3 = this._optimum[(IntPtr) len];
-          if (num10 < optimal3.Price)
-          {
-            optimal3.Price = num10;
-            optimal3.PosPrev = 0U;
-            optimal3.BackPrev = matchDistance + 4U;
-            optimal3.Prev1IsChar = false;
-          }
-          if ((int) len == (int) this._matchDistances[(IntPtr) index3])
-          {
-            index3 += 2U;
-            if ((int) index3 == (int) numDistancePairs)
-              break;
-          }
-          ++len;
-        }
-      }
-      uint cur = 0;
-label_45:
-      uint lenRes2;
-      Base.State state1;
-      uint posState2;
-      uint num11;
-      uint num12;
-      uint num13;
-      do
-      {
-        byte indexByte3;
-        byte indexByte4;
-        uint num14;
-        bool flag;
-        uint num15;
-        uint limit1;
-        do
-        {
-          ++cur;
-          if ((int) cur == (int) num5)
-            return this.Backward(out backRes, cur);
-          this.ReadMatchDistances(out lenRes2, out numDistancePairs);
-          if (lenRes2 >= this._numFastBytes)
-          {
-            this._numDistancePairs = numDistancePairs;
-            this._longestMatchLength = lenRes2;
-            this._longestMatchWasFound = true;
-            return this.Backward(out backRes, cur);
-          }
-          ++position;
-          uint index4 = this._optimum[(IntPtr) cur].PosPrev;
-          if (this._optimum[(IntPtr) cur].Prev1IsChar)
-          {
-            --index4;
-            if (this._optimum[(IntPtr) cur].Prev2)
-            {
-              state1 = this._optimum[(IntPtr) this._optimum[(IntPtr) cur].PosPrev2].State;
-              if (this._optimum[(IntPtr) cur].BackPrev2 < 4U)
-                state1.UpdateRep();
-              else
-                state1.UpdateMatch();
-            }
-            else
-              state1 = this._optimum[(IntPtr) index4].State;
-            state1.UpdateChar();
-          }
-          else
-            state1 = this._optimum[(IntPtr) index4].State;
-          if ((int) index4 == (int) cur - 1)
-          {
-            if (this._optimum[(IntPtr) cur].IsShortRep())
-              state1.UpdateShortRep();
-            else
-              state1.UpdateChar();
-          }
-          else
-          {
-            uint num16;
-            if (this._optimum[(IntPtr) cur].Prev1IsChar && this._optimum[(IntPtr) cur].Prev2)
-            {
-              index4 = this._optimum[(IntPtr) cur].PosPrev2;
-              num16 = this._optimum[(IntPtr) cur].BackPrev2;
-              state1.UpdateRep();
-            }
-            else
-            {
-              num16 = this._optimum[(IntPtr) cur].BackPrev;
-              if (num16 < 4U)
-                state1.UpdateRep();
-              else
-                state1.UpdateMatch();
-            }
-            Encoder.Optimal optimal4 = this._optimum[(IntPtr) index4];
-            if (num16 < 4U)
-            {
-              switch (num16)
-              {
-                case 0:
-                  this.reps[0] = optimal4.Backs0;
-                  this.reps[1] = optimal4.Backs1;
-                  this.reps[2] = optimal4.Backs2;
-                  this.reps[3] = optimal4.Backs3;
-                  break;
-                case 1:
-                  this.reps[0] = optimal4.Backs1;
-                  this.reps[1] = optimal4.Backs0;
-                  this.reps[2] = optimal4.Backs2;
-                  this.reps[3] = optimal4.Backs3;
-                  break;
-                case 2:
-                  this.reps[0] = optimal4.Backs2;
-                  this.reps[1] = optimal4.Backs0;
-                  this.reps[2] = optimal4.Backs1;
-                  this.reps[3] = optimal4.Backs3;
-                  break;
-                default:
-                  this.reps[0] = optimal4.Backs3;
-                  this.reps[1] = optimal4.Backs0;
-                  this.reps[2] = optimal4.Backs1;
-                  this.reps[3] = optimal4.Backs2;
-                  break;
-              }
-            }
-            else
-            {
-              this.reps[0] = num16 - 4U;
-              this.reps[1] = optimal4.Backs0;
-              this.reps[2] = optimal4.Backs1;
-              this.reps[3] = optimal4.Backs2;
-            }
-          }
-          this._optimum[(IntPtr) cur].State = state1;
-          this._optimum[(IntPtr) cur].Backs0 = this.reps[0];
-          this._optimum[(IntPtr) cur].Backs1 = this.reps[1];
-          this._optimum[(IntPtr) cur].Backs2 = this.reps[2];
-          this._optimum[(IntPtr) cur].Backs3 = this.reps[3];
-          uint price2 = this._optimum[(IntPtr) cur].Price;
-          indexByte3 = this._matchFinder.GetIndexByte(-1);
-          indexByte4 = this._matchFinder.GetIndexByte(-(int) this.reps[0] - 1 - 1);
-          posState2 = position & this._posStateMask;
-          int num17 = (int) price2 + (int) this._isMatch[(IntPtr) ((state1.Index << 4) + posState2)].GetPrice0();
-          subCoder = this._literalEncoder.GetSubCoder(position, this._matchFinder.GetIndexByte(-2));
-          int price3 = (int) subCoder.GetPrice(!state1.IsCharState(), indexByte4, indexByte3);
-          num14 = (uint) (num17 + price3);
-          Encoder.Optimal optimal5 = this._optimum[(IntPtr) (cur + 1U)];
-          flag = false;
-          if (num14 < optimal5.Price)
-          {
-            optimal5.Price = num14;
-            optimal5.PosPrev = cur;
-            optimal5.MakeAsChar();
-            flag = true;
-          }
-          num11 = price2 + this._isMatch[(IntPtr) ((state1.Index << 4) + posState2)].GetPrice1();
-          num15 = num11 + this._isRep[(IntPtr) state1.Index].GetPrice1();
-          if ((int) indexByte4 == (int) indexByte3 && (optimal5.PosPrev >= cur || optimal5.BackPrev != 0U))
-          {
-            uint num18 = num15 + this.GetRepLen1Price(state1, posState2);
-            if (num18 <= optimal5.Price)
-            {
-              optimal5.Price = num18;
-              optimal5.PosPrev = cur;
-              optimal5.MakeAsShortRep();
-              flag = true;
-            }
-          }
-          uint val2 = this._matchFinder.GetNumAvailableBytes() + 1U;
-          num12 = Math.Min(4095U - cur, val2);
-          limit1 = num12;
-        }
-        while (limit1 < 2U);
-        if (limit1 > this._numFastBytes)
-          limit1 = this._numFastBytes;
-        if (!flag && (int) indexByte4 != (int) indexByte3)
-        {
-          uint matchLen = this._matchFinder.GetMatchLen(0, this.reps[0], Math.Min(num12 - 1U, this._numFastBytes));
-          if (matchLen >= 2U)
-          {
-            Base.State state2 = state1;
-            state2.UpdateChar();
-            uint posState3 = position + 1U & this._posStateMask;
-            uint num19 = num14 + this._isMatch[(IntPtr) ((state2.Index << 4) + posState3)].GetPrice1() + this._isRep[(IntPtr) state2.Index].GetPrice1();
-            uint index5 = cur + 1U + matchLen;
-            while (num5 < index5)
-              this._optimum[(IntPtr) ++num5].Price = 268435455U;
-            uint num20 = num19 + this.GetRepPrice(0U, matchLen, state2, posState3);
-            Encoder.Optimal optimal6 = this._optimum[(IntPtr) index5];
-            if (num20 < optimal6.Price)
-            {
-              optimal6.Price = num20;
-              optimal6.PosPrev = cur + 1U;
-              optimal6.BackPrev = 0U;
-              optimal6.Prev1IsChar = true;
-              optimal6.Prev2 = false;
-            }
-          }
-        }
-        num13 = 2U;
-        for (uint repIndex = 0; repIndex < 4U; ++repIndex)
-        {
-          uint matchLen1 = this._matchFinder.GetMatchLen(-1, this.reps[(IntPtr) repIndex], limit1);
-          if (matchLen1 >= 2U)
-          {
-            uint num21 = matchLen1;
-            do
-            {
-              while (num5 < cur + matchLen1)
-                this._optimum[(IntPtr) ++num5].Price = 268435455U;
-              uint num22 = num15 + this.GetRepPrice(repIndex, matchLen1, state1, posState2);
-              Encoder.Optimal optimal7 = this._optimum[(IntPtr) (cur + matchLen1)];
-              if (num22 < optimal7.Price)
-              {
-                optimal7.Price = num22;
-                optimal7.PosPrev = cur;
-                optimal7.BackPrev = repIndex;
-                optimal7.Prev1IsChar = false;
-              }
-            }
-            while (--matchLen1 >= 2U);
-            uint num23 = num21;
-            if (repIndex == 0U)
-              num13 = num23 + 1U;
-            if (num23 < num12)
-            {
-              uint limit2 = Math.Min(num12 - 1U - num23, this._numFastBytes);
-              uint matchLen2 = this._matchFinder.GetMatchLen((int) num23, this.reps[(IntPtr) repIndex], limit2);
-              if (matchLen2 >= 2U)
-              {
-                Base.State state3 = state1;
-                state3.UpdateRep();
-                uint num24 = position + num23 & this._posStateMask;
-                int num25 = (int) num15 + (int) this.GetRepPrice(repIndex, num23, state1, posState2) + (int) this._isMatch[(IntPtr) ((state3.Index << 4) + num24)].GetPrice0();
-                subCoder = this._literalEncoder.GetSubCoder(position + num23, this._matchFinder.GetIndexByte((int) num23 - 1 - 1));
-                int price4 = (int) subCoder.GetPrice(true, this._matchFinder.GetIndexByte((int) num23 - 1 - ((int) this.reps[(IntPtr) repIndex] + 1)), this._matchFinder.GetIndexByte((int) num23 - 1));
-                uint num26 = (uint) (num25 + price4);
-                state3.UpdateChar();
-                uint posState4 = (uint) ((int) position + (int) num23 + 1) & this._posStateMask;
-                uint num27 = num26 + this._isMatch[(IntPtr) ((state3.Index << 4) + posState4)].GetPrice1() + this._isRep[(IntPtr) state3.Index].GetPrice1();
-                uint num28 = num23 + 1U + matchLen2;
-                while (num5 < cur + num28)
-                  this._optimum[(IntPtr) ++num5].Price = 268435455U;
-                uint num29 = num27 + this.GetRepPrice(0U, matchLen2, state3, posState4);
-                Encoder.Optimal optimal8 = this._optimum[(IntPtr) (cur + num28)];
-                if (num29 < optimal8.Price)
-                {
-                  optimal8.Price = num29;
-                  optimal8.PosPrev = (uint) ((int) cur + (int) num23 + 1);
-                  optimal8.BackPrev = 0U;
-                  optimal8.Prev1IsChar = true;
-                  optimal8.Prev2 = true;
-                  optimal8.PosPrev2 = cur;
-                  optimal8.BackPrev2 = repIndex;
-                }
-              }
-            }
-          }
-        }
-        if (lenRes2 > limit1)
-        {
-          lenRes2 = limit1;
-          uint index6 = 0;
-          while (lenRes2 > this._matchDistances[(IntPtr) index6])
-            index6 += 2U;
-          this._matchDistances[(IntPtr) index6] = lenRes2;
-          numDistancePairs = index6 + 2U;
-        }
-      }
-      while (lenRes2 < num13);
-      uint num30 = num11 + this._isRep[(IntPtr) state1.Index].GetPrice0();
-      while (num5 < cur + lenRes2)
-        this._optimum[(IntPtr) ++num5].Price = 268435455U;
-      uint index7 = 0;
-      while (num13 > this._matchDistances[(IntPtr) index7])
-        index7 += 2U;
-      uint num31 = num13;
-      while (true)
-      {
-        uint matchDistance = this._matchDistances[(IntPtr) (index7 + 1U)];
-        uint num32 = num30 + this.GetPosLenPrice(matchDistance, num31, posState2);
-        Encoder.Optimal optimal9 = this._optimum[(IntPtr) (cur + num31)];
-        if (num32 < optimal9.Price)
-        {
-          optimal9.Price = num32;
-          optimal9.PosPrev = cur;
-          optimal9.BackPrev = matchDistance + 4U;
-          optimal9.Prev1IsChar = false;
-        }
-        if ((int) num31 == (int) this._matchDistances[(IntPtr) index7])
-        {
-          if (num31 < num12)
-          {
-            uint limit = Math.Min(num12 - 1U - num31, this._numFastBytes);
-            uint matchLen = this._matchFinder.GetMatchLen((int) num31, matchDistance, limit);
-            if (matchLen >= 2U)
-            {
-              Base.State state4 = state1;
-              state4.UpdateMatch();
-              uint num33 = position + num31 & this._posStateMask;
-              int num34 = (int) num32 + (int) this._isMatch[(IntPtr) ((state4.Index << 4) + num33)].GetPrice0();
-              subCoder = this._literalEncoder.GetSubCoder(position + num31, this._matchFinder.GetIndexByte((int) num31 - 1 - 1));
-              int price5 = (int) subCoder.GetPrice(true, this._matchFinder.GetIndexByte((int) num31 - ((int) matchDistance + 1) - 1), this._matchFinder.GetIndexByte((int) num31 - 1));
-              uint num35 = (uint) (num34 + price5);
-              state4.UpdateChar();
-              uint posState5 = (uint) ((int) position + (int) num31 + 1) & this._posStateMask;
-              uint num36 = num35 + this._isMatch[(IntPtr) ((state4.Index << 4) + posState5)].GetPrice1() + this._isRep[(IntPtr) state4.Index].GetPrice1();
-              uint num37 = num31 + 1U + matchLen;
-              while (num5 < cur + num37)
-                this._optimum[(IntPtr) ++num5].Price = 268435455U;
-              uint num38 = num36 + this.GetRepPrice(0U, matchLen, state4, posState5);
-              Encoder.Optimal optimal10 = this._optimum[(IntPtr) (cur + num37)];
-              if (num38 < optimal10.Price)
-              {
-                optimal10.Price = num38;
-                optimal10.PosPrev = (uint) ((int) cur + (int) num31 + 1);
-                optimal10.BackPrev = 0U;
-                optimal10.Prev1IsChar = true;
-                optimal10.Prev2 = true;
-                optimal10.PosPrev2 = cur;
-                optimal10.BackPrev2 = matchDistance + 4U;
-              }
-            }
-          }
-          index7 += 2U;
-          if ((int) index7 == (int) numDistancePairs)
-            goto label_45;
-        }
-        ++num31;
-      }
-    }
-
-    private bool ChangePair(uint smallDist, uint bigDist)
-    {
-      return smallDist < 33554432U && bigDist >= smallDist << 7;
-    }
-
-    private void WriteEndMarker(uint posState)
-    {
-      if (!this._writeEndMark)
-        return;
-      this._isMatch[(IntPtr) ((this._state.Index << 4) + posState)].Encode(this._rangeEncoder, 1U);
-      this._isRep[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 0U);
-      this._state.UpdateMatch();
-      uint len = 2;
-      this._lenEncoder.Encode(this._rangeEncoder, len - 2U, posState);
-      uint symbol = 63;
-      this._posSlotEncoder[(IntPtr) Base.GetLenToPosState(len)].Encode(this._rangeEncoder, symbol);
-      int num1 = 30;
-      uint num2 = (uint) ((1 << num1) - 1);
-      this._rangeEncoder.EncodeDirectBits(num2 >> 4, num1 - 4);
-      this._posAlignEncoder.ReverseEncode(this._rangeEncoder, num2 & 15U);
-    }
-
-    private void Flush(uint nowPos)
-    {
-      this.ReleaseMFStream();
-      this.WriteEndMarker(nowPos & this._posStateMask);
-      this._rangeEncoder.FlushData();
-      this._rangeEncoder.FlushStream();
-    }
-
-    public void CodeOneBlock(out long inSize, out long outSize, out bool finished)
-    {
-      inSize = 0L;
-      outSize = 0L;
-      finished = true;
-      if (this._inStream != null)
-      {
-        this._matchFinder.SetStream(this._inStream);
-        this._matchFinder.Init();
-        this._needReleaseMFStream = true;
-        this._inStream = (Stream) null;
-      }
-      if (this._finished)
-        return;
-      this._finished = true;
-      long nowPos64 = this.nowPos64;
-      if (this.nowPos64 == 0L)
-      {
-        if (this._matchFinder.GetNumAvailableBytes() == 0U)
-        {
-          this.Flush((uint) this.nowPos64);
-          return;
-        }
-        this.ReadMatchDistances(out uint _, out uint _);
-        this._isMatch[(IntPtr) ((this._state.Index << 4) + ((uint) this.nowPos64 & this._posStateMask))].Encode(this._rangeEncoder, 0U);
-        this._state.UpdateChar();
-        byte indexByte = this._matchFinder.GetIndexByte(-(int) this._additionalOffset);
-        this._literalEncoder.GetSubCoder((uint) this.nowPos64, this._previousByte).Encode(this._rangeEncoder, indexByte);
-        this._previousByte = indexByte;
-        --this._additionalOffset;
-        ++this.nowPos64;
-      }
-      if (this._matchFinder.GetNumAvailableBytes() == 0U)
-      {
-        this.Flush((uint) this.nowPos64);
-      }
-      else
-      {
-        do
-        {
-          do
-          {
-            uint backRes;
-            uint optimum = this.GetOptimum((uint) this.nowPos64, out backRes);
-            uint posState = (uint) this.nowPos64 & this._posStateMask;
-            uint index1 = (this._state.Index << 4) + posState;
-            if (optimum == 1U && backRes == uint.MaxValue)
-            {
-              this._isMatch[(IntPtr) index1].Encode(this._rangeEncoder, 0U);
-              byte indexByte1 = this._matchFinder.GetIndexByte(-(int) this._additionalOffset);
-              Encoder.LiteralEncoder.Encoder2 subCoder = this._literalEncoder.GetSubCoder((uint) this.nowPos64, this._previousByte);
-              if (!this._state.IsCharState())
-              {
-                byte indexByte2 = this._matchFinder.GetIndexByte(-(int) this._repDistances[0] - 1 - (int) this._additionalOffset);
-                subCoder.EncodeMatched(this._rangeEncoder, indexByte2, indexByte1);
-              }
-              else
-                subCoder.Encode(this._rangeEncoder, indexByte1);
-              this._previousByte = indexByte1;
-              this._state.UpdateChar();
-            }
-            else
-            {
-              this._isMatch[(IntPtr) index1].Encode(this._rangeEncoder, 1U);
-              if (backRes < 4U)
-              {
-                this._isRep[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 1U);
-                if (backRes == 0U)
-                {
-                  this._isRepG0[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 0U);
-                  if (optimum == 1U)
-                    this._isRep0Long[(IntPtr) index1].Encode(this._rangeEncoder, 0U);
-                  else
-                    this._isRep0Long[(IntPtr) index1].Encode(this._rangeEncoder, 1U);
-                }
-                else
-                {
-                  this._isRepG0[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 1U);
-                  if (backRes == 1U)
-                  {
-                    this._isRepG1[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 0U);
-                  }
-                  else
-                  {
-                    this._isRepG1[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 1U);
-                    this._isRepG2[(IntPtr) this._state.Index].Encode(this._rangeEncoder, backRes - 2U);
-                  }
-                }
-                if (optimum == 1U)
-                {
-                  this._state.UpdateShortRep();
-                }
-                else
-                {
-                  this._repMatchLenEncoder.Encode(this._rangeEncoder, optimum - 2U, posState);
-                  this._state.UpdateRep();
-                }
-                uint repDistance = this._repDistances[(IntPtr) backRes];
-                if (backRes != 0U)
-                {
-                  for (uint index2 = backRes; index2 >= 1U; --index2)
-                    this._repDistances[(IntPtr) index2] = this._repDistances[(IntPtr) (index2 - 1U)];
-                  this._repDistances[0] = repDistance;
-                }
-              }
-              else
-              {
-                this._isRep[(IntPtr) this._state.Index].Encode(this._rangeEncoder, 0U);
-                this._state.UpdateMatch();
-                this._lenEncoder.Encode(this._rangeEncoder, optimum - 2U, posState);
-                backRes -= 4U;
-                uint posSlot = Encoder.GetPosSlot(backRes);
-                this._posSlotEncoder[(IntPtr) Base.GetLenToPosState(optimum)].Encode(this._rangeEncoder, posSlot);
-                if (posSlot >= 4U)
-                {
-                  int NumBitLevels = (int) (posSlot >> 1) - 1;
-                  uint num = (uint) ((2 | (int) posSlot & 1) << NumBitLevels);
-                  uint symbol = backRes - num;
-                  if (posSlot < 14U)
-                  {
-                    BitTreeEncoder.ReverseEncode(this._posEncoders, (uint) ((int) num - (int) posSlot - 1), this._rangeEncoder, NumBitLevels, symbol);
-                  }
-                  else
-                  {
-                    this._rangeEncoder.EncodeDirectBits(symbol >> 4, NumBitLevels - 4);
-                    this._posAlignEncoder.ReverseEncode(this._rangeEncoder, symbol & 15U);
-                    ++this._alignPriceCount;
-                  }
-                }
-                uint num1 = backRes;
-                for (uint index3 = 3; index3 >= 1U; --index3)
-                  this._repDistances[(IntPtr) index3] = this._repDistances[(IntPtr) (index3 - 1U)];
-                this._repDistances[0] = num1;
-                ++this._matchPriceCount;
-              }
-              this._previousByte = this._matchFinder.GetIndexByte((int) optimum - 1 - (int) this._additionalOffset);
-            }
-            this._additionalOffset -= optimum;
-            this.nowPos64 += (long) optimum;
-          }
-          while (this._additionalOffset != 0U);
-          if (this._matchPriceCount >= 128U)
-            this.FillDistancesPrices();
-          if (this._alignPriceCount >= 16U)
-            this.FillAlignPrices();
-          inSize = this.nowPos64;
-          outSize = this._rangeEncoder.GetProcessedSizeAdd();
-          if (this._matchFinder.GetNumAvailableBytes() == 0U)
-          {
-            this.Flush((uint) this.nowPos64);
-            return;
-          }
-        }
-        while (this.nowPos64 - nowPos64 < 4096L);
-        this._finished = false;
-        finished = false;
-      }
-    }
-
-    private void ReleaseMFStream()
-    {
-      if (this._matchFinder == null || !this._needReleaseMFStream)
-        return;
-      this._matchFinder.ReleaseStream();
-      this._needReleaseMFStream = false;
-    }
-
-    private void SetOutStream(Stream outStream) => this._rangeEncoder.SetStream(outStream);
-
-    private void ReleaseOutStream() => this._rangeEncoder.ReleaseStream();
-
-    private void ReleaseStreams()
-    {
-      this.ReleaseMFStream();
-      this.ReleaseOutStream();
-    }
-
-    private void SetStreams(Stream inStream, Stream outStream, long inSize, long outSize)
-    {
-      this._inStream = inStream;
-      this._finished = false;
-      this.Create();
-      this.SetOutStream(outStream);
-      this.Init();
-      this.FillDistancesPrices();
-      this.FillAlignPrices();
-      this._lenEncoder.SetTableSize((uint) ((int) this._numFastBytes + 1 - 2));
-      this._lenEncoder.UpdateTables((uint) (1 << this._posStateBits));
-      this._repMatchLenEncoder.SetTableSize((uint) ((int) this._numFastBytes + 1 - 2));
-      this._repMatchLenEncoder.UpdateTables((uint) (1 << this._posStateBits));
-      this.nowPos64 = 0L;
-    }
-
-    public void Code(
-      Stream inStream,
-      Stream outStream,
-      long inSize,
-      long outSize,
-      ICodeProgress progress)
-    {
-      this._needReleaseMFStream = false;
-      try
-      {
-        this.SetStreams(inStream, outStream, inSize, outSize);
-        while (true)
-        {
-          long inSize1;
-          long outSize1;
-          do
-          {
-            bool finished;
-            this.CodeOneBlock(out inSize1, out outSize1, out finished);
-            if (finished)
-              goto label_3;
-          }
-          while (progress == null);
-          progress.SetProgress(inSize1, outSize1);
-        }
-label_3:;
-      }
-      finally
-      {
-        this.ReleaseStreams();
-      }
-    }
-
-    public void WriteCoderProperties(Stream outStream)
-    {
-      this.properties[0] = (byte) ((this._posStateBits * 5 + this._numLiteralPosStateBits) * 9 + this._numLiteralContextBits);
-      for (int index = 0; index < 4; ++index)
-        this.properties[1 + index] = (byte) (this._dictionarySize >> 8 * index);
-      outStream.Write(this.properties, 0, 5);
-    }
-
-    private void FillDistancesPrices()
-    {
-      for (uint pos = 4; pos < 128U; ++pos)
-      {
-        uint posSlot = Encoder.GetPosSlot(pos);
-        int NumBitLevels = (int) (posSlot >> 1) - 1;
-        uint num = (uint) ((2 | (int) posSlot & 1) << NumBitLevels);
-        this.tempPrices[(IntPtr) pos] = BitTreeEncoder.ReverseGetPrice(this._posEncoders, (uint) ((int) num - (int) posSlot - 1), NumBitLevels, pos - num);
-      }
-      for (uint index1 = 0; index1 < 4U; ++index1)
-      {
-        BitTreeEncoder bitTreeEncoder = this._posSlotEncoder[(IntPtr) index1];
-        uint num1 = index1 << 6;
-        for (uint symbol = 0; symbol < this._distTableSize; ++symbol)
-          this._posSlotPrices[(IntPtr) (num1 + symbol)] = bitTreeEncoder.GetPrice(symbol);
-        for (uint index2 = 14; index2 < this._distTableSize; ++index2)
-          this._posSlotPrices[(IntPtr) (num1 + index2)] += (uint) ((int) (index2 >> 1) - 1 - 4 << 6);
-        uint num2 = index1 * 128U;
-        uint pos;
-        for (pos = 0U; pos < 4U; ++pos)
-          this._distancesPrices[(IntPtr) (num2 + pos)] = this._posSlotPrices[(IntPtr) (num1 + pos)];
-        for (; pos < 128U; ++pos)
-          this._distancesPrices[(IntPtr) (num2 + pos)] = this._posSlotPrices[(IntPtr) (num1 + Encoder.GetPosSlot(pos))] + this.tempPrices[(IntPtr) pos];
-      }
-      this._matchPriceCount = 0U;
-    }
-
-    private void FillAlignPrices()
-    {
-      for (uint symbol = 0; symbol < 16U; ++symbol)
-        this._alignPrices[(IntPtr) symbol] = this._posAlignEncoder.ReverseGetPrice(symbol);
-      this._alignPriceCount = 0U;
-    }
-
-    private static int FindMatchFinder(string s)
-    {
-      for (int matchFinder = 0; matchFinder < Encoder.kMatchFinderIDs.Length; ++matchFinder)
-      {
-        if (s == Encoder.kMatchFinderIDs[matchFinder])
-          return matchFinder;
-      }
-      return -1;
-    }
-
-    public void SetCoderProperties(CoderPropID[] propIDs, object[] properties)
-    {
-      for (uint index = 0; (long) index < (long) properties.Length; ++index)
-      {
-        object property = properties[(IntPtr) index];
-        switch (propIDs[(IntPtr) index])
-        {
-          case CoderPropID.DictionarySize:
-            if (!(property is int num1))
-              throw new InvalidParamException();
-            this._dictionarySize = num1 >= 1 && num1 <= 1073741824 ? (uint) num1 : throw new InvalidParamException();
-            int num2 = 0;
-            while (num2 < 30 && (long) num1 > (long) (uint) (1 << num2))
-              ++num2;
-            this._distTableSize = (uint) (num2 * 2);
-            continue;
-          case CoderPropID.PosStateBits:
-            if (!(property is int num3))
-              throw new InvalidParamException();
-            this._posStateBits = num3 >= 0 && num3 <= 4 ? num3 : throw new InvalidParamException();
-            this._posStateMask = (uint) ((1 << this._posStateBits) - 1);
-            continue;
-          case CoderPropID.LitContextBits:
-            if (!(property is int num4))
-              throw new InvalidParamException();
-            this._numLiteralContextBits = num4 >= 0 && num4 <= 8 ? num4 : throw new InvalidParamException();
-            continue;
-          case CoderPropID.LitPosBits:
-            if (!(property is int num5))
-              throw new InvalidParamException();
-            this._numLiteralPosStateBits = num5 >= 0 && num5 <= 4 ? num5 : throw new InvalidParamException();
-            continue;
-          case CoderPropID.NumFastBytes:
-            if (!(property is int num6))
-              throw new InvalidParamException();
-            this._numFastBytes = num6 >= 5 && num6 <= 273 ? (uint) num6 : throw new InvalidParamException();
-            continue;
-          case CoderPropID.MatchFinder:
-            if (!(property is string))
-              throw new InvalidParamException();
-            Encoder.EMatchFinderType matchFinderType = this._matchFinderType;
-            int matchFinder = Encoder.FindMatchFinder(((string) property).ToUpper());
-            this._matchFinderType = matchFinder >= 0 ? (Encoder.EMatchFinderType) matchFinder : throw new InvalidParamException();
-            if (this._matchFinder != null && matchFinderType != this._matchFinderType)
-            {
-              this._dictionarySizePrev = uint.MaxValue;
-              this._matchFinder = (IMatchFinder) null;
-              continue;
-            }
-            continue;
-          case CoderPropID.Algorithm:
-            continue;
-          case CoderPropID.EndMarker:
-            if (!(property is bool writeEndMarker))
-              throw new InvalidParamException();
-            this.SetWriteEndMarkerMode(writeEndMarker);
-            continue;
-          default:
-            throw new InvalidParamException();
-        }
-      }
-    }
-
-    private enum EMatchFinderType
-    {
-      BT2,
-      BT4,
-    }
-
-    private class LiteralEncoder
-    {
-      private Encoder.LiteralEncoder.Encoder2[] m_Coders;
-      private int m_NumPrevBits;
-      private int m_NumPosBits;
-      private uint m_PosMask;
-
-      public void Create(int numPosBits, int numPrevBits)
-      {
-        if (this.m_Coders != null && this.m_NumPrevBits == numPrevBits && this.m_NumPosBits == numPosBits)
-          return;
-        this.m_NumPosBits = numPosBits;
-        this.m_PosMask = (uint) ((1 << numPosBits) - 1);
-        this.m_NumPrevBits = numPrevBits;
-        uint length = (uint) (1 << this.m_NumPrevBits + this.m_NumPosBits);
-        this.m_Coders = new Encoder.LiteralEncoder.Encoder2[(IntPtr) length];
-        for (uint index = 0; index < length; ++index)
-          this.m_Coders[(IntPtr) index].Create();
-      }
-
-      public void Init()
-      {
-        uint num = (uint) (1 << this.m_NumPrevBits + this.m_NumPosBits);
-        for (uint index = 0; index < num; ++index)
-          this.m_Coders[(IntPtr) index].Init();
-      }
-
-      public Encoder.LiteralEncoder.Encoder2 GetSubCoder(uint pos, byte prevByte)
-      {
-        return this.m_Coders[(IntPtr) (uint) ((((int) pos & (int) this.m_PosMask) << this.m_NumPrevBits) + ((int) prevByte >> 8 - this.m_NumPrevBits))];
-      }
-
-      public struct Encoder2
-      {
-        private BitEncoder[] m_Encoders;
-
-        public void Create() => this.m_Encoders = new BitEncoder[768];
-
-        public void Init()
-        {
-          for (int index = 0; index < 768; ++index)
-            this.m_Encoders[index].Init();
-        }
-
-        public void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, byte symbol)
-        {
-          uint index1 = 1;
-          for (int index2 = 7; index2 >= 0; --index2)
-          {
-            uint symbol1 = (uint) ((int) symbol >> index2 & 1);
-            this.m_Encoders[(IntPtr) index1].Encode(rangeEncoder, symbol1);
-            index1 = index1 << 1 | symbol1;
-          }
-        }
-
-        public void EncodeMatched(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, byte matchByte, byte symbol)
-        {
-          uint num1 = 1;
-          bool flag = true;
-          for (int index1 = 7; index1 >= 0; --index1)
-          {
-            uint symbol1 = (uint) ((int) symbol >> index1 & 1);
-            uint index2 = num1;
-            if (flag)
-            {
-              uint num2 = (uint) ((int) matchByte >> index1 & 1);
-              index2 += (uint) (1 + (int) num2 << 8);
-              flag = (int) num2 == (int) symbol1;
-            }
-            this.m_Encoders[(IntPtr) index2].Encode(rangeEncoder, symbol1);
-            num1 = num1 << 1 | symbol1;
-          }
-        }
-
-        public uint GetPrice(bool matchMode, byte matchByte, byte symbol)
-        {
-          uint price = 0;
-          uint index = 1;
-          int num1 = 7;
-          if (matchMode)
-          {
-            for (; num1 >= 0; --num1)
-            {
-              uint num2 = (uint) ((int) matchByte >> num1 & 1);
-              uint symbol1 = (uint) ((int) symbol >> num1 & 1);
-              price += this.m_Encoders[(IntPtr) ((uint) (1 + (int) num2 << 8) + index)].GetPrice(symbol1);
-              index = index << 1 | symbol1;
-              if ((int) num2 != (int) symbol1)
-              {
-                --num1;
-                break;
-              }
-            }
-          }
-          for (; num1 >= 0; --num1)
-          {
-            uint symbol2 = (uint) ((int) symbol >> num1 & 1);
-            price += this.m_Encoders[(IntPtr) index].GetPrice(symbol2);
-            index = index << 1 | symbol2;
-          }
-          return price;
-        }
-      }
-    }
-
-    private class LenEncoder
-    {
-      private BitEncoder _choice = new BitEncoder();
-      private BitEncoder _choice2 = new BitEncoder();
-      private BitTreeEncoder[] _lowCoder = new BitTreeEncoder[new IntPtr(16)];
-      private BitTreeEncoder[] _midCoder = new BitTreeEncoder[new IntPtr(16)];
-      private BitTreeEncoder _highCoder = new BitTreeEncoder(8);
-
-      public LenEncoder()
-      {
-        for (uint index = 0; index < 16U; ++index)
-        {
-          this._lowCoder[(IntPtr) index] = new BitTreeEncoder(3);
-          this._midCoder[(IntPtr) index] = new BitTreeEncoder(3);
-        }
-      }
-
-      public void Init(uint numPosStates)
-      {
-        this._choice.Init();
-        this._choice2.Init();
-        for (uint index = 0; index < numPosStates; ++index)
-        {
-          this._lowCoder[(IntPtr) index].Init();
-          this._midCoder[(IntPtr) index].Init();
-        }
-        this._highCoder.Init();
-      }
-
-      public void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, uint symbol, uint posState)
-      {
-        if (symbol < 8U)
-        {
-          this._choice.Encode(rangeEncoder, 0U);
-          this._lowCoder[(IntPtr) posState].Encode(rangeEncoder, symbol);
-        }
-        else
-        {
-          symbol -= 8U;
-          this._choice.Encode(rangeEncoder, 1U);
-          if (symbol < 8U)
-          {
-            this._choice2.Encode(rangeEncoder, 0U);
-            this._midCoder[(IntPtr) posState].Encode(rangeEncoder, symbol);
-          }
-          else
-          {
-            this._choice2.Encode(rangeEncoder, 1U);
-            this._highCoder.Encode(rangeEncoder, symbol - 8U);
-          }
-        }
-      }
-
-      public void SetPrices(uint posState, uint numSymbols, uint[] prices, uint st)
-      {
-        uint price0 = this._choice.GetPrice0();
-        uint price1 = this._choice.GetPrice1();
-        uint num1 = price1 + this._choice2.GetPrice0();
-        uint num2 = price1 + this._choice2.GetPrice1();
-        uint symbol;
-        for (symbol = 0U; symbol < 8U; ++symbol)
-        {
-          if (symbol >= numSymbols)
-            return;
-          prices[(IntPtr) (st + symbol)] = price0 + this._lowCoder[(IntPtr) posState].GetPrice(symbol);
-        }
-        for (; symbol < 16U; ++symbol)
-        {
-          if (symbol >= numSymbols)
-            return;
-          prices[(IntPtr) (st + symbol)] = num1 + this._midCoder[(IntPtr) posState].GetPrice(symbol - 8U);
-        }
-        for (; symbol < numSymbols; ++symbol)
-          prices[(IntPtr) (st + symbol)] = num2 + this._highCoder.GetPrice((uint) ((int) symbol - 8 - 8));
-      }
-    }
-
-    private class LenPriceTableEncoder : Encoder.LenEncoder
-    {
-      private uint[] _prices = new uint[new IntPtr(4352)];
-      private uint _tableSize;
-      private uint[] _counters = new uint[new IntPtr(16)];
-
-      public void SetTableSize(uint tableSize) => this._tableSize = tableSize;
-
-      public uint GetPrice(uint symbol, uint posState)
-      {
-        return this._prices[(IntPtr) (posState * 272U + symbol)];
-      }
-
-      private void UpdateTable(uint posState)
-      {
-        this.SetPrices(posState, this._tableSize, this._prices, posState * 272U);
-        this._counters[(IntPtr) posState] = this._tableSize;
-      }
-
-      public void UpdateTables(uint numPosStates)
-      {
-        for (uint posState = 0; posState < numPosStates; ++posState)
-          this.UpdateTable(posState);
-      }
-
-      public new void Encode(SevenZip.Compression.RangeCoder.Encoder rangeEncoder, uint symbol, uint posState)
-      {
-        base.Encode(rangeEncoder, symbol, posState);
-        if (--this._counters[(IntPtr) posState] != 0U)
-          return;
-        this.UpdateTable(posState);
-      }
-    }
-
-    private class Optimal
-    {
-      public Base.State State;
-      public bool Prev1IsChar;
-      public bool Prev2;
-      public uint PosPrev2;
-      public uint BackPrev2;
-      public uint Price;
-      public uint PosPrev;
-      public uint BackPrev;
-      public uint Backs0;
-      public uint Backs1;
-      public uint Backs2;
-      public uint Backs3;
-
-      public void MakeAsChar()
-      {
-        this.BackPrev = uint.MaxValue;
-        this.Prev1IsChar = false;
-      }
-
-      public void MakeAsShortRep()
-      {
-        this.BackPrev = 0U;
-        this.Prev1IsChar = false;
-      }
-
-      public bool IsShortRep() => this.BackPrev == 0U;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitDecoder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitDecoder.cs
deleted file mode 100644
index 0909c99..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitDecoder.cs
+++ /dev/null
@@ -1,46 +0,0 @@
-
-namespace SevenZip.Compression.RangeCoder
-{
-  internal struct BitDecoder
-  {
-    public const int kNumBitModelTotalBits = 11;
-    public const uint kBitModelTotal = 2048;
-    private const int kNumMoveBits = 5;
-    private uint Prob;
-
-    public void UpdateModel(int numMoveBits, uint symbol)
-    {
-      if (symbol == 0U)
-        this.Prob += 2048U - this.Prob >> numMoveBits;
-      else
-        this.Prob -= this.Prob >> numMoveBits;
-    }
-
-    public void Init() => this.Prob = 1024U;
-
-    public uint Decode(Decoder rangeDecoder)
-    {
-      uint num = (rangeDecoder.Range >> 11) * this.Prob;
-      if (rangeDecoder.Code < num)
-      {
-        rangeDecoder.Range = num;
-        this.Prob += 2048U - this.Prob >> 5;
-        if (rangeDecoder.Range < 16777216U)
-        {
-          rangeDecoder.Code = rangeDecoder.Code << 8 | (uint) (byte) rangeDecoder.Stream.ReadByte();
-          rangeDecoder.Range <<= 8;
-        }
-        return 0;
-      }
-      rangeDecoder.Range -= num;
-      rangeDecoder.Code -= num;
-      this.Prob -= this.Prob >> 5;
-      if (rangeDecoder.Range < 16777216U)
-      {
-        rangeDecoder.Code = rangeDecoder.Code << 8 | (uint) (byte) rangeDecoder.Stream.ReadByte();
-        rangeDecoder.Range <<= 8;
-      }
-      return 1;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitEncoder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitEncoder.cs
deleted file mode 100644
index c6ab436..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitEncoder.cs
+++ /dev/null
@@ -1,66 +0,0 @@
-
-using System;
-
-namespace SevenZip.Compression.RangeCoder
-{
-  internal struct BitEncoder
-  {
-    public const int kNumBitModelTotalBits = 11;
-    public const uint kBitModelTotal = 2048;
-    private const int kNumMoveBits = 5;
-    private const int kNumMoveReducingBits = 2;
-    public const int kNumBitPriceShiftBits = 6;
-    private uint Prob;
-    private static uint[] ProbPrices = new uint[new IntPtr(512)];
-
-    public void Init() => this.Prob = 1024U;
-
-    public void UpdateModel(uint symbol)
-    {
-      if (symbol == 0U)
-        this.Prob += 2048U - this.Prob >> 5;
-      else
-        this.Prob -= this.Prob >> 5;
-    }
-
-    public void Encode(Encoder encoder, uint symbol)
-    {
-      uint num = (encoder.Range >> 11) * this.Prob;
-      if (symbol == 0U)
-      {
-        encoder.Range = num;
-        this.Prob += 2048U - this.Prob >> 5;
-      }
-      else
-      {
-        encoder.Low += (ulong) num;
-        encoder.Range -= num;
-        this.Prob -= this.Prob >> 5;
-      }
-      if (encoder.Range >= 16777216U)
-        return;
-      encoder.Range <<= 8;
-      encoder.ShiftLow();
-    }
-
-    static BitEncoder()
-    {
-      for (int index1 = 8; index1 >= 0; --index1)
-      {
-        uint num1 = (uint) (1 << 9 - index1 - 1);
-        uint num2 = (uint) (1 << 9 - index1);
-        for (uint index2 = num1; index2 < num2; ++index2)
-          BitEncoder.ProbPrices[(IntPtr) index2] = (uint) ((index1 << 6) + ((int) num2 - (int) index2 << 6 >>> 9 - index1 - 1));
-      }
-    }
-
-    public uint GetPrice(uint symbol)
-    {
-      return BitEncoder.ProbPrices[(((long) (this.Prob - symbol) ^ (long) -(int) symbol) & 2047L) >> 2];
-    }
-
-    public uint GetPrice0() => BitEncoder.ProbPrices[(IntPtr) (this.Prob >> 2)];
-
-    public uint GetPrice1() => BitEncoder.ProbPrices[(IntPtr) (2048U - this.Prob >> 2)];
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitTreeDecoder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitTreeDecoder.cs
deleted file mode 100644
index 25d2b3a..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitTreeDecoder.cs
+++ /dev/null
@@ -1,55 +0,0 @@
-
-using System;
-
-namespace SevenZip.Compression.RangeCoder
-{
-  internal struct BitTreeDecoder(int numBitLevels)
-  {
-    private BitDecoder[] Models = new BitDecoder[1 << numBitLevels];
-    private int NumBitLevels = numBitLevels;
-
-    public void Init()
-    {
-      for (uint index = 1; (long) index < (long) (1 << this.NumBitLevels); ++index)
-        this.Models[(IntPtr) index].Init();
-    }
-
-    public uint Decode(Decoder rangeDecoder)
-    {
-      uint index = 1;
-      for (int numBitLevels = this.NumBitLevels; numBitLevels > 0; --numBitLevels)
-        index = (index << 1) + this.Models[(IntPtr) index].Decode(rangeDecoder);
-      return index - (uint) (1 << this.NumBitLevels);
-    }
-
-    public uint ReverseDecode(Decoder rangeDecoder)
-    {
-      uint index1 = 1;
-      uint num1 = 0;
-      for (int index2 = 0; index2 < this.NumBitLevels; ++index2)
-      {
-        uint num2 = this.Models[(IntPtr) index1].Decode(rangeDecoder);
-        index1 = (index1 << 1) + num2;
-        num1 |= num2 << index2;
-      }
-      return num1;
-    }
-
-    public static uint ReverseDecode(
-      BitDecoder[] Models,
-      uint startIndex,
-      Decoder rangeDecoder,
-      int NumBitLevels)
-    {
-      uint num1 = 1;
-      uint num2 = 0;
-      for (int index = 0; index < NumBitLevels; ++index)
-      {
-        uint num3 = Models[(IntPtr) (startIndex + num1)].Decode(rangeDecoder);
-        num1 = (num1 << 1) + num3;
-        num2 |= num3 << index;
-      }
-      return num2;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitTreeEncoder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitTreeEncoder.cs
deleted file mode 100644
index 0413a18..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/BitTreeEncoder.cs
+++ /dev/null
@@ -1,106 +0,0 @@
-
-using System;
-
-namespace SevenZip.Compression.RangeCoder
-{
-  internal struct BitTreeEncoder(int numBitLevels)
-  {
-    private BitEncoder[] Models = new BitEncoder[1 << numBitLevels];
-    private int NumBitLevels = numBitLevels;
-
-    public void Init()
-    {
-      for (uint index = 1; (long) index < (long) (1 << this.NumBitLevels); ++index)
-        this.Models[(IntPtr) index].Init();
-    }
-
-    public void Encode(Encoder rangeEncoder, uint symbol)
-    {
-      uint index = 1;
-      int numBitLevels = this.NumBitLevels;
-      while (numBitLevels > 0)
-      {
-        --numBitLevels;
-        uint symbol1 = symbol >> numBitLevels & 1U;
-        this.Models[(IntPtr) index].Encode(rangeEncoder, symbol1);
-        index = index << 1 | symbol1;
-      }
-    }
-
-    public void ReverseEncode(Encoder rangeEncoder, uint symbol)
-    {
-      uint index1 = 1;
-      for (uint index2 = 0; (long) index2 < (long) this.NumBitLevels; ++index2)
-      {
-        uint symbol1 = symbol & 1U;
-        this.Models[(IntPtr) index1].Encode(rangeEncoder, symbol1);
-        index1 = index1 << 1 | symbol1;
-        symbol >>= 1;
-      }
-    }
-
-    public uint GetPrice(uint symbol)
-    {
-      uint price = 0;
-      uint index = 1;
-      int numBitLevels = this.NumBitLevels;
-      while (numBitLevels > 0)
-      {
-        --numBitLevels;
-        uint symbol1 = symbol >> numBitLevels & 1U;
-        price += this.Models[(IntPtr) index].GetPrice(symbol1);
-        index = (index << 1) + symbol1;
-      }
-      return price;
-    }
-
-    public uint ReverseGetPrice(uint symbol)
-    {
-      uint price = 0;
-      uint index = 1;
-      for (int numBitLevels = this.NumBitLevels; numBitLevels > 0; --numBitLevels)
-      {
-        uint symbol1 = symbol & 1U;
-        symbol >>= 1;
-        price += this.Models[(IntPtr) index].GetPrice(symbol1);
-        index = index << 1 | symbol1;
-      }
-      return price;
-    }
-
-    public static uint ReverseGetPrice(
-      BitEncoder[] Models,
-      uint startIndex,
-      int NumBitLevels,
-      uint symbol)
-    {
-      uint price = 0;
-      uint num = 1;
-      for (int index = NumBitLevels; index > 0; --index)
-      {
-        uint symbol1 = symbol & 1U;
-        symbol >>= 1;
-        price += Models[(IntPtr) (startIndex + num)].GetPrice(symbol1);
-        num = num << 1 | symbol1;
-      }
-      return price;
-    }
-
-    public static void ReverseEncode(
-      BitEncoder[] Models,
-      uint startIndex,
-      Encoder rangeEncoder,
-      int NumBitLevels,
-      uint symbol)
-    {
-      uint num = 1;
-      for (int index = 0; index < NumBitLevels; ++index)
-      {
-        uint symbol1 = symbol & 1U;
-        Models[(IntPtr) (startIndex + num)].Encode(rangeEncoder, symbol1);
-        num = num << 1 | symbol1;
-        symbol >>= 1;
-      }
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/Decoder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/Decoder.cs
deleted file mode 100644
index b28cadf..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/Decoder.cs
+++ /dev/null
@@ -1,90 +0,0 @@
-
-using System.IO;
-
-namespace SevenZip.Compression.RangeCoder
-{
-  internal class Decoder
-  {
-    public const uint kTopValue = 16777216;
-    public uint Range;
-    public uint Code;
-    public Stream Stream;
-
-    public void Init(Stream stream)
-    {
-      this.Stream = stream;
-      this.Code = 0U;
-      this.Range = uint.MaxValue;
-      for (int index = 0; index < 5; ++index)
-        this.Code = this.Code << 8 | (uint) (byte) this.Stream.ReadByte();
-    }
-
-    public void ReleaseStream() => this.Stream = (Stream) null;
-
-    public void CloseStream() => this.Stream.Close();
-
-    public void Normalize()
-    {
-      for (; this.Range < 16777216U; this.Range <<= 8)
-        this.Code = this.Code << 8 | (uint) (byte) this.Stream.ReadByte();
-    }
-
-    public void Normalize2()
-    {
-      if (this.Range >= 16777216U)
-        return;
-      this.Code = this.Code << 8 | (uint) (byte) this.Stream.ReadByte();
-      this.Range <<= 8;
-    }
-
-    public uint GetThreshold(uint total) => this.Code / (this.Range /= total);
-
-    public void Decode(uint start, uint size, uint total)
-    {
-      this.Code -= start * this.Range;
-      this.Range *= size;
-      this.Normalize();
-    }
-
-    public uint DecodeDirectBits(int numTotalBits)
-    {
-      uint range = this.Range;
-      uint num1 = this.Code;
-      uint num2 = 0;
-      for (int index = numTotalBits; index > 0; --index)
-      {
-        range >>= 1;
-        uint num3 = num1 - range >> 31;
-        num1 -= range & num3 - 1U;
-        num2 = (uint) ((int) num2 << 1 | 1 - (int) num3);
-        if (range < 16777216U)
-        {
-          num1 = num1 << 8 | (uint) (byte) this.Stream.ReadByte();
-          range <<= 8;
-        }
-      }
-      this.Range = range;
-      this.Code = num1;
-      return num2;
-    }
-
-    public uint DecodeBit(uint size0, int numTotalBits)
-    {
-      uint num1 = (this.Range >> numTotalBits) * size0;
-      uint num2;
-      if (this.Code < num1)
-      {
-        num2 = 0U;
-        this.Range = num1;
-      }
-      else
-      {
-        num2 = 1U;
-        this.Code -= num1;
-        this.Range -= num1;
-      }
-      this.Normalize();
-      return num2;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/Encoder.cs b/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/Encoder.cs
deleted file mode 100644
index b4b9e4e..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/Compression/RangeCoder/Encoder.cs
+++ /dev/null
@@ -1,106 +0,0 @@
-
-using System.IO;
-
-namespace SevenZip.Compression.RangeCoder
-{
-  internal class Encoder
-  {
-    public const uint kTopValue = 16777216;
-    private Stream Stream;
-    public ulong Low;
-    public uint Range;
-    private uint _cacheSize;
-    private byte _cache;
-    private long StartPosition;
-
-    public void SetStream(Stream stream) => this.Stream = stream;
-
-    public void ReleaseStream() => this.Stream = (Stream) null;
-
-    public void Init()
-    {
-      this.StartPosition = this.Stream.Position;
-      this.Low = 0UL;
-      this.Range = uint.MaxValue;
-      this._cacheSize = 1U;
-      this._cache = (byte) 0;
-    }
-
-    public void FlushData()
-    {
-      for (int index = 0; index < 5; ++index)
-        this.ShiftLow();
-    }
-
-    public void FlushStream() => this.Stream.Flush();
-
-    public void CloseStream() => this.Stream.Close();
-
-    public void Encode(uint start, uint size, uint total)
-    {
-      this.Low += (ulong) (start * (this.Range /= total));
-      this.Range *= size;
-      while (this.Range < 16777216U)
-      {
-        this.Range <<= 8;
-        this.ShiftLow();
-      }
-    }
-
-    public void ShiftLow()
-    {
-      if ((uint) this.Low < 4278190080U || (uint) (this.Low >> 32) == 1U)
-      {
-        byte num = this._cache;
-        do
-        {
-          this.Stream.WriteByte((byte) ((ulong) num + (this.Low >> 32)));
-          num = byte.MaxValue;
-        }
-        while (--this._cacheSize != 0U);
-        this._cache = (byte) ((uint) this.Low >> 24);
-      }
-      ++this._cacheSize;
-      this.Low = (ulong) ((uint) this.Low << 8);
-    }
-
-    public void EncodeDirectBits(uint v, int numTotalBits)
-    {
-      for (int index = numTotalBits - 1; index >= 0; --index)
-      {
-        this.Range >>= 1;
-        if (((int) (v >> index) & 1) == 1)
-          this.Low += (ulong) this.Range;
-        if (this.Range < 16777216U)
-        {
-          this.Range <<= 8;
-          this.ShiftLow();
-        }
-      }
-    }
-
-    public void EncodeBit(uint size0, int numTotalBits, uint symbol)
-    {
-      uint num = (this.Range >> numTotalBits) * size0;
-      if (symbol == 0U)
-      {
-        this.Range = num;
-      }
-      else
-      {
-        this.Low += (ulong) num;
-        this.Range -= num;
-      }
-      while (this.Range < 16777216U)
-      {
-        this.Range <<= 8;
-        this.ShiftLow();
-      }
-    }
-
-    public long GetProcessedSizeAdd()
-    {
-      return (long) this._cacheSize + this.Stream.Position - this.StartPosition + 4L;
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/DataErrorException.cs b/Redbox.HAL.Component.Model/SevenZip/DataErrorException.cs
deleted file mode 100644
index a9d65a8..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/DataErrorException.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-
-using System;
-
-namespace SevenZip
-{
-  internal class DataErrorException : ApplicationException
-  {
-    public DataErrorException()
-      : base("Data Error")
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/ICodeProgress.cs b/Redbox.HAL.Component.Model/SevenZip/ICodeProgress.cs
deleted file mode 100644
index 74c7dd0..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/ICodeProgress.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-
-using System.Runtime.InteropServices;
-
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface ICodeProgress
-  {
-    void SetProgress(long inSize, long outSize);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/ICoder.cs b/Redbox.HAL.Component.Model/SevenZip/ICoder.cs
deleted file mode 100644
index 5c4d964..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/ICoder.cs
+++ /dev/null
@@ -1,17 +0,0 @@
-
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface ICoder
-  {
-    void Code(
-      Stream inStream,
-      Stream outStream,
-      long inSize,
-      long outSize,
-      ICodeProgress progress);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/ISetCoderProperties.cs b/Redbox.HAL.Component.Model/SevenZip/ISetCoderProperties.cs
deleted file mode 100644
index e20dee3..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/ISetCoderProperties.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-
-using System.Runtime.InteropServices;
-
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface ISetCoderProperties
-  {
-    void SetCoderProperties(CoderPropID[] propIDs, object[] properties);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/ISetDecoderProperties.cs b/Redbox.HAL.Component.Model/SevenZip/ISetDecoderProperties.cs
deleted file mode 100644
index ff3b0fd..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/ISetDecoderProperties.cs
+++ /dev/null
@@ -1,11 +0,0 @@
-
-using System.Runtime.InteropServices;
-
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface ISetDecoderProperties
-  {
-    void SetDecoderProperties(byte[] properties);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/IWriteCoderProperties.cs b/Redbox.HAL.Component.Model/SevenZip/IWriteCoderProperties.cs
deleted file mode 100644
index acb660d..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/IWriteCoderProperties.cs
+++ /dev/null
@@ -1,12 +0,0 @@
-
-using System.IO;
-using System.Runtime.InteropServices;
-
-namespace SevenZip
-{
-  [ComVisible(true)]
-  public interface IWriteCoderProperties
-  {
-    void WriteCoderProperties(Stream outStream);
-  }
-}
diff --git a/Redbox.HAL.Component.Model/SevenZip/InvalidParamException.cs b/Redbox.HAL.Component.Model/SevenZip/InvalidParamException.cs
deleted file mode 100644
index 4f1350e..0000000
--- a/Redbox.HAL.Component.Model/SevenZip/InvalidParamException.cs
+++ /dev/null
@@ -1,13 +0,0 @@
-
-using System;
-
-namespace SevenZip
-{
-  internal class InvalidParamException : ApplicationException
-  {
-    public InvalidParamException()
-      : base("Invalid Parameter")
-    {
-    }
-  }
-}
diff --git a/Redbox.HAL.Component.Model/packages.config b/Redbox.HAL.Component.Model/packages.config
new file mode 100644
index 0000000..bffffb6
--- /dev/null
+++ b/Redbox.HAL.Component.Model/packages.config
@@ -0,0 +1,5 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<packages>
+  <package id="SevenZip" version="19.0.0" targetFramework="net35" />
+  <package id="SharpZipLib" version="0.86.0" targetFramework="net35" />
+</packages>
\ No newline at end of file
-- 
2.44.0.windows.1

